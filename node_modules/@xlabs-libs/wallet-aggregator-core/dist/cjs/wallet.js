"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallet = exports.WalletState = exports.BaseFeatures = exports.NotConnected = exports.NotSupported = void 0;
const eventemitter3_1 = __importDefault(require("eventemitter3"));
class NotSupported extends Error {
    constructor() {
        super("Not supported");
    }
}
exports.NotSupported = NotSupported;
class NotConnected extends Error {
    constructor() {
        super("Not connected");
    }
}
exports.NotConnected = NotConnected;
var BaseFeatures;
(function (BaseFeatures) {
    BaseFeatures["SignTransaction"] = "SignTransaction";
    BaseFeatures["SendTransaction"] = "SendTransaction";
    BaseFeatures["SignAndSendTransaction"] = "SignAndSendTransaction";
    BaseFeatures["SignMessage"] = "SignMessage";
})(BaseFeatures || (exports.BaseFeatures = BaseFeatures = {}));
var WalletState;
(function (WalletState) {
    WalletState["Installed"] = "Installed";
    WalletState["NotDetected"] = "NotDetected";
    WalletState["Loadable"] = "Loadable";
    WalletState["Unsupported"] = "Unsupported";
})(WalletState || (exports.WalletState = WalletState = {}));
/**
 * Base Wallet abstraction.
 *
 * Generic arguments (all of them `any` by default):
 *  * `ChainId` - The Wormhole chain id for the network
 *  * `ConnectOptions` - Options to pass to the `connect` method
 *  * `SignTransactionInput` - Transaction object to sign
 *  * `SignTransactionResult` - Result of the `signTransaction` method
 *  * `SendTransactionInput` - Transaction object to send. Might be signed or not, depending on the wallet implementation
 *  * `SendTransactionResultData` - Result of the `sendTransaction` method
 *  * `SignAndSendTransactionInput` - Transaction object to sign and send
 *  * `SignAndSendTransactionResultData` - Result of the `signAndSendTransaction` method
 *  * `SignMessageInput` - Message to sign
 *  * `SignMessageResult` - Result of the `signMessage` method
 *  * `NetworkInfo` - Object type that describes the blockchain's network information or state
 *  * `WalletFeatures` - Object type which describes the features the wallet implements
 *  * `WalletEvents` - Object type which describes the events the wallet can be listened on
 */
class Wallet extends eventemitter3_1.default {
    /**
     * Retrieve the wallet's current state
     *
     * The possible states are as those used by the {@link https://github.com/solana-labs/wallet-adapter solana} and {@link https://github.com/aptos-labs/aptos-wallet-adapter aptos} libraries, summarized as follows:
     *  * `Installed`: the wallet was detected through the global scope or any other mechanism and can be interacted with. Example: `window.ethereum` for Metamask or `window.phantom` for Phantom wallet)
     *  * `NotDetected`: as opposed to `Installed`, no point of interaction with the wallet was found, and thus it is not available. Users can be redirected to the project url offered by `getUrl`
     *  * `Loadable`: the wallet might not require installation, and thus can be interacted with after being loaded
     *  * `Unsupported`: the wallet is not supported by the environment
     *
     * @returns The wallet's state. Defaults to Installed.
     */
    getWalletState() {
        // default
        return WalletState.Installed;
    }
    /**
     * Query whether a feature or set of features is supported by the wallet.
     * For a list of features see {@link BaseFeatures}.
     * Some chains might add additional features of their own.
     */
    supportsFeature(feature) {
        const features = this.getFeatures();
        return Array.isArray(feature)
            ? feature.every((f) => features.includes(f))
            : features.includes(feature);
    }
}
exports.Wallet = Wallet;
//# sourceMappingURL=wallet.js.map