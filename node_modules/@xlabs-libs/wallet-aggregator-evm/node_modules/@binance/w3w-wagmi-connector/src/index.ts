import type WalletConnectProvider from '@binance/w3w-ethereum-provider'
import { isInBinance, log, normalizeChainId } from '@binance/w3w-utils'
import {
  UserRejectedRequestError,
  ProviderRpcError,
  createWalletClient,
  getAddress,
  custom,
  numberToHex,
  SwitchChainError,
} from 'viem'
import { Connector, WalletClient, Chain } from 'wagmi'
import { InjectedConnector } from 'wagmi/connectors/injected'

import { StorageStoreData } from './types'

type WalletConnectOptions = ConstructorParameters<
  typeof WalletConnectProvider
>[0]

class BinanceW3WConnector extends Connector<
  WalletConnectProvider,
  WalletConnectOptions
> {
  readonly id = 'BinanceW3W'
  readonly name = 'BinanceW3W'
  readonly ready = true

  #provider?: WalletConnectProvider
  #chainId?: number
  #lng?: string
  constructor(config: { chains?: Chain[]; options?: WalletConnectOptions }) {
    super({ options: {}, ...config })
    this.#chainId = config?.options?.chainId || 56
    this.#lng = config?.options?.lng || 'en'
  }

  connect = async (
    { chainId }: { chainId?: number } = { chainId: this.#chainId }
  ) => {
    chainId = chainId ?? this.#chainId ?? 56
    log.debug('ðŸš€ ~ connect ~ chainId:', chainId)
    try {
      let targetChainId = chainId
      if (!targetChainId) {
        const store = this.storage?.getItem<StorageStoreData>('store')
        const lastUsedChainId = store?.state?.data?.chain?.id
        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId))
          targetChainId = lastUsedChainId
      }

      const provider = await this.getProvider({
        chainId: targetChainId,
        create: true,
      })
      provider.on('accountsChanged', this.onAccountsChanged)
      provider.on('chainChanged', this.onChainChanged)
      provider.on('disconnect', this.onDisconnect)

      // Defer message to the next tick to ensure wallet connect data (provided by `.enable()`) is available
      setTimeout(() => this.emit('message', { type: 'connecting' }), 0)

      provider.setLng(this.#lng)
      const accounts = await provider.enable()
      const account = getAddress(accounts[0])
      const id = await this.getChainId()
      const unsupported = this.isChainUnsupported(id)

      return {
        account,
        chain: { id, unsupported },
      }
    } catch (error) {
      if (error.code === 100001) throw new UserRejectedRequestError(error)
      throw error
    }
  }

  async disconnect() {
    const provider = await this.getProvider()
    provider.disconnect()

    provider.removeListener('accountsChanged', this.onAccountsChanged)
    provider.removeListener('chainChanged', this.onChainChanged)
    provider.removeListener('disconnect', this.onDisconnect)

    typeof localStorage !== 'undefined' &&
      localStorage.removeItem('walletconnect')
  }

  async getAccount() {
    const provider = await this.getProvider()
    const accounts = provider.accounts
    // return checksum address
    return getAddress(accounts[0])
  }

  async getChainId() {
    const provider = await this.getProvider()
    const chainId = normalizeChainId(provider.chainId)
    return chainId
  }

  async getProvider({
    chainId,
    create,
  }: { chainId?: number; create?: boolean } = {}) {
    // Force create new provider
    if (!this.#provider || chainId || create) {
      const rpc = !this.options?.infuraId
        ? this.chains.reduce(
            (rpcProps, chain) => ({
              ...rpcProps,
              [chain.id]: chain.rpcUrls.default.http[0],
            }),
            {}
          )
        : {}

      const WalletConnectProvider = (
        await import('@binance/w3w-ethereum-provider')
      ).default
      this.#provider = new WalletConnectProvider({
        ...this.options,
        chainId,
        rpc: { ...rpc, ...this.options?.rpc },
      })
    }

    return this.#provider
  }

  async getWalletClient({
    chainId,
  }: { chainId?: number } = {}): Promise<WalletClient> {
    const [provider, account] = await Promise.all([
      this.getProvider({ chainId }),
      this.getAccount(),
    ])
    const chain = this.chains.find((x) => x.id === chainId)
    if (!provider) throw new Error('provider is required.')
    return createWalletClient({
      account,
      chain,
      transport: custom(provider),
    })
  }

  async isAuthorized() {
    try {
      const account = await this.getAccount()
      return !!account
    } catch {
      return false
    }
  }

  async switchChain(chainId: number) {
    const provider = await this.getProvider()
    const id = numberToHex(chainId)

    try {
      // Set up a race between `wallet_switchEthereumChain` & the `chainChanged` event
      // to ensure the chain has been switched. This is because there could be a case
      // where a wallet may not resolve the `wallet_switchEthereumChain` method, or
      // resolves slower than `chainChanged`.
      await Promise.race([
        provider.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: id }],
        }),
        new Promise((res) =>
          this.on('change', ({ chain }) => {
            if (chain?.id === chainId) res(chainId)
          })
        ),
      ])
      return (
        this.chains.find((x) => x.id === chainId) ??
        ({
          id: chainId,
          name: `Chain ${id}`,
          network: `${id}`,
          nativeCurrency: { name: 'Ether', decimals: 18, symbol: 'ETH' },
          rpcUrls: { default: { http: [''] }, public: { http: [''] } },
        } as Chain)
      )
    } catch (error) {
      const message =
        typeof error === 'string' ? error : (error as ProviderRpcError)?.message
      if (/user rejected request/i.test(message))
        throw new UserRejectedRequestError(error)
      throw new SwitchChainError(error)
    }
  }

  protected onAccountsChanged = (accounts: string[]) => {
    if (accounts.length === 0) this.emit('disconnect')
    else this.emit('change', { account: getAddress(accounts[0]) })
  }

  protected onChainChanged = (chainId: number | string) => {
    const id = normalizeChainId(chainId)
    const unsupported = this.isChainUnsupported(id)
    this.emit('change', { chain: { id, unsupported } })
  }

  protected onDisconnect = () => {
    this.emit('disconnect')
  }
}

export const getWagmiConnector = () => {
  if (isInBinance()) {
    return InjectedConnector
  }
  return BinanceW3WConnector
}
