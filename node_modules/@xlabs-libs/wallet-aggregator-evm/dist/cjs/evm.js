"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EVMWallet = exports.EVMWalletType = void 0;
const core_1 = require("@wagmi/core");
const public_1 = require("@wagmi/core/providers/public");
const wallet_aggregator_core_1 = require("@xlabs-libs/wallet-aggregator-core");
const ethers_1 = require("ethers");
const chains_1 = require("./chains");
const constants_1 = require("./constants");
// See:
// - https://github.com/MetaMask/eth-rpc-errors/blob/main/src/error-constants.ts
// - https://docs.metamask.io/guide/rpc-api.html#returns-7
var ERROR_CODES;
(function (ERROR_CODES) {
    ERROR_CODES[ERROR_CODES["USER_REJECTED"] = 4001] = "USER_REJECTED";
    ERROR_CODES[ERROR_CODES["CHAIN_NOT_ADDED"] = 4902] = "CHAIN_NOT_ADDED";
})(ERROR_CODES || (ERROR_CODES = {}));
var EVMWalletType;
(function (EVMWalletType) {
    EVMWalletType["BitgetWallet"] = "bitgetwallet";
    EVMWalletType["Binance"] = "binance";
    EVMWalletType["Coinbase"] = "coinbase";
    EVMWalletType["Injected"] = "injected";
    EVMWalletType["Ledger"] = "ledger";
    EVMWalletType["Metamask"] = "metamask";
    EVMWalletType["OKXWallet"] = "okxwallet";
    EVMWalletType["WalletConnect"] = "walletconnect";
})(EVMWalletType || (exports.EVMWalletType = EVMWalletType = {}));
class SwitchChainError extends Error {
    constructor(message, code, stack) {
        super(message);
        this.code = code;
        this.stack = stack;
    }
}
/**
 * @description An abstraction over EVM compatible blockchain wallets
 */
class EVMWallet extends wallet_aggregator_core_1.Wallet {
    constructor(config = {}) {
        super();
        this.addresses = [];
        this.switchingChain = false;
        this.chains = config.chains || chains_1.DEFAULT_CHAINS;
        this.autoSwitch = config.autoSwitch || false;
        this.connectorOptions = config.connectorOptions || {};
        this.config = config;
        // create here so that injected wallets can be detected before connecting
        this.connector = this.createConnector();
    }
    connect({ evmChainId } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { publicClient } = (0, core_1.configureChains)(this.chains, [(0, public_1.publicProvider)()]);
            this.wagmiConfig = (0, core_1.createConfig)({
                publicClient,
                autoConnect: false,
                connectors: [this.connector],
            });
            yield this.connector.connect({
                chainId: evmChainId || this.config.preferredChain,
            });
            this.provider = new ethers_1.ethers.BrowserProvider((yield this.connector.getProvider()), "any");
            this.connector.on("change", this.onChange.bind(this));
            this.connector.on("disconnect", this.onDisconnect.bind(this));
            this.network = yield this.fetchNetworkInfo();
            this.address = yield this.connector.getAccount();
            this.addresses = [this.address];
            this.emit("connect");
            return this.addresses;
        });
    }
    enforcePrefferedChain() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.config.preferredChain)
                return;
            if (!this.connector.switchChain)
                throw new wallet_aggregator_core_1.NotSupported();
            let currentChain = (_a = this.getNetworkInfo()) === null || _a === void 0 ? void 0 : _a.chainId;
            while (currentChain !== this.config.preferredChain) {
                try {
                    yield this.connector.switchChain(this.config.preferredChain);
                    currentChain = (_b = this.getNetworkInfo()) === null || _b === void 0 ? void 0 : _b.chainId;
                }
                catch (error) {
                    const { code } = error;
                    // ignore user rejections
                    if (code === ERROR_CODES.USER_REJECTED) {
                        return;
                    }
                    throw error;
                }
            }
        });
    }
    onChange(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (data.chain)
                yield this.onChainChanged();
            if (data.account)
                yield this.onAccountsChanged([data.account]);
        });
    }
    /**
     * @description Change the preferred evm chain. Calling this method will automatically trigger a switch to the new chain request.
     *
     * @param chainId The new evm chain id
     */
    setPrefferedChain(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.config.preferredChain = chainId;
            yield this.enforcePrefferedChain();
        });
    }
    isConnected() {
        return !!this.provider;
    }
    disconnect() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield ((_a = this.connector) === null || _a === void 0 ? void 0 : _a.disconnect());
            yield this.onDisconnect();
        });
    }
    getChainId() {
        if (!this.isConnected() || !this.network)
            return wallet_aggregator_core_1.CHAIN_ID_ETH;
        const evmChainId = this.network.chainId;
        const network = (0, constants_1.isTestnetEvm)(evmChainId) ? "TESTNET" : "MAINNET";
        return (0, constants_1.evmChainIdToChainId)(evmChainId, network);
    }
    getNetworkInfo() {
        return this.network;
    }
    getAddress() {
        return this.address;
    }
    getAddresses() {
        return this.addresses;
    }
    setMainAddress(address) {
        if (!this.addresses.includes(address))
            throw new Error("Unknown address");
        this.address = address;
    }
    signTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isConnected())
                throw new wallet_aggregator_core_1.NotConnected();
            yield this.enforcePrefferedChain();
            return Promise.resolve(tx);
        });
    }
    sendTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isConnected())
                throw new wallet_aggregator_core_1.NotConnected();
            yield this.enforcePrefferedChain();
            const signer = yield this.getSigner();
            const response = yield signer.sendTransaction(tx);
            const receipt = (yield response.wait(this.config.confirmations));
            return {
                id: receipt === null || receipt === void 0 ? void 0 : receipt.hash,
                data: receipt,
            };
        });
    }
    signAndSendTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.sendTransaction(tx);
        });
    }
    signMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isConnected())
                throw new wallet_aggregator_core_1.NotConnected();
            yield this.enforcePrefferedChain();
            const signer = yield this.getSigner();
            const signature = yield signer.signMessage(msg);
            return new Uint8Array(Buffer.from(signature.substring(2), "hex"));
        });
    }
    /**
     * @description Try to switch the evm chain the wallet is connected to through the {@link https://eips.ethereum.org/EIPS/eip-3326 EIP-3326} `wallet_switchEthereumChain` method, or throw if the wallet does not support it.
     * Should the chain be missing from the provider, it will try to add it through the {@link https://eips.ethereum.org/EIPS/eip-3085 EIP-3085} `wallet_addEthereumChain` method, using the information stored in the map `chainParameters` injected through the constructor.
     * If a switch chain request is already in progress, it will ignore the new request and return without doing anything.
     *
     * @param ethChainId The EVM chain id of the chain to switch to
     */
    switchChain(ethChainId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isConnected())
                throw new wallet_aggregator_core_1.NotConnected();
            if (!((_a = this.connector) === null || _a === void 0 ? void 0 : _a.switchChain))
                throw new wallet_aggregator_core_1.NotSupported();
            // some wallets like metamask throw an error if the provider makes multiple requests
            // while others will trigger as many operations as are requested
            if (this.switchingChain)
                return;
            try {
                this.switchingChain = true;
                yield this.connector.switchChain(ethChainId);
                this.network = yield this.fetchNetworkInfo();
            }
            catch (err) {
                const isChainNotAddedError = err.code === ERROR_CODES.CHAIN_NOT_ADDED;
                // wagmi only does this for injected wallets and not for walletconnect
                if (isChainNotAddedError) {
                    yield this.addChain(ethChainId);
                    return;
                }
                throw err;
            }
            finally {
                this.switchingChain = false;
            }
        });
    }
    /**
     * @description Try to add a new chain to the wallet through the {@link https://eips.ethereum.org/EIPS/eip-3085 EIP-3085} `wallet_addEthereumChain` method.
     * The chain information is looked up in the configured `chains` array.
     */
    addChain(ethChainId) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.provider)
                throw new wallet_aggregator_core_1.NotConnected();
            const chain = this.chains.find((chain) => chain.id === ethChainId);
            if (!chain) {
                throw new SwitchChainError(`Chain ${ethChainId} not configured`, ERROR_CODES.CHAIN_NOT_ADDED);
            }
            return (yield this.provider.send("wallet_addEthereumChain", [
                {
                    chainId: ethers_1.ethers.toBeHex(chain.id),
                    chainName: chain.name,
                    nativeCurrency: chain.nativeCurrency,
                    rpcUrls: [(_b = (_a = chain.rpcUrls.public) === null || _a === void 0 ? void 0 : _a.http[0]) !== null && _b !== void 0 ? _b : ""],
                    blockExplorerUrls: this.getBlockExplorerUrls(chain),
                },
            ]));
        });
    }
    /**
     * @description Try to add a new token to the wallet through the {@link https://eips.ethereum.org/EIPS/eip-747 EIP-747} `wallet_watchAsset` method.
     *
     * @param params The observed asset's information
     * @returns True if the request is recognized by the wallet, false otherwise. If the wallet does not support this method, it will always return false.
     */
    watchAsset(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.provider)
                throw new wallet_aggregator_core_1.NotConnected();
            if (this.connector.watchAsset)
                return this.connector.watchAsset(params.options);
            // some connectors might not have a watchAsset method, like WalletConnect,
            // but the underlying wallet it is connected to might support it
            try {
                // ugly cast since wallet_watchAsset expects an object and not an array of parameters
                yield this.provider.send("wallet_watchAsset", params);
                return true;
            }
            catch (err) {
                return false;
            }
        });
    }
    getBlockExplorerUrls(chain) {
        var _a;
        const _b = (_a = chain.blockExplorers) !== null && _a !== void 0 ? _a : {}, { default: blockExplorer } = _b, blockExplorers = __rest(_b, ["default"]);
        if (blockExplorer)
            return [
                blockExplorer.url,
                ...Object.values(blockExplorers).map((x) => x.url),
            ];
    }
    /**
     * Retrieve the underlying BrowserProvider
     *
     * @returns {ethers.BrowserProvider} Returns the underlying ethers.js BrowserProvider if connected, or undefined if not
     */
    getProvider() {
        return this.provider;
    }
    /**
     * Retrieve the underlying Signer.
     *
     * @returns {ethers.Signer} Returns the underlying ethers.js Signer if connected, or undefined if not
     */
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.provider)
                throw new wallet_aggregator_core_1.NotConnected();
            return yield this.provider.getSigner(this.address);
        });
    }
    getWalletState() {
        return this.connector.ready
            ? wallet_aggregator_core_1.WalletState.Loadable
            : wallet_aggregator_core_1.WalletState.NotDetected;
    }
    getBalance(assetAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isConnected() || !this.provider)
                throw new wallet_aggregator_core_1.NotConnected();
            const signer = yield this.getSigner();
            if (!signer)
                throw new Error("Signer not found");
            if (assetAddress) {
                const erc20 = new ethers_1.ethers.Contract(assetAddress, [
                    "function balanceOf(address) view returns (uint)",
                    "function decimals() public view returns (uint8)",
                ], signer);
                const decimals = yield erc20.decimals();
                const balance = yield erc20.balanceOf(assetAddress);
                return ethers_1.ethers.formatUnits(balance, decimals);
            }
            const address = yield signer.getAddress();
            const balance = yield this.provider.getBalance(address);
            return ethers_1.ethers.formatEther(balance);
        });
    }
    onChainChanged() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.autoSwitch) {
                yield this.enforcePrefferedChain();
            }
            this.network = yield this.fetchNetworkInfo();
            this.emit("networkChanged");
        });
    }
    onAccountsChanged(accounts) {
        return __awaiter(this, void 0, void 0, function* () {
            // no new accounts === wallet disconnected
            if (!accounts.length)
                return this.disconnect();
            this.address = yield this.connector.getAccount();
            this.emit("accountsChanged", accounts);
        });
    }
    onDisconnect() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.connector.removeAllListeners();
            yield ((_a = this.wagmiConfig) === null || _a === void 0 ? void 0 : _a.destroy());
            this.wagmiConfig = undefined;
            this.emit("disconnect");
        });
    }
    fetchNetworkInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isConnected())
                return;
            return {
                chainId: yield this.connector.getChainId(),
            };
        });
    }
    parseEvmChainId(id) {
        return ethers_1.ethers.isHexString(id)
            ? parseInt(id.toString().substring(2), 16)
            : id;
    }
    getFeatures() {
        return Object.values(wallet_aggregator_core_1.BaseFeatures);
    }
    supportsChain(chainId) {
        return (0, constants_1.isTestnetEvm)(chainId) || (0, wallet_aggregator_core_1.isEVMChain)(chainId);
    }
}
exports.EVMWallet = EVMWallet;
//# sourceMappingURL=evm.js.map