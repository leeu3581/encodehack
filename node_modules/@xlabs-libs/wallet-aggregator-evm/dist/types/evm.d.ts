import { Connector } from "@wagmi/core";
import { Address, BaseFeatures, ChainId, SendTransactionResult, Signature, Wallet, WalletEvents, WalletState } from "@xlabs-libs/wallet-aggregator-core";
import { ethers, TransactionReceipt, TransactionRequest } from "ethers";
import { Chain } from "./chains";
type EVMChainId = number;
interface EVMWalletEvents extends WalletEvents {
    accountsChanged(address: Address[]): void;
}
/** @description EVMWallet config options */
export interface EVMWalletConfig<COpts = any> {
    /**
     * @description An array of evm chain config objects as defined by wagmi's Chain type.
     * While the information is the same as in the {@link https://eips.ethereum.org/EIPS/eip-3085 EIP-3085}, the structure is slightly different
     * Defaults to all chains
     */
    chains?: Chain[];
    /**
     * @description An EVM chain id. When connecting, the wallet will try to switch to this chain if the provider network's chain id differs.
     */
    preferredChain?: EVMChainId;
    /**
     * @description Indicates whether the wallet should attempt to switch the network back to the preferredChain upon detecting a `chainChanged` event.
     */
    autoSwitch?: boolean;
    /**
     * @description Amount of confirmations/blocks to wait a transaction for
     */
    confirmations?: number;
    /**
     * @description Options specific to the connection method
     */
    connectorOptions?: COpts;
}
export declare enum EVMWalletType {
    BitgetWallet = "bitgetwallet",
    Binance = "binance",
    Coinbase = "coinbase",
    Injected = "injected",
    Ledger = "ledger",
    Metamask = "metamask",
    OKXWallet = "okxwallet",
    WalletConnect = "walletconnect"
}
export interface WatchAssetParams {
    type: string;
    options: {
        address: string;
        symbol: string;
        decimals?: number;
        image?: string;
        chainId?: number;
    };
}
export interface ConnectParams {
    evmChainId?: number;
}
export type EthereumMessage = string | Uint8Array;
export interface EVMNetworkInfo {
    /** @description Network EVM chain id */
    chainId: number;
}
/**
 * @description An abstraction over EVM compatible blockchain wallets
 */
export declare abstract class EVMWallet<C extends Connector = Connector, COpts = any> extends Wallet<ChainId, ConnectParams, TransactionRequest, TransactionRequest, TransactionRequest, TransactionReceipt, TransactionRequest, TransactionReceipt, EthereumMessage, Signature, EVMNetworkInfo, BaseFeatures, EVMWalletEvents> {
    protected chains: Chain[];
    protected connector: C;
    protected connectorOptions: COpts;
    protected network?: EVMNetworkInfo;
    protected config: EVMWalletConfig<COpts>;
    private addresses;
    private address?;
    private autoSwitch;
    private wagmiConfig?;
    private provider?;
    private switchingChain;
    constructor(config?: EVMWalletConfig<COpts>);
    connect({ evmChainId }?: ConnectParams): Promise<Address[]>;
    protected abstract createConnector(): C;
    private enforcePrefferedChain;
    private onChange;
    /**
     * @description Change the preferred evm chain. Calling this method will automatically trigger a switch to the new chain request.
     *
     * @param chainId The new evm chain id
     */
    setPrefferedChain(chainId: EVMChainId): Promise<void>;
    isConnected(): boolean;
    disconnect(): Promise<void>;
    getChainId(): ChainId;
    getNetworkInfo(): EVMNetworkInfo | undefined;
    getAddress(): string | undefined;
    getAddresses(): string[];
    setMainAddress(address: string): void;
    signTransaction(tx: TransactionRequest): Promise<TransactionRequest>;
    sendTransaction(tx: TransactionRequest): Promise<SendTransactionResult<TransactionReceipt>>;
    signAndSendTransaction(tx: TransactionRequest): Promise<SendTransactionResult<TransactionReceipt>>;
    signMessage(msg: EthereumMessage): Promise<Signature>;
    /**
     * @description Try to switch the evm chain the wallet is connected to through the {@link https://eips.ethereum.org/EIPS/eip-3326 EIP-3326} `wallet_switchEthereumChain` method, or throw if the wallet does not support it.
     * Should the chain be missing from the provider, it will try to add it through the {@link https://eips.ethereum.org/EIPS/eip-3085 EIP-3085} `wallet_addEthereumChain` method, using the information stored in the map `chainParameters` injected through the constructor.
     * If a switch chain request is already in progress, it will ignore the new request and return without doing anything.
     *
     * @param ethChainId The EVM chain id of the chain to switch to
     */
    switchChain(ethChainId: EVMChainId): Promise<void>;
    /**
     * @description Try to add a new chain to the wallet through the {@link https://eips.ethereum.org/EIPS/eip-3085 EIP-3085} `wallet_addEthereumChain` method.
     * The chain information is looked up in the configured `chains` array.
     */
    addChain(ethChainId: EVMChainId): Promise<Chain>;
    /**
     * @description Try to add a new token to the wallet through the {@link https://eips.ethereum.org/EIPS/eip-747 EIP-747} `wallet_watchAsset` method.
     *
     * @param params The observed asset's information
     * @returns True if the request is recognized by the wallet, false otherwise. If the wallet does not support this method, it will always return false.
     */
    watchAsset(params: WatchAssetParams): Promise<boolean>;
    protected getBlockExplorerUrls(chain: Chain): string[] | undefined;
    /**
     * Retrieve the underlying BrowserProvider
     *
     * @returns {ethers.BrowserProvider} Returns the underlying ethers.js BrowserProvider if connected, or undefined if not
     */
    getProvider(): ethers.BrowserProvider | undefined;
    /**
     * Retrieve the underlying Signer.
     *
     * @returns {ethers.Signer} Returns the underlying ethers.js Signer if connected, or undefined if not
     */
    getSigner(): Promise<ethers.Signer>;
    getWalletState(): WalletState;
    getBalance(assetAddress?: string): Promise<string>;
    protected onChainChanged(): Promise<void>;
    protected onAccountsChanged(accounts: string[]): Promise<void>;
    protected onDisconnect(): Promise<void>;
    private fetchNetworkInfo;
    protected parseEvmChainId(id: string | number): number;
    getFeatures(): BaseFeatures[];
    supportsChain(chainId: ChainId): boolean;
}
export {};
//# sourceMappingURL=evm.d.ts.map