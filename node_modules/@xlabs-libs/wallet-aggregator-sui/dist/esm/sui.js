import { JsonRpcProvider, } from "@mysten/sui.js";
import { BaseFeatures, CHAIN_ID_SUI, NotConnected, NotSupported, Wallet, } from "@xlabs-libs/wallet-aggregator-core";
import { DEFAULTS, WalletInfo } from "./walletsInfo";
export var FeatureName;
(function (FeatureName) {
    FeatureName["STANDARD__CONNECT"] = "standard:connect";
    FeatureName["STANDARD__DISCONNECT"] = "standard:disconnect";
    FeatureName["STANDARD__EVENTS"] = "standard:events";
    FeatureName["SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK"] = "sui:signAndExecuteTransactionBlock";
    FeatureName["SUI__SIGN_TRANSACTION_BLOCK"] = "sui:signTransactionBlock";
    FeatureName["SUI__SIGN_MESSAGE"] = "sui:signMessage";
})(FeatureName || (FeatureName = {}));
const DO_NOT_REMOVE_WALLET_FROM = ["OKX", "Bitget"];
export class SuiWallet extends Wallet {
    constructor(wallet, connection) {
        super();
        this.wallet = wallet;
        this.connection = connection;
        this.accounts = [];
        if (DO_NOT_REMOVE_WALLET_FROM.find((name) => wallet.name.includes(name))) {
            this._name = wallet.name;
        }
        else {
            this._name = wallet.name.replace("Wallet", "").trim();
        }
    }
    async connect() {
        const { connect } = this.getFeature(FeatureName.STANDARD__CONNECT);
        const { accounts } = await connect();
        this.accounts = [...accounts];
        this.activeAccount = accounts[0];
        this.emit("connect");
        return this.accounts.map((a) => a.address);
    }
    async disconnect() {
        const { disconnect } = this.getFeature(FeatureName.STANDARD__DISCONNECT, false) || {};
        if (disconnect) {
            await disconnect();
        }
        this.accounts = [];
        this.emit("disconnect");
    }
    signTransaction(transactionBlock) {
        if (!this.activeAccount)
            throw new NotConnected();
        const { signTransactionBlock } = this.getFeature(FeatureName.SUI__SIGN_TRANSACTION_BLOCK);
        return signTransactionBlock({
            transactionBlock,
            account: this.activeAccount,
            chain: this.activeAccount.chains[0],
        });
    }
    async sendTransaction(tx) {
        if (!this.connection)
            throw new Error("Connection not provided");
        const provider = new JsonRpcProvider(this.connection);
        const result = await provider.executeTransactionBlock({
            signature: tx.signature,
            transactionBlock: tx.transactionBlockBytes,
        });
        return {
            id: result.digest,
            data: result,
        };
    }
    async signAndSendTransaction(options) {
        if (!this.activeAccount)
            throw new NotConnected();
        const { signAndExecuteTransactionBlock } = this.getFeature(FeatureName.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK);
        const result = await signAndExecuteTransactionBlock({
            ...options,
            account: this.activeAccount,
            chain: this.activeAccount.chains[0],
        });
        return {
            id: result.digest,
            data: result,
        };
    }
    getName() {
        return this._name;
    }
    getUrl() {
        const info = WalletInfo[this.wallet.name];
        return info?.url || DEFAULTS.url;
    }
    getChainId() {
        return CHAIN_ID_SUI;
    }
    getAddress() {
        return this.activeAccount?.address;
    }
    getAddresses() {
        return this.accounts.map((a) => a.address);
    }
    setMainAddress(address) {
        const account = this.accounts.find((a) => a.address === address);
        if (!account)
            throw new Error("Account not found");
        this.activeAccount = account;
    }
    getBalance() {
        throw new Error("Method not implemented.");
    }
    signMessage(msg) {
        const { signMessage } = this.getFeature(FeatureName.SUI__SIGN_MESSAGE);
        return signMessage(msg);
    }
    getIcon() {
        const info = WalletInfo[this.wallet.name];
        return info?.icon || DEFAULTS.icon;
    }
    isConnected() {
        return this.accounts.length > 0;
    }
    getNetworkInfo() {
        return this.activeAccount
            ? { chain: this.activeAccount.chains[0] }
            : undefined;
    }
    getFeature(name, mustSupport = true) {
        const feature = this.wallet.features[name];
        if (!feature && mustSupport)
            throw new NotSupported();
        return feature;
    }
    getFeatures() {
        const features = [BaseFeatures.SendTransaction];
        if (this.wallet.features[FeatureName.SUI__SIGN_TRANSACTION_BLOCK]) {
            features.push(BaseFeatures.SignTransaction);
        }
        if (this.wallet.features[FeatureName.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK]) {
            features.push(BaseFeatures.SignAndSendTransaction);
        }
        if (this.wallet.features[FeatureName.SUI__SIGN_MESSAGE]) {
            features.push(BaseFeatures.SignMessage);
        }
        return features;
    }
    supportsChain(chainId) {
        return chainId === CHAIN_ID_SUI;
    }
}
//# sourceMappingURL=sui.js.map