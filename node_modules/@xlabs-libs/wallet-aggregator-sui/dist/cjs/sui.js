"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuiWallet = exports.FeatureName = void 0;
const sui_js_1 = require("@mysten/sui.js");
const wallet_aggregator_core_1 = require("@xlabs-libs/wallet-aggregator-core");
const walletsInfo_1 = require("./walletsInfo");
var FeatureName;
(function (FeatureName) {
    FeatureName["STANDARD__CONNECT"] = "standard:connect";
    FeatureName["STANDARD__DISCONNECT"] = "standard:disconnect";
    FeatureName["STANDARD__EVENTS"] = "standard:events";
    FeatureName["SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK"] = "sui:signAndExecuteTransactionBlock";
    FeatureName["SUI__SIGN_TRANSACTION_BLOCK"] = "sui:signTransactionBlock";
    FeatureName["SUI__SIGN_MESSAGE"] = "sui:signMessage";
})(FeatureName || (exports.FeatureName = FeatureName = {}));
const DO_NOT_REMOVE_WALLET_FROM = ["OKX", "Bitget"];
class SuiWallet extends wallet_aggregator_core_1.Wallet {
    constructor(wallet, connection) {
        super();
        this.wallet = wallet;
        this.connection = connection;
        this.accounts = [];
        if (DO_NOT_REMOVE_WALLET_FROM.find((name) => wallet.name.includes(name))) {
            this._name = wallet.name;
        }
        else {
            this._name = wallet.name.replace("Wallet", "").trim();
        }
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            const { connect } = this.getFeature(FeatureName.STANDARD__CONNECT);
            const { accounts } = yield connect();
            this.accounts = [...accounts];
            this.activeAccount = accounts[0];
            this.emit("connect");
            return this.accounts.map((a) => a.address);
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            const { disconnect } = this.getFeature(FeatureName.STANDARD__DISCONNECT, false) || {};
            if (disconnect) {
                yield disconnect();
            }
            this.accounts = [];
            this.emit("disconnect");
        });
    }
    signTransaction(transactionBlock) {
        if (!this.activeAccount)
            throw new wallet_aggregator_core_1.NotConnected();
        const { signTransactionBlock } = this.getFeature(FeatureName.SUI__SIGN_TRANSACTION_BLOCK);
        return signTransactionBlock({
            transactionBlock,
            account: this.activeAccount,
            chain: this.activeAccount.chains[0],
        });
    }
    sendTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.connection)
                throw new Error("Connection not provided");
            const provider = new sui_js_1.JsonRpcProvider(this.connection);
            const result = yield provider.executeTransactionBlock({
                signature: tx.signature,
                transactionBlock: tx.transactionBlockBytes,
            });
            return {
                id: result.digest,
                data: result,
            };
        });
    }
    signAndSendTransaction(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.activeAccount)
                throw new wallet_aggregator_core_1.NotConnected();
            const { signAndExecuteTransactionBlock } = this.getFeature(FeatureName.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK);
            const result = yield signAndExecuteTransactionBlock(Object.assign(Object.assign({}, options), { account: this.activeAccount, chain: this.activeAccount.chains[0] }));
            return {
                id: result.digest,
                data: result,
            };
        });
    }
    getName() {
        return this._name;
    }
    getUrl() {
        const info = walletsInfo_1.WalletInfo[this.wallet.name];
        return (info === null || info === void 0 ? void 0 : info.url) || walletsInfo_1.DEFAULTS.url;
    }
    getChainId() {
        return wallet_aggregator_core_1.CHAIN_ID_SUI;
    }
    getAddress() {
        var _a;
        return (_a = this.activeAccount) === null || _a === void 0 ? void 0 : _a.address;
    }
    getAddresses() {
        return this.accounts.map((a) => a.address);
    }
    setMainAddress(address) {
        const account = this.accounts.find((a) => a.address === address);
        if (!account)
            throw new Error("Account not found");
        this.activeAccount = account;
    }
    getBalance() {
        throw new Error("Method not implemented.");
    }
    signMessage(msg) {
        const { signMessage } = this.getFeature(FeatureName.SUI__SIGN_MESSAGE);
        return signMessage(msg);
    }
    getIcon() {
        const info = walletsInfo_1.WalletInfo[this.wallet.name];
        return (info === null || info === void 0 ? void 0 : info.icon) || walletsInfo_1.DEFAULTS.icon;
    }
    isConnected() {
        return this.accounts.length > 0;
    }
    getNetworkInfo() {
        return this.activeAccount
            ? { chain: this.activeAccount.chains[0] }
            : undefined;
    }
    getFeature(name, mustSupport = true) {
        const feature = this.wallet.features[name];
        if (!feature && mustSupport)
            throw new wallet_aggregator_core_1.NotSupported();
        return feature;
    }
    getFeatures() {
        const features = [wallet_aggregator_core_1.BaseFeatures.SendTransaction];
        if (this.wallet.features[FeatureName.SUI__SIGN_TRANSACTION_BLOCK]) {
            features.push(wallet_aggregator_core_1.BaseFeatures.SignTransaction);
        }
        if (this.wallet.features[FeatureName.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK]) {
            features.push(wallet_aggregator_core_1.BaseFeatures.SignAndSendTransaction);
        }
        if (this.wallet.features[FeatureName.SUI__SIGN_MESSAGE]) {
            features.push(wallet_aggregator_core_1.BaseFeatures.SignMessage);
        }
        return features;
    }
    supportsChain(chainId) {
        return chainId === wallet_aggregator_core_1.CHAIN_ID_SUI;
    }
}
exports.SuiWallet = SuiWallet;
//# sourceMappingURL=sui.js.map