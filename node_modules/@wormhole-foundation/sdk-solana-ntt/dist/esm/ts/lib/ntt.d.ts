/// <reference types="bn.js" />
import { BN, Program, web3 } from "@coral-xyz/anchor";
import { AddressLookupTableAccount, Connection, PublicKey, PublicKeyInitData, TransactionInstruction } from "@solana/web3.js";
import { Chain, ChainId } from "@wormhole-foundation/sdk-base";
import { ChainAddress, VAA } from "@wormhole-foundation/sdk-definitions";
import { Ntt } from "@wormhole-foundation/sdk-definitions-ntt";
import { IdlVersion, NttBindings } from "./bindings.js";
export declare namespace NTT {
    /** Arguments for transfer instruction */
    interface TransferArgs {
        amount: BN;
        recipientChain: {
            id: ChainId;
        };
        recipientAddress: number[];
        shouldQueue: boolean;
    }
    /** utility to create TransferArgs from SDK types */
    function transferArgs(amount: bigint, recipient: ChainAddress, shouldQueue: boolean): TransferArgs;
    /** Type of object containing methods to compute program addresses */
    type Pdas = ReturnType<typeof pdas>;
    /** pdas returns an object containing all functions to compute program addresses */
    const pdas: (programId: PublicKeyInitData) => {
        configAccount: () => PublicKey;
        outboxRateLimitAccount: () => PublicKey;
        inboxRateLimitAccount: (chain: Chain) => PublicKey;
        inboxItemAccount: (chain: Chain, nttMessage: Ntt.Message) => PublicKey;
        sessionAuthority: (sender: PublicKey, args: TransferArgs) => PublicKey;
        tokenAuthority: () => PublicKey;
        pendingTokenAuthority: () => PublicKey;
        peerAccount: (chain: Chain) => PublicKey;
        registeredTransceiver: (transceiver: PublicKey) => PublicKey;
        lutAccount: () => PublicKey;
        lutAuthority: () => PublicKey;
    };
    /** Type of object containing methods to compute program addresses */
    type TransceiverPdas = ReturnType<typeof transceiverPdas>;
    /** pdas returns an object containing all functions to compute program addresses */
    const transceiverPdas: (programId: PublicKeyInitData) => {
        emitterAccount: () => PublicKey;
        outboxItemSigner: () => web3.PublicKey;
        transceiverPeerAccount: (chain: Chain) => PublicKey;
        transceiverMessageAccount: (chain: Chain, id: Uint8Array) => PublicKey;
        wormholeMessageAccount: (outboxItem: PublicKey) => PublicKey;
    };
    function getVersion(connection: Connection, programId: PublicKey, sender?: PublicKey): Promise<IdlVersion>;
    function createInitializeInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, args: {
        payer: PublicKey;
        owner: PublicKey;
        chain: Chain;
        mint: PublicKey;
        outboundLimit: bigint;
        tokenProgram: PublicKey;
        mode: "burning" | "locking";
        multisigTokenAuthority?: PublicKey;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction>;
    function initializeOrUpdateLUT(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, config: NttBindings.Config<IdlVersion>, whTransceiver: PublicKey, args: {
        payer: PublicKey;
        wormholeId: PublicKey;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction | null | undefined>;
    function createTransferBurnInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, config: NttBindings.Config<IdlVersion>, args: {
        payer: PublicKey;
        from: PublicKey;
        fromAuthority: PublicKey;
        transferArgs: TransferArgs;
        outboxItem: PublicKey;
    }, pdas?: Pdas): Promise<TransactionInstruction>;
    /**
     * Creates a transfer_lock instruction. The `payer`, `fromAuthority`, and `outboxItem`
     * arguments must sign the transaction
     */
    function createTransferLockInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, config: NttBindings.Config<IdlVersion>, args: {
        payer: PublicKey;
        from: PublicKey;
        fromAuthority: PublicKey;
        transferArgs: NTT.TransferArgs;
        outboxItem: PublicKey;
    }, pdas?: Pdas): Promise<TransactionInstruction>;
    function createReleaseInboundMintInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, config: NttBindings.Config<IdlVersion>, args: {
        payer: PublicKey;
        chain: Chain;
        nttMessage: Ntt.Message;
        revertWhenNotReady: boolean;
        recipient?: PublicKey;
    }, pdas?: Pdas): Promise<TransactionInstruction>;
    function createReleaseInboundUnlockInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, config: NttBindings.Config<IdlVersion>, args: {
        payer: PublicKey;
        chain: Chain;
        nttMessage: Ntt.Message;
        revertWhenNotReady: boolean;
        recipient?: PublicKey;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction>;
    function createTransferOwnershipInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, args: {
        newOwner: PublicKey;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction>;
    function createAcceptTokenAuthorityInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, config: NttBindings.Config<IdlVersion>, args: {
        currentAuthority: PublicKey;
        multisigTokenAuthority?: PublicKey;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction>;
    function createAcceptTokenAuthorityFromMultisigInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, config: NttBindings.Config<IdlVersion>, args: {
        currentMultisigAuthority: PublicKey;
        additionalSigners: readonly PublicKey[];
        multisigTokenAuthority?: PublicKey;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction>;
    function createSetTokenAuthorityOneStepUncheckedInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, config: NttBindings.Config<IdlVersion>, args: {
        owner: PublicKey;
        newAuthority: PublicKey;
        multisigTokenAuthority?: PublicKey;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction>;
    function createSetTokenAuthorityInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, config: NttBindings.Config<IdlVersion>, args: {
        rentPayer: PublicKey;
        owner: PublicKey;
        newAuthority: PublicKey;
        multisigTokenAuthority?: PublicKey;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction>;
    function createRevertTokenAuthorityInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, config: NttBindings.Config<IdlVersion>, args: {
        rentPayer: PublicKey;
        owner: PublicKey;
        multisigTokenAuthority?: PublicKey;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction>;
    function createClaimTokenAuthorityInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, config: NttBindings.Config<IdlVersion>, args: {
        rentPayer: PublicKey;
        newAuthority: PublicKey;
        multisigTokenAuthority?: PublicKey;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction>;
    function createClaimTokenAuthorityToMultisigInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, config: NttBindings.Config<IdlVersion>, args: {
        rentPayer: PublicKey;
        newMultisigAuthority: PublicKey;
        additionalSigners: readonly PublicKey[];
        multisigTokenAuthority?: PublicKey;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction>;
    function createSetPeerInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, args: {
        payer: PublicKey;
        owner: PublicKey;
        chain: Chain;
        address: ArrayLike<number>;
        limit: BN;
        tokenDecimals: number;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction>;
    function createSetPausedInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, args: {
        owner: PublicKey;
        paused: boolean;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction>;
    function createSetThresholdInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, args: {
        owner: PublicKey;
        threshold: number;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction>;
    function createSetOutboundLimitInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, args: {
        owner: PublicKey;
        limit: BN;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction>;
    function setInboundLimit(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, args: {
        owner: PublicKey;
        chain: Chain;
        limit: BN;
    }, pdas?: Pdas): Promise<web3.TransactionInstruction>;
    function createRedeemInstruction(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, config: NttBindings.Config<IdlVersion>, transceiverProgramId: PublicKey, args: {
        payer: PublicKey;
        vaa: VAA<"Ntt:WormholeTransfer">;
    }, pdas?: Pdas, transceiverPdas?: TransceiverPdas): Promise<TransactionInstruction>;
    /**
     * Fetches the Config account from the contract.
     *
     * @param config If provided, the config is just returned without making a
     *               network request. This is handy in case multiple config
     *               accessor functions are used, the config can just be queried
     *               once and passed around.
     */
    function getConfig(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, pdas: Pdas): Promise<NttBindings.Config<IdlVersion>>;
    function getInboxItem(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, fromChain: Chain, nttMessage: Ntt.Message): Promise<NttBindings.InboxItem<IdlVersion>>;
    function getAddressLookupTable(program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>, pdas?: Pdas): Promise<AddressLookupTableAccount | null>;
    /**
     * Returns the address of the custody account. If the config is available
     * (i.e. the program is initialised), the mint is derived from the config.
     * Otherwise, the mint must be provided.
     */
    function custodyAccountAddress(pdas: Pdas, configOrMint: NttBindings.Config<IdlVersion> | PublicKey, tokenProgram?: web3.PublicKey): Promise<PublicKey>;
}
//# sourceMappingURL=ntt.d.ts.map