import { BN } from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";
import { encoding, toChainId, } from "@wormhole-foundation/sdk-base";
export const BPF_LOADER_UPGRADEABLE_PROGRAM_ID = new PublicKey("BPFLoaderUpgradeab1e11111111111111111111111");
export function programDataAddress(programId) {
    return PublicKey.findProgramAddressSync([new PublicKey(programId).toBytes()], BPF_LOADER_UPGRADEABLE_PROGRAM_ID)[0];
}
export function parseVersion(version) {
    const components = version.split(".");
    if (components.length < 3)
        throw new Error("Invalid version string");
    const patchVersion = components[2];
    const patchNumber = patchVersion.split(/[^0-9]/)[0];
    const patchLabel = patchVersion.slice(patchNumber.length);
    return [
        Number(components[0]),
        Number(components[1]),
        Number(patchNumber),
        patchLabel,
    ];
}
export const pubKeyConversion = {
    to: (encoded) => new PublicKey(encoded),
    from: (decoded) => decoded.toBytes(),
};
//neither anchor nor solana web3 have a built-in way to parse this, because ofc they don't
export const programDataLayout = [
    { name: "slot", binary: "uint", endianness: "little", size: 8 },
    {
        name: "upgradeAuthority",
        binary: "switch",
        idSize: 1,
        idTag: "isSome",
        layouts: [
            [[0, false], []],
            [
                [1, true],
                [
                    {
                        name: "value",
                        binary: "bytes",
                        size: 32,
                        custom: pubKeyConversion,
                    },
                ],
            ],
        ],
    },
];
export const programVersionLayout = [
    { name: "length", binary: "uint", endianness: "little", size: 4 },
    { name: "version", binary: "bytes" },
];
export const U64 = {
    MAX: new BN((2n ** 64n - 1n).toString()),
    to: (amount, unit) => {
        const ret = new BN(Math.round(amount * unit));
        if (ret.isNeg())
            throw new Error("Value negative");
        if (ret.bitLength() > 64)
            throw new Error("Value too large");
        return ret;
    },
    from: (amount, unit) => amount.toNumber() / unit,
};
export function derivePda(seeds, programId) {
    const toBytes = (s) => typeof s === "string" ? encoding.bytes.encode(s) : s;
    return PublicKey.findProgramAddressSync(Array.isArray(seeds) ? seeds.map(toBytes) : [toBytes(seeds)], new PublicKey(programId))[0];
}
export const chainToBytes = (chain) => encoding.bignum.toBytes(toChainId(chain), 2);
export const quoterAddresses = (programId) => {
    const instanceAccount = () => derivePda("instance", programId);
    const registeredNttAccount = (nttProgramId) => derivePda(["registered_ntt", nttProgramId.toBytes()], programId);
    const relayRequestAccount = (outboxItem) => derivePda(["relay_request", outboxItem.toBytes()], programId);
    const registeredChainAccount = (chain) => derivePda(["registered_chain", chainToBytes(chain)], programId);
    return {
        relayRequestAccount,
        instanceAccount,
        registeredChainAccount,
        registeredNttAccount,
    };
};
//# sourceMappingURL=utils.js.map