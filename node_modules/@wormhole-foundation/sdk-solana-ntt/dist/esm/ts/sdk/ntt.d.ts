import { Program, web3 } from "@coral-xyz/anchor";
import { AddressLookupTableAccount, Connection, Keypair, PublicKey } from "@solana/web3.js";
import { Chain, Network } from "@wormhole-foundation/sdk-base";
import { AccountAddress, ChainAddress, ChainsConfig, Contracts, UnsignedTransaction } from "@wormhole-foundation/sdk-definitions";
import { Ntt, SolanaNttTransceiver, WormholeNttTransceiver } from "@wormhole-foundation/sdk-definitions-ntt";
import { AnySolanaAddress, SolanaChains, SolanaPlatformType, SolanaTransaction, SolanaUnsignedTransaction } from "@wormhole-foundation/sdk-solana";
import { SolanaWormholeCore } from "@wormhole-foundation/sdk-solana-core";
import { IdlVersion, NttBindings } from "../lib/bindings.js";
import { NTT, NttQuoter } from "../lib/index.js";
export declare class SolanaNttWormholeTransceiver<N extends Network, C extends SolanaChains> implements WormholeNttTransceiver<N, C>, SolanaNttTransceiver<N, C, WormholeNttTransceiver.VAA> {
    readonly manager: SolanaNtt<N, C>;
    readonly program: Program<NttBindings.Transceiver<IdlVersion>>;
    readonly version: string;
    programId: PublicKey;
    pdas: NTT.TransceiverPdas;
    constructor(manager: SolanaNtt<N, C>, program: Program<NttBindings.Transceiver<IdlVersion>>, version?: string);
    getPauser(): Promise<AccountAddress<C> | null>;
    setPauser(_newPauser: AccountAddress<C>, _payer: AccountAddress<C>): AsyncGenerator<never, void, unknown>;
    receive(attestation: WormholeNttTransceiver.VAA, payer: AccountAddress<C>): AsyncGenerator<SolanaUnsignedTransaction<N, C>, void, unknown>;
    createReceiveIx(attestation: WormholeNttTransceiver.VAA<"WormholeTransfer">, payer: PublicKey): Promise<web3.TransactionInstruction>;
    getTransceiverType(payer: AccountAddress<C>): Promise<string>;
    getAddress(): ChainAddress<C>;
    setPeer(peer: ChainAddress<C>, payer: AccountAddress<C>): AsyncGenerator<SolanaUnsignedTransaction<N, C>, void, unknown>;
    getPeer<C extends Chain>(chain: C): Promise<ChainAddress<C> | null>;
    createBroadcastWormholeIdIx(payer: PublicKey, config: NttBindings.Config<IdlVersion>, wormholeMessage: PublicKey): Promise<web3.TransactionInstruction>;
    createBroadcastWormholePeerIx(chain: Chain, payer: PublicKey, wormholeMessage: PublicKey): Promise<web3.TransactionInstruction>;
    createReleaseWormholeOutboundIx(payer: PublicKey, outboxItem: PublicKey, revertOnDelay: boolean): Promise<web3.TransactionInstruction>;
}
export declare class SolanaNtt<N extends Network, C extends SolanaChains> implements Ntt<N, C> {
    readonly network: N;
    readonly chain: C;
    readonly connection: Connection;
    readonly contracts: Contracts & {
        ntt?: Ntt.Contracts;
    };
    readonly version: string;
    core: SolanaWormholeCore<N, C>;
    pdas: NTT.Pdas;
    program: Program<NttBindings.NativeTokenTransfer<IdlVersion>>;
    config?: NttBindings.Config<IdlVersion>;
    quoter?: NttQuoter;
    addressLookupTable?: AddressLookupTableAccount;
    transceivers: Program<NttBindings.Transceiver<IdlVersion>>[];
    private managerAddress;
    private tokenAddress;
    constructor(network: N, chain: C, connection: Connection, contracts: Contracts & {
        ntt?: Ntt.Contracts;
    }, version?: string);
    getTransceiver<T extends number>(ix: T): Promise<(T extends 0 ? SolanaNttWormholeTransceiver<N, C> : SolanaNttTransceiver<N, C, any>) | null>;
    getWormholeTransceiver(): Promise<SolanaNttWormholeTransceiver<N, C> | null>;
    getMode(): Promise<Ntt.Mode>;
    isPaused(): Promise<boolean>;
    pause(payer: AccountAddress<C>): AsyncGenerator<SolanaUnsignedTransaction<N, C>, void, unknown>;
    unpause(payer: AccountAddress<C>): AsyncGenerator<SolanaUnsignedTransaction<N, C>, void, unknown>;
    getThreshold(): Promise<number>;
    getOwner(): Promise<AccountAddress<C>>;
    getPauser(): Promise<AccountAddress<C> | null>;
    setOwner(newOwner: AnySolanaAddress, payer: AccountAddress<C>): AsyncGenerator<SolanaUnsignedTransaction<N, C>, void, unknown>;
    setPauser(_newPauser: AnySolanaAddress, _payer: AccountAddress<C>): AsyncGenerator<never, void, unknown>;
    isRelayingAvailable(destination: Chain): Promise<boolean>;
    quoteDeliveryPrice(destination: Chain, options: Ntt.TransferOptions): Promise<bigint>;
    static fromRpc<N extends Network>(provider: Connection, config: ChainsConfig<N, SolanaPlatformType>): Promise<SolanaNtt<N, SolanaChains>>;
    getConfig(): Promise<NttBindings.Config<IdlVersion>>;
    getTokenDecimals(): Promise<number>;
    getPeer<C extends Chain>(chain: C): Promise<Ntt.Peer<C> | null>;
    getCustodyAddress(): Promise<string>;
    static getVersion(connection: Connection, contracts: Contracts & {
        ntt: Ntt.Contracts;
    }, sender?: AccountAddress<SolanaChains>): Promise<IdlVersion>;
    initialize(sender: AccountAddress<C>, args: {
        mint: PublicKey;
        mode: Ntt.Mode;
        outboundLimit: bigint;
        multisigTokenAuthority?: PublicKey;
    }): AsyncGenerator<SolanaUnsignedTransaction<N, C>, void, unknown>;
    initializeOrUpdateLUT(args: {
        payer: PublicKey;
    }): AsyncGenerator<SolanaUnsignedTransaction<N, C>, void, unknown>;
    registerWormholeTransceiver(args: {
        payer: AccountAddress<C>;
        owner: AccountAddress<C>;
    }): AsyncGenerator<SolanaUnsignedTransaction<N, C>, void, unknown>;
    createRegisterTransceiverIx(ix: number, payer: web3.PublicKey, owner: web3.PublicKey): Promise<web3.TransactionInstruction>;
    createDeregisterTransceiverIx(ix: number, owner: web3.PublicKey): Promise<web3.TransactionInstruction>;
    setWormholeTransceiverPeer(peer: ChainAddress, payer: AccountAddress<C>): AsyncGenerator<UnsignedTransaction<N, C>, void, unknown>;
    setTransceiverPeer(ix: number, peer: ChainAddress, payer: AccountAddress<C>): AsyncGenerator<UnsignedTransaction<N, C>, void, unknown>;
    setPeer(peer: ChainAddress, tokenDecimals: number, inboundLimit: bigint, payer: AccountAddress<C>): AsyncGenerator<SolanaUnsignedTransaction<N, C>, void, unknown>;
    transfer(sender: AccountAddress<C>, amount: bigint, destination: ChainAddress, options: Ntt.TransferOptions, outboxItem?: Keypair): AsyncGenerator<UnsignedTransaction<N, C>, any, unknown>;
    private getTokenAccount;
    private createAta;
    redeem(attestations: Ntt.Attestation[], payer: AccountAddress<C>): AsyncGenerator<SolanaUnsignedTransaction<N, C>, void, unknown>;
    getCurrentOutboundCapacity(): Promise<bigint>;
    getOutboundLimit(): Promise<bigint>;
    setOutboundLimit(limit: bigint, payer: AccountAddress<C>): AsyncGenerator<SolanaUnsignedTransaction<N, C>, void, unknown>;
    getCurrentInboundCapacity(fromChain: Chain): Promise<bigint>;
    getRateLimitDuration(): Promise<bigint>;
    getInboundLimit(fromChain: Chain): Promise<bigint>;
    setInboundLimit(fromChain: Chain, limit: bigint, payer: AccountAddress<C>): AsyncGenerator<SolanaUnsignedTransaction<N, C>, void, unknown>;
    getIsExecuted(attestation: Ntt.Attestation): Promise<boolean>;
    getIsTransferInboundQueued(attestation: Ntt.Attestation): Promise<boolean>;
    getIsApproved(attestation: Ntt.Attestation): Promise<boolean>;
    completeInboundQueuedTransfer(fromChain: Chain, transceiverMessage: Ntt.Message, payer: AccountAddress<C>): AsyncGenerator<SolanaUnsignedTransaction<N, C>, void, unknown>;
    getInboundQueuedTransfer(chain: Chain, nttMessage: Ntt.Message): Promise<Ntt.InboundQueuedTransfer<C> | null>;
    verifyAddresses(): Promise<Partial<Ntt.Contracts> | null>;
    getAddressLookupTable(useCache?: boolean): Promise<AddressLookupTableAccount>;
    createUnsignedTx(txReq: SolanaTransaction, description: string, parallelizable?: boolean): SolanaUnsignedTransaction<N, C>;
}
//# sourceMappingURL=ntt.d.ts.map