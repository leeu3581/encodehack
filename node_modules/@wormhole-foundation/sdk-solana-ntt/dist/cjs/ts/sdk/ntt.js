"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaNtt = exports.SolanaNttWormholeTransceiver = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const splToken = __importStar(require("@solana/spl-token"));
const web3_js_1 = require("@solana/web3.js");
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const sdk_definitions_1 = require("@wormhole-foundation/sdk-definitions");
const sdk_solana_1 = require("@wormhole-foundation/sdk-solana");
const sdk_solana_core_1 = require("@wormhole-foundation/sdk-solana-core");
const bn_js_1 = __importDefault(require("bn.js"));
const bindings_js_1 = require("../lib/bindings.js");
const index_js_1 = require("../lib/index.js");
const utils_js_1 = require("../lib/utils.js");
class SolanaNttWormholeTransceiver {
    manager;
    program;
    version;
    programId;
    pdas;
    constructor(manager, program, version = "3.0.0") {
        this.manager = manager;
        this.program = program;
        this.version = version;
        this.programId = program.programId;
        this.pdas = index_js_1.NTT.transceiverPdas(program.programId);
    }
    async getPauser() {
        return null;
    }
    async *setPauser(_newPauser, _payer) {
        throw new Error("Method not implemented.");
    }
    // NOTE: this method is not used for the Solana Wormhole transceiver.
    // `createReceiveIx` is used directly as it can be batched with other ixs in a single tx
    async *receive(attestation, payer) {
        if (attestation.payloadName !== "WormholeTransfer") {
            throw new Error("Invalid attestation payload");
        }
        const senderAddress = new sdk_solana_1.SolanaAddress(payer).unwrap();
        const ix = await this.createReceiveIx(attestation, senderAddress);
        const tx = new web3_js_1.Transaction();
        tx.feePayer = senderAddress;
        tx.add(ix);
        yield this.manager.createUnsignedTx({ transaction: tx }, "Ntt.Redeem");
    }
    async createReceiveIx(attestation, payer) {
        const nttMessage = attestation.payload.nttManagerPayload;
        const chain = attestation.emitterChain;
        return this.program.methods
            .receiveWormholeMessage()
            .accounts({
            payer,
            config: { config: this.manager.pdas.configAccount() },
            peer: this.pdas.transceiverPeerAccount(chain),
            vaa: sdk_solana_core_1.utils.derivePostedVaaKey(this.manager.core.address, Buffer.from(attestation.hash)),
            transceiverMessage: this.pdas.transceiverMessageAccount(chain, nttMessage.id),
        })
            .instruction();
    }
    async getTransceiverType(payer) {
        // NOTE: transceiver type does not exist for versions < 3.x.x so we hardcode
        const [major, , ,] = (0, utils_js_1.parseVersion)(this.version);
        if (major < 3) {
            return "wormhole";
        }
        // the anchor library has a built-in method to read view functions. However,
        // it requires a signer, which would trigger a wallet prompt on the frontend.
        // Instead, we manually construct a versioned transaction and call the
        // simulate function with sigVerify: false below.
        //
        // This way, the simulation won't require a signer, but it still requires
        // the pubkey of an account that has some lamports in it (since the
        // simulation checks if the account has enough money to pay for the transaction).
        //
        // It's a little unfortunate but it's the best we can do.
        const payerKey = new sdk_solana_1.SolanaAddress(payer).unwrap();
        const ix = await this.program.methods
            .transceiverType()
            .accountsStrict({})
            .instruction();
        const latestBlockHash = await this.program.provider.connection.getLatestBlockhash();
        const msg = new web3_js_1.TransactionMessage({
            payerKey,
            recentBlockhash: latestBlockHash.blockhash,
            instructions: [ix],
        }).compileToV0Message();
        const tx = new web3_js_1.VersionedTransaction(msg);
        const txSimulation = await this.program.provider.connection.simulateTransaction(tx, {
            sigVerify: false,
        });
        // the return buffer is in base64 and it encodes the string with a 32 bit
        // little endian length prefix.
        if (txSimulation.value.returnData?.data[0]) {
            const buffer = Buffer.from(txSimulation.value.returnData?.data[0], "base64");
            const len = buffer.readUInt32LE(0);
            return buffer.subarray(4, len + 4).toString();
        }
        else {
            throw new Error("no transceiver type found");
        }
    }
    getAddress() {
        return {
            chain: this.manager.chain,
            address: (0, sdk_definitions_1.toUniversal)(this.manager.chain, this.pdas.emitterAccount().toBase58()),
        };
    }
    async *setPeer(peer, payer) {
        const sender = new sdk_solana_1.SolanaAddress(payer).unwrap();
        const ix = await this.program.methods
            .setWormholePeer({
            chainId: { id: (0, sdk_base_1.toChainId)(peer.chain) },
            address: Array.from(peer.address.toUniversalAddress().toUint8Array()),
        })
            .accounts({
            payer: sender,
            owner: sender,
            config: this.manager.pdas.configAccount(),
            peer: this.pdas.transceiverPeerAccount(peer.chain),
        })
            .instruction();
        const wormholeMessage = web3_js_1.Keypair.generate();
        const broadcastIx = await this.createBroadcastWormholePeerIx(peer.chain, sender, wormholeMessage.publicKey);
        const tx = new web3_js_1.Transaction();
        tx.feePayer = sender;
        tx.add(ix, broadcastIx);
        yield this.manager.createUnsignedTx({ transaction: tx, signers: [wormholeMessage] }, "Ntt.SetWormholeTransceiverPeer");
    }
    async getPeer(chain) {
        const peer = await this.manager.program.account.transceiverPeer.fetchNullable(this.pdas.transceiverPeerAccount(chain));
        if (!peer)
            return null;
        return {
            chain,
            address: (0, sdk_definitions_1.toUniversal)(chain, new Uint8Array(peer.address)),
        };
    }
    async createBroadcastWormholeIdIx(payer, config, wormholeMessage) {
        const whAccs = sdk_solana_core_1.utils.getWormholeDerivedAccounts(this.program.programId, this.manager.core.address);
        return this.program.methods
            .broadcastWormholeId()
            .accountsStrict({
            payer,
            config: this.manager.pdas.configAccount(),
            mint: config.mint,
            wormholeMessage: wormholeMessage,
            emitter: whAccs.wormholeEmitter,
            wormhole: {
                bridge: whAccs.wormholeBridge,
                feeCollector: whAccs.wormholeFeeCollector,
                sequence: whAccs.wormholeSequence,
                program: this.manager.core.address,
                systemProgram: web3_js_1.SystemProgram.programId,
                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
                rent: anchor_1.web3.SYSVAR_RENT_PUBKEY,
            },
        })
            .instruction();
    }
    async createBroadcastWormholePeerIx(chain, payer, wormholeMessage) {
        const whAccs = sdk_solana_core_1.utils.getWormholeDerivedAccounts(this.program.programId, this.manager.core.address);
        return this.program.methods
            .broadcastWormholePeer({ chainId: (0, sdk_base_1.toChainId)(chain) })
            .accounts({
            payer: payer,
            config: this.manager.pdas.configAccount(),
            peer: this.pdas.transceiverPeerAccount(chain),
            wormholeMessage: wormholeMessage,
            emitter: whAccs.wormholeEmitter,
            wormhole: {
                bridge: whAccs.wormholeBridge,
                feeCollector: whAccs.wormholeFeeCollector,
                sequence: whAccs.wormholeSequence,
                program: this.manager.core.address,
            },
        })
            .instruction();
    }
    async createReleaseWormholeOutboundIx(payer, outboxItem, revertOnDelay) {
        const [major, , ,] = (0, utils_js_1.parseVersion)(this.version);
        const whAccs = sdk_solana_core_1.utils.getWormholeDerivedAccounts(this.program.programId, this.manager.core.address);
        return this.program.methods
            .releaseWormholeOutbound({
            revertOnDelay: revertOnDelay,
        })
            .accounts({
            payer,
            config: { config: this.manager.pdas.configAccount() },
            outboxItem,
            wormholeMessage: this.pdas.wormholeMessageAccount(outboxItem),
            emitter: whAccs.wormholeEmitter,
            transceiver: this.manager.pdas.registeredTransceiver(this.program.programId),
            wormhole: {
                bridge: whAccs.wormholeBridge,
                feeCollector: whAccs.wormholeFeeCollector,
                sequence: whAccs.wormholeSequence,
                program: this.manager.core.address,
            },
            // NOTE: baked-in transceiver case is handled separately
            // due to tx size error when LUT is not configured
            ...(major >= 3 && {
                manager: this.manager.program.programId,
                outboxItemSigner: this.pdas.outboxItemSigner(),
            }),
        })
            .instruction();
    }
}
exports.SolanaNttWormholeTransceiver = SolanaNttWormholeTransceiver;
class SolanaNtt {
    network;
    chain;
    connection;
    contracts;
    version;
    core;
    pdas;
    program;
    config;
    quoter;
    addressLookupTable;
    // 0 = Wormhole xcvr
    transceivers;
    // NOTE: these are stored from the constructor, but are not used directly
    // (only in verifyAddresses)
    managerAddress;
    tokenAddress;
    constructor(network, chain, connection, contracts, version = "3.0.0") {
        this.network = network;
        this.chain = chain;
        this.connection = connection;
        this.contracts = contracts;
        this.version = version;
        if (!contracts.ntt)
            throw new Error("Ntt contracts not found");
        this.program = (0, bindings_js_1.getNttProgram)(connection, contracts.ntt.manager, version);
        this.transceivers = [];
        if ("wormhole" in contracts.ntt.transceiver &&
            contracts.ntt.transceiver["wormhole"]) {
            const transceiverTypes = [
                "wormhole", // wormhole xcvr should be ix 0
                ...Object.keys(contracts.ntt.transceiver).filter((transceiverType) => {
                    transceiverType !== "wormhole";
                }),
            ];
            transceiverTypes.map((transceiverType) => {
                // we currently only support wormhole transceivers
                if (transceiverType !== "wormhole") {
                    throw new Error(`Unsupported transceiver type: ${transceiverType}`);
                }
                const transceiverKey = new web3_js_1.PublicKey(contracts.ntt.transceiver[transceiverType]);
                // handle emitterAccount case separately
                if (!web3_js_1.PublicKey.isOnCurve(transceiverKey)) {
                    const whTransceiver = new SolanaNttWormholeTransceiver(this, (0, bindings_js_1.getTransceiverProgram)(connection, contracts.ntt.manager, version), version);
                    if (!whTransceiver.pdas.emitterAccount().equals(transceiverKey)) {
                        throw new Error(`Invalid emitterAccount provided. Expected: ${whTransceiver.pdas
                            .emitterAccount()
                            .toBase58()}; Actual: ${transceiverKey.toBase58()}`);
                    }
                    this.transceivers.push(whTransceiver.program);
                }
                else {
                    this.transceivers.push((0, bindings_js_1.getTransceiverProgram)(connection, contracts.ntt.transceiver[transceiverType], version));
                }
            });
        }
        this.managerAddress = contracts.ntt.manager;
        this.tokenAddress = contracts.ntt.token;
        if (this.contracts.ntt?.quoter)
            this.quoter = new index_js_1.NttQuoter(connection, this.contracts.ntt.quoter, this.contracts.ntt.manager);
        this.core = new sdk_solana_core_1.SolanaWormholeCore(network, chain, connection, contracts);
        this.pdas = index_js_1.NTT.pdas(this.program.programId);
    }
    async getTransceiver(ix) {
        const transceiverProgram = this.transceivers[ix] ?? null;
        if (!transceiverProgram)
            return null;
        if (ix === 0)
            return new SolanaNttWormholeTransceiver(this, transceiverProgram, this.version);
        return null;
    }
    async getWormholeTransceiver() {
        return this.getTransceiver(0);
    }
    async getMode() {
        const config = await this.getConfig();
        return config.mode.locking != null ? "locking" : "burning";
    }
    async isPaused() {
        const config = await this.getConfig();
        return config.paused;
    }
    async *pause(payer) {
        const sender = new sdk_solana_1.SolanaAddress(payer).unwrap();
        const ix = await index_js_1.NTT.createSetPausedInstruction(this.program, {
            owner: sender,
            paused: true,
        });
        const tx = new web3_js_1.Transaction();
        tx.feePayer = sender;
        tx.add(ix);
        yield this.createUnsignedTx({ transaction: tx }, "Ntt.Pause");
    }
    async *unpause(payer) {
        const sender = new sdk_solana_1.SolanaAddress(payer).unwrap();
        const ix = await index_js_1.NTT.createSetPausedInstruction(this.program, {
            owner: sender,
            paused: false,
        });
        const tx = new web3_js_1.Transaction();
        tx.feePayer = sender;
        tx.add(ix);
        yield this.createUnsignedTx({ transaction: tx }, "Ntt.Unpause");
    }
    async getThreshold() {
        const config = await this.getConfig();
        return config.threshold;
    }
    async getOwner() {
        const config = await this.getConfig();
        return new sdk_solana_1.SolanaAddress(config.owner);
    }
    async getPauser() {
        return null;
    }
    async *setOwner(newOwner, payer) {
        const sender = new sdk_solana_1.SolanaAddress(payer).unwrap();
        const ix = await index_js_1.NTT.createTransferOwnershipInstruction(this.program, {
            newOwner: new sdk_solana_1.SolanaAddress(newOwner).unwrap(),
        });
        const tx = new web3_js_1.Transaction();
        tx.feePayer = sender;
        tx.add(ix);
        yield this.createUnsignedTx({ transaction: tx }, "Ntt.SetOwner");
    }
    async *setPauser(_newPauser, _payer) {
        throw new Error("Pauser role not supported on Solana.");
    }
    async isRelayingAvailable(destination) {
        if (!this.quoter)
            return false;
        return await this.quoter.isRelayEnabled(destination);
    }
    async quoteDeliveryPrice(destination, options) {
        if (!this.quoter)
            throw new Error("Quoter not available");
        if (!this.quoter.isRelayEnabled(destination))
            throw new Error("Relay not enabled");
        return await this.quoter.quoteDeliveryPrice(destination, options.gasDropoff);
    }
    static async fromRpc(provider, config) {
        const [network, chain] = await sdk_solana_1.SolanaPlatform.chainFromRpc(provider);
        const conf = config[chain];
        if (conf.network !== network)
            throw new Error(`Network mismatch: ${conf.network} != ${network}`);
        if (!("ntt" in conf.contracts))
            throw new Error("Ntt contracts not found");
        const ntt = conf.contracts["ntt"];
        const version = await SolanaNtt.getVersion(provider, 
        //@ts-ignore
        conf.contracts);
        return new SolanaNtt(network, chain, provider, { ...conf.contracts, ntt }, version);
    }
    async getConfig() {
        this.config = this.config ?? (await index_js_1.NTT.getConfig(this.program, this.pdas));
        return this.config;
    }
    async getTokenDecimals() {
        const config = await this.getConfig();
        return await sdk_solana_1.SolanaPlatform.getDecimals(this.chain, this.connection, config.mint);
    }
    async getPeer(chain) {
        const peer = await this.program.account.nttManagerPeer.fetchNullable(this.pdas.peerAccount(chain));
        if (!peer)
            return null;
        return {
            address: {
                chain: chain,
                address: (0, sdk_definitions_1.toUniversal)(chain, new Uint8Array(peer.address)),
            },
            tokenDecimals: peer.tokenDecimals,
            inboundLimit: await this.getInboundLimit(chain),
        };
    }
    async getCustodyAddress() {
        return (await this.getConfig()).custody.toBase58();
    }
    static async getVersion(connection, contracts, sender) {
        try {
            return await index_js_1.NTT.getVersion(connection, new web3_js_1.PublicKey(contracts.ntt.manager), sender ? new sdk_solana_1.SolanaAddress(sender).unwrap() : undefined);
        }
        catch (e) {
            // This might happen if e.g. the program is not deployed yet.
            const version = "3.0.0";
            return version;
        }
    }
    async *initialize(sender, args) {
        const mintInfo = await this.connection.getAccountInfo(args.mint);
        if (mintInfo === null)
            throw new Error("Couldn't determine token program. Mint account is null.");
        const payer = new sdk_solana_1.SolanaAddress(sender).unwrap();
        const ix = await index_js_1.NTT.createInitializeInstruction(this.program, {
            ...args,
            payer,
            owner: payer,
            chain: this.chain,
            tokenProgram: mintInfo.owner,
            multisigTokenAuthority: args.multisigTokenAuthority,
        }, this.pdas);
        const tx = new web3_js_1.Transaction();
        tx.feePayer = payer;
        tx.add(ix);
        yield this.createUnsignedTx({ transaction: tx, signers: [] }, "Ntt.Initialize");
        yield* this.initializeOrUpdateLUT({ payer });
    }
    async *initializeOrUpdateLUT(args) {
        const config = await this.getConfig();
        const whTransceiver = await this.getWormholeTransceiver();
        if (!whTransceiver) {
            throw new Error("wormhole transceiver not found");
        }
        const whTransceiverProgramId = whTransceiver.programId;
        const ix = await index_js_1.NTT.initializeOrUpdateLUT(this.program, config, whTransceiverProgramId, {
            payer: args.payer,
            wormholeId: new web3_js_1.PublicKey(this.core.address),
        });
        // Already up to date
        if (!ix)
            return;
        const tx = new web3_js_1.Transaction().add(ix);
        tx.feePayer = args.payer;
        yield this.createUnsignedTx({ transaction: tx }, "Ntt.InitializeLUT");
    }
    async *registerWormholeTransceiver(args) {
        const payer = new sdk_solana_1.SolanaAddress(args.payer).unwrap();
        const owner = new sdk_solana_1.SolanaAddress(args.owner).unwrap();
        const config = await this.getConfig();
        if (config.paused)
            throw new Error("Contract is paused");
        const ix = await this.createRegisterTransceiverIx(0, payer, owner);
        const whTransceiver = (await this.getWormholeTransceiver());
        const wormholeMessage = web3_js_1.Keypair.generate();
        const broadcastIx = await whTransceiver.createBroadcastWormholeIdIx(payer, config, wormholeMessage.publicKey);
        const tx = new web3_js_1.Transaction();
        tx.feePayer = payer;
        tx.add(ix, broadcastIx);
        yield this.createUnsignedTx({ transaction: tx, signers: [wormholeMessage] }, "Ntt.RegisterTransceiver");
    }
    // TODO: maybe add to Ntt interface
    async createRegisterTransceiverIx(ix, payer, owner) {
        const transceiver = await this.getTransceiver(ix);
        if (!transceiver) {
            throw new Error(`Transceiver not found`);
        }
        const transceiverProgramId = transceiver.programId;
        return this.program.methods
            .registerTransceiver()
            .accountsStrict({
            payer,
            owner,
            config: this.pdas.configAccount(),
            transceiver: transceiverProgramId,
            registeredTransceiver: this.pdas.registeredTransceiver(transceiverProgramId),
            systemProgram: web3_js_1.SystemProgram.programId,
        })
            .instruction();
    }
    async createDeregisterTransceiverIx(ix, owner) {
        const transceiver = await this.getTransceiver(ix);
        if (!transceiver) {
            throw new Error(`Transceiver not found`);
        }
        const transceiverProgramId = transceiver.programId;
        return this.program.methods
            .deregisterTransceiver()
            .accountsStrict({
            owner,
            config: this.pdas.configAccount(),
            transceiver: transceiverProgramId,
            registeredTransceiver: this.pdas.registeredTransceiver(transceiverProgramId),
        })
            .instruction();
    }
    async *setWormholeTransceiverPeer(peer, payer) {
        yield* this.setTransceiverPeer(0, peer, payer);
    }
    async *setTransceiverPeer(ix, peer, payer) {
        const transceiver = await this.getTransceiver(ix);
        if (!transceiver) {
            throw new Error("Transceiver not found");
        }
        yield* transceiver.setPeer(peer, payer);
    }
    async *setPeer(peer, tokenDecimals, inboundLimit, payer) {
        const sender = new sdk_solana_1.SolanaAddress(payer).unwrap();
        const ix = await index_js_1.NTT.createSetPeerInstruction(this.program, {
            payer: sender,
            owner: sender,
            chain: peer.chain,
            address: peer.address.toUniversalAddress().toUint8Array(),
            limit: new bn_js_1.default(inboundLimit.toString()),
            tokenDecimals,
        });
        const tx = new web3_js_1.Transaction();
        tx.feePayer = sender;
        tx.add(ix);
        yield this.createUnsignedTx({ transaction: tx }, "Ntt.SetPeer");
    }
    async *transfer(sender, amount, destination, options, outboxItem) {
        const config = await this.getConfig();
        if (config.paused)
            throw new Error("Contract is paused");
        outboxItem = outboxItem ?? web3_js_1.Keypair.generate();
        const payerAddress = new sdk_solana_1.SolanaAddress(sender).unwrap();
        const fromAuthority = payerAddress;
        const from = await this.getTokenAccount(fromAuthority);
        if (options.wrapNative) {
            if (this.tokenAddress !== splToken.NATIVE_MINT.toBase58()) {
                throw new Error("Configured token must be native mint for wrapping");
            }
            const associatedTokenAccount = splToken.getAssociatedTokenAddressSync(splToken.NATIVE_MINT, payerAddress);
            const accountExists = await this.connection.getAccountInfo(associatedTokenAccount);
            const instructions = [
                // Create the associated token account if it doesn't exist
                ...(accountExists
                    ? []
                    : [
                        splToken.createAssociatedTokenAccountInstruction(payerAddress, associatedTokenAccount, payerAddress, splToken.NATIVE_MINT),
                    ]),
                web3_js_1.SystemProgram.transfer({
                    fromPubkey: payerAddress,
                    toPubkey: associatedTokenAccount,
                    lamports: amount,
                }),
                // Sync the native token account
                splToken.createSyncNativeInstruction(associatedTokenAccount),
            ];
            const { blockhash } = await this.connection.getLatestBlockhash();
            const messageV0 = new web3_js_1.TransactionMessage({
                payerKey: payerAddress,
                instructions,
                recentBlockhash: blockhash,
            }).compileToV0Message();
            const transaction = new web3_js_1.VersionedTransaction(messageV0);
            // NOTE: wrap native is handled separately due to tx size error
            yield this.createUnsignedTx({ transaction }, "Ntt.WrapNative");
        }
        const transferArgs = index_js_1.NTT.transferArgs(amount, destination, options.queue);
        const txArgs = {
            transferArgs,
            payer: payerAddress,
            from,
            fromAuthority,
            outboxItem: outboxItem.publicKey,
        };
        const approveIx = splToken.createApproveInstruction(from, this.pdas.sessionAuthority(fromAuthority, transferArgs), fromAuthority, amount, [], config.tokenProgram);
        const asyncIxs = [];
        const transferIx = config.mode.locking != null
            ? index_js_1.NTT.createTransferLockInstruction(this.program, config, txArgs, this.pdas)
            : index_js_1.NTT.createTransferBurnInstruction(this.program, config, txArgs, this.pdas);
        asyncIxs.push(transferIx);
        for (let ix = 0; ix < this.transceivers.length; ++ix) {
            if (ix === 0) {
                const whTransceiver = await this.getWormholeTransceiver();
                if (!whTransceiver) {
                    throw new Error("wormhole transceiver not found");
                }
                const releaseIx = whTransceiver.createReleaseWormholeOutboundIx(payerAddress, outboxItem.publicKey, !options.queue);
                asyncIxs.push(releaseIx);
            }
        }
        const tx = new web3_js_1.Transaction();
        tx.feePayer = payerAddress;
        tx.add(approveIx, ...(await Promise.all(asyncIxs)));
        if (options.automatic) {
            if (!this.quoter)
                throw new Error("No quoter available, cannot initiate an automatic transfer.");
            const fee = await this.quoteDeliveryPrice(destination.chain, options);
            const relayIx = await this.quoter.createRequestRelayInstruction(payerAddress, outboxItem.publicKey, destination.chain, Number(fee) / web3_js_1.LAMPORTS_PER_SOL, 
            // NOTE: quoter expects gas dropoff to be in terms of gwei
            Number(options.gasDropoff ?? 0n) / index_js_1.WEI_PER_GWEI);
            tx.add(relayIx);
        }
        const luts = [];
        try {
            luts.push(await this.getAddressLookupTable());
        }
        catch { }
        const messageV0 = new web3_js_1.TransactionMessage({
            payerKey: payerAddress,
            instructions: tx.instructions,
            recentBlockhash: (await this.connection.getLatestBlockhash()).blockhash,
        }).compileToV0Message(luts);
        const vtx = new web3_js_1.VersionedTransaction(messageV0);
        yield this.createUnsignedTx({ transaction: vtx, signers: [outboxItem] }, "Ntt.Transfer");
    }
    async getTokenAccount(sender) {
        const config = await this.getConfig();
        const tokenAccount = await splToken.getAssociatedTokenAddress(config.mint, sender, true, config.tokenProgram);
        return tokenAccount;
    }
    async *createAta(sender) {
        const config = await this.getConfig();
        const senderAddress = new sdk_solana_1.SolanaAddress(sender).unwrap();
        const ata = await this.getTokenAccount(senderAddress);
        // If the ata doesn't exist yet, create it
        const acctInfo = await this.connection.getAccountInfo(ata);
        if (acctInfo === null) {
            const transaction = new web3_js_1.Transaction().add(splToken.createAssociatedTokenAccountInstruction(senderAddress, ata, senderAddress, config.mint, config.tokenProgram));
            transaction.feePayer = senderAddress;
            yield this.createUnsignedTx({ transaction }, "Redeem.CreateATA");
        }
    }
    async *redeem(attestations, payer) {
        const config = await this.getConfig();
        if (config.paused)
            throw new Error("Contract is paused");
        if (attestations.length !== this.transceivers.length) {
            throw new Error("Not enough attestations provided");
        }
        for (const { attestation, ix } of attestations.map((attestation, ix) => ({
            attestation,
            ix,
        }))) {
            if (ix === 0) {
                const wormholeNTT = attestation;
                if (wormholeNTT.payloadName !== "WormholeTransfer") {
                    throw new Error("Invalid attestation payload");
                }
                const whTransceiver = await this.getWormholeTransceiver();
                if (!whTransceiver) {
                    throw new Error("wormhole transceiver not found");
                }
                // Create the vaa if necessary
                yield* this.createAta(payer);
                // Post the VAA that we intend to redeem
                yield* this.core.postVaa(payer, wormholeNTT);
                const senderAddress = new sdk_solana_1.SolanaAddress(payer).unwrap();
                const receiveMessageIx = whTransceiver.createReceiveIx(wormholeNTT, senderAddress);
                const redeemIx = index_js_1.NTT.createRedeemInstruction(this.program, config, whTransceiver.program.programId, {
                    payer: senderAddress,
                    vaa: wormholeNTT,
                });
                const nttMessage = wormholeNTT.payload.nttManagerPayload;
                const emitterChain = wormholeNTT.emitterChain;
                const releaseArgs = {
                    payer: senderAddress,
                    config,
                    nttMessage,
                    recipient: new web3_js_1.PublicKey(nttMessage.payload.recipientAddress.toUint8Array()),
                    chain: emitterChain,
                    // NOTE: this acts as `revertOnDelay` for versions < 3.x.x
                    revertWhenNotReady: false,
                };
                let releaseIx = config.mode.locking != null
                    ? index_js_1.NTT.createReleaseInboundUnlockInstruction(this.program, config, {
                        ...releaseArgs,
                    })
                    : index_js_1.NTT.createReleaseInboundMintInstruction(this.program, config, {
                        ...releaseArgs,
                    });
                const tx = new web3_js_1.Transaction();
                tx.feePayer = senderAddress;
                tx.add(...(await Promise.all([receiveMessageIx, redeemIx, releaseIx])));
                const luts = [];
                try {
                    luts.push(await this.getAddressLookupTable());
                }
                catch { }
                const messageV0 = new web3_js_1.TransactionMessage({
                    payerKey: senderAddress,
                    instructions: tx.instructions,
                    recentBlockhash: (await this.connection.getLatestBlockhash())
                        .blockhash,
                }).compileToV0Message(luts);
                const vtx = new web3_js_1.VersionedTransaction(messageV0);
                yield this.createUnsignedTx({ transaction: vtx }, "Ntt.Redeem");
            }
        }
    }
    async getCurrentOutboundCapacity() {
        const rl = await this.program.account.outboxRateLimit.fetch(this.pdas.outboxRateLimitAccount());
        return BigInt(rl.rateLimit.capacityAtLastTx.toString());
    }
    async getOutboundLimit() {
        const rl = await this.program.account.outboxRateLimit.fetch(this.pdas.outboxRateLimitAccount());
        return BigInt(rl.rateLimit.limit.toString());
    }
    async *setOutboundLimit(limit, payer) {
        const sender = new sdk_solana_1.SolanaAddress(payer).unwrap();
        const ix = await index_js_1.NTT.createSetOutboundLimitInstruction(this.program, {
            owner: sender,
            limit: new bn_js_1.default(limit.toString()),
        });
        const tx = new web3_js_1.Transaction();
        tx.feePayer = sender;
        tx.add(ix);
        yield this.createUnsignedTx({ transaction: tx }, "Ntt.SetOutboundLimit");
    }
    async getCurrentInboundCapacity(fromChain) {
        const rl = await this.program.account.inboxRateLimit.fetch(this.pdas.inboxRateLimitAccount(fromChain));
        return BigInt(rl.rateLimit.capacityAtLastTx.toString());
    }
    async getRateLimitDuration() {
        // The rate limit duration is hardcoded to 24 hours on Solana
        return BigInt(24 * 60 * 60);
    }
    async getInboundLimit(fromChain) {
        const rl = await this.program.account.inboxRateLimit.fetch(this.pdas.inboxRateLimitAccount(fromChain));
        return BigInt(rl.rateLimit.limit.toString());
    }
    async *setInboundLimit(fromChain, limit, payer) {
        const sender = new sdk_solana_1.SolanaAddress(payer).unwrap();
        const ix = await index_js_1.NTT.setInboundLimit(this.program, {
            owner: sender,
            chain: fromChain,
            limit: new bn_js_1.default(limit.toString()),
        });
        const tx = new web3_js_1.Transaction();
        tx.feePayer = sender;
        tx.add(ix);
        yield this.createUnsignedTx({ transaction: tx }, "Ntt.SetInboundLimit");
    }
    async getIsExecuted(attestation) {
        if (attestation.payloadName !== "WormholeTransfer")
            return false;
        const payload = attestation.payload["nttManagerPayload"];
        let inboxItem;
        try {
            inboxItem = await this.program.account.inboxItem.fetch(this.pdas.inboxItemAccount(attestation.emitterChain, payload));
        }
        catch (e) {
            if (e.message?.includes("Account does not exist")) {
                return false;
            }
            throw e;
        }
        return !!inboxItem.releaseStatus.released;
    }
    async getIsTransferInboundQueued(attestation) {
        if (attestation.payloadName !== "WormholeTransfer")
            return false;
        const payload = attestation.payload["nttManagerPayload"];
        let inboxItem;
        try {
            inboxItem = await this.program.account.inboxItem.fetch(this.pdas.inboxItemAccount(attestation.emitterChain, payload));
        }
        catch (e) {
            if (e.message?.includes("Account does not exist")) {
                return false;
            }
            throw e;
        }
        return !!inboxItem.releaseStatus.releaseAfter;
    }
    async getIsApproved(attestation) {
        if (attestation.payloadName !== "WormholeTransfer") {
            throw new Error(`Invalid payload: ${attestation.payloadName}`);
        }
        const payload = attestation.payload["nttManagerPayload"];
        try {
            // check that the inbox item was initialized
            const inboxItem = await this.program.account.inboxItem.fetch(this.pdas.inboxItemAccount(attestation.emitterChain, payload));
            return inboxItem.init;
        }
        catch (e) {
            if (e.message?.includes("Account does not exist")) {
                return false;
            }
            throw e;
        }
    }
    async *completeInboundQueuedTransfer(fromChain, transceiverMessage, payer) {
        const config = await this.getConfig();
        if (config.paused)
            throw new Error("Contract is paused");
        const senderAddress = new sdk_solana_1.SolanaAddress(payer).unwrap();
        const tx = new web3_js_1.Transaction();
        tx.feePayer = senderAddress;
        const releaseArgs = {
            payer: senderAddress,
            config,
            nttMessage: transceiverMessage,
            recipient: new web3_js_1.PublicKey(transceiverMessage.payload.recipientAddress.toUint8Array()),
            chain: fromChain,
            // NOTE: this acts as `revertOnDelay` for versions < 3.x.x
            revertWhenNotReady: false,
        };
        tx.add(await (config.mode.locking != null
            ? index_js_1.NTT.createReleaseInboundUnlockInstruction(this.program, config, releaseArgs)
            : index_js_1.NTT.createReleaseInboundMintInstruction(this.program, config, releaseArgs)));
        yield this.createUnsignedTx({ transaction: tx }, "Ntt.CompleteInboundTransfer");
    }
    async getInboundQueuedTransfer(chain, nttMessage) {
        let inboxItem;
        try {
            inboxItem = await this.program.account.inboxItem.fetch(this.pdas.inboxItemAccount(chain, nttMessage));
        }
        catch (e) {
            if (e.message?.includes("Account does not exist")) {
                return null;
            }
            throw e;
        }
        if (inboxItem.releaseStatus.releaseAfter) {
            const { recipientAddress, amount, releaseStatus } = inboxItem;
            const rateLimitExpiry = releaseStatus.releaseAfter[0].toNumber();
            const xfer = {
                recipient: new sdk_solana_1.SolanaAddress(recipientAddress),
                amount: BigInt(amount.toString()),
                rateLimitExpiryTimestamp: rateLimitExpiry,
            };
            return xfer;
        }
        return null;
    }
    async verifyAddresses() {
        // NOTE: This function should only be called when the wormhole transceiver is the manager.
        // For the generic transceiver case, transceivers can not be compared as there is no
        // reverse lookup given manager address to the registered transceivers.
        const whTransceiver = await this.getWormholeTransceiver();
        const local = {
            manager: this.managerAddress,
            token: this.tokenAddress,
            transceiver: {
                ...(whTransceiver && {
                    wormhole: whTransceiver.pdas.emitterAccount().toBase58(),
                }),
            },
        };
        const remote = {
            manager: this.program.programId.toBase58(),
            token: (await this.getConfig()).mint.toBase58(),
            transceiver: {
                wormhole: index_js_1.NTT.transceiverPdas(this.program.programId)
                    .emitterAccount()
                    .toBase58(),
            },
        };
        const deleteMatching = (a, b) => {
            for (const k in a) {
                if (typeof a[k] === "object") {
                    deleteMatching(a[k], b[k]);
                    if (Object.keys(a[k]).length === 0)
                        delete a[k];
                }
                else if (a[k] === b[k]) {
                    delete a[k];
                }
            }
        };
        deleteMatching(remote, local);
        return Object.keys(remote).length > 0 ? remote : null;
    }
    async getAddressLookupTable(useCache = true) {
        if (!useCache || !this.addressLookupTable) {
            const alut = await index_js_1.NTT.getAddressLookupTable(this.program, this.pdas);
            if (alut)
                this.addressLookupTable = alut;
        }
        if (!this.addressLookupTable)
            throw new Error("Address lookup table not found. Did you forget to call initializeLUT?");
        return this.addressLookupTable;
    }
    createUnsignedTx(txReq, description, parallelizable = false) {
        return new sdk_solana_1.SolanaUnsignedTransaction(txReq, this.network, this.chain, description, parallelizable);
    }
}
exports.SolanaNtt = SolanaNtt;
//# sourceMappingURL=ntt.js.map