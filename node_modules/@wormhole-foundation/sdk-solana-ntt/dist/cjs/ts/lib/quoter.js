"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NttQuoter = exports.WEI_PER_GWEI = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const sdk_base_2 = require("@wormhole-foundation/sdk-base");
const ntt_quoter_json_1 = __importDefault(require("../idl/2_0_0/json/ntt_quoter.json"));
const utils_js_1 = require("./utils.js");
//constants that must match ntt-quoter lib.rs / implementation:
const USD_UNIT = 1e6;
const GWEI_PER_ETH = 1e9;
exports.WEI_PER_GWEI = 1e9;
const SEED_PREFIX_INSTANCE = "instance";
const SEED_PREFIX_REGISTERED_CHAIN = "registered_chain";
const SEED_PREFIX_REGISTERED_NTT = "registered_ntt";
const SEED_PREFIX_RELAY_REQUEST = "relay_request";
class NttQuoter {
    instance;
    program;
    nttProgramId;
    pdas;
    constructor(connection, programId, nttProgramId) {
        // @ts-ignore
        this.program = new anchor_1.Program(ntt_quoter_json_1.default, new web3_js_1.PublicKey(programId), {
            connection,
        });
        this.nttProgramId = new web3_js_1.PublicKey(nttProgramId);
        this.pdas = (0, utils_js_1.quoterAddresses)(this.program.programId);
        this.instance = (0, utils_js_1.derivePda)([SEED_PREFIX_INSTANCE], this.program.programId);
    }
    // ---- user relevant functions ----
    async isRelayEnabled(destination) {
        try {
            const { paused } = await this.getRegisteredChain(destination);
            return !paused;
        }
        catch (e) {
            if (e.message?.includes("Account does not exist")) {
                return false;
            }
            throw e;
        }
    }
    async calcRelayCostInSol(nttProgramId, chain, requestedGasDropoffEth) {
        const [chainData, nttData, instanceData, rentCost] = await Promise.all([
            this.getRegisteredChain(chain),
            this.getRegisteredNtt(nttProgramId),
            this.getInstance(),
            this.program.provider.connection.getMinimumBalanceForRentExemption(this.program.account.relayRequest.size),
        ]);
        if (requestedGasDropoffEth > chainData.maxGasDropoffEth)
            throw new Error("Requested gas dropoff exceeds allowed maximum");
        const totalNativeGasCostUsd = chainData.nativePriceUsd *
            (requestedGasDropoffEth +
                (chainData.gasPriceGwei * nttData.gasCost) / GWEI_PER_ETH);
        const totalCostSol = rentCost / web3_js_1.LAMPORTS_PER_SOL +
            (chainData.basePriceUsd + totalNativeGasCostUsd) /
                instanceData.solPriceUsd;
        return totalCostSol;
    }
    /**
     * Estimate the cost of a relay request
     * @param chain The destination chain
     * @param gasDropoff The amount of native gas to end up with on the destination chain
     * @returns The estimated cost in lamports
     */
    async quoteDeliveryPrice(chain, gasDropoff) {
        if ((0, sdk_base_1.chainToPlatform)(chain) !== "Evm")
            throw new Error("Only EVM chains are supported");
        // Convert to decimal number since we're multiplying other numbers
        const gasDropoffEth = sdk_base_1.amount.whole(sdk_base_1.amount.fromBaseUnits(gasDropoff ?? 0n, 18));
        const [chainData, instanceData, nttData, rentCost] = await Promise.all([
            this.getRegisteredChain(chain),
            this.getInstance(),
            this.getRegisteredNtt(this.nttProgramId),
            this.program.provider.connection.getMinimumBalanceForRentExemption(this.program.account.relayRequest.size),
        ]);
        if (chainData.nativePriceUsd === 0)
            throw new Error("Native price is 0");
        if (instanceData.solPriceUsd === 0)
            throw new Error("SOL price is 0");
        if (gasDropoffEth > chainData.maxGasDropoffEth)
            throw new Error("Requested gas dropoff exceeds allowed maximum");
        const totalNativeGasCostUsd = chainData.nativePriceUsd *
            (gasDropoffEth +
                (chainData.gasPriceGwei * nttData.gasCost) / GWEI_PER_ETH);
        const totalCostSol = rentCost / web3_js_1.LAMPORTS_PER_SOL +
            (chainData.basePriceUsd + totalNativeGasCostUsd) /
                instanceData.solPriceUsd;
        // Add 5% to account for possible price updates while the tx is in flight
        return BigInt(utils_js_1.U64.to(totalCostSol * 1.05, web3_js_1.LAMPORTS_PER_SOL).toString());
    }
    async createRequestRelayInstruction(payer, outboxItem, chain, maxFeeSol, gasDropoffEth) {
        return this.program.methods
            .requestRelay({
            maxFee: utils_js_1.U64.to(maxFeeSol, web3_js_1.LAMPORTS_PER_SOL),
            gasDropoff: utils_js_1.U64.to(gasDropoffEth, GWEI_PER_ETH),
        })
            .accountsStrict({
            payer,
            instance: this.instance,
            registeredChain: this.registeredChainPda(chain),
            outboxItem,
            relayRequest: this.relayRequestPda(outboxItem),
            systemProgram: web3_js_1.SystemProgram.programId,
            registeredNtt: this.pdas.registeredNttAccount(this.nttProgramId),
        })
            .instruction();
    }
    // ---- admin/assistant (=authority) relevant functions ----
    async getInstance() {
        const data = await this.program.account.instance.fetch(this.instance);
        return {
            owner: data.owner,
            assistant: data.assistant,
            feeRecipient: data.feeRecipient,
            solPriceUsd: utils_js_1.U64.from(data.solPrice, USD_UNIT),
        };
    }
    async getRegisteredChain(chain) {
        const data = await this.program.account.registeredChain.fetch(this.registeredChainPda(chain));
        return {
            paused: data.basePrice.eq(utils_js_1.U64.MAX),
            maxGasDropoffEth: utils_js_1.U64.from(data.maxGasDropoff, GWEI_PER_ETH),
            basePriceUsd: utils_js_1.U64.from(data.basePrice, USD_UNIT),
            nativePriceUsd: utils_js_1.U64.from(data.nativePrice, USD_UNIT),
            gasPriceGwei: utils_js_1.U64.from(data.gasPrice, exports.WEI_PER_GWEI),
        };
    }
    async getRegisteredNtt(nttProgramId) {
        const data = await this.program.account.registeredNtt.fetch(this.registeredNttPda(nttProgramId));
        return {
            gasCost: data.gasCost,
            wormholeTransceiverIndex: data.wormholeTransceiverIndex,
        };
    }
    //returns null if no relay was requested, otherwise it the requested gas dropoff (in eth),
    //  which can be 0, so a strict === null check is required!
    async wasRelayRequested(outboxItem) {
        const relayRequest = await this.program.account.relayRequest.fetchNullable(this.relayRequestPda(outboxItem));
        return relayRequest
            ? utils_js_1.U64.from(relayRequest.requestedGasDropoff, GWEI_PER_ETH)
            : null;
    }
    async createInitalizeInstruction(feeRecipient) {
        if (!this.program.account.instance.fetchNullable(this.instance))
            throw new Error("Already initialized");
        const programData = (0, utils_js_1.programDataAddress)(this.program.programId);
        const accInfo = await this.program.provider.connection.getAccountInfo(programData);
        if (!accInfo)
            throw new Error("Could not find program data account");
        const deserProgramData = (0, sdk_base_2.deserializeLayout)(utils_js_1.programDataLayout, accInfo.data);
        if (!deserProgramData.upgradeAuthority.isSome)
            throw new Error("Could not determine program owner from program data.");
        return this.program.methods
            .initialize()
            .accounts({
            owner: deserProgramData.upgradeAuthority.value,
            instance: this.instance,
            feeRecipient,
            programData,
            systemProgram: web3_js_1.SystemProgram.programId,
        })
            .instruction();
    }
    async createSetAssistantInstruction(assistant) {
        const { owner, assistant: currentAssistant } = await this.getInstance();
        if (currentAssistant.equals(assistant))
            throw new Error("Is already assistant");
        return this.program.methods
            .setAssistant()
            .accounts({
            owner,
            instance: this.instance,
            assistant,
        })
            .instruction();
    }
    async createSetFeeRecipientInstruction(feeRecipient) {
        if (feeRecipient.equals(web3_js_1.PublicKey.default))
            throw new Error("Fee recipient cannot be default public key");
        const { owner, feeRecipient: currentFeeRecipient } = await this.getInstance();
        if (currentFeeRecipient.equals(feeRecipient))
            throw new Error("Is already feeRecipient");
        return this.program.methods
            .setFeeRecipient()
            .accounts({
            owner,
            instance: this.instance,
            feeRecipient,
        })
            .instruction();
    }
    async createRegisterChainInstruction(authority, chain) {
        const chainId = (0, sdk_base_2.toChainId)(chain);
        return this.program.methods
            .registerChain({ chainId })
            .accounts({
            authority,
            instance: this.instance,
            registeredChain: this.registeredChainPda(chain),
            systemProgram: web3_js_1.SystemProgram.programId,
        })
            .instruction();
    }
    async createRegisterNttInstruction(authority, nttProgramId, gasCost, wormholeTransceiverIndex) {
        return this.program.methods
            .registerNtt({
            nttProgramId,
            gasCost,
            wormholeTransceiverIndex,
        })
            .accounts({
            authority,
            instance: this.instance,
            registeredNtt: this.registeredNttPda(nttProgramId),
            systemProgram: web3_js_1.SystemProgram.programId,
        })
            .instruction();
    }
    async createDeregisterNttInstruction(authority, nttProgramId) {
        return this.program.methods
            .deregisterNtt({ nttProgramId })
            .accounts({
            authority,
            instance: this.instance,
            registeredNtt: this.registeredNttPda(nttProgramId),
            systemProgram: web3_js_1.SystemProgram.programId,
        })
            .instruction();
    }
    async createUpdateSolPriceInstruction(authority, solPriceUsd) {
        return this.program.methods
            .updateSolPrice({
            solPrice: utils_js_1.U64.to(solPriceUsd, USD_UNIT),
        })
            .accounts({
            authority,
            instance: this.instance,
        })
            .instruction();
    }
    async createUpdateChainParamsInstruction(authority, chain, maxGasDropoffEth, basePriceUsd) {
        return this.program.methods
            .updateChainParams({
            maxGasDropoff: utils_js_1.U64.to(maxGasDropoffEth, GWEI_PER_ETH),
            basePrice: utils_js_1.U64.to(basePriceUsd, USD_UNIT),
        })
            .accounts({
            authority,
            instance: this.instance,
            registeredChain: this.registeredChainPda(chain),
        })
            .instruction();
    }
    async createPauseRelayForChainInstruction(authority, chain) {
        return this.program.methods
            .updateChainParams({
            maxGasDropoff: utils_js_1.U64.to(0, 1),
            basePrice: utils_js_1.U64.MAX,
        })
            .accounts({
            authority,
            instance: this.instance,
            registeredChain: this.registeredChainPda(chain),
        })
            .instruction();
    }
    async createUpdateChainPricesInstruction(authority, chain, nativePriceUsd, gasPriceGwei) {
        return this.program.methods
            .updateChainPrices({
            nativePrice: utils_js_1.U64.to(nativePriceUsd, USD_UNIT),
            gasPrice: utils_js_1.U64.to(gasPriceGwei, exports.WEI_PER_GWEI),
        })
            .accounts({
            authority,
            instance: this.instance,
            registeredChain: this.registeredChainPda(chain),
        })
            .instruction();
    }
    async createCloseRelayInstruction(authority, outboxItem) {
        return this.program.methods
            .closeRelay()
            .accounts({
            authority,
            instance: this.instance,
            relayRequest: this.relayRequestPda(outboxItem),
        })
            .instruction();
    }
    // ---- private ----
    registeredChainPda(chainId) {
        return (0, utils_js_1.derivePda)([SEED_PREFIX_REGISTERED_CHAIN, (0, utils_js_1.chainToBytes)(chainId)], this.program.programId);
    }
    registeredNttPda(nttProgramId) {
        return (0, utils_js_1.derivePda)([SEED_PREFIX_REGISTERED_NTT, nttProgramId.toBytes()], this.program.programId);
    }
    relayRequestPda(outboxItem) {
        return (0, utils_js_1.derivePda)([SEED_PREFIX_RELAY_REQUEST, outboxItem.toBytes()], this.program.programId);
    }
}
exports.NttQuoter = NttQuoter;
//# sourceMappingURL=quoter.js.map