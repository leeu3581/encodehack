"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.quoterAddresses = exports.chainToBytes = exports.derivePda = exports.U64 = exports.programVersionLayout = exports.programDataLayout = exports.pubKeyConversion = exports.parseVersion = exports.programDataAddress = exports.BPF_LOADER_UPGRADEABLE_PROGRAM_ID = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
exports.BPF_LOADER_UPGRADEABLE_PROGRAM_ID = new web3_js_1.PublicKey("BPFLoaderUpgradeab1e11111111111111111111111");
function programDataAddress(programId) {
    return web3_js_1.PublicKey.findProgramAddressSync([new web3_js_1.PublicKey(programId).toBytes()], exports.BPF_LOADER_UPGRADEABLE_PROGRAM_ID)[0];
}
exports.programDataAddress = programDataAddress;
function parseVersion(version) {
    const components = version.split(".");
    if (components.length < 3)
        throw new Error("Invalid version string");
    const patchVersion = components[2];
    const patchNumber = patchVersion.split(/[^0-9]/)[0];
    const patchLabel = patchVersion.slice(patchNumber.length);
    return [
        Number(components[0]),
        Number(components[1]),
        Number(patchNumber),
        patchLabel,
    ];
}
exports.parseVersion = parseVersion;
exports.pubKeyConversion = {
    to: (encoded) => new web3_js_1.PublicKey(encoded),
    from: (decoded) => decoded.toBytes(),
};
//neither anchor nor solana web3 have a built-in way to parse this, because ofc they don't
exports.programDataLayout = [
    { name: "slot", binary: "uint", endianness: "little", size: 8 },
    {
        name: "upgradeAuthority",
        binary: "switch",
        idSize: 1,
        idTag: "isSome",
        layouts: [
            [[0, false], []],
            [
                [1, true],
                [
                    {
                        name: "value",
                        binary: "bytes",
                        size: 32,
                        custom: exports.pubKeyConversion,
                    },
                ],
            ],
        ],
    },
];
exports.programVersionLayout = [
    { name: "length", binary: "uint", endianness: "little", size: 4 },
    { name: "version", binary: "bytes" },
];
exports.U64 = {
    MAX: new anchor_1.BN((2n ** 64n - 1n).toString()),
    to: (amount, unit) => {
        const ret = new anchor_1.BN(Math.round(amount * unit));
        if (ret.isNeg())
            throw new Error("Value negative");
        if (ret.bitLength() > 64)
            throw new Error("Value too large");
        return ret;
    },
    from: (amount, unit) => amount.toNumber() / unit,
};
function derivePda(seeds, programId) {
    const toBytes = (s) => typeof s === "string" ? sdk_base_1.encoding.bytes.encode(s) : s;
    return web3_js_1.PublicKey.findProgramAddressSync(Array.isArray(seeds) ? seeds.map(toBytes) : [toBytes(seeds)], new web3_js_1.PublicKey(programId))[0];
}
exports.derivePda = derivePda;
const chainToBytes = (chain) => sdk_base_1.encoding.bignum.toBytes((0, sdk_base_1.toChainId)(chain), 2);
exports.chainToBytes = chainToBytes;
const quoterAddresses = (programId) => {
    const instanceAccount = () => derivePda("instance", programId);
    const registeredNttAccount = (nttProgramId) => derivePda(["registered_ntt", nttProgramId.toBytes()], programId);
    const relayRequestAccount = (outboxItem) => derivePda(["relay_request", outboxItem.toBytes()], programId);
    const registeredChainAccount = (chain) => derivePda(["registered_chain", (0, exports.chainToBytes)(chain)], programId);
    return {
        relayRequestAccount,
        instanceAccount,
        registeredChainAccount,
        registeredNttAccount,
    };
};
exports.quoterAddresses = quoterAddresses;
//# sourceMappingURL=utils.js.map