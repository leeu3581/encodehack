import { cS as xo, cT as ot, O as Z, Q as Ow, cU as Do, cO as $u } from "./index-CGIqRhuR.mjs";
import { s as Fo, x as Lh, r as kh, H as Rw, c as zh, q as Ss } from "./evm-BKJMUoQ5.mjs";
import { c as F } from "./index-Dmzj0s48.mjs";
import { I as ur, f as gt, t as nt, c as Cu, C as $w, d as Cw, r as Nw, a as xr, g as Hh, i as bt, b as Cs, e as Nu, h as Tw, j as Aw, k as Ns, p as Vh, T as Ts, l as As, E as ke, m as xw, y as Qe, P as Tu, Q as Dw, n as Fw, o as qo, q as xs, s as Bt, _ as qw, u as jw, v as Au } from "./index-BlqxhAuq.mjs";
var se = {};
Object.defineProperty(se, "__esModule", { value: !0 });
se.getLocalStorage = se.getLocalStorageOrThrow = se.getCrypto = se.getCryptoOrThrow = se.getLocation = se.getLocationOrThrow = se.getNavigator = se.getNavigatorOrThrow = se.getDocument = se.getDocumentOrThrow = se.getFromWindowOrThrow = se.getFromWindow = void 0;
function hr(a) {
  let t;
  return typeof window < "u" && typeof window[a] < "u" && (t = window[a]), t;
}
se.getFromWindow = hr;
function qr(a) {
  const t = hr(a);
  if (!t)
    throw new Error(`${a} is not defined in Window`);
  return t;
}
se.getFromWindowOrThrow = qr;
function Uw() {
  return qr("document");
}
se.getDocumentOrThrow = Uw;
function Mw() {
  return hr("document");
}
se.getDocument = Mw;
function Lw() {
  return qr("navigator");
}
se.getNavigatorOrThrow = Lw;
function kw() {
  return hr("navigator");
}
se.getNavigator = kw;
function zw() {
  return qr("location");
}
se.getLocationOrThrow = zw;
function Hw() {
  return hr("location");
}
se.getLocation = Hw;
function Vw() {
  return qr("crypto");
}
se.getCryptoOrThrow = Vw;
function Kw() {
  return hr("crypto");
}
se.getCrypto = Kw;
function Bw() {
  return qr("localStorage");
}
se.getLocalStorageOrThrow = Bw;
function Ww() {
  return hr("localStorage");
}
se.getLocalStorage = Ww;
var jo = {};
Object.defineProperty(jo, "__esModule", { value: !0 });
jo.getWindowMetadata = void 0;
const xu = se;
function Gw() {
  let a, t;
  try {
    a = xu.getDocumentOrThrow(), t = xu.getLocationOrThrow();
  } catch {
    return null;
  }
  function r() {
    const S = a.getElementsByTagName("link"), R = [];
    for (let q = 0; q < S.length; q++) {
      const A = S[q], V = A.getAttribute("rel");
      if (V && V.toLowerCase().indexOf("icon") > -1) {
        const x = A.getAttribute("href");
        if (x)
          if (x.toLowerCase().indexOf("https:") === -1 && x.toLowerCase().indexOf("http:") === -1 && x.indexOf("//") !== 0) {
            let G = t.protocol + "//" + t.host;
            if (x.indexOf("/") === 0)
              G += x;
            else {
              const pe = t.pathname.split("/");
              pe.pop();
              const J = pe.join("/");
              G += J + "/" + x;
            }
            R.push(G);
          } else if (x.indexOf("//") === 0) {
            const G = t.protocol + x;
            R.push(G);
          } else
            R.push(x);
      }
    }
    return R;
  }
  function s(...S) {
    const R = a.getElementsByTagName("meta");
    for (let q = 0; q < R.length; q++) {
      const A = R[q], V = ["itemprop", "property", "name"].map((x) => A.getAttribute(x)).filter((x) => x ? S.includes(x) : !1);
      if (V.length && V) {
        const x = A.getAttribute("content");
        if (x)
          return x;
      }
    }
    return "";
  }
  function o() {
    let S = s("name", "og:site_name", "og:title", "twitter:title");
    return S || (S = a.title), S;
  }
  function u() {
    return s("description", "og:description", "twitter:description", "keywords");
  }
  const l = o(), g = u(), w = t.origin, b = r();
  return {
    description: g,
    url: w,
    icons: b,
    name: l
  };
}
jo.getWindowMetadata = Gw;
function Qw(a, t = []) {
  const r = [];
  return Object.keys(a).forEach((s) => {
    if (t.length && !t.includes(s)) return;
    const o = a[s];
    r.push(...o.accounts);
  }), r;
}
const Jw = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
function Yw(a, t) {
  const { message: r, code: s } = Jw[a];
  return { message: r, code: s };
}
function wo(a, t) {
  return !!Array.isArray(a);
}
var jr = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var _o = function(a, t) {
  return _o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, s) {
    r.__proto__ = s;
  } || function(r, s) {
    for (var o in s) s.hasOwnProperty(o) && (r[o] = s[o]);
  }, _o(a, t);
};
function Zw(a, t) {
  _o(a, t);
  function r() {
    this.constructor = a;
  }
  a.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var bo = function() {
  return bo = Object.assign || function(t) {
    for (var r, s = 1, o = arguments.length; s < o; s++) {
      r = arguments[s];
      for (var u in r) Object.prototype.hasOwnProperty.call(r, u) && (t[u] = r[u]);
    }
    return t;
  }, bo.apply(this, arguments);
};
function Xw(a, t) {
  var r = {};
  for (var s in a) Object.prototype.hasOwnProperty.call(a, s) && t.indexOf(s) < 0 && (r[s] = a[s]);
  if (a != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, s = Object.getOwnPropertySymbols(a); o < s.length; o++)
      t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(a, s[o]) && (r[s[o]] = a[s[o]]);
  return r;
}
function e_(a, t, r, s) {
  var o = arguments.length, u = o < 3 ? t : s === null ? s = Object.getOwnPropertyDescriptor(t, r) : s, l;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") u = Reflect.decorate(a, t, r, s);
  else for (var g = a.length - 1; g >= 0; g--) (l = a[g]) && (u = (o < 3 ? l(u) : o > 3 ? l(t, r, u) : l(t, r)) || u);
  return o > 3 && u && Object.defineProperty(t, r, u), u;
}
function t_(a, t) {
  return function(r, s) {
    t(r, s, a);
  };
}
function r_(a, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(a, t);
}
function i_(a, t, r, s) {
  function o(u) {
    return u instanceof r ? u : new r(function(l) {
      l(u);
    });
  }
  return new (r || (r = Promise))(function(u, l) {
    function g($) {
      try {
        b(s.next($));
      } catch (S) {
        l(S);
      }
    }
    function w($) {
      try {
        b(s.throw($));
      } catch (S) {
        l(S);
      }
    }
    function b($) {
      $.done ? u($.value) : o($.value).then(g, w);
    }
    b((s = s.apply(a, t || [])).next());
  });
}
function s_(a, t) {
  var r = { label: 0, sent: function() {
    if (u[0] & 1) throw u[1];
    return u[1];
  }, trys: [], ops: [] }, s, o, u, l;
  return l = { next: g(0), throw: g(1), return: g(2) }, typeof Symbol == "function" && (l[Symbol.iterator] = function() {
    return this;
  }), l;
  function g(b) {
    return function($) {
      return w([b, $]);
    };
  }
  function w(b) {
    if (s) throw new TypeError("Generator is already executing.");
    for (; r; ) try {
      if (s = 1, o && (u = b[0] & 2 ? o.return : b[0] ? o.throw || ((u = o.return) && u.call(o), 0) : o.next) && !(u = u.call(o, b[1])).done) return u;
      switch (o = 0, u && (b = [b[0] & 2, u.value]), b[0]) {
        case 0:
        case 1:
          u = b;
          break;
        case 4:
          return r.label++, { value: b[1], done: !1 };
        case 5:
          r.label++, o = b[1], b = [0];
          continue;
        case 7:
          b = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (u = r.trys, !(u = u.length > 0 && u[u.length - 1]) && (b[0] === 6 || b[0] === 2)) {
            r = 0;
            continue;
          }
          if (b[0] === 3 && (!u || b[1] > u[0] && b[1] < u[3])) {
            r.label = b[1];
            break;
          }
          if (b[0] === 6 && r.label < u[1]) {
            r.label = u[1], u = b;
            break;
          }
          if (u && r.label < u[2]) {
            r.label = u[2], r.ops.push(b);
            break;
          }
          u[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      b = t.call(a, r);
    } catch ($) {
      b = [6, $], o = 0;
    } finally {
      s = u = 0;
    }
    if (b[0] & 5) throw b[1];
    return { value: b[0] ? b[1] : void 0, done: !0 };
  }
}
function n_(a, t, r, s) {
  s === void 0 && (s = r), a[s] = t[r];
}
function o_(a, t) {
  for (var r in a) r !== "default" && !t.hasOwnProperty(r) && (t[r] = a[r]);
}
function Eo(a) {
  var t = typeof Symbol == "function" && Symbol.iterator, r = t && a[t], s = 0;
  if (r) return r.call(a);
  if (a && typeof a.length == "number") return {
    next: function() {
      return a && s >= a.length && (a = void 0), { value: a && a[s++], done: !a };
    }
  };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Kh(a, t) {
  var r = typeof Symbol == "function" && a[Symbol.iterator];
  if (!r) return a;
  var s = r.call(a), o, u = [], l;
  try {
    for (; (t === void 0 || t-- > 0) && !(o = s.next()).done; ) u.push(o.value);
  } catch (g) {
    l = { error: g };
  } finally {
    try {
      o && !o.done && (r = s.return) && r.call(s);
    } finally {
      if (l) throw l.error;
    }
  }
  return u;
}
function a_() {
  for (var a = [], t = 0; t < arguments.length; t++)
    a = a.concat(Kh(arguments[t]));
  return a;
}
function c_() {
  for (var a = 0, t = 0, r = arguments.length; t < r; t++) a += arguments[t].length;
  for (var s = Array(a), o = 0, t = 0; t < r; t++)
    for (var u = arguments[t], l = 0, g = u.length; l < g; l++, o++)
      s[o] = u[l];
  return s;
}
function _i(a) {
  return this instanceof _i ? (this.v = a, this) : new _i(a);
}
function u_(a, t, r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var s = r.apply(a, t || []), o, u = [];
  return o = {}, l("next"), l("throw"), l("return"), o[Symbol.asyncIterator] = function() {
    return this;
  }, o;
  function l(R) {
    s[R] && (o[R] = function(q) {
      return new Promise(function(A, V) {
        u.push([R, q, A, V]) > 1 || g(R, q);
      });
    });
  }
  function g(R, q) {
    try {
      w(s[R](q));
    } catch (A) {
      S(u[0][3], A);
    }
  }
  function w(R) {
    R.value instanceof _i ? Promise.resolve(R.value.v).then(b, $) : S(u[0][2], R);
  }
  function b(R) {
    g("next", R);
  }
  function $(R) {
    g("throw", R);
  }
  function S(R, q) {
    R(q), u.shift(), u.length && g(u[0][0], u[0][1]);
  }
}
function h_(a) {
  var t, r;
  return t = {}, s("next"), s("throw", function(o) {
    throw o;
  }), s("return"), t[Symbol.iterator] = function() {
    return this;
  }, t;
  function s(o, u) {
    t[o] = a[o] ? function(l) {
      return (r = !r) ? { value: _i(a[o](l)), done: o === "return" } : u ? u(l) : l;
    } : u;
  }
}
function l_(a) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = a[Symbol.asyncIterator], r;
  return t ? t.call(a) : (a = typeof Eo == "function" ? Eo(a) : a[Symbol.iterator](), r = {}, s("next"), s("throw"), s("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function s(u) {
    r[u] = a[u] && function(l) {
      return new Promise(function(g, w) {
        l = a[u](l), o(g, w, l.done, l.value);
      });
    };
  }
  function o(u, l, g, w) {
    Promise.resolve(w).then(function(b) {
      u({ value: b, done: g });
    }, l);
  }
}
function p_(a, t) {
  return Object.defineProperty ? Object.defineProperty(a, "raw", { value: t }) : a.raw = t, a;
}
function f_(a) {
  if (a && a.__esModule) return a;
  var t = {};
  if (a != null) for (var r in a) Object.hasOwnProperty.call(a, r) && (t[r] = a[r]);
  return t.default = a, t;
}
function d_(a) {
  return a && a.__esModule ? a : { default: a };
}
function g_(a, t) {
  if (!t.has(a))
    throw new TypeError("attempted to get private field on non-instance");
  return t.get(a);
}
function y_(a, t, r) {
  if (!t.has(a))
    throw new TypeError("attempted to set private field on non-instance");
  return t.set(a, r), r;
}
const v_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return bo;
  },
  __asyncDelegator: h_,
  __asyncGenerator: u_,
  __asyncValues: l_,
  __await: _i,
  __awaiter: i_,
  __classPrivateFieldGet: g_,
  __classPrivateFieldSet: y_,
  __createBinding: n_,
  __decorate: e_,
  __exportStar: o_,
  __extends: Zw,
  __generator: s_,
  __importDefault: d_,
  __importStar: f_,
  __makeTemplateObject: p_,
  __metadata: r_,
  __param: t_,
  __read: Kh,
  __rest: Xw,
  __spread: a_,
  __spreadArrays: c_,
  __values: Eo
}, Symbol.toStringTag, { value: "Module" })), Ds = /* @__PURE__ */ xo(v_);
var hi = {}, no = {}, li = {};
const m_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IEvents: ur
}, Symbol.toStringTag, { value: "Module" })), w_ = /* @__PURE__ */ xo(m_);
var Du;
function __() {
  if (Du) return li;
  Du = 1, Object.defineProperty(li, "__esModule", { value: !0 }), li.IHeartBeat = void 0;
  const a = w_;
  class t extends a.IEvents {
    constructor(s) {
      super();
    }
  }
  return li.IHeartBeat = t, li;
}
var Fu;
function Bh() {
  return Fu || (Fu = 1, function(a) {
    Object.defineProperty(a, "__esModule", { value: !0 }), Ds.__exportStar(__(), a);
  }(no)), no;
}
var oo = {}, or = {}, qu;
function b_() {
  if (qu) return or;
  qu = 1, Object.defineProperty(or, "__esModule", { value: !0 }), or.HEARTBEAT_EVENTS = or.HEARTBEAT_INTERVAL = void 0;
  const a = F;
  return or.HEARTBEAT_INTERVAL = a.FIVE_SECONDS, or.HEARTBEAT_EVENTS = {
    pulse: "heartbeat_pulse"
  }, or;
}
var ju;
function Wh() {
  return ju || (ju = 1, function(a) {
    Object.defineProperty(a, "__esModule", { value: !0 }), Ds.__exportStar(b_(), a);
  }(oo)), oo;
}
var Uu;
function E_() {
  if (Uu) return hi;
  Uu = 1, Object.defineProperty(hi, "__esModule", { value: !0 }), hi.HeartBeat = void 0;
  const a = Ds, t = ot, r = F, s = Bh(), o = Wh();
  class u extends s.IHeartBeat {
    constructor(g) {
      super(g), this.events = new t.EventEmitter(), this.interval = o.HEARTBEAT_INTERVAL, this.interval = (g == null ? void 0 : g.interval) || o.HEARTBEAT_INTERVAL;
    }
    static init(g) {
      return a.__awaiter(this, void 0, void 0, function* () {
        const w = new u(g);
        return yield w.init(), w;
      });
    }
    init() {
      return a.__awaiter(this, void 0, void 0, function* () {
        yield this.initialize();
      });
    }
    stop() {
      clearInterval(this.intervalRef);
    }
    on(g, w) {
      this.events.on(g, w);
    }
    once(g, w) {
      this.events.once(g, w);
    }
    off(g, w) {
      this.events.off(g, w);
    }
    removeListener(g, w) {
      this.events.removeListener(g, w);
    }
    initialize() {
      return a.__awaiter(this, void 0, void 0, function* () {
        this.intervalRef = setInterval(() => this.pulse(), r.toMiliseconds(this.interval));
      });
    }
    pulse() {
      this.events.emit(o.HEARTBEAT_EVENTS.pulse);
    }
  }
  return hi.HeartBeat = u, hi;
}
(function(a) {
  Object.defineProperty(a, "__esModule", { value: !0 });
  const t = Ds;
  t.__exportStar(E_(), a), t.__exportStar(Bh(), a), t.__exportStar(Wh(), a);
})(jr);
class I_ extends ur {
  constructor(t) {
    super(), this.opts = t, this.protocol = "wc", this.version = 2;
  }
}
let P_ = class extends ur {
  constructor(t, r) {
    super(), this.core = t, this.logger = r, this.records = /* @__PURE__ */ new Map();
  }
}, S_ = class {
  constructor(t, r) {
    this.logger = t, this.core = r;
  }
}, O_ = class extends ur {
  constructor(t, r) {
    super(), this.relayer = t, this.logger = r;
  }
}, R_ = class extends ur {
  constructor(t) {
    super();
  }
}, $_ = class {
  constructor(t, r, s, o) {
    this.core = t, this.logger = r, this.name = s;
  }
}, C_ = class extends ur {
  constructor(t, r) {
    super(), this.relayer = t, this.logger = r;
  }
}, N_ = class extends ur {
  constructor(t, r) {
    super(), this.core = t, this.logger = r;
  }
}, T_ = class {
  constructor(t, r) {
    this.projectId = t, this.logger = r;
  }
}, A_ = class {
  constructor(t, r) {
    this.projectId = t, this.logger = r;
  }
}, x_ = class {
  constructor(t) {
    this.opts = t, this.protocol = "wc", this.version = 2;
  }
}, D_ = class {
  constructor(t) {
    this.client = t;
  }
};
const F_ = (a) => JSON.stringify(a, (t, r) => typeof r == "bigint" ? r.toString() + "n" : r), q_ = (a) => {
  const t = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, r = a.replace(t, '$1"$2n"$3');
  return JSON.parse(r, (s, o) => typeof o == "string" && o.match(/^\d+n$/) ? BigInt(o.substring(0, o.length - 1)) : o);
};
function Gh(a) {
  if (typeof a != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof a}`);
  try {
    return q_(a);
  } catch {
    return a;
  }
}
function Qh(a) {
  return typeof a == "string" ? a : F_(a) || "";
}
var ne = {};
Object.defineProperty(ne, "__esModule", { value: !0 });
ne.getLocalStorage = ne.getLocalStorageOrThrow = ne.getCrypto = ne.getCryptoOrThrow = Jh = ne.getLocation = ne.getLocationOrThrow = Mo = ne.getNavigator = ne.getNavigatorOrThrow = Uo = ne.getDocument = ne.getDocumentOrThrow = ne.getFromWindowOrThrow = ne.getFromWindow = void 0;
function lr(a) {
  let t;
  return typeof window < "u" && typeof window[a] < "u" && (t = window[a]), t;
}
ne.getFromWindow = lr;
function Ur(a) {
  const t = lr(a);
  if (!t)
    throw new Error(`${a} is not defined in Window`);
  return t;
}
ne.getFromWindowOrThrow = Ur;
function j_() {
  return Ur("document");
}
ne.getDocumentOrThrow = j_;
function U_() {
  return lr("document");
}
var Uo = ne.getDocument = U_;
function M_() {
  return Ur("navigator");
}
ne.getNavigatorOrThrow = M_;
function L_() {
  return lr("navigator");
}
var Mo = ne.getNavigator = L_;
function k_() {
  return Ur("location");
}
ne.getLocationOrThrow = k_;
function z_() {
  return lr("location");
}
var Jh = ne.getLocation = z_;
function H_() {
  return Ur("crypto");
}
ne.getCryptoOrThrow = H_;
function V_() {
  return lr("crypto");
}
ne.getCrypto = V_;
function K_() {
  return Ur("localStorage");
}
ne.getLocalStorageOrThrow = K_;
function B_() {
  return lr("localStorage");
}
ne.getLocalStorage = B_;
var Lo = {};
Object.defineProperty(Lo, "__esModule", { value: !0 });
var Yh = Lo.getWindowMetadata = void 0;
const Mu = ne;
function W_() {
  let a, t;
  try {
    a = Mu.getDocumentOrThrow(), t = Mu.getLocationOrThrow();
  } catch {
    return null;
  }
  function r() {
    const S = a.getElementsByTagName("link"), R = [];
    for (let q = 0; q < S.length; q++) {
      const A = S[q], V = A.getAttribute("rel");
      if (V && V.toLowerCase().indexOf("icon") > -1) {
        const x = A.getAttribute("href");
        if (x)
          if (x.toLowerCase().indexOf("https:") === -1 && x.toLowerCase().indexOf("http:") === -1 && x.indexOf("//") !== 0) {
            let G = t.protocol + "//" + t.host;
            if (x.indexOf("/") === 0)
              G += x;
            else {
              const pe = t.pathname.split("/");
              pe.pop();
              const J = pe.join("/");
              G += J + "/" + x;
            }
            R.push(G);
          } else if (x.indexOf("//") === 0) {
            const G = t.protocol + x;
            R.push(G);
          } else
            R.push(x);
      }
    }
    return R;
  }
  function s(...S) {
    const R = a.getElementsByTagName("meta");
    for (let q = 0; q < R.length; q++) {
      const A = R[q], V = ["itemprop", "property", "name"].map((x) => A.getAttribute(x)).filter((x) => x ? S.includes(x) : !1);
      if (V.length && V) {
        const x = A.getAttribute("content");
        if (x)
          return x;
      }
    }
    return "";
  }
  function o() {
    let S = s("name", "og:site_name", "og:title", "twitter:title");
    return S || (S = a.title), S;
  }
  function u() {
    return s("description", "og:description", "twitter:description", "keywords");
  }
  const l = o(), g = u(), w = t.origin, b = r();
  return {
    description: g,
    url: w,
    icons: b,
    name: l
  };
}
Yh = Lo.getWindowMetadata = W_;
const G_ = ":";
function Q_(a) {
  const [t, r] = a.split(G_);
  return { namespace: t, reference: r };
}
function Zh(a, t) {
  return a.includes(":") ? [a] : t.chains || [];
}
const Xh = "base10", xe = "base16", Io = "base64pad", ko = "utf8", el = 0, pr = 1, J_ = 0, Lu = 1, Po = 12, zo = 32;
function Y_() {
  const a = Lh.generateKeyPair();
  return { privateKey: nt(a.secretKey, xe), publicKey: nt(a.publicKey, xe) };
}
function So() {
  const a = kh.randomBytes(zo);
  return nt(a, xe);
}
function Z_(a, t) {
  const r = Lh.sharedKey(gt(a, xe), gt(t, xe), !0), s = new Rw(Fo.SHA256, r).expand(zo);
  return nt(s, xe);
}
function X_(a) {
  const t = Fo.hash(gt(a, xe));
  return nt(t, xe);
}
function Dr(a) {
  const t = Fo.hash(gt(a, ko));
  return nt(t, xe);
}
function e1(a) {
  return gt(`${a}`, Xh);
}
function Ei(a) {
  return Number(nt(a, Xh));
}
function t1(a) {
  const t = e1(typeof a.type < "u" ? a.type : el);
  if (Ei(t) === pr && typeof a.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const r = typeof a.senderPublicKey < "u" ? gt(a.senderPublicKey, xe) : void 0, s = typeof a.iv < "u" ? gt(a.iv, xe) : kh.randomBytes(Po), o = new zh.ChaCha20Poly1305(gt(a.symKey, xe)).seal(s, gt(a.message, ko));
  return i1({ type: t, sealed: o, iv: s, senderPublicKey: r });
}
function r1(a) {
  const t = new zh.ChaCha20Poly1305(gt(a.symKey, xe)), { sealed: r, iv: s } = Os(a.encoded), o = t.open(s, r);
  if (o === null) throw new Error("Failed to decrypt");
  return nt(o, ko);
}
function i1(a) {
  if (Ei(a.type) === pr) {
    if (typeof a.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return nt(Cu([a.type, a.senderPublicKey, a.iv, a.sealed]), Io);
  }
  return nt(Cu([a.type, a.iv, a.sealed]), Io);
}
function Os(a) {
  const t = gt(a, Io), r = t.slice(J_, Lu), s = Lu;
  if (Ei(r) === pr) {
    const g = s + zo, w = g + Po, b = t.slice(s, g), $ = t.slice(g, w), S = t.slice(w);
    return { type: r, sealed: S, iv: $, senderPublicKey: b };
  }
  const o = s + Po, u = t.slice(s, o), l = t.slice(o);
  return { type: r, sealed: l, iv: u };
}
function s1(a, t) {
  const r = Os(a);
  return tl({ type: Ei(r.type), senderPublicKey: typeof r.senderPublicKey < "u" ? nt(r.senderPublicKey, xe) : void 0, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey });
}
function tl(a) {
  const t = (a == null ? void 0 : a.type) || el;
  if (t === pr) {
    if (typeof (a == null ? void 0 : a.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (a == null ? void 0 : a.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: t, senderPublicKey: a == null ? void 0 : a.senderPublicKey, receiverPublicKey: a == null ? void 0 : a.receiverPublicKey };
}
function ku(a) {
  return a.type === pr && typeof a.senderPublicKey == "string" && typeof a.receiverPublicKey == "string";
}
var n1 = Object.defineProperty, zu = Object.getOwnPropertySymbols, o1 = Object.prototype.hasOwnProperty, a1 = Object.prototype.propertyIsEnumerable, Hu = (a, t, r) => t in a ? n1(a, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : a[t] = r, Vu = (a, t) => {
  for (var r in t || (t = {})) o1.call(t, r) && Hu(a, r, t[r]);
  if (zu) for (var r of zu(t)) a1.call(t, r) && Hu(a, r, t[r]);
  return a;
};
const c1 = "ReactNative", Ge = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, u1 = "js";
function Ho() {
  return typeof Z.process < "u" && typeof Z.process.versions < "u" && typeof Z.process.versions.node < "u";
}
function Mr() {
  return !Uo() && !!Mo() && navigator.product === c1;
}
function Lr() {
  return !Ho() && !!Mo() && !!Uo();
}
function Ii() {
  return Mr() ? Ge.reactNative : Ho() ? Ge.node : Lr() ? Ge.browser : Ge.unknown;
}
function h1() {
  var a;
  try {
    return Mr() && typeof Z.global < "u" && typeof (Z.global == null ? void 0 : Z.global.Application) < "u" ? (a = Z.global.Application) == null ? void 0 : a.applicationId : void 0;
  } catch {
    return;
  }
}
function l1(a, t) {
  let r = Ss.parse(a);
  return r = Vu(Vu({}, r), t), a = Ss.stringify(r), a;
}
function p1() {
  return Yh() || { name: "", description: "", url: "", icons: [""] };
}
function f1() {
  if (Ii() === Ge.reactNative && typeof Z.global < "u" && typeof (Z.global == null ? void 0 : Z.global.Platform) < "u") {
    const { OS: r, Version: s } = Z.global.Platform;
    return [r, s].join("-");
  }
  const a = Cw();
  if (a === null) return "unknown";
  const t = a.os ? a.os.replace(" ", "").toLowerCase() : "unknown";
  return a.type === "browser" ? [t, a.name, a.version].join("-") : [t, a.version].join("-");
}
function d1() {
  var a;
  const t = Ii();
  return t === Ge.browser ? [t, ((a = Jh()) == null ? void 0 : a.host) || "unknown"].join(":") : t;
}
function g1(a, t, r) {
  const s = f1(), o = d1();
  return [[a, t].join("-"), [u1, r].join("-"), s, o].join("/");
}
function y1({ protocol: a, version: t, relayUrl: r, sdkVersion: s, auth: o, projectId: u, useOnCloseEvent: l, bundleId: g }) {
  const w = r.split("?"), b = g1(a, t, s), $ = { auth: o, ua: b, projectId: u, useOnCloseEvent: l, origin: g || void 0 }, S = l1(w[1] || "", $);
  return w[0] + "?" + S;
}
function ar(a, t) {
  return a.filter((r) => t.includes(r)).length === a.length;
}
function rl(a) {
  return Object.fromEntries(a.entries());
}
function il(a) {
  return new Map(Object.entries(a));
}
function Tr(a = F.FIVE_MINUTES, t) {
  const r = F.toMiliseconds(a || F.FIVE_MINUTES);
  let s, o, u;
  return { resolve: (l) => {
    u && s && (clearTimeout(u), s(l));
  }, reject: (l) => {
    u && o && (clearTimeout(u), o(l));
  }, done: () => new Promise((l, g) => {
    u = setTimeout(() => {
      g(new Error(t));
    }, r), s = l, o = g;
  }) };
}
function bi(a, t, r) {
  return new Promise(async (s, o) => {
    const u = setTimeout(() => o(new Error(r)), t);
    try {
      const l = await a;
      s(l);
    } catch (l) {
      o(l);
    }
    clearTimeout(u);
  });
}
function sl(a, t) {
  if (typeof t == "string" && t.startsWith(`${a}:`)) return t;
  if (a.toLowerCase() === "topic") {
    if (typeof t != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${t}`;
  } else if (a.toLowerCase() === "id") {
    if (typeof t != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${t}`;
  }
  throw new Error(`Unknown expirer target type: ${a}`);
}
function v1(a) {
  return sl("topic", a);
}
function m1(a) {
  return sl("id", a);
}
function nl(a) {
  const [t, r] = a.split(":"), s = { id: void 0, topic: void 0 };
  if (t === "topic" && typeof r == "string") s.topic = r;
  else if (t === "id" && Number.isInteger(Number(r))) s.id = Number(r);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${r}`);
  return s;
}
function dt(a, t) {
  return F.fromMiliseconds(Date.now() + F.toMiliseconds(a));
}
function Wt(a) {
  return Date.now() >= F.toMiliseconds(a);
}
function ve(a, t) {
  return `${a}${t ? `:${t}` : ""}`;
}
function ao(a = [], t = []) {
  return [.../* @__PURE__ */ new Set([...a, ...t])];
}
async function w1({ id: a, topic: t, wcDeepLink: r }) {
  try {
    if (!r) return;
    const s = typeof r == "string" ? JSON.parse(r) : r;
    let o = s == null ? void 0 : s.href;
    if (typeof o != "string") return;
    o.endsWith("/") && (o = o.slice(0, -1));
    const u = `${o}/wc?requestId=${a}&sessionTopic=${t}`, l = Ii();
    l === Ge.browser ? u.startsWith("https://") ? window.open(u, "_blank", "noreferrer noopener") : window.open(u, "_self", "noreferrer noopener") : l === Ge.reactNative && typeof (Z.global == null ? void 0 : Z.global.Linking) < "u" && await Z.global.Linking.openURL(u);
  } catch (s) {
    console.error(s);
  }
}
async function _1(a, t) {
  try {
    return await a.getItem(t) || (Lr() ? localStorage.getItem(t) : void 0);
  } catch (r) {
    console.error(r);
  }
}
const b1 = "irn";
function Oo(a) {
  return (a == null ? void 0 : a.relay) || { protocol: b1 };
}
function Is(a) {
  const t = $w[a];
  if (typeof t > "u") throw new Error(`Relay Protocol not supported: ${a}`);
  return t;
}
var E1 = Object.defineProperty, Ku = Object.getOwnPropertySymbols, I1 = Object.prototype.hasOwnProperty, P1 = Object.prototype.propertyIsEnumerable, Bu = (a, t, r) => t in a ? E1(a, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : a[t] = r, S1 = (a, t) => {
  for (var r in t || (t = {})) I1.call(t, r) && Bu(a, r, t[r]);
  if (Ku) for (var r of Ku(t)) P1.call(t, r) && Bu(a, r, t[r]);
  return a;
};
function O1(a, t = "-") {
  const r = {}, s = "relay" + t;
  return Object.keys(a).forEach((o) => {
    if (o.startsWith(s)) {
      const u = o.replace(s, ""), l = a[o];
      r[u] = l;
    }
  }), r;
}
function Wu(a) {
  a = a.includes("wc://") ? a.replace("wc://", "") : a, a = a.includes("wc:") ? a.replace("wc:", "") : a;
  const t = a.indexOf(":"), r = a.indexOf("?") !== -1 ? a.indexOf("?") : void 0, s = a.substring(0, t), o = a.substring(t + 1, r).split("@"), u = typeof r < "u" ? a.substring(r) : "", l = Ss.parse(u);
  return { protocol: s, topic: R1(o[0]), version: parseInt(o[1], 10), symKey: l.symKey, relay: O1(l) };
}
function R1(a) {
  return a.startsWith("//") ? a.substring(2) : a;
}
function $1(a, t = "-") {
  const r = "relay", s = {};
  return Object.keys(a).forEach((o) => {
    const u = r + t + o;
    a[o] && (s[u] = a[o]);
  }), s;
}
function C1(a) {
  return `${a.protocol}:${a.topic}@${a.version}?` + Ss.stringify(S1({ symKey: a.symKey }, $1(a.relay)));
}
function kr(a) {
  const t = [];
  return a.forEach((r) => {
    const [s, o] = r.split(":");
    t.push(`${s}:${o}`);
  }), t;
}
function N1(a) {
  const t = [];
  return Object.values(a).forEach((r) => {
    t.push(...kr(r.accounts));
  }), t;
}
function T1(a, t) {
  const r = [];
  return Object.values(a).forEach((s) => {
    kr(s.accounts).includes(t) && r.push(...s.methods);
  }), r;
}
function A1(a, t) {
  const r = [];
  return Object.values(a).forEach((s) => {
    kr(s.accounts).includes(t) && r.push(...s.events);
  }), r;
}
function x1(a, t) {
  const r = Ps(a, t);
  if (r) throw new Error(r.message);
  const s = {};
  for (const [o, u] of Object.entries(a)) s[o] = { methods: u.methods, events: u.events, chains: u.accounts.map((l) => `${l.split(":")[0]}:${l.split(":")[1]}`) };
  return s;
}
function Vo(a) {
  return a.includes(":");
}
function vi(a) {
  return Vo(a) ? a.split(":")[0] : a;
}
const D1 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, F1 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function C(a, t) {
  const { message: r, code: s } = F1[a];
  return { message: t ? `${r} ${t}` : r, code: s };
}
function ye(a, t) {
  const { message: r, code: s } = D1[a];
  return { message: t ? `${r} ${t}` : r, code: s };
}
function cr(a, t) {
  return !!Array.isArray(a);
}
function Fr(a) {
  return Object.getPrototypeOf(a) === Object.prototype && Object.keys(a).length;
}
function Ae(a) {
  return typeof a > "u";
}
function be(a, t) {
  return t && Ae(a) ? !0 : typeof a == "string" && !!a.trim().length;
}
function Ko(a, t) {
  return t && Ae(a) ? !0 : typeof a == "number" && !isNaN(a);
}
function q1(a, t) {
  const { requiredNamespaces: r } = t, s = Object.keys(a.namespaces), o = Object.keys(r);
  let u = !0;
  return ar(o, s) ? (s.forEach((l) => {
    const { accounts: g, methods: w, events: b } = a.namespaces[l], $ = kr(g), S = r[l];
    (!ar(Zh(l, S), $) || !ar(S.methods, w) || !ar(S.events, b)) && (u = !1);
  }), u) : !1;
}
function Rs(a) {
  return be(a, !1) && a.includes(":") ? a.split(":").length === 2 : !1;
}
function j1(a) {
  if (be(a, !1) && a.includes(":")) {
    const t = a.split(":");
    if (t.length === 3) {
      const r = t[0] + ":" + t[1];
      return !!t[2] && Rs(r);
    }
  }
  return !1;
}
function U1(a) {
  if (be(a, !1)) try {
    return typeof new URL(a) < "u";
  } catch {
    return !1;
  }
  return !1;
}
function M1(a) {
  var t;
  return (t = a == null ? void 0 : a.proposer) == null ? void 0 : t.publicKey;
}
function L1(a) {
  return a == null ? void 0 : a.topic;
}
function k1(a, t) {
  let r = null;
  return be(a == null ? void 0 : a.publicKey, !1) || (r = C("MISSING_OR_INVALID", `${t} controller public key should be a string`)), r;
}
function Gu(a) {
  let t = !0;
  return cr(a) ? a.length && (t = a.every((r) => be(r, !1))) : t = !1, t;
}
function z1(a, t, r) {
  let s = null;
  return cr(t) && t.length ? t.forEach((o) => {
    s || Rs(o) || (s = ye("UNSUPPORTED_CHAINS", `${r}, chain ${o} should be a string and conform to "namespace:chainId" format`));
  }) : Rs(a) || (s = ye("UNSUPPORTED_CHAINS", `${r}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), s;
}
function H1(a, t, r) {
  let s = null;
  return Object.entries(a).forEach(([o, u]) => {
    if (s) return;
    const l = z1(o, Zh(o, u), `${t} ${r}`);
    l && (s = l);
  }), s;
}
function V1(a, t) {
  let r = null;
  return cr(a) ? a.forEach((s) => {
    r || j1(s) || (r = ye("UNSUPPORTED_ACCOUNTS", `${t}, account ${s} should be a string and conform to "namespace:chainId:address" format`));
  }) : r = ye("UNSUPPORTED_ACCOUNTS", `${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), r;
}
function K1(a, t) {
  let r = null;
  return Object.values(a).forEach((s) => {
    if (r) return;
    const o = V1(s == null ? void 0 : s.accounts, `${t} namespace`);
    o && (r = o);
  }), r;
}
function B1(a, t) {
  let r = null;
  return Gu(a == null ? void 0 : a.methods) ? Gu(a == null ? void 0 : a.events) || (r = ye("UNSUPPORTED_EVENTS", `${t}, events should be an array of strings or empty array for no events`)) : r = ye("UNSUPPORTED_METHODS", `${t}, methods should be an array of strings or empty array for no methods`), r;
}
function ol(a, t) {
  let r = null;
  return Object.values(a).forEach((s) => {
    if (r) return;
    const o = B1(s, `${t}, namespace`);
    o && (r = o);
  }), r;
}
function W1(a, t, r) {
  let s = null;
  if (a && Fr(a)) {
    const o = ol(a, t);
    o && (s = o);
    const u = H1(a, t, r);
    u && (s = u);
  } else s = C("MISSING_OR_INVALID", `${t}, ${r} should be an object with data`);
  return s;
}
function Ps(a, t) {
  let r = null;
  if (a && Fr(a)) {
    const s = ol(a, t);
    s && (r = s);
    const o = K1(a, t);
    o && (r = o);
  } else r = C("MISSING_OR_INVALID", `${t}, namespaces should be an object with data`);
  return r;
}
function al(a) {
  return be(a.protocol, !0);
}
function G1(a, t) {
  let r = !1;
  return a ? a && cr(a) && a.length && a.forEach((s) => {
    r = al(s);
  }) : r = !0, r;
}
function Q1(a) {
  return typeof a == "number";
}
function Le(a) {
  return typeof a < "u" && typeof a !== null;
}
function J1(a) {
  return !(!a || typeof a != "object" || !a.code || !Ko(a.code, !1) || !a.message || !be(a.message, !1));
}
function Y1(a) {
  return !(Ae(a) || !be(a.method, !1));
}
function Z1(a) {
  return !(Ae(a) || Ae(a.result) && Ae(a.error) || !Ko(a.id, !1) || !be(a.jsonrpc, !1));
}
function X1(a) {
  return !(Ae(a) || !be(a.name, !1));
}
function Qu(a, t) {
  return !(!Rs(t) || !N1(a).includes(t));
}
function e0(a, t, r) {
  return be(r, !1) ? T1(a, t).includes(r) : !1;
}
function t0(a, t, r) {
  return be(r, !1) ? A1(a, t).includes(r) : !1;
}
function Ju(a, t, r) {
  let s = null;
  const o = r0(a), u = i0(t), l = Object.keys(o), g = Object.keys(u), w = Yu(Object.keys(a)), b = Yu(Object.keys(t)), $ = w.filter((S) => !b.includes(S));
  return $.length && (s = C("NON_CONFORMING_NAMESPACES", `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${$.toString()}
      Received: ${Object.keys(t).toString()}`)), ar(l, g) || (s = C("NON_CONFORMING_NAMESPACES", `${r} namespaces chains don't satisfy required namespaces.
      Required: ${l.toString()}
      Approved: ${g.toString()}`)), Object.keys(t).forEach((S) => {
    if (!S.includes(":") || s) return;
    const R = kr(t[S].accounts);
    R.includes(S) || (s = C("NON_CONFORMING_NAMESPACES", `${r} namespaces accounts don't satisfy namespace accounts for ${S}
        Required: ${S}
        Approved: ${R.toString()}`));
  }), l.forEach((S) => {
    s || (ar(o[S].methods, u[S].methods) ? ar(o[S].events, u[S].events) || (s = C("NON_CONFORMING_NAMESPACES", `${r} namespaces events don't satisfy namespace events for ${S}`)) : s = C("NON_CONFORMING_NAMESPACES", `${r} namespaces methods don't satisfy namespace methods for ${S}`));
  }), s;
}
function r0(a) {
  const t = {};
  return Object.keys(a).forEach((r) => {
    var s;
    r.includes(":") ? t[r] = a[r] : (s = a[r].chains) == null || s.forEach((o) => {
      t[o] = { methods: a[r].methods, events: a[r].events };
    });
  }), t;
}
function Yu(a) {
  return [...new Set(a.map((t) => t.includes(":") ? t.split(":")[0] : t))];
}
function i0(a) {
  const t = {};
  return Object.keys(a).forEach((r) => {
    if (r.includes(":")) t[r] = a[r];
    else {
      const s = kr(a[r].accounts);
      s == null || s.forEach((o) => {
        t[o] = { accounts: a[r].accounts.filter((u) => u.includes(`${o}:`)), methods: a[r].methods, events: a[r].events };
      });
    }
  }), t;
}
function s0(a, t) {
  return Ko(a, !1) && a <= t.max && a >= t.min;
}
function Zu() {
  const a = Ii();
  return new Promise((t) => {
    switch (a) {
      case Ge.browser:
        t(n0());
        break;
      case Ge.reactNative:
        t(o0());
        break;
      case Ge.node:
        t(a0());
        break;
      default:
        t(!0);
    }
  });
}
function n0() {
  return Lr() && (navigator == null ? void 0 : navigator.onLine);
}
async function o0() {
  if (Mr() && typeof Z.global < "u" && Z.global != null && Z.global.NetInfo) {
    const a = await (Z.global == null ? void 0 : Z.global.NetInfo.fetch());
    return a == null ? void 0 : a.isConnected;
  }
  return !0;
}
function a0() {
  return !0;
}
function c0(a) {
  switch (Ii()) {
    case Ge.browser:
      u0(a);
      break;
    case Ge.reactNative:
      h0(a);
      break;
  }
}
function u0(a) {
  !Mr() && Lr() && (window.addEventListener("online", () => a(!0)), window.addEventListener("offline", () => a(!1)));
}
function h0(a) {
  var t;
  Mr() && typeof Z.global < "u" && Z.global != null && Z.global.NetInfo && ((t = Z.global) == null || t.NetInfo.addEventListener((r) => a(r == null ? void 0 : r.isConnected)));
}
const co = {};
let ws = class {
  static get(t) {
    return co[t];
  }
  static set(t, r) {
    co[t] = r;
  }
  static delete(t) {
    delete co[t];
  }
};
class Dt extends Nw {
  constructor(t) {
    super(t), this.events = new ot.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners();
  }
  async connect(t = this.connection) {
    await this.open(t);
  }
  async disconnect() {
    await this.close();
  }
  on(t, r) {
    this.events.on(t, r);
  }
  once(t, r) {
    this.events.once(t, r);
  }
  off(t, r) {
    this.events.off(t, r);
  }
  removeListener(t, r) {
    this.events.removeListener(t, r);
  }
  async request(t, r) {
    return this.requestStrict(xr(t.method, t.params || [], t.id || Hh().toString()), r);
  }
  async requestStrict(t, r) {
    return new Promise(async (s, o) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (u) {
          o(u);
        }
      this.events.on(`${t.id}`, (u) => {
        bt(u) ? o(u.error) : s(u.result);
      });
      try {
        await this.connection.send(t, r);
      } catch (u) {
        o(u);
      }
    });
  }
  setConnection(t = this.connection) {
    return t;
  }
  onPayload(t) {
    this.events.emit("payload", t), Cs(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", {
      type: t.method,
      data: t.params
    });
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason ? `(${t.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t) => this.onPayload(t)), this.connection.on("close", (t) => this.onClose(t)), this.connection.on("error", (t) => this.events.emit("error", t)), this.connection.on("register_error", (t) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
}
const l0 = () => typeof WebSocket < "u" ? WebSocket : typeof Z.global < "u" && typeof Z.global.WebSocket < "u" ? Z.global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), p0 = () => typeof WebSocket < "u" || typeof Z.global < "u" && typeof Z.global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", Xu = (a) => a.split("?")[0], eh = 10, f0 = l0();
let d0 = class {
  constructor(t) {
    if (this.url = t, this.events = new ot.EventEmitter(), this.registering = !1, !Nu(t)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${t}`);
    this.url = t;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(t, r) {
    this.events.on(t, r);
  }
  once(t, r) {
    this.events.once(t, r);
  }
  off(t, r) {
    this.events.off(t, r);
  }
  removeListener(t, r) {
    this.events.removeListener(t, r);
  }
  async open(t = this.url) {
    await this.register(t);
  }
  async close() {
    return new Promise((t, r) => {
      if (typeof this.socket > "u") {
        r(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (s) => {
        this.onClose(s), t();
      }, this.socket.close();
    });
  }
  async send(t) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(Qh(t));
    } catch (r) {
      this.onError(t.id, r);
    }
  }
  register(t = this.url) {
    if (!Nu(t)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${t}`);
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((s, o) => {
        this.events.once("register_error", (u) => {
          this.resetMaxListeners(), o(u);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return o(new Error("WebSocket connection is missing or invalid"));
          s(this.socket);
        });
      });
    }
    return this.url = t, this.registering = !0, new Promise((r, s) => {
      const o = new URLSearchParams(t).get("origin"), u = Tw.isReactNative() ? { headers: { origin: o } } : { rejectUnauthorized: !Aw(t) }, l = new f0(t, [], u);
      p0() ? l.onerror = (g) => {
        const w = g;
        s(this.emitError(w.error));
      } : l.on("error", (g) => {
        s(this.emitError(g));
      }), l.onopen = () => {
        this.onOpen(l), r(l);
      };
    });
  }
  onOpen(t) {
    t.onmessage = (r) => this.onPayload(r), t.onclose = (r) => this.onClose(r), this.socket = t, this.registering = !1, this.events.emit("open");
  }
  onClose(t) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", t);
  }
  onPayload(t) {
    if (typeof t.data > "u") return;
    const r = typeof t.data == "string" ? Gh(t.data) : t.data;
    this.events.emit("payload", r);
  }
  onError(t, r) {
    const s = this.parseError(r), o = s.message || s.toString(), u = Ns(t, o);
    this.events.emit("payload", u);
  }
  parseError(t, r = this.url) {
    return Vh(t, Xu(r), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > eh && this.events.setMaxListeners(eh);
  }
  emitError(t) {
    const r = this.parseError(new Error((t == null ? void 0 : t.message) || `WebSocket connection failed for host: ${Xu(this.url)}`));
    return this.events.emit("register_error", r), r;
  }
};
function g0(a, t) {
  return t = t || {}, new Promise(function(r, s) {
    var o = new XMLHttpRequest(), u = [], l = [], g = {}, w = function() {
      return { ok: (o.status / 100 | 0) == 2, statusText: o.statusText, status: o.status, url: o.responseURL, text: function() {
        return Promise.resolve(o.responseText);
      }, json: function() {
        return Promise.resolve(o.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([o.response]));
      }, clone: w, headers: { keys: function() {
        return u;
      }, entries: function() {
        return l;
      }, get: function($) {
        return g[$.toLowerCase()];
      }, has: function($) {
        return $.toLowerCase() in g;
      } } };
    };
    for (var b in o.open(t.method || "get", a, !0), o.onload = function() {
      o.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function($, S, R) {
        u.push(S = S.toLowerCase()), l.push([S, R]), g[S] = g[S] ? g[S] + "," + R : R;
      }), r(w());
    }, o.onerror = s, o.withCredentials = t.credentials == "include", t.headers) o.setRequestHeader(b, t.headers[b]);
    o.send(t.body || null);
  });
}
const y0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: g0
}, Symbol.toStringTag, { value: "Module" })), th = /* @__PURE__ */ xo(y0);
var v0 = self.fetch || (self.fetch = th.default || th);
const m0 = /* @__PURE__ */ Ow(v0);
function w0(a, t) {
  if (a.length >= 255) throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), s = 0; s < r.length; s++) r[s] = 255;
  for (var o = 0; o < a.length; o++) {
    var u = a.charAt(o), l = u.charCodeAt(0);
    if (r[l] !== 255) throw new TypeError(u + " is ambiguous");
    r[l] = o;
  }
  var g = a.length, w = a.charAt(0), b = Math.log(g) / Math.log(256), $ = Math.log(256) / Math.log(g);
  function S(A) {
    if (A instanceof Uint8Array || (ArrayBuffer.isView(A) ? A = new Uint8Array(A.buffer, A.byteOffset, A.byteLength) : Array.isArray(A) && (A = Uint8Array.from(A))), !(A instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (A.length === 0) return "";
    for (var V = 0, x = 0, G = 0, pe = A.length; G !== pe && A[G] === 0; ) G++, V++;
    for (var J = (pe - G) * $ + 1 >>> 0, X = new Uint8Array(J); G !== pe; ) {
      for (var ue = A[G], De = 0, fe = J - 1; (ue !== 0 || De < x) && fe !== -1; fe--, De++) ue += 256 * X[fe] >>> 0, X[fe] = ue % g >>> 0, ue = ue / g >>> 0;
      if (ue !== 0) throw new Error("Non-zero carry");
      x = De, G++;
    }
    for (var $e = J - x; $e !== J && X[$e] === 0; ) $e++;
    for (var qt = w.repeat(V); $e < J; ++$e) qt += a.charAt(X[$e]);
    return qt;
  }
  function R(A) {
    if (typeof A != "string") throw new TypeError("Expected String");
    if (A.length === 0) return new Uint8Array();
    var V = 0;
    if (A[V] !== " ") {
      for (var x = 0, G = 0; A[V] === w; ) x++, V++;
      for (var pe = (A.length - V) * b + 1 >>> 0, J = new Uint8Array(pe); A[V]; ) {
        var X = r[A.charCodeAt(V)];
        if (X === 255) return;
        for (var ue = 0, De = pe - 1; (X !== 0 || ue < G) && De !== -1; De--, ue++) X += g * J[De] >>> 0, J[De] = X % 256 >>> 0, X = X / 256 >>> 0;
        if (X !== 0) throw new Error("Non-zero carry");
        G = ue, V++;
      }
      if (A[V] !== " ") {
        for (var fe = pe - G; fe !== pe && J[fe] === 0; ) fe++;
        for (var $e = new Uint8Array(x + (pe - fe)), qt = x; fe !== pe; ) $e[qt++] = J[fe++];
        return $e;
      }
    }
  }
  function q(A) {
    var V = R(A);
    if (V) return V;
    throw new Error(`Non-${t} character`);
  }
  return { encode: S, decodeUnsafe: R, decode: q };
}
var _0 = w0, b0 = _0;
const cl = (a) => {
  if (a instanceof Uint8Array && a.constructor.name === "Uint8Array") return a;
  if (a instanceof ArrayBuffer) return new Uint8Array(a);
  if (ArrayBuffer.isView(a)) return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
  throw new Error("Unknown type, must be binary type");
}, E0 = (a) => new TextEncoder().encode(a), I0 = (a) => new TextDecoder().decode(a);
class P0 {
  constructor(t, r, s) {
    this.name = t, this.prefix = r, this.baseEncode = s;
  }
  encode(t) {
    if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class S0 {
  constructor(t, r, s) {
    if (this.name = t, this.prefix = r, r.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = s;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(t) {
    return ul(this, t);
  }
}
class O0 {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return ul(this, t);
  }
  decode(t) {
    const r = t[0], s = this.decoders[r];
    if (s) return s.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const ul = (a, t) => new O0({ ...a.decoders || { [a.prefix]: a }, ...t.decoders || { [t.prefix]: t } });
class R0 {
  constructor(t, r, s, o) {
    this.name = t, this.prefix = r, this.baseEncode = s, this.baseDecode = o, this.encoder = new P0(t, r, s), this.decoder = new S0(t, r, o);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
}
const Fs = ({ name: a, prefix: t, encode: r, decode: s }) => new R0(a, t, r, s), Pi = ({ prefix: a, name: t, alphabet: r }) => {
  const { encode: s, decode: o } = b0(r, t);
  return Fs({ prefix: a, name: t, encode: s, decode: (u) => cl(o(u)) });
}, $0 = (a, t, r, s) => {
  const o = {};
  for (let $ = 0; $ < t.length; ++$) o[t[$]] = $;
  let u = a.length;
  for (; a[u - 1] === "="; ) --u;
  const l = new Uint8Array(u * r / 8 | 0);
  let g = 0, w = 0, b = 0;
  for (let $ = 0; $ < u; ++$) {
    const S = o[a[$]];
    if (S === void 0) throw new SyntaxError(`Non-${s} character`);
    w = w << r | S, g += r, g >= 8 && (g -= 8, l[b++] = 255 & w >> g);
  }
  if (g >= r || 255 & w << 8 - g) throw new SyntaxError("Unexpected end of data");
  return l;
}, C0 = (a, t, r) => {
  const s = t[t.length - 1] === "=", o = (1 << r) - 1;
  let u = "", l = 0, g = 0;
  for (let w = 0; w < a.length; ++w) for (g = g << 8 | a[w], l += 8; l > r; ) l -= r, u += t[o & g >> l];
  if (l && (u += t[o & g << r - l]), s) for (; u.length * r & 7; ) u += "=";
  return u;
}, Pe = ({ name: a, prefix: t, bitsPerChar: r, alphabet: s }) => Fs({ prefix: t, name: a, encode(o) {
  return C0(o, s, r);
}, decode(o) {
  return $0(o, s, r, a);
} }), N0 = Fs({ prefix: "\0", name: "identity", encode: (a) => I0(a), decode: (a) => E0(a) });
var T0 = Object.freeze({ __proto__: null, identity: N0 });
const A0 = Pe({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var x0 = Object.freeze({ __proto__: null, base2: A0 });
const D0 = Pe({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var F0 = Object.freeze({ __proto__: null, base8: D0 });
const q0 = Pi({ prefix: "9", name: "base10", alphabet: "0123456789" });
var j0 = Object.freeze({ __proto__: null, base10: q0 });
const U0 = Pe({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), M0 = Pe({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var L0 = Object.freeze({ __proto__: null, base16: U0, base16upper: M0 });
const k0 = Pe({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), z0 = Pe({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), H0 = Pe({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), V0 = Pe({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), K0 = Pe({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), B0 = Pe({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), W0 = Pe({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), G0 = Pe({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), Q0 = Pe({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var J0 = Object.freeze({ __proto__: null, base32: k0, base32upper: z0, base32pad: H0, base32padupper: V0, base32hex: K0, base32hexupper: B0, base32hexpad: W0, base32hexpadupper: G0, base32z: Q0 });
const Y0 = Pi({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), Z0 = Pi({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var X0 = Object.freeze({ __proto__: null, base36: Y0, base36upper: Z0 });
const eb = Pi({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), tb = Pi({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var rb = Object.freeze({ __proto__: null, base58btc: eb, base58flickr: tb });
const ib = Pe({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), sb = Pe({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), nb = Pe({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), ob = Pe({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var ab = Object.freeze({ __proto__: null, base64: ib, base64pad: sb, base64url: nb, base64urlpad: ob });
const hl = Array.from(""), cb = hl.reduce((a, t, r) => (a[r] = t, a), []), ub = hl.reduce((a, t, r) => (a[t.codePointAt(0)] = r, a), []);
function hb(a) {
  return a.reduce((t, r) => (t += cb[r], t), "");
}
function lb(a) {
  const t = [];
  for (const r of a) {
    const s = ub[r.codePointAt(0)];
    if (s === void 0) throw new Error(`Non-base256emoji character: ${r}`);
    t.push(s);
  }
  return new Uint8Array(t);
}
const pb = Fs({ prefix: "", name: "base256emoji", encode: hb, decode: lb });
var fb = Object.freeze({ __proto__: null, base256emoji: pb }), db = ll, rh = 128, gb = -128, yb = Math.pow(2, 31);
function ll(a, t, r) {
  t = t || [], r = r || 0;
  for (var s = r; a >= yb; ) t[r++] = a & 255 | rh, a /= 128;
  for (; a & gb; ) t[r++] = a & 255 | rh, a >>>= 7;
  return t[r] = a | 0, ll.bytes = r - s + 1, t;
}
var vb = Ro, mb = 128, ih = 127;
function Ro(a, s) {
  var r = 0, s = s || 0, o = 0, u = s, l, g = a.length;
  do {
    if (u >= g) throw Ro.bytes = 0, new RangeError("Could not decode varint");
    l = a[u++], r += o < 28 ? (l & ih) << o : (l & ih) * Math.pow(2, o), o += 7;
  } while (l >= mb);
  return Ro.bytes = u - s, r;
}
var wb = Math.pow(2, 7), _b = Math.pow(2, 14), bb = Math.pow(2, 21), Eb = Math.pow(2, 28), Ib = Math.pow(2, 35), Pb = Math.pow(2, 42), Sb = Math.pow(2, 49), Ob = Math.pow(2, 56), Rb = Math.pow(2, 63), $b = function(a) {
  return a < wb ? 1 : a < _b ? 2 : a < bb ? 3 : a < Eb ? 4 : a < Ib ? 5 : a < Pb ? 6 : a < Sb ? 7 : a < Ob ? 8 : a < Rb ? 9 : 10;
}, Cb = { encode: db, decode: vb, encodingLength: $b }, pl = Cb;
const sh = (a, t, r = 0) => (pl.encode(a, t, r), t), nh = (a) => pl.encodingLength(a), $o = (a, t) => {
  const r = t.byteLength, s = nh(a), o = s + nh(r), u = new Uint8Array(o + r);
  return sh(a, u, 0), sh(r, u, s), u.set(t, o), new Nb(a, r, t, u);
};
class Nb {
  constructor(t, r, s, o) {
    this.code = t, this.size = r, this.digest = s, this.bytes = o;
  }
}
const fl = ({ name: a, code: t, encode: r }) => new Tb(a, t, r);
class Tb {
  constructor(t, r, s) {
    this.name = t, this.code = r, this.encode = s;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const r = this.encode(t);
      return r instanceof Uint8Array ? $o(this.code, r) : r.then((s) => $o(this.code, s));
    } else throw Error("Unknown type, must be binary type");
  }
}
const dl = (a) => async (t) => new Uint8Array(await crypto.subtle.digest(a, t)), Ab = fl({ name: "sha2-256", code: 18, encode: dl("SHA-256") }), xb = fl({ name: "sha2-512", code: 19, encode: dl("SHA-512") });
var Db = Object.freeze({ __proto__: null, sha256: Ab, sha512: xb });
const gl = 0, Fb = "identity", yl = cl, qb = (a) => $o(gl, yl(a)), jb = { code: gl, name: Fb, encode: yl, digest: qb };
var Ub = Object.freeze({ __proto__: null, identity: jb });
new TextEncoder(), new TextDecoder();
const oh = { ...T0, ...x0, ...F0, ...j0, ...L0, ...J0, ...X0, ...rb, ...ab, ...fb };
({ ...Db, ...Ub });
function vl(a) {
  return globalThis.Buffer != null ? new Uint8Array(a.buffer, a.byteOffset, a.byteLength) : a;
}
function Mb(a = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? vl(globalThis.Buffer.allocUnsafe(a)) : new Uint8Array(a);
}
function ml(a, t, r, s) {
  return { name: a, prefix: t, encoder: { name: a, prefix: t, encode: r }, decoder: { decode: s } };
}
const ah = ml("utf8", "u", (a) => "u" + new TextDecoder("utf8").decode(a), (a) => new TextEncoder().encode(a.substring(1))), uo = ml("ascii", "a", (a) => {
  let t = "a";
  for (let r = 0; r < a.length; r++) t += String.fromCharCode(a[r]);
  return t;
}, (a) => {
  a = a.substring(1);
  const t = Mb(a.length);
  for (let r = 0; r < a.length; r++) t[r] = a.charCodeAt(r);
  return t;
}), Lb = { utf8: ah, "utf-8": ah, hex: oh.base16, latin1: uo, ascii: uo, binary: uo, ...oh };
function kb(a, t = "utf8") {
  const r = Lb[t];
  if (!r) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? vl(globalThis.Buffer.from(a, "utf-8")) : r.decoder.decode(`${r.prefix}${a}`);
}
const wl = "wc", zb = 2, _l = "core", Gt = `${wl}@2:${_l}:`, Hb = { logger: "error" }, Vb = { database: ":memory:" }, Kb = "crypto", ch = "client_ed25519_seed", Bb = F.ONE_DAY, Wb = "keychain", Gb = "0.3", Qb = "messages", Jb = "0.3", Yb = F.SIX_HOURS, Zb = "publisher", bl = "irn", Xb = "error", El = "wss://relay.walletconnect.com", uh = "wss://relay.walletconnect.org", eE = "relayer", Re = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, tE = "_subscription", At = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, rE = F.ONE_SECOND, iE = "2.11.0", sE = 1e4, nE = "0.3", oE = "WALLETCONNECT_CLIENT_ID", ft = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, aE = "subscription", cE = "0.3", uE = F.FIVE_SECONDS * 1e3, hE = "pairing", lE = "0.3", pi = { wc_pairingDelete: { req: { ttl: F.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: F.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: F.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: F.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: F.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: F.ONE_DAY, prompt: !1, tag: 0 } } }, mi = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, _t = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, pE = "history", fE = "0.3", dE = "expirer", st = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, gE = "0.3", ho = "verify-api", Ar = "https://verify.walletconnect.com", Co = "https://verify.walletconnect.org", yE = [Ar, Co], vE = "echo", mE = "https://echo.walletconnect.com";
class wE {
  constructor(t, r) {
    this.core = t, this.logger = r, this.keychain = /* @__PURE__ */ new Map(), this.name = Wb, this.version = Gb, this.initialized = !1, this.storagePrefix = Gt, this.init = async () => {
      if (!this.initialized) {
        const s = await this.getKeyChain();
        typeof s < "u" && (this.keychain = s), this.initialized = !0;
      }
    }, this.has = (s) => (this.isInitialized(), this.keychain.has(s)), this.set = async (s, o) => {
      this.isInitialized(), this.keychain.set(s, o), await this.persist();
    }, this.get = (s) => {
      this.isInitialized();
      const o = this.keychain.get(s);
      if (typeof o > "u") {
        const { message: u } = C("NO_MATCHING_KEY", `${this.name}: ${s}`);
        throw new Error(u);
      }
      return o;
    }, this.del = async (s) => {
      this.isInitialized(), this.keychain.delete(s), await this.persist();
    }, this.core = t, this.logger = ke(r, this.name);
  }
  get context() {
    return Qe(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(t) {
    await this.core.storage.setItem(this.storageKey, rl(t));
  }
  async getKeyChain() {
    const t = await this.core.storage.getItem(this.storageKey);
    return typeof t < "u" ? il(t) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = C("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class _E {
  constructor(t, r, s) {
    this.core = t, this.logger = r, this.name = Kb, this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (o) => (this.isInitialized(), this.keychain.has(o)), this.getClientId = async () => {
      this.isInitialized();
      const o = await this.getClientSeed(), u = Tu(o);
      return Dw(u.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const o = Y_();
      return this.setPrivateKey(o.publicKey, o.privateKey);
    }, this.signJWT = async (o) => {
      this.isInitialized();
      const u = await this.getClientSeed(), l = Tu(u), g = So();
      return await Fw(g, o, Bb, l);
    }, this.generateSharedKey = (o, u, l) => {
      this.isInitialized();
      const g = this.getPrivateKey(o), w = Z_(g, u);
      return this.setSymKey(w, l);
    }, this.setSymKey = async (o, u) => {
      this.isInitialized();
      const l = u || X_(o);
      return await this.keychain.set(l, o), l;
    }, this.deleteKeyPair = async (o) => {
      this.isInitialized(), await this.keychain.del(o);
    }, this.deleteSymKey = async (o) => {
      this.isInitialized(), await this.keychain.del(o);
    }, this.encode = async (o, u, l) => {
      this.isInitialized();
      const g = tl(l), w = Qh(u);
      if (ku(g)) {
        const R = g.senderPublicKey, q = g.receiverPublicKey;
        o = await this.generateSharedKey(R, q);
      }
      const b = this.getSymKey(o), { type: $, senderPublicKey: S } = g;
      return t1({ type: $, symKey: b, message: w, senderPublicKey: S });
    }, this.decode = async (o, u, l) => {
      this.isInitialized();
      const g = s1(u, l);
      if (ku(g)) {
        const w = g.receiverPublicKey, b = g.senderPublicKey;
        o = await this.generateSharedKey(w, b);
      }
      try {
        const w = this.getSymKey(o), b = r1({ symKey: w, encoded: u });
        return Gh(b);
      } catch (w) {
        this.logger.error(`Failed to decode message from topic: '${o}', clientId: '${await this.getClientId()}'`), this.logger.error(w);
      }
    }, this.getPayloadType = (o) => {
      const u = Os(o);
      return Ei(u.type);
    }, this.getPayloadSenderPublicKey = (o) => {
      const u = Os(o);
      return u.senderPublicKey ? nt(u.senderPublicKey, xe) : void 0;
    }, this.core = t, this.logger = ke(r, this.name), this.keychain = s || new wE(this.core, this.logger);
  }
  get context() {
    return Qe(this.logger);
  }
  async setPrivateKey(t, r) {
    return await this.keychain.set(t, r), t;
  }
  getPrivateKey(t) {
    return this.keychain.get(t);
  }
  async getClientSeed() {
    let t = "";
    try {
      t = this.keychain.get(ch);
    } catch {
      t = So(), await this.keychain.set(ch, t);
    }
    return kb(t, "base16");
  }
  getSymKey(t) {
    return this.keychain.get(t);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = C("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class bE extends S_ {
  constructor(t, r) {
    super(t, r), this.logger = t, this.core = r, this.messages = /* @__PURE__ */ new Map(), this.name = Qb, this.version = Jb, this.initialized = !1, this.storagePrefix = Gt, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s = await this.getRelayerMessages();
          typeof s < "u" && (this.messages = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (s, o) => {
      this.isInitialized();
      const u = Dr(o);
      let l = this.messages.get(s);
      return typeof l > "u" && (l = {}), typeof l[u] < "u" || (l[u] = o, this.messages.set(s, l), await this.persist()), u;
    }, this.get = (s) => {
      this.isInitialized();
      let o = this.messages.get(s);
      return typeof o > "u" && (o = {}), o;
    }, this.has = (s, o) => {
      this.isInitialized();
      const u = this.get(s), l = Dr(o);
      return typeof u[l] < "u";
    }, this.del = async (s) => {
      this.isInitialized(), this.messages.delete(s), await this.persist();
    }, this.logger = ke(t, this.name), this.core = r;
  }
  get context() {
    return Qe(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(t) {
    await this.core.storage.setItem(this.storageKey, rl(t));
  }
  async getRelayerMessages() {
    const t = await this.core.storage.getItem(this.storageKey);
    return typeof t < "u" ? il(t) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = C("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class EE extends O_ {
  constructor(t, r) {
    super(t, r), this.relayer = t, this.logger = r, this.events = new ot.EventEmitter(), this.name = Zb, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = F.toMiliseconds(F.TEN_SECONDS), this.needsTransportRestart = !1, this.publish = async (s, o, u) => {
      var l;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s, message: o, opts: u } });
      try {
        const g = (u == null ? void 0 : u.ttl) || Yb, w = Oo(u), b = (u == null ? void 0 : u.prompt) || !1, $ = (u == null ? void 0 : u.tag) || 0, S = (u == null ? void 0 : u.id) || Hh().toString(), R = { topic: s, message: o, opts: { ttl: g, relay: w, prompt: b, tag: $, id: S } }, q = setTimeout(() => this.queue.set(S, R), this.publishTimeout);
        try {
          await await bi(this.rpcPublish(s, o, g, w, b, $, S), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(S), this.relayer.events.emit(Re.publish, R);
        } catch (A) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = !0, (l = u == null ? void 0 : u.internal) != null && l.throwOnFailedPublish) throw this.removeRequestFromQueue(S), A;
          return;
        } finally {
          clearTimeout(q);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s, message: o, opts: u } });
      } catch (g) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(g), g;
      }
    }, this.on = (s, o) => {
      this.events.on(s, o);
    }, this.once = (s, o) => {
      this.events.once(s, o);
    }, this.off = (s, o) => {
      this.events.off(s, o);
    }, this.removeListener = (s, o) => {
      this.events.removeListener(s, o);
    }, this.relayer = t, this.logger = ke(r, this.name), this.registerEventListeners();
  }
  get context() {
    return Qe(this.logger);
  }
  rpcPublish(t, r, s, o, u, l, g) {
    var w, b, $, S;
    const R = { method: Is(o.protocol).publish, params: { topic: t, message: r, ttl: s, prompt: u, tag: l }, id: g };
    return Ae((w = R.params) == null ? void 0 : w.prompt) && ((b = R.params) == null || delete b.prompt), Ae(($ = R.params) == null ? void 0 : $.tag) && ((S = R.params) == null || delete S.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: R }), this.relayer.request(R);
  }
  removeRequestFromQueue(t) {
    this.queue.delete(t);
  }
  checkQueue() {
    this.queue.forEach(async (t) => {
      const { topic: r, message: s, opts: o } = t;
      await this.publish(r, s, o);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(jr.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(Re.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(Re.message_ack, (t) => {
      this.removeRequestFromQueue(t.id.toString());
    });
  }
}
class IE {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (t, r) => {
      const s = this.get(t);
      this.exists(t, r) || this.map.set(t, [...s, r]);
    }, this.get = (t) => this.map.get(t) || [], this.exists = (t, r) => this.get(t).includes(r), this.delete = (t, r) => {
      if (typeof r > "u") {
        this.map.delete(t);
        return;
      }
      if (!this.map.has(t)) return;
      const s = this.get(t);
      if (!this.exists(t, r)) return;
      const o = s.filter((u) => u !== r);
      if (!o.length) {
        this.map.delete(t);
        return;
      }
      this.map.set(t, o);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var PE = Object.defineProperty, SE = Object.defineProperties, OE = Object.getOwnPropertyDescriptors, hh = Object.getOwnPropertySymbols, RE = Object.prototype.hasOwnProperty, $E = Object.prototype.propertyIsEnumerable, lh = (a, t, r) => t in a ? PE(a, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : a[t] = r, fi = (a, t) => {
  for (var r in t || (t = {})) RE.call(t, r) && lh(a, r, t[r]);
  if (hh) for (var r of hh(t)) $E.call(t, r) && lh(a, r, t[r]);
  return a;
}, lo = (a, t) => SE(a, OE(t));
class CE extends C_ {
  constructor(t, r) {
    super(t, r), this.relayer = t, this.logger = r, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new IE(), this.events = new ot.EventEmitter(), this.name = aE, this.version = cE, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = Gt, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (s, o) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s, opts: o } });
      try {
        const u = Oo(o), l = { topic: s, relay: u };
        this.pending.set(s, l);
        const g = await this.rpcSubscribe(s, u);
        return this.onSubscribe(g, l), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s, opts: o } }), g;
      } catch (u) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(u), u;
      }
    }, this.unsubscribe = async (s, o) => {
      await this.restartToComplete(), this.isInitialized(), typeof (o == null ? void 0 : o.id) < "u" ? await this.unsubscribeById(s, o.id, o) : await this.unsubscribeByTopic(s, o);
    }, this.isSubscribed = async (s) => this.topics.includes(s) ? !0 : await new Promise((o, u) => {
      const l = new F.Watch();
      l.start(this.pendingSubscriptionWatchLabel);
      const g = setInterval(() => {
        !this.pending.has(s) && this.topics.includes(s) && (clearInterval(g), l.stop(this.pendingSubscriptionWatchLabel), o(!0)), l.elapsed(this.pendingSubscriptionWatchLabel) >= uE && (clearInterval(g), l.stop(this.pendingSubscriptionWatchLabel), u(new Error("Subscription resolution timeout")));
      }, this.pollingInterval);
    }).catch(() => !1), this.on = (s, o) => {
      this.events.on(s, o);
    }, this.once = (s, o) => {
      this.events.once(s, o);
    }, this.off = (s, o) => {
      this.events.off(s, o);
    }, this.removeListener = (s, o) => {
      this.events.removeListener(s, o);
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = t, this.logger = ke(r, this.name), this.clientId = "";
  }
  get context() {
    return Qe(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(t, r) {
    let s = !1;
    try {
      s = this.getSubscription(t).topic === r;
    } catch {
    }
    return s;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(t, r) {
    const s = this.topicMap.get(t);
    await Promise.all(s.map(async (o) => await this.unsubscribeById(t, o, r)));
  }
  async unsubscribeById(t, r, s) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: t, id: r, opts: s } });
    try {
      const o = Oo(s);
      await this.rpcUnsubscribe(t, r, o);
      const u = ye("USER_DISCONNECTED", `${this.name}, ${t}`);
      await this.onUnsubscribe(t, r, u), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: t, id: r, opts: s } });
    } catch (o) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(o), o;
    }
  }
  async rpcSubscribe(t, r) {
    const s = { method: Is(r.protocol).subscribe, params: { topic: t } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s });
    try {
      await await bi(this.relayer.request(s), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(Re.connection_stalled);
    }
    return Dr(t + this.clientId);
  }
  async rpcBatchSubscribe(t) {
    if (!t.length) return;
    const r = t[0].relay, s = { method: Is(r.protocol).batchSubscribe, params: { topics: t.map((o) => o.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s });
    try {
      return await await bi(this.relayer.request(s), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(Re.connection_stalled);
    }
  }
  rpcUnsubscribe(t, r, s) {
    const o = { method: Is(s.protocol).unsubscribe, params: { topic: t, id: r } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: o }), this.relayer.request(o);
  }
  onSubscribe(t, r) {
    this.setSubscription(t, lo(fi({}, r), { id: t })), this.pending.delete(r.topic);
  }
  onBatchSubscribe(t) {
    t.length && t.forEach((r) => {
      this.setSubscription(r.id, fi({}, r)), this.pending.delete(r.topic);
    });
  }
  async onUnsubscribe(t, r, s) {
    this.events.removeAllListeners(r), this.hasSubscription(r, t) && this.deleteSubscription(r, s), await this.relayer.messages.del(t);
  }
  async setRelayerSubscriptions(t) {
    await this.relayer.core.storage.setItem(this.storageKey, t);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(t, r) {
    this.subscriptions.has(t) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: t, subscription: r }), this.addSubscription(t, r));
  }
  addSubscription(t, r) {
    this.subscriptions.set(t, fi({}, r)), this.topicMap.set(r.topic, t), this.events.emit(ft.created, r);
  }
  getSubscription(t) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: t });
    const r = this.subscriptions.get(t);
    if (!r) {
      const { message: s } = C("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw new Error(s);
    }
    return r;
  }
  deleteSubscription(t, r) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: t, reason: r });
    const s = this.getSubscription(t);
    this.subscriptions.delete(t), this.topicMap.delete(s.topic, t), this.events.emit(ft.deleted, lo(fi({}, s), { reason: r }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(ft.sync);
  }
  async reset() {
    if (this.cached.length) {
      const t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let r = 0; r < t; r++) {
        const s = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(s);
      }
    }
    this.events.emit(ft.resubscribed);
  }
  async restore() {
    try {
      const t = await this.getRelayerSubscriptions();
      if (typeof t > "u" || !t.length) return;
      if (this.subscriptions.size) {
        const { message: r } = C("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(r);
      }
      this.cached = t, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(t);
    }
  }
  async batchSubscribe(t) {
    if (!t.length) return;
    const r = await this.rpcBatchSubscribe(t);
    cr(r) && this.onBatchSubscribe(r.map((s, o) => lo(fi({}, t[o]), { id: s })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed) return;
    const t = [];
    this.pending.forEach((r) => {
      t.push(r);
    }), await this.batchSubscribe(t);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(jr.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(Re.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(Re.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(ft.created, async (t) => {
      const r = ft.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: t }), await this.persist();
    }), this.events.on(ft.deleted, async (t) => {
      const r = ft.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: t }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = C("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((t) => {
      const r = setInterval(() => {
        this.restartInProgress || (clearInterval(r), t());
      }, this.pollingInterval);
    });
  }
}
var NE = Object.defineProperty, ph = Object.getOwnPropertySymbols, TE = Object.prototype.hasOwnProperty, AE = Object.prototype.propertyIsEnumerable, fh = (a, t, r) => t in a ? NE(a, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : a[t] = r, xE = (a, t) => {
  for (var r in t || (t = {})) TE.call(t, r) && fh(a, r, t[r]);
  if (ph) for (var r of ph(t)) AE.call(t, r) && fh(a, r, t[r]);
  return a;
};
class DE extends R_ {
  constructor(t) {
    super(t), this.protocol = "wc", this.version = 2, this.events = new ot.EventEmitter(), this.name = eE, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = !1, this.request = async (r) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(r);
      } catch (s) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(s), s;
      }
    }, this.onPayloadHandler = (r) => {
      this.onProviderPayload(r);
    }, this.onConnectHandler = () => {
      this.events.emit(Re.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (r) => {
      this.logger.error(r), this.events.emit(Re.error, r), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(At.payload, this.onPayloadHandler), this.provider.on(At.connect, this.onConnectHandler), this.provider.on(At.disconnect, this.onDisconnectHandler), this.provider.on(At.error, this.onProviderErrorHandler);
    }, this.core = t.core, this.logger = typeof t.logger < "u" && typeof t.logger != "string" ? ke(t.logger, this.name) : Ts(As({ level: t.logger || Xb })), this.messages = new bE(this.logger, t.core), this.subscriber = new CE(this, this.logger), this.publisher = new EE(this, this.logger), this.relayUrl = (t == null ? void 0 : t.relayUrl) || El, this.projectId = t.projectId, this.bundleId = h1(), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${uh}...`), await this.restartTransport(uh);
    }
    this.initialized = !0, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = !1);
    }, sE);
  }
  get context() {
    return Qe(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(t, r, s) {
    this.isInitialized(), await this.publisher.publish(t, r, s), await this.recordMessageEvent({ topic: t, message: r, publishedAt: Date.now() });
  }
  async subscribe(t, r) {
    var s;
    this.isInitialized();
    let o = ((s = this.subscriber.topicMap.get(t)) == null ? void 0 : s[0]) || "";
    if (o) return o;
    let u;
    const l = (g) => {
      g.topic === t && (this.subscriber.off(ft.created, l), u());
    };
    return await Promise.all([new Promise((g) => {
      u = g, this.subscriber.on(ft.created, l);
    }), new Promise(async (g) => {
      o = await this.subscriber.subscribe(t, r), g();
    })]), o;
  }
  async unsubscribe(t, r) {
    this.isInitialized(), await this.subscriber.unsubscribe(t, r);
  }
  on(t, r) {
    this.events.on(t, r);
  }
  once(t, r) {
    this.events.once(t, r);
  }
  off(t, r) {
    this.events.off(t, r);
  }
  removeListener(t, r) {
    this.events.removeListener(t, r);
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, this.hasExperiencedNetworkDisruption && this.connected ? await bi(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(t) {
    if (this.transportExplicitlyClosed = !1, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      t && t !== this.relayUrl && (this.relayUrl = t, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = !0;
      try {
        await Promise.all([new Promise((r) => {
          if (!this.initialized) return r();
          this.subscriber.once(ft.resubscribed, () => {
            r();
          });
        }), new Promise(async (r, s) => {
          try {
            await bi(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (o) {
            s(o);
            return;
          }
          r();
        })]);
      } catch (r) {
        this.logger.error(r);
        const s = r;
        if (!this.isConnectionStalled(s.message)) throw r;
        this.provider.events.emit(At.disconnect);
      } finally {
        this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1;
      }
    }
  }
  async restartTransport(t) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = t || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Zu()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(t) {
    return this.staleConnectionErrors.some((r) => t.includes(r));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const t = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new Dt(new d0(y1({ sdkVersion: iE, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: t, useOnCloseEvent: !0, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(t) {
    const { topic: r, message: s } = t;
    await this.messages.set(r, s);
  }
  async shouldIgnoreMessageEvent(t) {
    const { topic: r, message: s } = t;
    if (!s || s.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${s}`), !0;
    if (!await this.subscriber.isSubscribed(r)) return this.logger.debug(`Ignoring message for non-subscribed topic ${r}`), !0;
    const o = this.messages.has(r, s);
    return o && this.logger.debug(`Ignoring duplicate message: ${s}`), o;
  }
  async onProviderPayload(t) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: t }), qo(t)) {
      if (!t.method.endsWith(tE)) return;
      const r = t.params, { topic: s, message: o, publishedAt: u } = r.data, l = { topic: s, message: o, publishedAt: u };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(xE({ type: "event", event: r.id }, l)), this.events.emit(r.id, l), await this.acknowledgePayload(t), await this.onMessageEvent(l);
    } else Cs(t) && this.events.emit(Re.message_ack, t);
  }
  async onMessageEvent(t) {
    await this.shouldIgnoreMessageEvent(t) || (this.events.emit(Re.message, t), await this.recordMessageEvent(t));
  }
  async acknowledgePayload(t) {
    const r = xs(t.id, !0);
    await this.provider.connection.send(r);
  }
  unregisterProviderListeners() {
    this.provider.off(At.payload, this.onPayloadHandler), this.provider.off(At.connect, this.onConnectHandler), this.provider.off(At.disconnect, this.onDisconnectHandler), this.provider.off(At.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(Re.connection_stalled, () => {
      this.restartTransport().catch((r) => this.logger.error(r));
    });
    let t = await Zu();
    c0(async (r) => {
      this.initialized && t !== r && (t = r, r ? await this.restartTransport().catch((s) => this.logger.error(s)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportClose().catch((s) => this.logger.error(s))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(Re.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((t) => this.logger.error(t));
    }, F.toMiliseconds(rE)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = C("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress) return await new Promise((t) => {
        const r = setInterval(() => {
          this.connected && (clearInterval(r), t());
        }, this.connectionStatusPollingInterval);
      });
      await this.restartTransport();
    }
  }
}
var FE = Object.defineProperty, dh = Object.getOwnPropertySymbols, qE = Object.prototype.hasOwnProperty, jE = Object.prototype.propertyIsEnumerable, gh = (a, t, r) => t in a ? FE(a, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : a[t] = r, yh = (a, t) => {
  for (var r in t || (t = {})) qE.call(t, r) && gh(a, r, t[r]);
  if (dh) for (var r of dh(t)) jE.call(t, r) && gh(a, r, t[r]);
  return a;
};
class qs extends $_ {
  constructor(t, r, s, o = Gt, u = void 0) {
    super(t, r, s, o), this.core = t, this.logger = r, this.name = s, this.map = /* @__PURE__ */ new Map(), this.version = nE, this.cached = [], this.initialized = !1, this.storagePrefix = Gt, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((l) => {
        this.getKey && l !== null && !Ae(l) ? this.map.set(this.getKey(l), l) : M1(l) ? this.map.set(l.id, l) : L1(l) && this.map.set(l.topic, l);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async (l, g) => {
      this.isInitialized(), this.map.has(l) ? await this.update(l, g) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: l, value: g }), this.map.set(l, g), await this.persist());
    }, this.get = (l) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: l }), this.getData(l)), this.getAll = (l) => (this.isInitialized(), l ? this.values.filter((g) => Object.keys(l).every((w) => qw(g[w], l[w]))) : this.values), this.update = async (l, g) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: l, update: g });
      const w = yh(yh({}, this.getData(l)), g);
      this.map.set(l, w), await this.persist();
    }, this.delete = async (l, g) => {
      this.isInitialized(), this.map.has(l) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: l, reason: g }), this.map.delete(l), await this.persist());
    }, this.logger = ke(r, this.name), this.storagePrefix = o, this.getKey = u;
  }
  get context() {
    return Qe(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(t) {
    await this.core.storage.setItem(this.storageKey, t);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(t) {
    const r = this.map.get(t);
    if (!r) {
      const { message: s } = C("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw this.logger.error(s), new Error(s);
    }
    return r;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const t = await this.getDataStore();
      if (typeof t > "u" || !t.length) return;
      if (this.map.size) {
        const { message: r } = C("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = t, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(t);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = C("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class UE {
  constructor(t, r) {
    this.core = t, this.logger = r, this.name = hE, this.version = lE, this.events = new Do(), this.initialized = !1, this.storagePrefix = Gt, this.ignoredPayloadTypes = [pr], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: s }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s])];
    }, this.create = async () => {
      this.isInitialized();
      const s = So(), o = await this.core.crypto.setSymKey(s), u = dt(F.FIVE_MINUTES), l = { protocol: bl }, g = { topic: o, expiry: u, relay: l, active: !1 }, w = C1({ protocol: this.core.protocol, version: this.core.version, topic: o, symKey: s, relay: l });
      return await this.pairings.set(o, g), await this.core.relayer.subscribe(o), this.core.expirer.set(o, u), { topic: o, uri: w };
    }, this.pair = async (s) => {
      this.isInitialized(), this.isValidPair(s);
      const { topic: o, symKey: u, relay: l } = Wu(s.uri);
      let g;
      if (this.pairings.keys.includes(o) && (g = this.pairings.get(o), g.active)) throw new Error(`Pairing already exists: ${o}. Please try again with a new connection URI.`);
      const w = dt(F.FIVE_MINUTES), b = { topic: o, relay: l, expiry: w, active: !1 };
      return await this.pairings.set(o, b), this.core.expirer.set(o, w), s.activatePairing && await this.activate({ topic: o }), this.events.emit(mi.create, b), this.core.crypto.keychain.has(o) || (await this.core.crypto.setSymKey(u, o), await this.core.relayer.subscribe(o, { relay: l })), b;
    }, this.activate = async ({ topic: s }) => {
      this.isInitialized();
      const o = dt(F.THIRTY_DAYS);
      await this.pairings.update(s, { active: !0, expiry: o }), this.core.expirer.set(s, o);
    }, this.ping = async (s) => {
      this.isInitialized(), await this.isValidPing(s);
      const { topic: o } = s;
      if (this.pairings.keys.includes(o)) {
        const u = await this.sendRequest(o, "wc_pairingPing", {}), { done: l, resolve: g, reject: w } = Tr();
        this.events.once(ve("pairing_ping", u), ({ error: b }) => {
          b ? w(b) : g();
        }), await l();
      }
    }, this.updateExpiry = async ({ topic: s, expiry: o }) => {
      this.isInitialized(), await this.pairings.update(s, { expiry: o });
    }, this.updateMetadata = async ({ topic: s, metadata: o }) => {
      this.isInitialized(), await this.pairings.update(s, { peerMetadata: o });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (s) => {
      this.isInitialized(), await this.isValidDisconnect(s);
      const { topic: o } = s;
      this.pairings.keys.includes(o) && (await this.sendRequest(o, "wc_pairingDelete", ye("USER_DISCONNECTED")), await this.deletePairing(o));
    }, this.sendRequest = async (s, o, u) => {
      const l = xr(o, u), g = await this.core.crypto.encode(s, l), w = pi[o].req;
      return this.core.history.set(s, l), this.core.relayer.publish(s, g, w), l.id;
    }, this.sendResult = async (s, o, u) => {
      const l = xs(s, u), g = await this.core.crypto.encode(o, l), w = await this.core.history.get(o, s), b = pi[w.request.method].res;
      await this.core.relayer.publish(o, g, b), await this.core.history.resolve(l);
    }, this.sendError = async (s, o, u) => {
      const l = Ns(s, u), g = await this.core.crypto.encode(o, l), w = await this.core.history.get(o, s), b = pi[w.request.method] ? pi[w.request.method].res : pi.unregistered_method.res;
      await this.core.relayer.publish(o, g, b), await this.core.history.resolve(l);
    }, this.deletePairing = async (s, o) => {
      await this.core.relayer.unsubscribe(s), await Promise.all([this.pairings.delete(s, ye("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s), o ? Promise.resolve() : this.core.expirer.del(s)]);
    }, this.cleanup = async () => {
      const s = this.pairings.getAll().filter((o) => Wt(o.expiry));
      await Promise.all(s.map((o) => this.deletePairing(o.topic)));
    }, this.onRelayEventRequest = (s) => {
      const { topic: o, payload: u } = s;
      switch (u.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(o, u);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(o, u);
        default:
          return this.onUnknownRpcMethodRequest(o, u);
      }
    }, this.onRelayEventResponse = async (s) => {
      const { topic: o, payload: u } = s, l = (await this.core.history.get(o, u.id)).request.method;
      switch (l) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(o, u);
        default:
          return this.onUnknownRpcMethodResponse(l);
      }
    }, this.onPairingPingRequest = async (s, o) => {
      const { id: u } = o;
      try {
        this.isValidPing({ topic: s }), await this.sendResult(u, s, !0), this.events.emit(mi.ping, { id: u, topic: s });
      } catch (l) {
        await this.sendError(u, s, l), this.logger.error(l);
      }
    }, this.onPairingPingResponse = (s, o) => {
      const { id: u } = o;
      setTimeout(() => {
        Bt(o) ? this.events.emit(ve("pairing_ping", u), {}) : bt(o) && this.events.emit(ve("pairing_ping", u), { error: o.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (s, o) => {
      const { id: u } = o;
      try {
        this.isValidDisconnect({ topic: s }), await this.deletePairing(s), this.events.emit(mi.delete, { id: u, topic: s });
      } catch (l) {
        await this.sendError(u, s, l), this.logger.error(l);
      }
    }, this.onUnknownRpcMethodRequest = async (s, o) => {
      const { id: u, method: l } = o;
      try {
        if (this.registeredMethods.includes(l)) return;
        const g = ye("WC_METHOD_UNSUPPORTED", l);
        await this.sendError(u, s, g), this.logger.error(g);
      } catch (g) {
        await this.sendError(u, s, g), this.logger.error(g);
      }
    }, this.onUnknownRpcMethodResponse = (s) => {
      this.registeredMethods.includes(s) || this.logger.error(ye("WC_METHOD_UNSUPPORTED", s));
    }, this.isValidPair = (s) => {
      var o;
      if (!Le(s)) {
        const { message: l } = C("MISSING_OR_INVALID", `pair() params: ${s}`);
        throw new Error(l);
      }
      if (!U1(s.uri)) {
        const { message: l } = C("MISSING_OR_INVALID", `pair() uri: ${s.uri}`);
        throw new Error(l);
      }
      const u = Wu(s.uri);
      if (!((o = u == null ? void 0 : u.relay) != null && o.protocol)) {
        const { message: l } = C("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw new Error(l);
      }
      if (!(u != null && u.symKey)) {
        const { message: l } = C("MISSING_OR_INVALID", "pair() uri#symKey");
        throw new Error(l);
      }
    }, this.isValidPing = async (s) => {
      if (!Le(s)) {
        const { message: u } = C("MISSING_OR_INVALID", `ping() params: ${s}`);
        throw new Error(u);
      }
      const { topic: o } = s;
      await this.isValidPairingTopic(o);
    }, this.isValidDisconnect = async (s) => {
      if (!Le(s)) {
        const { message: u } = C("MISSING_OR_INVALID", `disconnect() params: ${s}`);
        throw new Error(u);
      }
      const { topic: o } = s;
      await this.isValidPairingTopic(o);
    }, this.isValidPairingTopic = async (s) => {
      if (!be(s, !1)) {
        const { message: o } = C("MISSING_OR_INVALID", `pairing topic should be a string: ${s}`);
        throw new Error(o);
      }
      if (!this.pairings.keys.includes(s)) {
        const { message: o } = C("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s}`);
        throw new Error(o);
      }
      if (Wt(this.pairings.get(s).expiry)) {
        await this.deletePairing(s);
        const { message: o } = C("EXPIRED", `pairing topic: ${s}`);
        throw new Error(o);
      }
    }, this.core = t, this.logger = ke(r, this.name), this.pairings = new qs(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return Qe(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = C("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(Re.message, async (t) => {
      const { topic: r, message: s } = t;
      if (!this.pairings.keys.includes(r) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s))) return;
      const o = await this.core.crypto.decode(r, s);
      try {
        qo(o) ? (this.core.history.set(r, o), this.onRelayEventRequest({ topic: r, payload: o })) : Cs(o) && (await this.core.history.resolve(o), await this.onRelayEventResponse({ topic: r, payload: o }), this.core.history.delete(r, o.id));
      } catch (u) {
        this.logger.error(u);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(st.expired, async (t) => {
      const { topic: r } = nl(t.target);
      r && this.pairings.keys.includes(r) && (await this.deletePairing(r, !0), this.events.emit(mi.expire, { topic: r }));
    });
  }
}
class ME extends P_ {
  constructor(t, r) {
    super(t, r), this.core = t, this.logger = r, this.records = /* @__PURE__ */ new Map(), this.events = new ot.EventEmitter(), this.name = pE, this.version = fE, this.cached = [], this.initialized = !1, this.storagePrefix = Gt, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s) => this.records.set(s.id, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (s, o, u) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s, request: o, chainId: u }), this.records.has(o.id)) return;
      const l = { id: o.id, topic: s, request: { method: o.method, params: o.params || null }, chainId: u, expiry: dt(F.THIRTY_DAYS) };
      this.records.set(l.id, l), this.events.emit(_t.created, l);
    }, this.resolve = async (s) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s }), !this.records.has(s.id)) return;
      const o = await this.getRecord(s.id);
      typeof o.response > "u" && (o.response = bt(s) ? { error: s.error } : { result: s.result }, this.records.set(o.id, o), this.events.emit(_t.updated, o));
    }, this.get = async (s, o) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s, id: o }), await this.getRecord(o)), this.delete = (s, o) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: o }), this.values.forEach((u) => {
        if (u.topic === s) {
          if (typeof o < "u" && u.id !== o) return;
          this.records.delete(u.id), this.events.emit(_t.deleted, u);
        }
      });
    }, this.exists = async (s, o) => (this.isInitialized(), this.records.has(o) ? (await this.getRecord(o)).topic === s : !1), this.on = (s, o) => {
      this.events.on(s, o);
    }, this.once = (s, o) => {
      this.events.once(s, o);
    }, this.off = (s, o) => {
      this.events.off(s, o);
    }, this.removeListener = (s, o) => {
      this.events.removeListener(s, o);
    }, this.logger = ke(r, this.name);
  }
  get context() {
    return Qe(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const t = [];
    return this.values.forEach((r) => {
      if (typeof r.response < "u") return;
      const s = { topic: r.topic, request: xr(r.request.method, r.request.params, r.id), chainId: r.chainId };
      return t.push(s);
    }), t;
  }
  async setJsonRpcRecords(t) {
    await this.core.storage.setItem(this.storageKey, t);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(t) {
    this.isInitialized();
    const r = this.records.get(t);
    if (!r) {
      const { message: s } = C("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw new Error(s);
    }
    return r;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(_t.sync);
  }
  async restore() {
    try {
      const t = await this.getJsonRpcRecords();
      if (typeof t > "u" || !t.length) return;
      if (this.records.size) {
        const { message: r } = C("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = t, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(t);
    }
  }
  registerEventListeners() {
    this.events.on(_t.created, (t) => {
      const r = _t.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: t }), this.persist();
    }), this.events.on(_t.updated, (t) => {
      const r = _t.updated;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: t }), this.persist();
    }), this.events.on(_t.deleted, (t) => {
      const r = _t.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: t }), this.persist();
    }), this.core.heartbeat.on(jr.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((t) => {
        F.toMiliseconds(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.delete(t.topic, t.id));
      });
    } catch (t) {
      this.logger.warn(t);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = C("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class LE extends N_ {
  constructor(t, r) {
    super(t, r), this.core = t, this.logger = r, this.expirations = /* @__PURE__ */ new Map(), this.events = new ot.EventEmitter(), this.name = dE, this.version = gE, this.cached = [], this.initialized = !1, this.storagePrefix = Gt, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s) => this.expirations.set(s.target, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (s) => {
      try {
        const o = this.formatTarget(s);
        return typeof this.getExpiration(o) < "u";
      } catch {
        return !1;
      }
    }, this.set = (s, o) => {
      this.isInitialized();
      const u = this.formatTarget(s), l = { target: u, expiry: o };
      this.expirations.set(u, l), this.checkExpiry(u, l), this.events.emit(st.created, { target: u, expiration: l });
    }, this.get = (s) => {
      this.isInitialized();
      const o = this.formatTarget(s);
      return this.getExpiration(o);
    }, this.del = (s) => {
      if (this.isInitialized(), this.has(s)) {
        const o = this.formatTarget(s), u = this.getExpiration(o);
        this.expirations.delete(o), this.events.emit(st.deleted, { target: o, expiration: u });
      }
    }, this.on = (s, o) => {
      this.events.on(s, o);
    }, this.once = (s, o) => {
      this.events.once(s, o);
    }, this.off = (s, o) => {
      this.events.off(s, o);
    }, this.removeListener = (s, o) => {
      this.events.removeListener(s, o);
    }, this.logger = ke(r, this.name);
  }
  get context() {
    return Qe(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(t) {
    if (typeof t == "string") return v1(t);
    if (typeof t == "number") return m1(t);
    const { message: r } = C("UNKNOWN_TYPE", `Target type: ${typeof t}`);
    throw new Error(r);
  }
  async setExpirations(t) {
    await this.core.storage.setItem(this.storageKey, t);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(st.sync);
  }
  async restore() {
    try {
      const t = await this.getExpirations();
      if (typeof t > "u" || !t.length) return;
      if (this.expirations.size) {
        const { message: r } = C("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = t, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(t);
    }
  }
  getExpiration(t) {
    const r = this.expirations.get(t);
    if (!r) {
      const { message: s } = C("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw this.logger.error(s), new Error(s);
    }
    return r;
  }
  checkExpiry(t, r) {
    const { expiry: s } = r;
    F.toMiliseconds(s) - Date.now() <= 0 && this.expire(t, r);
  }
  expire(t, r) {
    this.expirations.delete(t), this.events.emit(st.expired, { target: t, expiration: r });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((t, r) => this.checkExpiry(r, t));
  }
  registerEventListeners() {
    this.core.heartbeat.on(jr.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(st.created, (t) => {
      const r = st.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: t }), this.persist();
    }), this.events.on(st.expired, (t) => {
      const r = st.expired;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: t }), this.persist();
    }), this.events.on(st.deleted, (t) => {
      const r = st.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: t }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = C("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class kE extends T_ {
  constructor(t, r) {
    super(t, r), this.projectId = t, this.logger = r, this.name = ho, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = async (s) => {
      if (this.verifyDisabled || Mr() || !Lr()) return;
      const o = this.getVerifyUrl(s == null ? void 0 : s.verifyUrl);
      this.verifyUrl !== o && this.removeIframe(), this.verifyUrl = o;
      try {
        await this.createIframe();
      } catch (u) {
        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(u);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = Co;
        try {
          await this.createIframe();
        } catch (u) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(u), this.verifyDisabled = !0;
        }
      }
    }, this.register = async (s) => {
      this.initialized ? this.sendPost(s.attestationId) : (this.addToQueue(s.attestationId), await this.init());
    }, this.resolve = async (s) => {
      if (this.isDevEnv) return "";
      const o = this.getVerifyUrl(s == null ? void 0 : s.verifyUrl);
      let u;
      try {
        u = await this.fetchAttestation(s.attestationId, o);
      } catch (l) {
        this.logger.info(`failed to resolve attestation: ${s.attestationId} from url: ${o}`), this.logger.info(l), u = await this.fetchAttestation(s.attestationId, Co);
      }
      return u;
    }, this.fetchAttestation = async (s, o) => {
      this.logger.info(`resolving attestation: ${s} from url: ${o}`);
      const u = this.startAbortTimer(F.ONE_SECOND * 2), l = await fetch(`${o}/attestation/${s}`, { signal: this.abortController.signal });
      return clearTimeout(u), l.status === 200 ? await l.json() : void 0;
    }, this.addToQueue = (s) => {
      this.queue.push(s);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((s) => this.sendPost(s)), this.queue = []);
    }, this.sendPost = (s) => {
      var o;
      try {
        if (!this.iframe) return;
        (o = this.iframe.contentWindow) == null || o.postMessage(s, "*"), this.logger.info(`postMessage sent: ${s} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let s;
      const o = (u) => {
        u.data === "verify_ready" && (this.initialized = !0, this.processQueue(), window.removeEventListener("message", o), s());
      };
      await Promise.race([new Promise((u) => {
        if (document.getElementById(ho)) return u();
        window.addEventListener("message", o);
        const l = document.createElement("iframe");
        l.id = ho, l.src = `${this.verifyUrl}/${this.projectId}`, l.style.display = "none", document.body.append(l), this.iframe = l, s = u;
      }), new Promise((u, l) => setTimeout(() => {
        window.removeEventListener("message", o), l("verify iframe load timeout");
      }, F.toMiliseconds(F.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1);
    }, this.getVerifyUrl = (s) => {
      let o = s || Ar;
      return yE.includes(o) || (this.logger.info(`verify url: ${o}, not included in trusted list, assigning default: ${Ar}`), o = Ar), o;
    }, this.logger = ke(r, this.name), this.verifyUrl = Ar, this.abortController = new AbortController(), this.isDevEnv = Ho() && Z.process.env.IS_VITEST;
  }
  get context() {
    return Qe(this.logger);
  }
  startAbortTimer(t) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), F.toMiliseconds(t));
  }
}
class zE extends A_ {
  constructor(t, r) {
    super(t, r), this.projectId = t, this.logger = r, this.context = vE, this.registerDeviceToken = async (s) => {
      const { clientId: o, token: u, notificationType: l, enableEncrypted: g = !1 } = s, w = `${mE}/${this.projectId}/clients`;
      await m0(w, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: o, type: l, token: u, always_raw: g }) });
    }, this.logger = ke(r, this.context);
  }
}
var HE = Object.defineProperty, vh = Object.getOwnPropertySymbols, VE = Object.prototype.hasOwnProperty, KE = Object.prototype.propertyIsEnumerable, mh = (a, t, r) => t in a ? HE(a, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : a[t] = r, wh = (a, t) => {
  for (var r in t || (t = {})) VE.call(t, r) && mh(a, r, t[r]);
  if (vh) for (var r of vh(t)) KE.call(t, r) && mh(a, r, t[r]);
  return a;
};
class Bo extends I_ {
  constructor(t) {
    super(t), this.protocol = wl, this.version = zb, this.name = _l, this.events = new ot.EventEmitter(), this.initialized = !1, this.on = (s, o) => this.events.on(s, o), this.once = (s, o) => this.events.once(s, o), this.off = (s, o) => this.events.off(s, o), this.removeListener = (s, o) => this.events.removeListener(s, o), this.projectId = t == null ? void 0 : t.projectId, this.relayUrl = (t == null ? void 0 : t.relayUrl) || El, this.customStoragePrefix = t != null && t.customStoragePrefix ? `:${t.customStoragePrefix}` : "";
    const r = typeof (t == null ? void 0 : t.logger) < "u" && typeof (t == null ? void 0 : t.logger) != "string" ? t.logger : Ts(As({ level: (t == null ? void 0 : t.logger) || Hb.logger }));
    this.logger = ke(r, this.name), this.heartbeat = new jr.HeartBeat(), this.crypto = new _E(this, this.logger, t == null ? void 0 : t.keychain), this.history = new ME(this, this.logger), this.expirer = new LE(this, this.logger), this.storage = t != null && t.storage ? t.storage : new xw(wh(wh({}, Vb), t == null ? void 0 : t.storageOptions)), this.relayer = new DE({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new UE(this, this.logger), this.verify = new kE(this.projectId || "", this.logger), this.echoClient = new zE(this.projectId || "", this.logger);
  }
  static async init(t) {
    const r = new Bo(t);
    await r.initialize();
    const s = await r.crypto.getClientId();
    return await r.storage.setItem(oE, s), r;
  }
  get context() {
    return Qe(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (t) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, t), this.logger.error(t.message), t;
    }
  }
}
const BE = Bo, Il = "wc", Pl = 2, Sl = "client", Wo = `${Il}@${Pl}:${Sl}:`, po = { name: Sl, logger: "error" }, _h = "WALLETCONNECT_DEEPLINK_CHOICE", WE = "proposal", Ol = "Proposal expired", GE = "session", _s = F.SEVEN_DAYS, QE = "engine", di = { wc_sessionPropose: { req: { ttl: F.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: F.FIVE_MINUTES, prompt: !1, tag: 1101 } }, wc_sessionSettle: { req: { ttl: F.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: F.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: F.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: F.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: F.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: F.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: F.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: F.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: F.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: F.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: F.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: F.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: F.THIRTY_SECONDS, prompt: !1, tag: 1114 }, res: { ttl: F.THIRTY_SECONDS, prompt: !1, tag: 1115 } } }, fo = { min: F.FIVE_MINUTES, max: F.SEVEN_DAYS }, xt = { idle: "IDLE", active: "ACTIVE" }, JE = "request", YE = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var ZE = Object.defineProperty, XE = Object.defineProperties, eI = Object.getOwnPropertyDescriptors, bh = Object.getOwnPropertySymbols, tI = Object.prototype.hasOwnProperty, rI = Object.prototype.propertyIsEnumerable, Eh = (a, t, r) => t in a ? ZE(a, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : a[t] = r, Me = (a, t) => {
  for (var r in t || (t = {})) tI.call(t, r) && Eh(a, r, t[r]);
  if (bh) for (var r of bh(t)) rI.call(t, r) && Eh(a, r, t[r]);
  return a;
}, gi = (a, t) => XE(a, eI(t));
class iI extends D_ {
  constructor(t) {
    super(t), this.name = QE, this.events = new Do(), this.initialized = !1, this.ignoredPayloadTypes = [pr], this.requestQueue = { state: xt.idle, queue: [] }, this.sessionRequestQueue = { state: xt.idle, queue: [] }, this.requestQueueDelay = F.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(di) }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, F.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (r) => {
      await this.isInitialized();
      const s = gi(Me({}, r), { requiredNamespaces: r.requiredNamespaces || {}, optionalNamespaces: r.optionalNamespaces || {} });
      await this.isValidConnect(s);
      const { pairingTopic: o, requiredNamespaces: u, optionalNamespaces: l, sessionProperties: g, relays: w } = s;
      let b = o, $, S = !1;
      if (b && (S = this.client.core.pairing.pairings.get(b).active), !b || !S) {
        const { topic: J, uri: X } = await this.client.core.pairing.create();
        b = J, $ = X;
      }
      const R = await this.client.core.crypto.generateKeyPair(), q = Me({ requiredNamespaces: u, optionalNamespaces: l, relays: w ?? [{ protocol: bl }], proposer: { publicKey: R, metadata: this.client.metadata } }, g && { sessionProperties: g }), { reject: A, resolve: V, done: x } = Tr(F.FIVE_MINUTES, Ol);
      if (this.events.once(ve("session_connect"), async ({ error: J, session: X }) => {
        if (J) A(J);
        else if (X) {
          X.self.publicKey = R;
          const ue = gi(Me({}, X), { requiredNamespaces: X.requiredNamespaces, optionalNamespaces: X.optionalNamespaces });
          await this.client.session.set(X.topic, ue), await this.setExpiry(X.topic, X.expiry), b && await this.client.core.pairing.updateMetadata({ topic: b, metadata: X.peer.metadata }), V(ue);
        }
      }), !b) {
        const { message: J } = C("NO_MATCHING_KEY", `connect() pairing topic: ${b}`);
        throw new Error(J);
      }
      const G = await this.sendRequest({ topic: b, method: "wc_sessionPropose", params: q }), pe = dt(F.FIVE_MINUTES);
      return await this.setProposal(G, Me({ id: G, expiry: pe }, q)), { uri: $, approval: x };
    }, this.pair = async (r) => (await this.isInitialized(), await this.client.core.pairing.pair(r)), this.approve = async (r) => {
      await this.isInitialized(), await this.isValidApprove(r);
      const { id: s, relayProtocol: o, namespaces: u, sessionProperties: l } = r, g = this.client.proposal.get(s);
      let { pairingTopic: w, proposer: b, requiredNamespaces: $, optionalNamespaces: S } = g;
      w = w || "", Fr($) || ($ = x1(u, "approve()"));
      const R = await this.client.core.crypto.generateKeyPair(), q = b.publicKey, A = await this.client.core.crypto.generateSharedKey(R, q);
      w && s && (await this.client.core.pairing.updateMetadata({ topic: w, metadata: b.metadata }), await this.sendResult({ id: s, topic: w, result: { relay: { protocol: o ?? "irn" }, responderPublicKey: R } }), await this.client.proposal.delete(s, ye("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: w }));
      const V = Me({ relay: { protocol: o ?? "irn" }, namespaces: u, requiredNamespaces: $, optionalNamespaces: S, pairingTopic: w, controller: { publicKey: R, metadata: this.client.metadata }, expiry: dt(_s) }, l && { sessionProperties: l });
      await this.client.core.relayer.subscribe(A), await this.sendRequest({ topic: A, method: "wc_sessionSettle", params: V, throwOnFailedPublish: !0 });
      const x = gi(Me({}, V), { topic: A, pairingTopic: w, acknowledged: !1, self: V.controller, peer: { publicKey: b.publicKey, metadata: b.metadata }, controller: R });
      return await this.client.session.set(A, x), await this.setExpiry(A, dt(_s)), { topic: A, acknowledged: () => new Promise((G) => setTimeout(() => G(this.client.session.get(A)), 500)) };
    }, this.reject = async (r) => {
      await this.isInitialized(), await this.isValidReject(r);
      const { id: s, reason: o } = r, { pairingTopic: u } = this.client.proposal.get(s);
      u && (await this.sendError(s, u, o), await this.client.proposal.delete(s, ye("USER_DISCONNECTED")));
    }, this.update = async (r) => {
      await this.isInitialized(), await this.isValidUpdate(r);
      const { topic: s, namespaces: o } = r, u = await this.sendRequest({ topic: s, method: "wc_sessionUpdate", params: { namespaces: o } }), { done: l, resolve: g, reject: w } = Tr();
      return this.events.once(ve("session_update", u), ({ error: b }) => {
        b ? w(b) : g();
      }), await this.client.session.update(s, { namespaces: o }), { acknowledged: l };
    }, this.extend = async (r) => {
      await this.isInitialized(), await this.isValidExtend(r);
      const { topic: s } = r, o = await this.sendRequest({ topic: s, method: "wc_sessionExtend", params: {} }), { done: u, resolve: l, reject: g } = Tr();
      return this.events.once(ve("session_extend", o), ({ error: w }) => {
        w ? g(w) : l();
      }), await this.setExpiry(s, dt(_s)), { acknowledged: u };
    }, this.request = async (r) => {
      await this.isInitialized(), await this.isValidRequest(r);
      const { chainId: s, request: o, topic: u, expiry: l } = r, g = jw(), { done: w, resolve: b, reject: $ } = Tr(l, "Request expired. Please try again.");
      return this.events.once(ve("session_request", g), ({ error: S, result: R }) => {
        S ? $(S) : b(R);
      }), await Promise.all([new Promise(async (S) => {
        await this.sendRequest({ clientRpcId: g, topic: u, method: "wc_sessionRequest", params: { request: o, chainId: s }, expiry: l, throwOnFailedPublish: !0 }).catch((R) => $(R)), this.client.events.emit("session_request_sent", { topic: u, request: o, chainId: s, id: g }), S();
      }), new Promise(async (S) => {
        const R = await _1(this.client.core.storage, _h);
        w1({ id: g, topic: u, wcDeepLink: R }), S();
      }), w()]).then((S) => S[2]);
    }, this.respond = async (r) => {
      await this.isInitialized(), await this.isValidRespond(r);
      const { topic: s, response: o } = r, { id: u } = o;
      Bt(o) ? await this.sendResult({ id: u, topic: s, result: o.result, throwOnFailedPublish: !0 }) : bt(o) && await this.sendError(u, s, o.error), this.cleanupAfterResponse(r);
    }, this.ping = async (r) => {
      await this.isInitialized(), await this.isValidPing(r);
      const { topic: s } = r;
      if (this.client.session.keys.includes(s)) {
        const o = await this.sendRequest({ topic: s, method: "wc_sessionPing", params: {} }), { done: u, resolve: l, reject: g } = Tr();
        this.events.once(ve("session_ping", o), ({ error: w }) => {
          w ? g(w) : l();
        }), await u();
      } else this.client.core.pairing.pairings.keys.includes(s) && await this.client.core.pairing.ping({ topic: s });
    }, this.emit = async (r) => {
      await this.isInitialized(), await this.isValidEmit(r);
      const { topic: s, event: o, chainId: u } = r;
      await this.sendRequest({ topic: s, method: "wc_sessionEvent", params: { event: o, chainId: u } });
    }, this.disconnect = async (r) => {
      await this.isInitialized(), await this.isValidDisconnect(r);
      const { topic: s } = r;
      this.client.session.keys.includes(s) ? (await this.sendRequest({ topic: s, method: "wc_sessionDelete", params: ye("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession(s)) : await this.client.core.pairing.disconnect({ topic: s });
    }, this.find = (r) => (this.isInitialized(), this.client.session.getAll().filter((s) => q1(s, r))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (r) => {
      if (r.pairingTopic) try {
        const s = this.client.core.pairing.pairings.get(r.pairingTopic), o = this.client.core.pairing.pairings.getAll().filter((u) => {
          var l, g;
          return ((l = u.peerMetadata) == null ? void 0 : l.url) && ((g = u.peerMetadata) == null ? void 0 : g.url) === r.peer.metadata.url && u.topic && u.topic !== s.topic;
        });
        if (o.length === 0) return;
        this.client.logger.info(`Cleaning up ${o.length} duplicate pairing(s)`), await Promise.all(o.map((u) => this.client.core.pairing.disconnect({ topic: u.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.deleteSession = async (r, s) => {
      const { self: o } = this.client.session.get(r);
      await this.client.core.relayer.unsubscribe(r), this.client.session.delete(r, ye("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(o.publicKey) && await this.client.core.crypto.deleteKeyPair(o.publicKey), this.client.core.crypto.keychain.has(r) && await this.client.core.crypto.deleteSymKey(r), s || this.client.core.expirer.del(r), this.client.core.storage.removeItem(_h).catch((u) => this.client.logger.warn(u)), this.getPendingSessionRequests().forEach((u) => {
        u.topic === r && this.deletePendingSessionRequest(u.id, ye("USER_DISCONNECTED"));
      });
    }, this.deleteProposal = async (r, s) => {
      await Promise.all([this.client.proposal.delete(r, ye("USER_DISCONNECTED")), s ? Promise.resolve() : this.client.core.expirer.del(r)]);
    }, this.deletePendingSessionRequest = async (r, s, o = !1) => {
      await Promise.all([this.client.pendingRequest.delete(r, s), o ? Promise.resolve() : this.client.core.expirer.del(r)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((u) => u.id !== r), o && (this.sessionRequestQueue.state = xt.idle);
    }, this.setExpiry = async (r, s) => {
      this.client.session.keys.includes(r) && await this.client.session.update(r, { expiry: s }), this.client.core.expirer.set(r, s);
    }, this.setProposal = async (r, s) => {
      await this.client.proposal.set(r, s), this.client.core.expirer.set(r, s.expiry);
    }, this.setPendingSessionRequest = async (r) => {
      const s = di.wc_sessionRequest.req.ttl, { id: o, topic: u, params: l, verifyContext: g } = r;
      await this.client.pendingRequest.set(o, { id: o, topic: u, params: l, verifyContext: g }), s && this.client.core.expirer.set(o, dt(s));
    }, this.sendRequest = async (r) => {
      const { topic: s, method: o, params: u, expiry: l, relayRpcId: g, clientRpcId: w, throwOnFailedPublish: b } = r, $ = xr(o, u, w);
      if (Lr() && YE.includes(o)) {
        const q = Dr(JSON.stringify($));
        this.client.core.verify.register({ attestationId: q });
      }
      const S = await this.client.core.crypto.encode(s, $), R = di[o].req;
      return l && (R.ttl = l), g && (R.id = g), this.client.core.history.set(s, $), b ? (R.internal = gi(Me({}, R.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(s, S, R)) : this.client.core.relayer.publish(s, S, R).catch((q) => this.client.logger.error(q)), $.id;
    }, this.sendResult = async (r) => {
      const { id: s, topic: o, result: u, throwOnFailedPublish: l } = r, g = xs(s, u), w = await this.client.core.crypto.encode(o, g), b = await this.client.core.history.get(o, s), $ = di[b.request.method].res;
      l ? ($.internal = gi(Me({}, $.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(o, w, $)) : this.client.core.relayer.publish(o, w, $).catch((S) => this.client.logger.error(S)), await this.client.core.history.resolve(g);
    }, this.sendError = async (r, s, o) => {
      const u = Ns(r, o), l = await this.client.core.crypto.encode(s, u), g = await this.client.core.history.get(s, r), w = di[g.request.method].res;
      this.client.core.relayer.publish(s, l, w), await this.client.core.history.resolve(u);
    }, this.cleanup = async () => {
      const r = [], s = [];
      this.client.session.getAll().forEach((o) => {
        Wt(o.expiry) && r.push(o.topic);
      }), this.client.proposal.getAll().forEach((o) => {
        Wt(o.expiry) && s.push(o.id);
      }), await Promise.all([...r.map((o) => this.deleteSession(o)), ...s.map((o) => this.deleteProposal(o))]);
    }, this.onRelayEventRequest = async (r) => {
      this.requestQueue.queue.push(r), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === xt.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = xt.active;
        const r = this.requestQueue.queue.shift();
        if (r) try {
          this.processRequest(r), await new Promise((s) => setTimeout(s, 300));
        } catch (s) {
          this.client.logger.warn(s);
        }
      }
      this.requestQueue.state = xt.idle;
    }, this.processRequest = (r) => {
      const { topic: s, payload: o } = r, u = o.method;
      switch (u) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(s, o);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(s, o);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(s, o);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(s, o);
        case "wc_sessionPing":
          return this.onSessionPingRequest(s, o);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(s, o);
        case "wc_sessionRequest":
          return this.onSessionRequest(s, o);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(s, o);
        default:
          return this.client.logger.info(`Unsupported request method ${u}`);
      }
    }, this.onRelayEventResponse = async (r) => {
      const { topic: s, payload: o } = r, u = (await this.client.core.history.get(s, o.id)).request.method;
      switch (u) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(s, o);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(s, o);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(s, o);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(s, o);
        case "wc_sessionPing":
          return this.onSessionPingResponse(s, o);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(s, o);
        default:
          return this.client.logger.info(`Unsupported response method ${u}`);
      }
    }, this.onRelayEventUnknownPayload = (r) => {
      const { topic: s } = r, { message: o } = C("MISSING_OR_INVALID", `Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(o);
    }, this.onSessionProposeRequest = async (r, s) => {
      const { params: o, id: u } = s;
      try {
        this.isValidConnect(Me({}, s.params));
        const l = dt(F.FIVE_MINUTES), g = Me({ id: u, pairingTopic: r, expiry: l }, o);
        await this.setProposal(u, g);
        const w = Dr(JSON.stringify(s)), b = await this.getVerifyContext(w, g.proposer.metadata);
        this.client.events.emit("session_proposal", { id: u, params: g, verifyContext: b });
      } catch (l) {
        await this.sendError(u, r, l), this.client.logger.error(l);
      }
    }, this.onSessionProposeResponse = async (r, s) => {
      const { id: o } = s;
      if (Bt(s)) {
        const { result: u } = s;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: u });
        const l = this.client.proposal.get(o);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: l });
        const g = l.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: g });
        const w = u.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: w });
        const b = await this.client.core.crypto.generateSharedKey(g, w);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: b });
        const $ = await this.client.core.relayer.subscribe(b);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: $ }), await this.client.core.pairing.activate({ topic: r });
      } else bt(s) && (await this.client.proposal.delete(o, ye("USER_DISCONNECTED")), this.events.emit(ve("session_connect"), { error: s.error }));
    }, this.onSessionSettleRequest = async (r, s) => {
      const { id: o, params: u } = s;
      try {
        this.isValidSessionSettleRequest(u);
        const { relay: l, controller: g, expiry: w, namespaces: b, requiredNamespaces: $, optionalNamespaces: S, sessionProperties: R, pairingTopic: q } = s.params, A = Me({ topic: r, relay: l, expiry: w, namespaces: b, acknowledged: !0, pairingTopic: q, requiredNamespaces: $, optionalNamespaces: S, controller: g.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: g.publicKey, metadata: g.metadata } }, R && { sessionProperties: R });
        await this.sendResult({ id: s.id, topic: r, result: !0 }), this.events.emit(ve("session_connect"), { session: A }), this.cleanupDuplicatePairings(A);
      } catch (l) {
        await this.sendError(o, r, l), this.client.logger.error(l);
      }
    }, this.onSessionSettleResponse = async (r, s) => {
      const { id: o } = s;
      Bt(s) ? (await this.client.session.update(r, { acknowledged: !0 }), this.events.emit(ve("session_approve", o), {})) : bt(s) && (await this.client.session.delete(r, ye("USER_DISCONNECTED")), this.events.emit(ve("session_approve", o), { error: s.error }));
    }, this.onSessionUpdateRequest = async (r, s) => {
      const { params: o, id: u } = s;
      try {
        const l = `${r}_session_update`, g = ws.get(l);
        if (g && this.isRequestOutOfSync(g, u)) {
          this.client.logger.info(`Discarding out of sync request - ${u}`);
          return;
        }
        this.isValidUpdate(Me({ topic: r }, o)), await this.client.session.update(r, { namespaces: o.namespaces }), await this.sendResult({ id: u, topic: r, result: !0 }), this.client.events.emit("session_update", { id: u, topic: r, params: o }), ws.set(l, u);
      } catch (l) {
        await this.sendError(u, r, l), this.client.logger.error(l);
      }
    }, this.isRequestOutOfSync = (r, s) => parseInt(s.toString().slice(0, -3)) <= parseInt(r.toString().slice(0, -3)), this.onSessionUpdateResponse = (r, s) => {
      const { id: o } = s;
      Bt(s) ? this.events.emit(ve("session_update", o), {}) : bt(s) && this.events.emit(ve("session_update", o), { error: s.error });
    }, this.onSessionExtendRequest = async (r, s) => {
      const { id: o } = s;
      try {
        this.isValidExtend({ topic: r }), await this.setExpiry(r, dt(_s)), await this.sendResult({ id: o, topic: r, result: !0 }), this.client.events.emit("session_extend", { id: o, topic: r });
      } catch (u) {
        await this.sendError(o, r, u), this.client.logger.error(u);
      }
    }, this.onSessionExtendResponse = (r, s) => {
      const { id: o } = s;
      Bt(s) ? this.events.emit(ve("session_extend", o), {}) : bt(s) && this.events.emit(ve("session_extend", o), { error: s.error });
    }, this.onSessionPingRequest = async (r, s) => {
      const { id: o } = s;
      try {
        this.isValidPing({ topic: r }), await this.sendResult({ id: o, topic: r, result: !0 }), this.client.events.emit("session_ping", { id: o, topic: r });
      } catch (u) {
        await this.sendError(o, r, u), this.client.logger.error(u);
      }
    }, this.onSessionPingResponse = (r, s) => {
      const { id: o } = s;
      setTimeout(() => {
        Bt(s) ? this.events.emit(ve("session_ping", o), {}) : bt(s) && this.events.emit(ve("session_ping", o), { error: s.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (r, s) => {
      const { id: o } = s;
      try {
        this.isValidDisconnect({ topic: r, reason: s.params }), await Promise.all([new Promise((u) => {
          this.client.core.relayer.once(Re.publish, async () => {
            u(await this.deleteSession(r));
          });
        }), this.sendResult({ id: o, topic: r, result: !0 })]), this.client.events.emit("session_delete", { id: o, topic: r });
      } catch (u) {
        this.client.logger.error(u);
      }
    }, this.onSessionRequest = async (r, s) => {
      const { id: o, params: u } = s;
      try {
        this.isValidRequest(Me({ topic: r }, u));
        const l = Dr(JSON.stringify(xr("wc_sessionRequest", u, o))), g = this.client.session.get(r), w = await this.getVerifyContext(l, g.peer.metadata), b = { id: o, topic: r, params: u, verifyContext: w };
        await this.setPendingSessionRequest(b), this.addSessionRequestToSessionRequestQueue(b), this.processSessionRequestQueue();
      } catch (l) {
        await this.sendError(o, r, l), this.client.logger.error(l);
      }
    }, this.onSessionRequestResponse = (r, s) => {
      const { id: o } = s;
      Bt(s) ? this.events.emit(ve("session_request", o), { result: s.result }) : bt(s) && this.events.emit(ve("session_request", o), { error: s.error });
    }, this.onSessionEventRequest = async (r, s) => {
      const { id: o, params: u } = s;
      try {
        const l = `${r}_session_event_${u.event.name}`, g = ws.get(l);
        if (g && this.isRequestOutOfSync(g, o)) {
          this.client.logger.info(`Discarding out of sync request - ${o}`);
          return;
        }
        this.isValidEmit(Me({ topic: r }, u)), this.client.events.emit("session_event", { id: o, topic: r, params: u }), ws.set(l, o);
      } catch (l) {
        await this.sendError(o, r, l), this.client.logger.error(l);
      }
    }, this.addSessionRequestToSessionRequestQueue = (r) => {
      this.sessionRequestQueue.queue.push(r);
    }, this.cleanupAfterResponse = (r) => {
      this.deletePendingSessionRequest(r.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = xt.idle, this.processSessionRequestQueue();
      }, F.toMiliseconds(this.requestQueueDelay));
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === xt.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const r = this.sessionRequestQueue.queue[0];
      if (!r) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = xt.active, this.client.events.emit("session_request", r);
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.onPairingCreated = (r) => {
      if (r.active) return;
      const s = this.client.proposal.getAll().find((o) => o.pairingTopic === r.topic);
      s && this.onSessionProposeRequest(r.topic, xr("wc_sessionPropose", { requiredNamespaces: s.requiredNamespaces, optionalNamespaces: s.optionalNamespaces, relays: s.relays, proposer: s.proposer, sessionProperties: s.sessionProperties }, s.id));
    }, this.isValidConnect = async (r) => {
      if (!Le(r)) {
        const { message: w } = C("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(r)}`);
        throw new Error(w);
      }
      const { pairingTopic: s, requiredNamespaces: o, optionalNamespaces: u, sessionProperties: l, relays: g } = r;
      if (Ae(s) || await this.isValidPairingTopic(s), !G1(g)) {
        const { message: w } = C("MISSING_OR_INVALID", `connect() relays: ${g}`);
        throw new Error(w);
      }
      !Ae(o) && Fr(o) !== 0 && this.validateNamespaces(o, "requiredNamespaces"), !Ae(u) && Fr(u) !== 0 && this.validateNamespaces(u, "optionalNamespaces"), Ae(l) || this.validateSessionProps(l, "sessionProperties");
    }, this.validateNamespaces = (r, s) => {
      const o = W1(r, "connect()", s);
      if (o) throw new Error(o.message);
    }, this.isValidApprove = async (r) => {
      if (!Le(r)) throw new Error(C("MISSING_OR_INVALID", `approve() params: ${r}`).message);
      const { id: s, namespaces: o, relayProtocol: u, sessionProperties: l } = r;
      await this.isValidProposalId(s);
      const g = this.client.proposal.get(s), w = Ps(o, "approve()");
      if (w) throw new Error(w.message);
      const b = Ju(g.requiredNamespaces, o, "approve()");
      if (b) throw new Error(b.message);
      if (!be(u, !0)) {
        const { message: $ } = C("MISSING_OR_INVALID", `approve() relayProtocol: ${u}`);
        throw new Error($);
      }
      Ae(l) || this.validateSessionProps(l, "sessionProperties");
    }, this.isValidReject = async (r) => {
      if (!Le(r)) {
        const { message: u } = C("MISSING_OR_INVALID", `reject() params: ${r}`);
        throw new Error(u);
      }
      const { id: s, reason: o } = r;
      if (await this.isValidProposalId(s), !J1(o)) {
        const { message: u } = C("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(o)}`);
        throw new Error(u);
      }
    }, this.isValidSessionSettleRequest = (r) => {
      if (!Le(r)) {
        const { message: b } = C("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${r}`);
        throw new Error(b);
      }
      const { relay: s, controller: o, namespaces: u, expiry: l } = r;
      if (!al(s)) {
        const { message: b } = C("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(b);
      }
      const g = k1(o, "onSessionSettleRequest()");
      if (g) throw new Error(g.message);
      const w = Ps(u, "onSessionSettleRequest()");
      if (w) throw new Error(w.message);
      if (Wt(l)) {
        const { message: b } = C("EXPIRED", "onSessionSettleRequest()");
        throw new Error(b);
      }
    }, this.isValidUpdate = async (r) => {
      if (!Le(r)) {
        const { message: w } = C("MISSING_OR_INVALID", `update() params: ${r}`);
        throw new Error(w);
      }
      const { topic: s, namespaces: o } = r;
      await this.isValidSessionTopic(s);
      const u = this.client.session.get(s), l = Ps(o, "update()");
      if (l) throw new Error(l.message);
      const g = Ju(u.requiredNamespaces, o, "update()");
      if (g) throw new Error(g.message);
    }, this.isValidExtend = async (r) => {
      if (!Le(r)) {
        const { message: o } = C("MISSING_OR_INVALID", `extend() params: ${r}`);
        throw new Error(o);
      }
      const { topic: s } = r;
      await this.isValidSessionTopic(s);
    }, this.isValidRequest = async (r) => {
      if (!Le(r)) {
        const { message: w } = C("MISSING_OR_INVALID", `request() params: ${r}`);
        throw new Error(w);
      }
      const { topic: s, request: o, chainId: u, expiry: l } = r;
      await this.isValidSessionTopic(s);
      const { namespaces: g } = this.client.session.get(s);
      if (!Qu(g, u)) {
        const { message: w } = C("MISSING_OR_INVALID", `request() chainId: ${u}`);
        throw new Error(w);
      }
      if (!Y1(o)) {
        const { message: w } = C("MISSING_OR_INVALID", `request() ${JSON.stringify(o)}`);
        throw new Error(w);
      }
      if (!e0(g, u, o.method)) {
        const { message: w } = C("MISSING_OR_INVALID", `request() method: ${o.method}`);
        throw new Error(w);
      }
      if (l && !s0(l, fo)) {
        const { message: w } = C("MISSING_OR_INVALID", `request() expiry: ${l}. Expiry must be a number (in seconds) between ${fo.min} and ${fo.max}`);
        throw new Error(w);
      }
    }, this.isValidRespond = async (r) => {
      var s;
      if (!Le(r)) {
        const { message: l } = C("MISSING_OR_INVALID", `respond() params: ${r}`);
        throw new Error(l);
      }
      const { topic: o, response: u } = r;
      try {
        await this.isValidSessionTopic(o);
      } catch (l) {
        throw (s = r == null ? void 0 : r.response) != null && s.id && this.cleanupAfterResponse(r), l;
      }
      if (!Z1(u)) {
        const { message: l } = C("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(u)}`);
        throw new Error(l);
      }
    }, this.isValidPing = async (r) => {
      if (!Le(r)) {
        const { message: o } = C("MISSING_OR_INVALID", `ping() params: ${r}`);
        throw new Error(o);
      }
      const { topic: s } = r;
      await this.isValidSessionOrPairingTopic(s);
    }, this.isValidEmit = async (r) => {
      if (!Le(r)) {
        const { message: g } = C("MISSING_OR_INVALID", `emit() params: ${r}`);
        throw new Error(g);
      }
      const { topic: s, event: o, chainId: u } = r;
      await this.isValidSessionTopic(s);
      const { namespaces: l } = this.client.session.get(s);
      if (!Qu(l, u)) {
        const { message: g } = C("MISSING_OR_INVALID", `emit() chainId: ${u}`);
        throw new Error(g);
      }
      if (!X1(o)) {
        const { message: g } = C("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(o)}`);
        throw new Error(g);
      }
      if (!t0(l, u, o.name)) {
        const { message: g } = C("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(o)}`);
        throw new Error(g);
      }
    }, this.isValidDisconnect = async (r) => {
      if (!Le(r)) {
        const { message: o } = C("MISSING_OR_INVALID", `disconnect() params: ${r}`);
        throw new Error(o);
      }
      const { topic: s } = r;
      await this.isValidSessionOrPairingTopic(s);
    }, this.getVerifyContext = async (r, s) => {
      const o = { verified: { verifyUrl: s.verifyUrl || Ar, validation: "UNKNOWN", origin: s.url || "" } };
      try {
        const u = await this.client.core.verify.resolve({ attestationId: r, verifyUrl: s.verifyUrl });
        u && (o.verified.origin = u.origin, o.verified.isScam = u.isScam, o.verified.validation = u.origin === new URL(s.url).origin ? "VALID" : "INVALID");
      } catch (u) {
        this.client.logger.info(u);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(o)}`), o;
    }, this.validateSessionProps = (r, s) => {
      Object.values(r).forEach((o) => {
        if (!be(o, !1)) {
          const { message: u } = C("MISSING_OR_INVALID", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(o)}`);
          throw new Error(u);
        }
      });
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: t } = C("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(Re.message, async (t) => {
      const { topic: r, message: s } = t;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s))) return;
      const o = await this.client.core.crypto.decode(r, s);
      try {
        qo(o) ? (this.client.core.history.set(r, o), this.onRelayEventRequest({ topic: r, payload: o })) : Cs(o) ? (await this.client.core.history.resolve(o), await this.onRelayEventResponse({ topic: r, payload: o }), this.client.core.history.delete(r, o.id)) : this.onRelayEventUnknownPayload({ topic: r, payload: o });
      } catch (u) {
        this.client.logger.error(u);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(st.expired, async (t) => {
      const { topic: r, id: s } = nl(t.target);
      if (s && this.client.pendingRequest.keys.includes(s)) return await this.deletePendingSessionRequest(s, C("EXPIRED"), !0);
      r ? this.client.session.keys.includes(r) && (await this.deleteSession(r, !0), this.client.events.emit("session_expire", { topic: r })) : s && (await this.deleteProposal(s, !0), this.client.events.emit("proposal_expire", { id: s }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(mi.create, (t) => this.onPairingCreated(t));
  }
  isValidPairingTopic(t) {
    if (!be(t, !1)) {
      const { message: r } = C("MISSING_OR_INVALID", `pairing topic should be a string: ${t}`);
      throw new Error(r);
    }
    if (!this.client.core.pairing.pairings.keys.includes(t)) {
      const { message: r } = C("NO_MATCHING_KEY", `pairing topic doesn't exist: ${t}`);
      throw new Error(r);
    }
    if (Wt(this.client.core.pairing.pairings.get(t).expiry)) {
      const { message: r } = C("EXPIRED", `pairing topic: ${t}`);
      throw new Error(r);
    }
  }
  async isValidSessionTopic(t) {
    if (!be(t, !1)) {
      const { message: r } = C("MISSING_OR_INVALID", `session topic should be a string: ${t}`);
      throw new Error(r);
    }
    if (!this.client.session.keys.includes(t)) {
      const { message: r } = C("NO_MATCHING_KEY", `session topic doesn't exist: ${t}`);
      throw new Error(r);
    }
    if (Wt(this.client.session.get(t).expiry)) {
      await this.deleteSession(t);
      const { message: r } = C("EXPIRED", `session topic: ${t}`);
      throw new Error(r);
    }
  }
  async isValidSessionOrPairingTopic(t) {
    if (this.client.session.keys.includes(t)) await this.isValidSessionTopic(t);
    else if (this.client.core.pairing.pairings.keys.includes(t)) this.isValidPairingTopic(t);
    else if (be(t, !1)) {
      const { message: r } = C("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${t}`);
      throw new Error(r);
    } else {
      const { message: r } = C("MISSING_OR_INVALID", `session or pairing topic should be a string: ${t}`);
      throw new Error(r);
    }
  }
  async isValidProposalId(t) {
    if (!Q1(t)) {
      const { message: r } = C("MISSING_OR_INVALID", `proposal id should be a number: ${t}`);
      throw new Error(r);
    }
    if (!this.client.proposal.keys.includes(t)) {
      const { message: r } = C("NO_MATCHING_KEY", `proposal id doesn't exist: ${t}`);
      throw new Error(r);
    }
    if (Wt(this.client.proposal.get(t).expiry)) {
      await this.deleteProposal(t);
      const { message: r } = C("EXPIRED", `proposal id: ${t}`);
      throw new Error(r);
    }
  }
}
class sI extends qs {
  constructor(t, r) {
    super(t, r, WE, Wo), this.core = t, this.logger = r;
  }
}
class nI extends qs {
  constructor(t, r) {
    super(t, r, GE, Wo), this.core = t, this.logger = r;
  }
}
class oI extends qs {
  constructor(t, r) {
    super(t, r, JE, Wo, (s) => s.id), this.core = t, this.logger = r;
  }
}
let aI = class Rl extends x_ {
  constructor(t) {
    super(t), this.protocol = Il, this.version = Pl, this.name = po.name, this.events = new ot.EventEmitter(), this.on = (s, o) => this.events.on(s, o), this.once = (s, o) => this.events.once(s, o), this.off = (s, o) => this.events.off(s, o), this.removeListener = (s, o) => this.events.removeListener(s, o), this.removeAllListeners = (s) => this.events.removeAllListeners(s), this.connect = async (s) => {
      try {
        return await this.engine.connect(s);
      } catch (o) {
        throw this.logger.error(o.message), o;
      }
    }, this.pair = async (s) => {
      try {
        return await this.engine.pair(s);
      } catch (o) {
        throw this.logger.error(o.message), o;
      }
    }, this.approve = async (s) => {
      try {
        return await this.engine.approve(s);
      } catch (o) {
        throw this.logger.error(o.message), o;
      }
    }, this.reject = async (s) => {
      try {
        return await this.engine.reject(s);
      } catch (o) {
        throw this.logger.error(o.message), o;
      }
    }, this.update = async (s) => {
      try {
        return await this.engine.update(s);
      } catch (o) {
        throw this.logger.error(o.message), o;
      }
    }, this.extend = async (s) => {
      try {
        return await this.engine.extend(s);
      } catch (o) {
        throw this.logger.error(o.message), o;
      }
    }, this.request = async (s) => {
      try {
        return await this.engine.request(s);
      } catch (o) {
        throw this.logger.error(o.message), o;
      }
    }, this.respond = async (s) => {
      try {
        return await this.engine.respond(s);
      } catch (o) {
        throw this.logger.error(o.message), o;
      }
    }, this.ping = async (s) => {
      try {
        return await this.engine.ping(s);
      } catch (o) {
        throw this.logger.error(o.message), o;
      }
    }, this.emit = async (s) => {
      try {
        return await this.engine.emit(s);
      } catch (o) {
        throw this.logger.error(o.message), o;
      }
    }, this.disconnect = async (s) => {
      try {
        return await this.engine.disconnect(s);
      } catch (o) {
        throw this.logger.error(o.message), o;
      }
    }, this.find = (s) => {
      try {
        return this.engine.find(s);
      } catch (o) {
        throw this.logger.error(o.message), o;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.name = (t == null ? void 0 : t.name) || po.name, this.metadata = (t == null ? void 0 : t.metadata) || p1();
    const r = typeof (t == null ? void 0 : t.logger) < "u" && typeof (t == null ? void 0 : t.logger) != "string" ? t.logger : Ts(As({ level: (t == null ? void 0 : t.logger) || po.logger }));
    this.core = (t == null ? void 0 : t.core) || new BE(t), this.logger = ke(r, this.name), this.session = new nI(this.core, this.logger), this.proposal = new sI(this.core, this.logger), this.pendingRequest = new oI(this.core, this.logger), this.engine = new iI(this);
  }
  static async init(t) {
    const r = new Rl(t);
    return await r.initialize(), r;
  }
  get context() {
    return Qe(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (t) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
const cI = (a) => JSON.stringify(a, (t, r) => typeof r == "bigint" ? r.toString() + "n" : r), uI = (a) => {
  const t = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, r = a.replace(t, '$1"$2n"$3');
  return JSON.parse(r, (s, o) => typeof o == "string" && o.match(/^\d+n$/) ? BigInt(o.substring(0, o.length - 1)) : o);
};
function hI(a) {
  if (typeof a != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof a}`);
  try {
    return uI(a);
  } catch {
    return a;
  }
}
function Ih(a) {
  return typeof a == "string" ? a : cI(a) || "";
}
var lI = Object.defineProperty, pI = Object.defineProperties, fI = Object.getOwnPropertyDescriptors, Ph = Object.getOwnPropertySymbols, dI = Object.prototype.hasOwnProperty, gI = Object.prototype.propertyIsEnumerable, Sh = (a, t, r) => t in a ? lI(a, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : a[t] = r, Oh = (a, t) => {
  for (var r in t || (t = {})) dI.call(t, r) && Sh(a, r, t[r]);
  if (Ph) for (var r of Ph(t)) gI.call(t, r) && Sh(a, r, t[r]);
  return a;
}, Rh = (a, t) => pI(a, fI(t));
const yI = { Accept: "application/json", "Content-Type": "application/json" }, vI = "POST", $h = { headers: yI, method: vI }, Ch = 10;
let Jt = class {
  constructor(t, r = !1) {
    if (this.url = t, this.disableProviderPing = r, this.events = new ot.EventEmitter(), this.isAvailable = !1, this.registering = !1, !Au(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
    this.url = t, this.disableProviderPing = r;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(t, r) {
    this.events.on(t, r);
  }
  once(t, r) {
    this.events.once(t, r);
  }
  off(t, r) {
    this.events.off(t, r);
  }
  removeListener(t, r) {
    this.events.removeListener(t, r);
  }
  async open(t = this.url) {
    await this.register(t);
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose();
  }
  async send(t) {
    this.isAvailable || await this.register();
    try {
      const r = Ih(t), s = await (await $u(this.url, Rh(Oh({}, $h), { body: r }))).json();
      this.onPayload({ data: s });
    } catch (r) {
      this.onError(t.id, r);
    }
  }
  async register(t = this.url) {
    if (!Au(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((s, o) => {
        this.events.once("register_error", (u) => {
          this.resetMaxListeners(), o(u);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.isAvailable > "u") return o(new Error("HTTP connection is missing or invalid"));
          s();
        });
      });
    }
    this.url = t, this.registering = !0;
    try {
      if (!this.disableProviderPing) {
        const r = Ih({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await $u(t, Rh(Oh({}, $h), { body: r }));
      }
      this.onOpen();
    } catch (r) {
      const s = this.parseError(r);
      throw this.events.emit("register_error", s), this.onClose(), s;
    }
  }
  onOpen() {
    this.isAvailable = !0, this.registering = !1, this.events.emit("open");
  }
  onClose() {
    this.isAvailable = !1, this.registering = !1, this.events.emit("close");
  }
  onPayload(t) {
    if (typeof t.data > "u") return;
    const r = typeof t.data == "string" ? hI(t.data) : t.data;
    this.events.emit("payload", r);
  }
  onError(t, r) {
    const s = this.parseError(r), o = s.message || s.toString(), u = Ns(t, o);
    this.events.emit("payload", u);
  }
  parseError(t, r = this.url) {
    return Vh(t, r, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > Ch && this.events.setMaxListeners(Ch);
  }
};
const Nh = "error", mI = "wss://relay.walletconnect.com", wI = "wc", _I = "universal_provider", Th = `${wI}@2:${_I}:`, bI = "https://rpc.walletconnect.com/v1/", Ft = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var yi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof Z.global < "u" ? Z.global : typeof self < "u" ? self : {}, No = { exports: {} };
/**
* @license
* Lodash <https://lodash.com/>
* Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
* Released under MIT license <https://lodash.com/license>
* Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
* Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
*/
(function(a, t) {
  (function() {
    var r, s = "4.17.21", o = 200, u = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", l = "Expected a function", g = "Invalid `variable` option passed into `_.template`", w = "__lodash_hash_undefined__", b = 500, $ = "__lodash_placeholder__", S = 1, R = 2, q = 4, A = 1, V = 2, x = 1, G = 2, pe = 4, J = 8, X = 16, ue = 32, De = 64, fe = 128, $e = 256, qt = 512, Nl = 30, Tl = "...", Al = 800, xl = 16, Jo = 1, Dl = 2, Fl = 3, Si = 1 / 0, dr = 9007199254740991, ql = 17976931348623157e292, Oi = NaN, yt = 4294967295, jl = yt - 1, Ul = yt >>> 1, Ml = [["ary", fe], ["bind", x], ["bindKey", G], ["curry", J], ["curryRight", X], ["flip", qt], ["partial", ue], ["partialRight", De], ["rearg", $e]], gr = "[object Arguments]", Ri = "[object Array]", Ll = "[object AsyncFunction]", zr = "[object Boolean]", Hr = "[object Date]", kl = "[object DOMException]", $i = "[object Error]", Ci = "[object Function]", Yo = "[object GeneratorFunction]", at = "[object Map]", Vr = "[object Number]", zl = "[object Null]", Et = "[object Object]", Zo = "[object Promise]", Hl = "[object Proxy]", Kr = "[object RegExp]", ct = "[object Set]", Br = "[object String]", Ni = "[object Symbol]", Vl = "[object Undefined]", Wr = "[object WeakMap]", Kl = "[object WeakSet]", Gr = "[object ArrayBuffer]", yr = "[object DataView]", js = "[object Float32Array]", Us = "[object Float64Array]", Ms = "[object Int8Array]", Ls = "[object Int16Array]", ks = "[object Int32Array]", zs = "[object Uint8Array]", Hs = "[object Uint8ClampedArray]", Vs = "[object Uint16Array]", Ks = "[object Uint32Array]", Bl = /\b__p \+= '';/g, Wl = /\b(__p \+=) '' \+/g, Gl = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Xo = /&(?:amp|lt|gt|quot|#39);/g, ea = /[&<>"']/g, Ql = RegExp(Xo.source), Jl = RegExp(ea.source), Yl = /<%-([\s\S]+?)%>/g, Zl = /<%([\s\S]+?)%>/g, ta = /<%=([\s\S]+?)%>/g, Xl = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, ep = /^\w*$/, tp = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Bs = /[\\^$.*+?()[\]{}|]/g, rp = RegExp(Bs.source), Ws = /^\s+/, ip = /\s/, sp = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, np = /\{\n\/\* \[wrapped with (.+)\] \*/, op = /,? & /, ap = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, cp = /[()=,{}\[\]\/\s]/, up = /\\(\\)?/g, hp = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, ra = /\w*$/, lp = /^[-+]0x[0-9a-f]+$/i, pp = /^0b[01]+$/i, fp = /^\[object .+?Constructor\]$/, dp = /^0o[0-7]+$/i, gp = /^(?:0|[1-9]\d*)$/, yp = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ti = /($^)/, vp = /['\n\r\u2028\u2029\\]/g, Ai = "\\ud800-\\udfff", mp = "\\u0300-\\u036f", wp = "\\ufe20-\\ufe2f", _p = "\\u20d0-\\u20ff", ia = mp + wp + _p, sa = "\\u2700-\\u27bf", na = "a-z\\xdf-\\xf6\\xf8-\\xff", bp = "\\xac\\xb1\\xd7\\xf7", Ep = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Ip = "\\u2000-\\u206f", Pp = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", oa = "A-Z\\xc0-\\xd6\\xd8-\\xde", aa = "\\ufe0e\\ufe0f", ca = bp + Ep + Ip + Pp, Gs = "[']", Sp = "[" + Ai + "]", ua = "[" + ca + "]", xi = "[" + ia + "]", ha = "\\d+", Op = "[" + sa + "]", la = "[" + na + "]", pa = "[^" + Ai + ca + ha + sa + na + oa + "]", Qs = "\\ud83c[\\udffb-\\udfff]", Rp = "(?:" + xi + "|" + Qs + ")", fa = "[^" + Ai + "]", Js = "(?:\\ud83c[\\udde6-\\uddff]){2}", Ys = "[\\ud800-\\udbff][\\udc00-\\udfff]", vr = "[" + oa + "]", da = "\\u200d", ga = "(?:" + la + "|" + pa + ")", $p = "(?:" + vr + "|" + pa + ")", ya = "(?:" + Gs + "(?:d|ll|m|re|s|t|ve))?", va = "(?:" + Gs + "(?:D|LL|M|RE|S|T|VE))?", ma = Rp + "?", wa = "[" + aa + "]?", Cp = "(?:" + da + "(?:" + [fa, Js, Ys].join("|") + ")" + wa + ma + ")*", Np = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Tp = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", _a = wa + ma + Cp, Ap = "(?:" + [Op, Js, Ys].join("|") + ")" + _a, xp = "(?:" + [fa + xi + "?", xi, Js, Ys, Sp].join("|") + ")", Dp = RegExp(Gs, "g"), Fp = RegExp(xi, "g"), Zs = RegExp(Qs + "(?=" + Qs + ")|" + xp + _a, "g"), qp = RegExp([vr + "?" + la + "+" + ya + "(?=" + [ua, vr, "$"].join("|") + ")", $p + "+" + va + "(?=" + [ua, vr + ga, "$"].join("|") + ")", vr + "?" + ga + "+" + ya, vr + "+" + va, Tp, Np, ha, Ap].join("|"), "g"), jp = RegExp("[" + da + Ai + ia + aa + "]"), Up = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Mp = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], Lp = -1, oe = {};
    oe[js] = oe[Us] = oe[Ms] = oe[Ls] = oe[ks] = oe[zs] = oe[Hs] = oe[Vs] = oe[Ks] = !0, oe[gr] = oe[Ri] = oe[Gr] = oe[zr] = oe[yr] = oe[Hr] = oe[$i] = oe[Ci] = oe[at] = oe[Vr] = oe[Et] = oe[Kr] = oe[ct] = oe[Br] = oe[Wr] = !1;
    var ie = {};
    ie[gr] = ie[Ri] = ie[Gr] = ie[yr] = ie[zr] = ie[Hr] = ie[js] = ie[Us] = ie[Ms] = ie[Ls] = ie[ks] = ie[at] = ie[Vr] = ie[Et] = ie[Kr] = ie[ct] = ie[Br] = ie[Ni] = ie[zs] = ie[Hs] = ie[Vs] = ie[Ks] = !0, ie[$i] = ie[Ci] = ie[Wr] = !1;
    var kp = { : "A", : "A", : "A", : "A", : "A", : "A", : "a", : "a", : "a", : "a", : "a", : "a", : "C", : "c", : "D", : "d", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "N", : "n", : "O", : "O", : "O", : "O", : "O", : "O", : "o", : "o", : "o", : "o", : "o", : "o", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "Y", : "y", : "y", : "Ae", : "ae", : "Th", : "th", : "ss", : "A", : "A", : "A", : "a", : "a", : "a", : "C", : "C", : "C", : "C", : "c", : "c", : "c", : "c", : "D", : "D", : "d", : "d", : "E", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "e", : "G", : "G", : "G", : "G", : "g", : "g", : "g", : "g", : "H", : "H", : "h", : "h", : "I", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "i", : "J", : "j", : "K", : "k", : "k", : "L", : "L", : "L", : "L", : "L", : "l", : "l", : "l", : "l", : "l", : "N", : "N", : "N", : "N", : "n", : "n", : "n", : "n", : "O", : "O", : "O", : "o", : "o", : "o", : "R", : "R", : "R", : "r", : "r", : "r", : "S", : "S", : "S", : "S", : "s", : "s", : "s", : "s", : "T", : "T", : "T", : "t", : "t", : "t", : "U", : "U", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "u", : "u", : "W", : "w", : "Y", : "y", : "Y", : "Z", : "Z", : "Z", : "z", : "z", : "z", : "IJ", : "ij", : "Oe", : "oe", : "'n", : "s" }, zp = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, Hp = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, Vp = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, Kp = parseFloat, Bp = parseInt, ba = typeof yi == "object" && yi && yi.Object === Object && yi, Wp = typeof self == "object" && self && self.Object === Object && self, Ee = ba || Wp || Function("return this")(), Xs = t && !t.nodeType && t, Yt = Xs && !0 && a && !a.nodeType && a, Ea = Yt && Yt.exports === Xs, en = Ea && ba.process, Je = function() {
      try {
        var v = Yt && Yt.require && Yt.require("util").types;
        return v || en && en.binding && en.binding("util");
      } catch {
      }
    }(), Ia = Je && Je.isArrayBuffer, Pa = Je && Je.isDate, Sa = Je && Je.isMap, Oa = Je && Je.isRegExp, Ra = Je && Je.isSet, $a = Je && Je.isTypedArray;
    function ze(v, E, _) {
      switch (_.length) {
        case 0:
          return v.call(E);
        case 1:
          return v.call(E, _[0]);
        case 2:
          return v.call(E, _[0], _[1]);
        case 3:
          return v.call(E, _[0], _[1], _[2]);
      }
      return v.apply(E, _);
    }
    function Gp(v, E, _, T) {
      for (var L = -1, Y = v == null ? 0 : v.length; ++L < Y; ) {
        var me = v[L];
        E(T, me, _(me), v);
      }
      return T;
    }
    function Ye(v, E) {
      for (var _ = -1, T = v == null ? 0 : v.length; ++_ < T && E(v[_], _, v) !== !1; ) ;
      return v;
    }
    function Qp(v, E) {
      for (var _ = v == null ? 0 : v.length; _-- && E(v[_], _, v) !== !1; ) ;
      return v;
    }
    function Ca(v, E) {
      for (var _ = -1, T = v == null ? 0 : v.length; ++_ < T; ) if (!E(v[_], _, v)) return !1;
      return !0;
    }
    function jt(v, E) {
      for (var _ = -1, T = v == null ? 0 : v.length, L = 0, Y = []; ++_ < T; ) {
        var me = v[_];
        E(me, _, v) && (Y[L++] = me);
      }
      return Y;
    }
    function Di(v, E) {
      var _ = v == null ? 0 : v.length;
      return !!_ && mr(v, E, 0) > -1;
    }
    function tn(v, E, _) {
      for (var T = -1, L = v == null ? 0 : v.length; ++T < L; ) if (_(E, v[T])) return !0;
      return !1;
    }
    function ae(v, E) {
      for (var _ = -1, T = v == null ? 0 : v.length, L = Array(T); ++_ < T; ) L[_] = E(v[_], _, v);
      return L;
    }
    function Ut(v, E) {
      for (var _ = -1, T = E.length, L = v.length; ++_ < T; ) v[L + _] = E[_];
      return v;
    }
    function rn(v, E, _, T) {
      var L = -1, Y = v == null ? 0 : v.length;
      for (T && Y && (_ = v[++L]); ++L < Y; ) _ = E(_, v[L], L, v);
      return _;
    }
    function Jp(v, E, _, T) {
      var L = v == null ? 0 : v.length;
      for (T && L && (_ = v[--L]); L--; ) _ = E(_, v[L], L, v);
      return _;
    }
    function sn(v, E) {
      for (var _ = -1, T = v == null ? 0 : v.length; ++_ < T; ) if (E(v[_], _, v)) return !0;
      return !1;
    }
    var Yp = nn("length");
    function Zp(v) {
      return v.split("");
    }
    function Xp(v) {
      return v.match(ap) || [];
    }
    function Na(v, E, _) {
      var T;
      return _(v, function(L, Y, me) {
        if (E(L, Y, me)) return T = Y, !1;
      }), T;
    }
    function Fi(v, E, _, T) {
      for (var L = v.length, Y = _ + (T ? 1 : -1); T ? Y-- : ++Y < L; ) if (E(v[Y], Y, v)) return Y;
      return -1;
    }
    function mr(v, E, _) {
      return E === E ? pf(v, E, _) : Fi(v, Ta, _);
    }
    function ef(v, E, _, T) {
      for (var L = _ - 1, Y = v.length; ++L < Y; ) if (T(v[L], E)) return L;
      return -1;
    }
    function Ta(v) {
      return v !== v;
    }
    function Aa(v, E) {
      var _ = v == null ? 0 : v.length;
      return _ ? an(v, E) / _ : Oi;
    }
    function nn(v) {
      return function(E) {
        return E == null ? r : E[v];
      };
    }
    function on(v) {
      return function(E) {
        return v == null ? r : v[E];
      };
    }
    function xa(v, E, _, T, L) {
      return L(v, function(Y, me, re) {
        _ = T ? (T = !1, Y) : E(_, Y, me, re);
      }), _;
    }
    function tf(v, E) {
      var _ = v.length;
      for (v.sort(E); _--; ) v[_] = v[_].value;
      return v;
    }
    function an(v, E) {
      for (var _, T = -1, L = v.length; ++T < L; ) {
        var Y = E(v[T]);
        Y !== r && (_ = _ === r ? Y : _ + Y);
      }
      return _;
    }
    function cn(v, E) {
      for (var _ = -1, T = Array(v); ++_ < v; ) T[_] = E(_);
      return T;
    }
    function rf(v, E) {
      return ae(E, function(_) {
        return [_, v[_]];
      });
    }
    function Da(v) {
      return v && v.slice(0, Ua(v) + 1).replace(Ws, "");
    }
    function He(v) {
      return function(E) {
        return v(E);
      };
    }
    function un(v, E) {
      return ae(E, function(_) {
        return v[_];
      });
    }
    function Qr(v, E) {
      return v.has(E);
    }
    function Fa(v, E) {
      for (var _ = -1, T = v.length; ++_ < T && mr(E, v[_], 0) > -1; ) ;
      return _;
    }
    function qa(v, E) {
      for (var _ = v.length; _-- && mr(E, v[_], 0) > -1; ) ;
      return _;
    }
    function sf(v, E) {
      for (var _ = v.length, T = 0; _--; ) v[_] === E && ++T;
      return T;
    }
    var nf = on(kp), of = on(zp);
    function af(v) {
      return "\\" + Vp[v];
    }
    function cf(v, E) {
      return v == null ? r : v[E];
    }
    function wr(v) {
      return jp.test(v);
    }
    function uf(v) {
      return Up.test(v);
    }
    function hf(v) {
      for (var E, _ = []; !(E = v.next()).done; ) _.push(E.value);
      return _;
    }
    function hn(v) {
      var E = -1, _ = Array(v.size);
      return v.forEach(function(T, L) {
        _[++E] = [L, T];
      }), _;
    }
    function ja(v, E) {
      return function(_) {
        return v(E(_));
      };
    }
    function Mt(v, E) {
      for (var _ = -1, T = v.length, L = 0, Y = []; ++_ < T; ) {
        var me = v[_];
        (me === E || me === $) && (v[_] = $, Y[L++] = _);
      }
      return Y;
    }
    function qi(v) {
      var E = -1, _ = Array(v.size);
      return v.forEach(function(T) {
        _[++E] = T;
      }), _;
    }
    function lf(v) {
      var E = -1, _ = Array(v.size);
      return v.forEach(function(T) {
        _[++E] = [T, T];
      }), _;
    }
    function pf(v, E, _) {
      for (var T = _ - 1, L = v.length; ++T < L; ) if (v[T] === E) return T;
      return -1;
    }
    function ff(v, E, _) {
      for (var T = _ + 1; T--; ) if (v[T] === E) return T;
      return T;
    }
    function _r(v) {
      return wr(v) ? gf(v) : Yp(v);
    }
    function ut(v) {
      return wr(v) ? yf(v) : Zp(v);
    }
    function Ua(v) {
      for (var E = v.length; E-- && ip.test(v.charAt(E)); ) ;
      return E;
    }
    var df = on(Hp);
    function gf(v) {
      for (var E = Zs.lastIndex = 0; Zs.test(v); ) ++E;
      return E;
    }
    function yf(v) {
      return v.match(Zs) || [];
    }
    function vf(v) {
      return v.match(qp) || [];
    }
    var mf = function v(E) {
      E = E == null ? Ee : br.defaults(Ee.Object(), E, br.pick(Ee, Mp));
      var _ = E.Array, T = E.Date, L = E.Error, Y = E.Function, me = E.Math, re = E.Object, ln = E.RegExp, wf = E.String, Ze = E.TypeError, ji = _.prototype, _f = Y.prototype, Er = re.prototype, Ui = E["__core-js_shared__"], Mi = _f.toString, te = Er.hasOwnProperty, bf = 0, Ma = function() {
        var e = /[^.]+$/.exec(Ui && Ui.keys && Ui.keys.IE_PROTO || "");
        return e ? "Symbol(src)_1." + e : "";
      }(), Li = Er.toString, Ef = Mi.call(re), If = Ee._, Pf = ln("^" + Mi.call(te).replace(Bs, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), ki = Ea ? E.Buffer : r, Lt = E.Symbol, zi = E.Uint8Array, La = ki ? ki.allocUnsafe : r, Hi = ja(re.getPrototypeOf, re), ka = re.create, za = Er.propertyIsEnumerable, Vi = ji.splice, Ha = Lt ? Lt.isConcatSpreadable : r, Jr = Lt ? Lt.iterator : r, Zt = Lt ? Lt.toStringTag : r, Ki = function() {
        try {
          var e = ir(re, "defineProperty");
          return e({}, "", {}), e;
        } catch {
        }
      }(), Sf = E.clearTimeout !== Ee.clearTimeout && E.clearTimeout, Of = T && T.now !== Ee.Date.now && T.now, Rf = E.setTimeout !== Ee.setTimeout && E.setTimeout, Bi = me.ceil, Wi = me.floor, pn = re.getOwnPropertySymbols, $f = ki ? ki.isBuffer : r, Va = E.isFinite, Cf = ji.join, Nf = ja(re.keys, re), we = me.max, Se = me.min, Tf = T.now, Af = E.parseInt, Ka = me.random, xf = ji.reverse, fn = ir(E, "DataView"), Yr = ir(E, "Map"), dn = ir(E, "Promise"), Ir = ir(E, "Set"), Zr = ir(E, "WeakMap"), Xr = ir(re, "create"), Gi = Zr && new Zr(), Pr = {}, Df = sr(fn), Ff = sr(Yr), qf = sr(dn), jf = sr(Ir), Uf = sr(Zr), Qi = Lt ? Lt.prototype : r, ei = Qi ? Qi.valueOf : r, Ba = Qi ? Qi.toString : r;
      function p(e) {
        if (le(e) && !k(e) && !(e instanceof W)) {
          if (e instanceof Xe) return e;
          if (te.call(e, "__wrapped__")) return Wc(e);
        }
        return new Xe(e);
      }
      var Sr = /* @__PURE__ */ function() {
        function e() {
        }
        return function(i) {
          if (!he(i)) return {};
          if (ka) return ka(i);
          e.prototype = i;
          var n = new e();
          return e.prototype = r, n;
        };
      }();
      function Ji() {
      }
      function Xe(e, i) {
        this.__wrapped__ = e, this.__actions__ = [], this.__chain__ = !!i, this.__index__ = 0, this.__values__ = r;
      }
      p.templateSettings = { escape: Yl, evaluate: Zl, interpolate: ta, variable: "", imports: { _: p } }, p.prototype = Ji.prototype, p.prototype.constructor = p, Xe.prototype = Sr(Ji.prototype), Xe.prototype.constructor = Xe;
      function W(e) {
        this.__wrapped__ = e, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = yt, this.__views__ = [];
      }
      function Mf() {
        var e = new W(this.__wrapped__);
        return e.__actions__ = Fe(this.__actions__), e.__dir__ = this.__dir__, e.__filtered__ = this.__filtered__, e.__iteratees__ = Fe(this.__iteratees__), e.__takeCount__ = this.__takeCount__, e.__views__ = Fe(this.__views__), e;
      }
      function Lf() {
        if (this.__filtered__) {
          var e = new W(this);
          e.__dir__ = -1, e.__filtered__ = !0;
        } else e = this.clone(), e.__dir__ *= -1;
        return e;
      }
      function kf() {
        var e = this.__wrapped__.value(), i = this.__dir__, n = k(e), c = i < 0, h = n ? e.length : 0, f = Xd(0, h, this.__views__), d = f.start, y = f.end, m = y - d, I = c ? y : d - 1, P = this.__iteratees__, O = P.length, N = 0, D = Se(m, this.__takeCount__);
        if (!n || !c && h == m && D == m) return yc(e, this.__actions__);
        var U = [];
        e: for (; m-- && N < D; ) {
          I += i;
          for (var H = -1, M = e[I]; ++H < O; ) {
            var B = P[H], Q = B.iteratee, Be = B.type, Te = Q(M);
            if (Be == Dl) M = Te;
            else if (!Te) {
              if (Be == Jo) continue e;
              break e;
            }
          }
          U[N++] = M;
        }
        return U;
      }
      W.prototype = Sr(Ji.prototype), W.prototype.constructor = W;
      function Xt(e) {
        var i = -1, n = e == null ? 0 : e.length;
        for (this.clear(); ++i < n; ) {
          var c = e[i];
          this.set(c[0], c[1]);
        }
      }
      function zf() {
        this.__data__ = Xr ? Xr(null) : {}, this.size = 0;
      }
      function Hf(e) {
        var i = this.has(e) && delete this.__data__[e];
        return this.size -= i ? 1 : 0, i;
      }
      function Vf(e) {
        var i = this.__data__;
        if (Xr) {
          var n = i[e];
          return n === w ? r : n;
        }
        return te.call(i, e) ? i[e] : r;
      }
      function Kf(e) {
        var i = this.__data__;
        return Xr ? i[e] !== r : te.call(i, e);
      }
      function Bf(e, i) {
        var n = this.__data__;
        return this.size += this.has(e) ? 0 : 1, n[e] = Xr && i === r ? w : i, this;
      }
      Xt.prototype.clear = zf, Xt.prototype.delete = Hf, Xt.prototype.get = Vf, Xt.prototype.has = Kf, Xt.prototype.set = Bf;
      function It(e) {
        var i = -1, n = e == null ? 0 : e.length;
        for (this.clear(); ++i < n; ) {
          var c = e[i];
          this.set(c[0], c[1]);
        }
      }
      function Wf() {
        this.__data__ = [], this.size = 0;
      }
      function Gf(e) {
        var i = this.__data__, n = Yi(i, e);
        if (n < 0) return !1;
        var c = i.length - 1;
        return n == c ? i.pop() : Vi.call(i, n, 1), --this.size, !0;
      }
      function Qf(e) {
        var i = this.__data__, n = Yi(i, e);
        return n < 0 ? r : i[n][1];
      }
      function Jf(e) {
        return Yi(this.__data__, e) > -1;
      }
      function Yf(e, i) {
        var n = this.__data__, c = Yi(n, e);
        return c < 0 ? (++this.size, n.push([e, i])) : n[c][1] = i, this;
      }
      It.prototype.clear = Wf, It.prototype.delete = Gf, It.prototype.get = Qf, It.prototype.has = Jf, It.prototype.set = Yf;
      function Pt(e) {
        var i = -1, n = e == null ? 0 : e.length;
        for (this.clear(); ++i < n; ) {
          var c = e[i];
          this.set(c[0], c[1]);
        }
      }
      function Zf() {
        this.size = 0, this.__data__ = { hash: new Xt(), map: new (Yr || It)(), string: new Xt() };
      }
      function Xf(e) {
        var i = us(this, e).delete(e);
        return this.size -= i ? 1 : 0, i;
      }
      function ed(e) {
        return us(this, e).get(e);
      }
      function td(e) {
        return us(this, e).has(e);
      }
      function rd(e, i) {
        var n = us(this, e), c = n.size;
        return n.set(e, i), this.size += n.size == c ? 0 : 1, this;
      }
      Pt.prototype.clear = Zf, Pt.prototype.delete = Xf, Pt.prototype.get = ed, Pt.prototype.has = td, Pt.prototype.set = rd;
      function er(e) {
        var i = -1, n = e == null ? 0 : e.length;
        for (this.__data__ = new Pt(); ++i < n; ) this.add(e[i]);
      }
      function id(e) {
        return this.__data__.set(e, w), this;
      }
      function sd(e) {
        return this.__data__.has(e);
      }
      er.prototype.add = er.prototype.push = id, er.prototype.has = sd;
      function ht(e) {
        var i = this.__data__ = new It(e);
        this.size = i.size;
      }
      function nd() {
        this.__data__ = new It(), this.size = 0;
      }
      function od(e) {
        var i = this.__data__, n = i.delete(e);
        return this.size = i.size, n;
      }
      function ad(e) {
        return this.__data__.get(e);
      }
      function cd(e) {
        return this.__data__.has(e);
      }
      function ud(e, i) {
        var n = this.__data__;
        if (n instanceof It) {
          var c = n.__data__;
          if (!Yr || c.length < o - 1) return c.push([e, i]), this.size = ++n.size, this;
          n = this.__data__ = new Pt(c);
        }
        return n.set(e, i), this.size = n.size, this;
      }
      ht.prototype.clear = nd, ht.prototype.delete = od, ht.prototype.get = ad, ht.prototype.has = cd, ht.prototype.set = ud;
      function Wa(e, i) {
        var n = k(e), c = !n && nr(e), h = !n && !c && Kt(e), f = !n && !c && !h && Cr(e), d = n || c || h || f, y = d ? cn(e.length, wf) : [], m = y.length;
        for (var I in e) (i || te.call(e, I)) && !(d && (I == "length" || h && (I == "offset" || I == "parent") || f && (I == "buffer" || I == "byteLength" || I == "byteOffset") || $t(I, m))) && y.push(I);
        return y;
      }
      function Ga(e) {
        var i = e.length;
        return i ? e[Sn(0, i - 1)] : r;
      }
      function hd(e, i) {
        return hs(Fe(e), tr(i, 0, e.length));
      }
      function ld(e) {
        return hs(Fe(e));
      }
      function gn(e, i, n) {
        (n !== r && !lt(e[i], n) || n === r && !(i in e)) && St(e, i, n);
      }
      function ti(e, i, n) {
        var c = e[i];
        (!(te.call(e, i) && lt(c, n)) || n === r && !(i in e)) && St(e, i, n);
      }
      function Yi(e, i) {
        for (var n = e.length; n--; ) if (lt(e[n][0], i)) return n;
        return -1;
      }
      function pd(e, i, n, c) {
        return kt(e, function(h, f, d) {
          i(c, h, n(h), d);
        }), c;
      }
      function Qa(e, i) {
        return e && mt(i, _e(i), e);
      }
      function fd(e, i) {
        return e && mt(i, je(i), e);
      }
      function St(e, i, n) {
        i == "__proto__" && Ki ? Ki(e, i, { configurable: !0, enumerable: !0, value: n, writable: !0 }) : e[i] = n;
      }
      function yn(e, i) {
        for (var n = -1, c = i.length, h = _(c), f = e == null; ++n < c; ) h[n] = f ? r : Jn(e, i[n]);
        return h;
      }
      function tr(e, i, n) {
        return e === e && (n !== r && (e = e <= n ? e : n), i !== r && (e = e >= i ? e : i)), e;
      }
      function et(e, i, n, c, h, f) {
        var d, y = i & S, m = i & R, I = i & q;
        if (n && (d = h ? n(e, c, h, f) : n(e)), d !== r) return d;
        if (!he(e)) return e;
        var P = k(e);
        if (P) {
          if (d = tg(e), !y) return Fe(e, d);
        } else {
          var O = Oe(e), N = O == Ci || O == Yo;
          if (Kt(e)) return wc(e, y);
          if (O == Et || O == gr || N && !h) {
            if (d = m || N ? {} : Uc(e), !y) return m ? Vd(e, fd(d, e)) : Hd(e, Qa(d, e));
          } else {
            if (!ie[O]) return h ? e : {};
            d = rg(e, O, y);
          }
        }
        f || (f = new ht());
        var D = f.get(e);
        if (D) return D;
        f.set(e, d), fu(e) ? e.forEach(function(M) {
          d.add(et(M, i, n, M, e, f));
        }) : lu(e) && e.forEach(function(M, B) {
          d.set(B, et(M, i, n, B, e, f));
        });
        var U = I ? m ? qn : Fn : m ? je : _e, H = P ? r : U(e);
        return Ye(H || e, function(M, B) {
          H && (B = M, M = e[B]), ti(d, B, et(M, i, n, B, e, f));
        }), d;
      }
      function dd(e) {
        var i = _e(e);
        return function(n) {
          return Ja(n, e, i);
        };
      }
      function Ja(e, i, n) {
        var c = n.length;
        if (e == null) return !c;
        for (e = re(e); c--; ) {
          var h = n[c], f = i[h], d = e[h];
          if (d === r && !(h in e) || !f(d)) return !1;
        }
        return !0;
      }
      function Ya(e, i, n) {
        if (typeof e != "function") throw new Ze(l);
        return ci(function() {
          e.apply(r, n);
        }, i);
      }
      function ri(e, i, n, c) {
        var h = -1, f = Di, d = !0, y = e.length, m = [], I = i.length;
        if (!y) return m;
        n && (i = ae(i, He(n))), c ? (f = tn, d = !1) : i.length >= o && (f = Qr, d = !1, i = new er(i));
        e: for (; ++h < y; ) {
          var P = e[h], O = n == null ? P : n(P);
          if (P = c || P !== 0 ? P : 0, d && O === O) {
            for (var N = I; N--; ) if (i[N] === O) continue e;
            m.push(P);
          } else f(i, O, c) || m.push(P);
        }
        return m;
      }
      var kt = Pc(vt), Za = Pc(mn, !0);
      function gd(e, i) {
        var n = !0;
        return kt(e, function(c, h, f) {
          return n = !!i(c, h, f), n;
        }), n;
      }
      function Zi(e, i, n) {
        for (var c = -1, h = e.length; ++c < h; ) {
          var f = e[c], d = i(f);
          if (d != null && (y === r ? d === d && !Ke(d) : n(d, y))) var y = d, m = f;
        }
        return m;
      }
      function yd(e, i, n, c) {
        var h = e.length;
        for (n = z(n), n < 0 && (n = -n > h ? 0 : h + n), c = c === r || c > h ? h : z(c), c < 0 && (c += h), c = n > c ? 0 : gu(c); n < c; ) e[n++] = i;
        return e;
      }
      function Xa(e, i) {
        var n = [];
        return kt(e, function(c, h, f) {
          i(c, h, f) && n.push(c);
        }), n;
      }
      function Ie(e, i, n, c, h) {
        var f = -1, d = e.length;
        for (n || (n = sg), h || (h = []); ++f < d; ) {
          var y = e[f];
          i > 0 && n(y) ? i > 1 ? Ie(y, i - 1, n, c, h) : Ut(h, y) : c || (h[h.length] = y);
        }
        return h;
      }
      var vn = Sc(), ec = Sc(!0);
      function vt(e, i) {
        return e && vn(e, i, _e);
      }
      function mn(e, i) {
        return e && ec(e, i, _e);
      }
      function Xi(e, i) {
        return jt(i, function(n) {
          return Ct(e[n]);
        });
      }
      function rr(e, i) {
        i = Ht(i, e);
        for (var n = 0, c = i.length; e != null && n < c; ) e = e[wt(i[n++])];
        return n && n == c ? e : r;
      }
      function tc(e, i, n) {
        var c = i(e);
        return k(e) ? c : Ut(c, n(e));
      }
      function Ce(e) {
        return e == null ? e === r ? Vl : zl : Zt && Zt in re(e) ? Zd(e) : lg(e);
      }
      function wn(e, i) {
        return e > i;
      }
      function vd(e, i) {
        return e != null && te.call(e, i);
      }
      function md(e, i) {
        return e != null && i in re(e);
      }
      function wd(e, i, n) {
        return e >= Se(i, n) && e < we(i, n);
      }
      function _n(e, i, n) {
        for (var c = n ? tn : Di, h = e[0].length, f = e.length, d = f, y = _(f), m = 1 / 0, I = []; d--; ) {
          var P = e[d];
          d && i && (P = ae(P, He(i))), m = Se(P.length, m), y[d] = !n && (i || h >= 120 && P.length >= 120) ? new er(d && P) : r;
        }
        P = e[0];
        var O = -1, N = y[0];
        e: for (; ++O < h && I.length < m; ) {
          var D = P[O], U = i ? i(D) : D;
          if (D = n || D !== 0 ? D : 0, !(N ? Qr(N, U) : c(I, U, n))) {
            for (d = f; --d; ) {
              var H = y[d];
              if (!(H ? Qr(H, U) : c(e[d], U, n))) continue e;
            }
            N && N.push(U), I.push(D);
          }
        }
        return I;
      }
      function _d(e, i, n, c) {
        return vt(e, function(h, f, d) {
          i(c, n(h), f, d);
        }), c;
      }
      function ii(e, i, n) {
        i = Ht(i, e), e = zc(e, i);
        var c = e == null ? e : e[wt(rt(i))];
        return c == null ? r : ze(c, e, n);
      }
      function rc(e) {
        return le(e) && Ce(e) == gr;
      }
      function bd(e) {
        return le(e) && Ce(e) == Gr;
      }
      function Ed(e) {
        return le(e) && Ce(e) == Hr;
      }
      function si(e, i, n, c, h) {
        return e === i ? !0 : e == null || i == null || !le(e) && !le(i) ? e !== e && i !== i : Id(e, i, n, c, si, h);
      }
      function Id(e, i, n, c, h, f) {
        var d = k(e), y = k(i), m = d ? Ri : Oe(e), I = y ? Ri : Oe(i);
        m = m == gr ? Et : m, I = I == gr ? Et : I;
        var P = m == Et, O = I == Et, N = m == I;
        if (N && Kt(e)) {
          if (!Kt(i)) return !1;
          d = !0, P = !1;
        }
        if (N && !P) return f || (f = new ht()), d || Cr(e) ? Fc(e, i, n, c, h, f) : Jd(e, i, m, n, c, h, f);
        if (!(n & A)) {
          var D = P && te.call(e, "__wrapped__"), U = O && te.call(i, "__wrapped__");
          if (D || U) {
            var H = D ? e.value() : e, M = U ? i.value() : i;
            return f || (f = new ht()), h(H, M, n, c, f);
          }
        }
        return N ? (f || (f = new ht()), Yd(e, i, n, c, h, f)) : !1;
      }
      function Pd(e) {
        return le(e) && Oe(e) == at;
      }
      function bn(e, i, n, c) {
        var h = n.length, f = h, d = !c;
        if (e == null) return !f;
        for (e = re(e); h--; ) {
          var y = n[h];
          if (d && y[2] ? y[1] !== e[y[0]] : !(y[0] in e)) return !1;
        }
        for (; ++h < f; ) {
          y = n[h];
          var m = y[0], I = e[m], P = y[1];
          if (d && y[2]) {
            if (I === r && !(m in e)) return !1;
          } else {
            var O = new ht();
            if (c) var N = c(I, P, m, e, i, O);
            if (!(N === r ? si(P, I, A | V, c, O) : N)) return !1;
          }
        }
        return !0;
      }
      function ic(e) {
        if (!he(e) || og(e)) return !1;
        var i = Ct(e) ? Pf : fp;
        return i.test(sr(e));
      }
      function Sd(e) {
        return le(e) && Ce(e) == Kr;
      }
      function Od(e) {
        return le(e) && Oe(e) == ct;
      }
      function Rd(e) {
        return le(e) && ys(e.length) && !!oe[Ce(e)];
      }
      function sc(e) {
        return typeof e == "function" ? e : e == null ? Ue : typeof e == "object" ? k(e) ? ac(e[0], e[1]) : oc(e) : Ou(e);
      }
      function En(e) {
        if (!ai(e)) return Nf(e);
        var i = [];
        for (var n in re(e)) te.call(e, n) && n != "constructor" && i.push(n);
        return i;
      }
      function $d(e) {
        if (!he(e)) return hg(e);
        var i = ai(e), n = [];
        for (var c in e) c == "constructor" && (i || !te.call(e, c)) || n.push(c);
        return n;
      }
      function In(e, i) {
        return e < i;
      }
      function nc(e, i) {
        var n = -1, c = qe(e) ? _(e.length) : [];
        return kt(e, function(h, f, d) {
          c[++n] = i(h, f, d);
        }), c;
      }
      function oc(e) {
        var i = Un(e);
        return i.length == 1 && i[0][2] ? Lc(i[0][0], i[0][1]) : function(n) {
          return n === e || bn(n, e, i);
        };
      }
      function ac(e, i) {
        return Ln(e) && Mc(i) ? Lc(wt(e), i) : function(n) {
          var c = Jn(n, e);
          return c === r && c === i ? Yn(n, e) : si(i, c, A | V);
        };
      }
      function es(e, i, n, c, h) {
        e !== i && vn(i, function(f, d) {
          if (h || (h = new ht()), he(f)) Cd(e, i, d, n, es, c, h);
          else {
            var y = c ? c(zn(e, d), f, d + "", e, i, h) : r;
            y === r && (y = f), gn(e, d, y);
          }
        }, je);
      }
      function Cd(e, i, n, c, h, f, d) {
        var y = zn(e, n), m = zn(i, n), I = d.get(m);
        if (I) {
          gn(e, n, I);
          return;
        }
        var P = f ? f(y, m, n + "", e, i, d) : r, O = P === r;
        if (O) {
          var N = k(m), D = !N && Kt(m), U = !N && !D && Cr(m);
          P = m, N || D || U ? k(y) ? P = y : de(y) ? P = Fe(y) : D ? (O = !1, P = wc(m, !0)) : U ? (O = !1, P = _c(m, !0)) : P = [] : ui(m) || nr(m) ? (P = y, nr(y) ? P = yu(y) : (!he(y) || Ct(y)) && (P = Uc(m))) : O = !1;
        }
        O && (d.set(m, P), h(P, m, c, f, d), d.delete(m)), gn(e, n, P);
      }
      function cc(e, i) {
        var n = e.length;
        if (n) return i += i < 0 ? n : 0, $t(i, n) ? e[i] : r;
      }
      function uc(e, i, n) {
        i.length ? i = ae(i, function(f) {
          return k(f) ? function(d) {
            return rr(d, f.length === 1 ? f[0] : f);
          } : f;
        }) : i = [Ue];
        var c = -1;
        i = ae(i, He(j()));
        var h = nc(e, function(f, d, y) {
          var m = ae(i, function(I) {
            return I(f);
          });
          return { criteria: m, index: ++c, value: f };
        });
        return tf(h, function(f, d) {
          return zd(f, d, n);
        });
      }
      function Nd(e, i) {
        return hc(e, i, function(n, c) {
          return Yn(e, c);
        });
      }
      function hc(e, i, n) {
        for (var c = -1, h = i.length, f = {}; ++c < h; ) {
          var d = i[c], y = rr(e, d);
          n(y, d) && ni(f, Ht(d, e), y);
        }
        return f;
      }
      function Td(e) {
        return function(i) {
          return rr(i, e);
        };
      }
      function Pn(e, i, n, c) {
        var h = c ? ef : mr, f = -1, d = i.length, y = e;
        for (e === i && (i = Fe(i)), n && (y = ae(e, He(n))); ++f < d; ) for (var m = 0, I = i[f], P = n ? n(I) : I; (m = h(y, P, m, c)) > -1; ) y !== e && Vi.call(y, m, 1), Vi.call(e, m, 1);
        return e;
      }
      function lc(e, i) {
        for (var n = e ? i.length : 0, c = n - 1; n--; ) {
          var h = i[n];
          if (n == c || h !== f) {
            var f = h;
            $t(h) ? Vi.call(e, h, 1) : $n(e, h);
          }
        }
        return e;
      }
      function Sn(e, i) {
        return e + Wi(Ka() * (i - e + 1));
      }
      function Ad(e, i, n, c) {
        for (var h = -1, f = we(Bi((i - e) / (n || 1)), 0), d = _(f); f--; ) d[c ? f : ++h] = e, e += n;
        return d;
      }
      function On(e, i) {
        var n = "";
        if (!e || i < 1 || i > dr) return n;
        do
          i % 2 && (n += e), i = Wi(i / 2), i && (e += e);
        while (i);
        return n;
      }
      function K(e, i) {
        return Hn(kc(e, i, Ue), e + "");
      }
      function xd(e) {
        return Ga(Nr(e));
      }
      function Dd(e, i) {
        var n = Nr(e);
        return hs(n, tr(i, 0, n.length));
      }
      function ni(e, i, n, c) {
        if (!he(e)) return e;
        i = Ht(i, e);
        for (var h = -1, f = i.length, d = f - 1, y = e; y != null && ++h < f; ) {
          var m = wt(i[h]), I = n;
          if (m === "__proto__" || m === "constructor" || m === "prototype") return e;
          if (h != d) {
            var P = y[m];
            I = c ? c(P, m, y) : r, I === r && (I = he(P) ? P : $t(i[h + 1]) ? [] : {});
          }
          ti(y, m, I), y = y[m];
        }
        return e;
      }
      var pc = Gi ? function(e, i) {
        return Gi.set(e, i), e;
      } : Ue, Fd = Ki ? function(e, i) {
        return Ki(e, "toString", { configurable: !0, enumerable: !1, value: Xn(i), writable: !0 });
      } : Ue;
      function qd(e) {
        return hs(Nr(e));
      }
      function tt(e, i, n) {
        var c = -1, h = e.length;
        i < 0 && (i = -i > h ? 0 : h + i), n = n > h ? h : n, n < 0 && (n += h), h = i > n ? 0 : n - i >>> 0, i >>>= 0;
        for (var f = _(h); ++c < h; ) f[c] = e[c + i];
        return f;
      }
      function jd(e, i) {
        var n;
        return kt(e, function(c, h, f) {
          return n = i(c, h, f), !n;
        }), !!n;
      }
      function ts(e, i, n) {
        var c = 0, h = e == null ? c : e.length;
        if (typeof i == "number" && i === i && h <= Ul) {
          for (; c < h; ) {
            var f = c + h >>> 1, d = e[f];
            d !== null && !Ke(d) && (n ? d <= i : d < i) ? c = f + 1 : h = f;
          }
          return h;
        }
        return Rn(e, i, Ue, n);
      }
      function Rn(e, i, n, c) {
        var h = 0, f = e == null ? 0 : e.length;
        if (f === 0) return 0;
        i = n(i);
        for (var d = i !== i, y = i === null, m = Ke(i), I = i === r; h < f; ) {
          var P = Wi((h + f) / 2), O = n(e[P]), N = O !== r, D = O === null, U = O === O, H = Ke(O);
          if (d) var M = c || U;
          else I ? M = U && (c || N) : y ? M = U && N && (c || !D) : m ? M = U && N && !D && (c || !H) : D || H ? M = !1 : M = c ? O <= i : O < i;
          M ? h = P + 1 : f = P;
        }
        return Se(f, jl);
      }
      function fc(e, i) {
        for (var n = -1, c = e.length, h = 0, f = []; ++n < c; ) {
          var d = e[n], y = i ? i(d) : d;
          if (!n || !lt(y, m)) {
            var m = y;
            f[h++] = d === 0 ? 0 : d;
          }
        }
        return f;
      }
      function dc(e) {
        return typeof e == "number" ? e : Ke(e) ? Oi : +e;
      }
      function Ve(e) {
        if (typeof e == "string") return e;
        if (k(e)) return ae(e, Ve) + "";
        if (Ke(e)) return Ba ? Ba.call(e) : "";
        var i = e + "";
        return i == "0" && 1 / e == -1 / 0 ? "-0" : i;
      }
      function zt(e, i, n) {
        var c = -1, h = Di, f = e.length, d = !0, y = [], m = y;
        if (n) d = !1, h = tn;
        else if (f >= o) {
          var I = i ? null : Gd(e);
          if (I) return qi(I);
          d = !1, h = Qr, m = new er();
        } else m = i ? [] : y;
        e: for (; ++c < f; ) {
          var P = e[c], O = i ? i(P) : P;
          if (P = n || P !== 0 ? P : 0, d && O === O) {
            for (var N = m.length; N--; ) if (m[N] === O) continue e;
            i && m.push(O), y.push(P);
          } else h(m, O, n) || (m !== y && m.push(O), y.push(P));
        }
        return y;
      }
      function $n(e, i) {
        return i = Ht(i, e), e = zc(e, i), e == null || delete e[wt(rt(i))];
      }
      function gc(e, i, n, c) {
        return ni(e, i, n(rr(e, i)), c);
      }
      function rs(e, i, n, c) {
        for (var h = e.length, f = c ? h : -1; (c ? f-- : ++f < h) && i(e[f], f, e); ) ;
        return n ? tt(e, c ? 0 : f, c ? f + 1 : h) : tt(e, c ? f + 1 : 0, c ? h : f);
      }
      function yc(e, i) {
        var n = e;
        return n instanceof W && (n = n.value()), rn(i, function(c, h) {
          return h.func.apply(h.thisArg, Ut([c], h.args));
        }, n);
      }
      function Cn(e, i, n) {
        var c = e.length;
        if (c < 2) return c ? zt(e[0]) : [];
        for (var h = -1, f = _(c); ++h < c; ) for (var d = e[h], y = -1; ++y < c; ) y != h && (f[h] = ri(f[h] || d, e[y], i, n));
        return zt(Ie(f, 1), i, n);
      }
      function vc(e, i, n) {
        for (var c = -1, h = e.length, f = i.length, d = {}; ++c < h; ) {
          var y = c < f ? i[c] : r;
          n(d, e[c], y);
        }
        return d;
      }
      function Nn(e) {
        return de(e) ? e : [];
      }
      function Tn(e) {
        return typeof e == "function" ? e : Ue;
      }
      function Ht(e, i) {
        return k(e) ? e : Ln(e, i) ? [e] : Bc(ee(e));
      }
      var Ud = K;
      function Vt(e, i, n) {
        var c = e.length;
        return n = n === r ? c : n, !i && n >= c ? e : tt(e, i, n);
      }
      var mc = Sf || function(e) {
        return Ee.clearTimeout(e);
      };
      function wc(e, i) {
        if (i) return e.slice();
        var n = e.length, c = La ? La(n) : new e.constructor(n);
        return e.copy(c), c;
      }
      function An(e) {
        var i = new e.constructor(e.byteLength);
        return new zi(i).set(new zi(e)), i;
      }
      function Md(e, i) {
        var n = i ? An(e.buffer) : e.buffer;
        return new e.constructor(n, e.byteOffset, e.byteLength);
      }
      function Ld(e) {
        var i = new e.constructor(e.source, ra.exec(e));
        return i.lastIndex = e.lastIndex, i;
      }
      function kd(e) {
        return ei ? re(ei.call(e)) : {};
      }
      function _c(e, i) {
        var n = i ? An(e.buffer) : e.buffer;
        return new e.constructor(n, e.byteOffset, e.length);
      }
      function bc(e, i) {
        if (e !== i) {
          var n = e !== r, c = e === null, h = e === e, f = Ke(e), d = i !== r, y = i === null, m = i === i, I = Ke(i);
          if (!y && !I && !f && e > i || f && d && m && !y && !I || c && d && m || !n && m || !h) return 1;
          if (!c && !f && !I && e < i || I && n && h && !c && !f || y && n && h || !d && h || !m) return -1;
        }
        return 0;
      }
      function zd(e, i, n) {
        for (var c = -1, h = e.criteria, f = i.criteria, d = h.length, y = n.length; ++c < d; ) {
          var m = bc(h[c], f[c]);
          if (m) {
            if (c >= y) return m;
            var I = n[c];
            return m * (I == "desc" ? -1 : 1);
          }
        }
        return e.index - i.index;
      }
      function Ec(e, i, n, c) {
        for (var h = -1, f = e.length, d = n.length, y = -1, m = i.length, I = we(f - d, 0), P = _(m + I), O = !c; ++y < m; ) P[y] = i[y];
        for (; ++h < d; ) (O || h < f) && (P[n[h]] = e[h]);
        for (; I--; ) P[y++] = e[h++];
        return P;
      }
      function Ic(e, i, n, c) {
        for (var h = -1, f = e.length, d = -1, y = n.length, m = -1, I = i.length, P = we(f - y, 0), O = _(P + I), N = !c; ++h < P; ) O[h] = e[h];
        for (var D = h; ++m < I; ) O[D + m] = i[m];
        for (; ++d < y; ) (N || h < f) && (O[D + n[d]] = e[h++]);
        return O;
      }
      function Fe(e, i) {
        var n = -1, c = e.length;
        for (i || (i = _(c)); ++n < c; ) i[n] = e[n];
        return i;
      }
      function mt(e, i, n, c) {
        var h = !n;
        n || (n = {});
        for (var f = -1, d = i.length; ++f < d; ) {
          var y = i[f], m = c ? c(n[y], e[y], y, n, e) : r;
          m === r && (m = e[y]), h ? St(n, y, m) : ti(n, y, m);
        }
        return n;
      }
      function Hd(e, i) {
        return mt(e, Mn(e), i);
      }
      function Vd(e, i) {
        return mt(e, qc(e), i);
      }
      function is(e, i) {
        return function(n, c) {
          var h = k(n) ? Gp : pd, f = i ? i() : {};
          return h(n, e, j(c, 2), f);
        };
      }
      function Or(e) {
        return K(function(i, n) {
          var c = -1, h = n.length, f = h > 1 ? n[h - 1] : r, d = h > 2 ? n[2] : r;
          for (f = e.length > 3 && typeof f == "function" ? (h--, f) : r, d && Ne(n[0], n[1], d) && (f = h < 3 ? r : f, h = 1), i = re(i); ++c < h; ) {
            var y = n[c];
            y && e(i, y, c, f);
          }
          return i;
        });
      }
      function Pc(e, i) {
        return function(n, c) {
          if (n == null) return n;
          if (!qe(n)) return e(n, c);
          for (var h = n.length, f = i ? h : -1, d = re(n); (i ? f-- : ++f < h) && c(d[f], f, d) !== !1; ) ;
          return n;
        };
      }
      function Sc(e) {
        return function(i, n, c) {
          for (var h = -1, f = re(i), d = c(i), y = d.length; y--; ) {
            var m = d[e ? y : ++h];
            if (n(f[m], m, f) === !1) break;
          }
          return i;
        };
      }
      function Kd(e, i, n) {
        var c = i & x, h = oi(e);
        function f() {
          var d = this && this !== Ee && this instanceof f ? h : e;
          return d.apply(c ? n : this, arguments);
        }
        return f;
      }
      function Oc(e) {
        return function(i) {
          i = ee(i);
          var n = wr(i) ? ut(i) : r, c = n ? n[0] : i.charAt(0), h = n ? Vt(n, 1).join("") : i.slice(1);
          return c[e]() + h;
        };
      }
      function Rr(e) {
        return function(i) {
          return rn(Pu(Iu(i).replace(Dp, "")), e, "");
        };
      }
      function oi(e) {
        return function() {
          var i = arguments;
          switch (i.length) {
            case 0:
              return new e();
            case 1:
              return new e(i[0]);
            case 2:
              return new e(i[0], i[1]);
            case 3:
              return new e(i[0], i[1], i[2]);
            case 4:
              return new e(i[0], i[1], i[2], i[3]);
            case 5:
              return new e(i[0], i[1], i[2], i[3], i[4]);
            case 6:
              return new e(i[0], i[1], i[2], i[3], i[4], i[5]);
            case 7:
              return new e(i[0], i[1], i[2], i[3], i[4], i[5], i[6]);
          }
          var n = Sr(e.prototype), c = e.apply(n, i);
          return he(c) ? c : n;
        };
      }
      function Bd(e, i, n) {
        var c = oi(e);
        function h() {
          for (var f = arguments.length, d = _(f), y = f, m = $r(h); y--; ) d[y] = arguments[y];
          var I = f < 3 && d[0] !== m && d[f - 1] !== m ? [] : Mt(d, m);
          if (f -= I.length, f < n) return Tc(e, i, ss, h.placeholder, r, d, I, r, r, n - f);
          var P = this && this !== Ee && this instanceof h ? c : e;
          return ze(P, this, d);
        }
        return h;
      }
      function Rc(e) {
        return function(i, n, c) {
          var h = re(i);
          if (!qe(i)) {
            var f = j(n, 3);
            i = _e(i), n = function(y) {
              return f(h[y], y, h);
            };
          }
          var d = e(i, n, c);
          return d > -1 ? h[f ? i[d] : d] : r;
        };
      }
      function $c(e) {
        return Rt(function(i) {
          var n = i.length, c = n, h = Xe.prototype.thru;
          for (e && i.reverse(); c--; ) {
            var f = i[c];
            if (typeof f != "function") throw new Ze(l);
            if (h && !d && cs(f) == "wrapper") var d = new Xe([], !0);
          }
          for (c = d ? c : n; ++c < n; ) {
            f = i[c];
            var y = cs(f), m = y == "wrapper" ? jn(f) : r;
            m && kn(m[0]) && m[1] == (fe | J | ue | $e) && !m[4].length && m[9] == 1 ? d = d[cs(m[0])].apply(d, m[3]) : d = f.length == 1 && kn(f) ? d[y]() : d.thru(f);
          }
          return function() {
            var I = arguments, P = I[0];
            if (d && I.length == 1 && k(P)) return d.plant(P).value();
            for (var O = 0, N = n ? i[O].apply(this, I) : P; ++O < n; ) N = i[O].call(this, N);
            return N;
          };
        });
      }
      function ss(e, i, n, c, h, f, d, y, m, I) {
        var P = i & fe, O = i & x, N = i & G, D = i & (J | X), U = i & qt, H = N ? r : oi(e);
        function M() {
          for (var B = arguments.length, Q = _(B), Be = B; Be--; ) Q[Be] = arguments[Be];
          if (D) var Te = $r(M), We = sf(Q, Te);
          if (c && (Q = Ec(Q, c, h, D)), f && (Q = Ic(Q, f, d, D)), B -= We, D && B < I) {
            var ge = Mt(Q, Te);
            return Tc(e, i, ss, M.placeholder, n, Q, ge, y, m, I - B);
          }
          var pt = O ? n : this, Tt = N ? pt[e] : e;
          return B = Q.length, y ? Q = pg(Q, y) : U && B > 1 && Q.reverse(), P && m < B && (Q.length = m), this && this !== Ee && this instanceof M && (Tt = H || oi(Tt)), Tt.apply(pt, Q);
        }
        return M;
      }
      function Cc(e, i) {
        return function(n, c) {
          return _d(n, e, i(c), {});
        };
      }
      function ns(e, i) {
        return function(n, c) {
          var h;
          if (n === r && c === r) return i;
          if (n !== r && (h = n), c !== r) {
            if (h === r) return c;
            typeof n == "string" || typeof c == "string" ? (n = Ve(n), c = Ve(c)) : (n = dc(n), c = dc(c)), h = e(n, c);
          }
          return h;
        };
      }
      function xn(e) {
        return Rt(function(i) {
          return i = ae(i, He(j())), K(function(n) {
            var c = this;
            return e(i, function(h) {
              return ze(h, c, n);
            });
          });
        });
      }
      function os(e, i) {
        i = i === r ? " " : Ve(i);
        var n = i.length;
        if (n < 2) return n ? On(i, e) : i;
        var c = On(i, Bi(e / _r(i)));
        return wr(i) ? Vt(ut(c), 0, e).join("") : c.slice(0, e);
      }
      function Wd(e, i, n, c) {
        var h = i & x, f = oi(e);
        function d() {
          for (var y = -1, m = arguments.length, I = -1, P = c.length, O = _(P + m), N = this && this !== Ee && this instanceof d ? f : e; ++I < P; ) O[I] = c[I];
          for (; m--; ) O[I++] = arguments[++y];
          return ze(N, h ? n : this, O);
        }
        return d;
      }
      function Nc(e) {
        return function(i, n, c) {
          return c && typeof c != "number" && Ne(i, n, c) && (n = c = r), i = Nt(i), n === r ? (n = i, i = 0) : n = Nt(n), c = c === r ? i < n ? 1 : -1 : Nt(c), Ad(i, n, c, e);
        };
      }
      function as(e) {
        return function(i, n) {
          return typeof i == "string" && typeof n == "string" || (i = it(i), n = it(n)), e(i, n);
        };
      }
      function Tc(e, i, n, c, h, f, d, y, m, I) {
        var P = i & J, O = P ? d : r, N = P ? r : d, D = P ? f : r, U = P ? r : f;
        i |= P ? ue : De, i &= ~(P ? De : ue), i & pe || (i &= -4);
        var H = [e, i, h, D, O, U, N, y, m, I], M = n.apply(r, H);
        return kn(e) && Hc(M, H), M.placeholder = c, Vc(M, e, i);
      }
      function Dn(e) {
        var i = me[e];
        return function(n, c) {
          if (n = it(n), c = c == null ? 0 : Se(z(c), 292), c && Va(n)) {
            var h = (ee(n) + "e").split("e"), f = i(h[0] + "e" + (+h[1] + c));
            return h = (ee(f) + "e").split("e"), +(h[0] + "e" + (+h[1] - c));
          }
          return i(n);
        };
      }
      var Gd = Ir && 1 / qi(new Ir([, -0]))[1] == Si ? function(e) {
        return new Ir(e);
      } : ro;
      function Ac(e) {
        return function(i) {
          var n = Oe(i);
          return n == at ? hn(i) : n == ct ? lf(i) : rf(i, e(i));
        };
      }
      function Ot(e, i, n, c, h, f, d, y) {
        var m = i & G;
        if (!m && typeof e != "function") throw new Ze(l);
        var I = c ? c.length : 0;
        if (I || (i &= -97, c = h = r), d = d === r ? d : we(z(d), 0), y = y === r ? y : z(y), I -= h ? h.length : 0, i & De) {
          var P = c, O = h;
          c = h = r;
        }
        var N = m ? r : jn(e), D = [e, i, n, c, h, P, O, f, d, y];
        if (N && ug(D, N), e = D[0], i = D[1], n = D[2], c = D[3], h = D[4], y = D[9] = D[9] === r ? m ? 0 : e.length : we(D[9] - I, 0), !y && i & (J | X) && (i &= -25), !i || i == x) var U = Kd(e, i, n);
        else i == J || i == X ? U = Bd(e, i, y) : (i == ue || i == (x | ue)) && !h.length ? U = Wd(e, i, n, c) : U = ss.apply(r, D);
        var H = N ? pc : Hc;
        return Vc(H(U, D), e, i);
      }
      function xc(e, i, n, c) {
        return e === r || lt(e, Er[n]) && !te.call(c, n) ? i : e;
      }
      function Dc(e, i, n, c, h, f) {
        return he(e) && he(i) && (f.set(i, e), es(e, i, r, Dc, f), f.delete(i)), e;
      }
      function Qd(e) {
        return ui(e) ? r : e;
      }
      function Fc(e, i, n, c, h, f) {
        var d = n & A, y = e.length, m = i.length;
        if (y != m && !(d && m > y)) return !1;
        var I = f.get(e), P = f.get(i);
        if (I && P) return I == i && P == e;
        var O = -1, N = !0, D = n & V ? new er() : r;
        for (f.set(e, i), f.set(i, e); ++O < y; ) {
          var U = e[O], H = i[O];
          if (c) var M = d ? c(H, U, O, i, e, f) : c(U, H, O, e, i, f);
          if (M !== r) {
            if (M) continue;
            N = !1;
            break;
          }
          if (D) {
            if (!sn(i, function(B, Q) {
              if (!Qr(D, Q) && (U === B || h(U, B, n, c, f))) return D.push(Q);
            })) {
              N = !1;
              break;
            }
          } else if (!(U === H || h(U, H, n, c, f))) {
            N = !1;
            break;
          }
        }
        return f.delete(e), f.delete(i), N;
      }
      function Jd(e, i, n, c, h, f, d) {
        switch (n) {
          case yr:
            if (e.byteLength != i.byteLength || e.byteOffset != i.byteOffset) return !1;
            e = e.buffer, i = i.buffer;
          case Gr:
            return !(e.byteLength != i.byteLength || !f(new zi(e), new zi(i)));
          case zr:
          case Hr:
          case Vr:
            return lt(+e, +i);
          case $i:
            return e.name == i.name && e.message == i.message;
          case Kr:
          case Br:
            return e == i + "";
          case at:
            var y = hn;
          case ct:
            var m = c & A;
            if (y || (y = qi), e.size != i.size && !m) return !1;
            var I = d.get(e);
            if (I) return I == i;
            c |= V, d.set(e, i);
            var P = Fc(y(e), y(i), c, h, f, d);
            return d.delete(e), P;
          case Ni:
            if (ei) return ei.call(e) == ei.call(i);
        }
        return !1;
      }
      function Yd(e, i, n, c, h, f) {
        var d = n & A, y = Fn(e), m = y.length, I = Fn(i), P = I.length;
        if (m != P && !d) return !1;
        for (var O = m; O--; ) {
          var N = y[O];
          if (!(d ? N in i : te.call(i, N))) return !1;
        }
        var D = f.get(e), U = f.get(i);
        if (D && U) return D == i && U == e;
        var H = !0;
        f.set(e, i), f.set(i, e);
        for (var M = d; ++O < m; ) {
          N = y[O];
          var B = e[N], Q = i[N];
          if (c) var Be = d ? c(Q, B, N, i, e, f) : c(B, Q, N, e, i, f);
          if (!(Be === r ? B === Q || h(B, Q, n, c, f) : Be)) {
            H = !1;
            break;
          }
          M || (M = N == "constructor");
        }
        if (H && !M) {
          var Te = e.constructor, We = i.constructor;
          Te != We && "constructor" in e && "constructor" in i && !(typeof Te == "function" && Te instanceof Te && typeof We == "function" && We instanceof We) && (H = !1);
        }
        return f.delete(e), f.delete(i), H;
      }
      function Rt(e) {
        return Hn(kc(e, r, Jc), e + "");
      }
      function Fn(e) {
        return tc(e, _e, Mn);
      }
      function qn(e) {
        return tc(e, je, qc);
      }
      var jn = Gi ? function(e) {
        return Gi.get(e);
      } : ro;
      function cs(e) {
        for (var i = e.name + "", n = Pr[i], c = te.call(Pr, i) ? n.length : 0; c--; ) {
          var h = n[c], f = h.func;
          if (f == null || f == e) return h.name;
        }
        return i;
      }
      function $r(e) {
        var i = te.call(p, "placeholder") ? p : e;
        return i.placeholder;
      }
      function j() {
        var e = p.iteratee || eo;
        return e = e === eo ? sc : e, arguments.length ? e(arguments[0], arguments[1]) : e;
      }
      function us(e, i) {
        var n = e.__data__;
        return ng(i) ? n[typeof i == "string" ? "string" : "hash"] : n.map;
      }
      function Un(e) {
        for (var i = _e(e), n = i.length; n--; ) {
          var c = i[n], h = e[c];
          i[n] = [c, h, Mc(h)];
        }
        return i;
      }
      function ir(e, i) {
        var n = cf(e, i);
        return ic(n) ? n : r;
      }
      function Zd(e) {
        var i = te.call(e, Zt), n = e[Zt];
        try {
          e[Zt] = r;
          var c = !0;
        } catch {
        }
        var h = Li.call(e);
        return c && (i ? e[Zt] = n : delete e[Zt]), h;
      }
      var Mn = pn ? function(e) {
        return e == null ? [] : (e = re(e), jt(pn(e), function(i) {
          return za.call(e, i);
        }));
      } : io, qc = pn ? function(e) {
        for (var i = []; e; ) Ut(i, Mn(e)), e = Hi(e);
        return i;
      } : io, Oe = Ce;
      (fn && Oe(new fn(new ArrayBuffer(1))) != yr || Yr && Oe(new Yr()) != at || dn && Oe(dn.resolve()) != Zo || Ir && Oe(new Ir()) != ct || Zr && Oe(new Zr()) != Wr) && (Oe = function(e) {
        var i = Ce(e), n = i == Et ? e.constructor : r, c = n ? sr(n) : "";
        if (c) switch (c) {
          case Df:
            return yr;
          case Ff:
            return at;
          case qf:
            return Zo;
          case jf:
            return ct;
          case Uf:
            return Wr;
        }
        return i;
      });
      function Xd(e, i, n) {
        for (var c = -1, h = n.length; ++c < h; ) {
          var f = n[c], d = f.size;
          switch (f.type) {
            case "drop":
              e += d;
              break;
            case "dropRight":
              i -= d;
              break;
            case "take":
              i = Se(i, e + d);
              break;
            case "takeRight":
              e = we(e, i - d);
              break;
          }
        }
        return { start: e, end: i };
      }
      function eg(e) {
        var i = e.match(np);
        return i ? i[1].split(op) : [];
      }
      function jc(e, i, n) {
        i = Ht(i, e);
        for (var c = -1, h = i.length, f = !1; ++c < h; ) {
          var d = wt(i[c]);
          if (!(f = e != null && n(e, d))) break;
          e = e[d];
        }
        return f || ++c != h ? f : (h = e == null ? 0 : e.length, !!h && ys(h) && $t(d, h) && (k(e) || nr(e)));
      }
      function tg(e) {
        var i = e.length, n = new e.constructor(i);
        return i && typeof e[0] == "string" && te.call(e, "index") && (n.index = e.index, n.input = e.input), n;
      }
      function Uc(e) {
        return typeof e.constructor == "function" && !ai(e) ? Sr(Hi(e)) : {};
      }
      function rg(e, i, n) {
        var c = e.constructor;
        switch (i) {
          case Gr:
            return An(e);
          case zr:
          case Hr:
            return new c(+e);
          case yr:
            return Md(e, n);
          case js:
          case Us:
          case Ms:
          case Ls:
          case ks:
          case zs:
          case Hs:
          case Vs:
          case Ks:
            return _c(e, n);
          case at:
            return new c();
          case Vr:
          case Br:
            return new c(e);
          case Kr:
            return Ld(e);
          case ct:
            return new c();
          case Ni:
            return kd(e);
        }
      }
      function ig(e, i) {
        var n = i.length;
        if (!n) return e;
        var c = n - 1;
        return i[c] = (n > 1 ? "& " : "") + i[c], i = i.join(n > 2 ? ", " : " "), e.replace(sp, `{
/* [wrapped with ` + i + `] */
`);
      }
      function sg(e) {
        return k(e) || nr(e) || !!(Ha && e && e[Ha]);
      }
      function $t(e, i) {
        var n = typeof e;
        return i = i ?? dr, !!i && (n == "number" || n != "symbol" && gp.test(e)) && e > -1 && e % 1 == 0 && e < i;
      }
      function Ne(e, i, n) {
        if (!he(n)) return !1;
        var c = typeof i;
        return (c == "number" ? qe(n) && $t(i, n.length) : c == "string" && i in n) ? lt(n[i], e) : !1;
      }
      function Ln(e, i) {
        if (k(e)) return !1;
        var n = typeof e;
        return n == "number" || n == "symbol" || n == "boolean" || e == null || Ke(e) ? !0 : ep.test(e) || !Xl.test(e) || i != null && e in re(i);
      }
      function ng(e) {
        var i = typeof e;
        return i == "string" || i == "number" || i == "symbol" || i == "boolean" ? e !== "__proto__" : e === null;
      }
      function kn(e) {
        var i = cs(e), n = p[i];
        if (typeof n != "function" || !(i in W.prototype)) return !1;
        if (e === n) return !0;
        var c = jn(n);
        return !!c && e === c[0];
      }
      function og(e) {
        return !!Ma && Ma in e;
      }
      var ag = Ui ? Ct : so;
      function ai(e) {
        var i = e && e.constructor, n = typeof i == "function" && i.prototype || Er;
        return e === n;
      }
      function Mc(e) {
        return e === e && !he(e);
      }
      function Lc(e, i) {
        return function(n) {
          return n == null ? !1 : n[e] === i && (i !== r || e in re(n));
        };
      }
      function cg(e) {
        var i = ds(e, function(c) {
          return n.size === b && n.clear(), c;
        }), n = i.cache;
        return i;
      }
      function ug(e, i) {
        var n = e[1], c = i[1], h = n | c, f = h < (x | G | fe), d = c == fe && n == J || c == fe && n == $e && e[7].length <= i[8] || c == (fe | $e) && i[7].length <= i[8] && n == J;
        if (!(f || d)) return e;
        c & x && (e[2] = i[2], h |= n & x ? 0 : pe);
        var y = i[3];
        if (y) {
          var m = e[3];
          e[3] = m ? Ec(m, y, i[4]) : y, e[4] = m ? Mt(e[3], $) : i[4];
        }
        return y = i[5], y && (m = e[5], e[5] = m ? Ic(m, y, i[6]) : y, e[6] = m ? Mt(e[5], $) : i[6]), y = i[7], y && (e[7] = y), c & fe && (e[8] = e[8] == null ? i[8] : Se(e[8], i[8])), e[9] == null && (e[9] = i[9]), e[0] = i[0], e[1] = h, e;
      }
      function hg(e) {
        var i = [];
        if (e != null) for (var n in re(e)) i.push(n);
        return i;
      }
      function lg(e) {
        return Li.call(e);
      }
      function kc(e, i, n) {
        return i = we(i === r ? e.length - 1 : i, 0), function() {
          for (var c = arguments, h = -1, f = we(c.length - i, 0), d = _(f); ++h < f; ) d[h] = c[i + h];
          h = -1;
          for (var y = _(i + 1); ++h < i; ) y[h] = c[h];
          return y[i] = n(d), ze(e, this, y);
        };
      }
      function zc(e, i) {
        return i.length < 2 ? e : rr(e, tt(i, 0, -1));
      }
      function pg(e, i) {
        for (var n = e.length, c = Se(i.length, n), h = Fe(e); c--; ) {
          var f = i[c];
          e[c] = $t(f, n) ? h[f] : r;
        }
        return e;
      }
      function zn(e, i) {
        if (!(i === "constructor" && typeof e[i] == "function") && i != "__proto__") return e[i];
      }
      var Hc = Kc(pc), ci = Rf || function(e, i) {
        return Ee.setTimeout(e, i);
      }, Hn = Kc(Fd);
      function Vc(e, i, n) {
        var c = i + "";
        return Hn(e, ig(c, fg(eg(c), n)));
      }
      function Kc(e) {
        var i = 0, n = 0;
        return function() {
          var c = Tf(), h = xl - (c - n);
          if (n = c, h > 0) {
            if (++i >= Al) return arguments[0];
          } else i = 0;
          return e.apply(r, arguments);
        };
      }
      function hs(e, i) {
        var n = -1, c = e.length, h = c - 1;
        for (i = i === r ? c : i; ++n < i; ) {
          var f = Sn(n, h), d = e[f];
          e[f] = e[n], e[n] = d;
        }
        return e.length = i, e;
      }
      var Bc = cg(function(e) {
        var i = [];
        return e.charCodeAt(0) === 46 && i.push(""), e.replace(tp, function(n, c, h, f) {
          i.push(h ? f.replace(up, "$1") : c || n);
        }), i;
      });
      function wt(e) {
        if (typeof e == "string" || Ke(e)) return e;
        var i = e + "";
        return i == "0" && 1 / e == -1 / 0 ? "-0" : i;
      }
      function sr(e) {
        if (e != null) {
          try {
            return Mi.call(e);
          } catch {
          }
          try {
            return e + "";
          } catch {
          }
        }
        return "";
      }
      function fg(e, i) {
        return Ye(Ml, function(n) {
          var c = "_." + n[0];
          i & n[1] && !Di(e, c) && e.push(c);
        }), e.sort();
      }
      function Wc(e) {
        if (e instanceof W) return e.clone();
        var i = new Xe(e.__wrapped__, e.__chain__);
        return i.__actions__ = Fe(e.__actions__), i.__index__ = e.__index__, i.__values__ = e.__values__, i;
      }
      function dg(e, i, n) {
        (n ? Ne(e, i, n) : i === r) ? i = 1 : i = we(z(i), 0);
        var c = e == null ? 0 : e.length;
        if (!c || i < 1) return [];
        for (var h = 0, f = 0, d = _(Bi(c / i)); h < c; ) d[f++] = tt(e, h, h += i);
        return d;
      }
      function gg(e) {
        for (var i = -1, n = e == null ? 0 : e.length, c = 0, h = []; ++i < n; ) {
          var f = e[i];
          f && (h[c++] = f);
        }
        return h;
      }
      function yg() {
        var e = arguments.length;
        if (!e) return [];
        for (var i = _(e - 1), n = arguments[0], c = e; c--; ) i[c - 1] = arguments[c];
        return Ut(k(n) ? Fe(n) : [n], Ie(i, 1));
      }
      var vg = K(function(e, i) {
        return de(e) ? ri(e, Ie(i, 1, de, !0)) : [];
      }), mg = K(function(e, i) {
        var n = rt(i);
        return de(n) && (n = r), de(e) ? ri(e, Ie(i, 1, de, !0), j(n, 2)) : [];
      }), wg = K(function(e, i) {
        var n = rt(i);
        return de(n) && (n = r), de(e) ? ri(e, Ie(i, 1, de, !0), r, n) : [];
      });
      function _g(e, i, n) {
        var c = e == null ? 0 : e.length;
        return c ? (i = n || i === r ? 1 : z(i), tt(e, i < 0 ? 0 : i, c)) : [];
      }
      function bg(e, i, n) {
        var c = e == null ? 0 : e.length;
        return c ? (i = n || i === r ? 1 : z(i), i = c - i, tt(e, 0, i < 0 ? 0 : i)) : [];
      }
      function Eg(e, i) {
        return e && e.length ? rs(e, j(i, 3), !0, !0) : [];
      }
      function Ig(e, i) {
        return e && e.length ? rs(e, j(i, 3), !0) : [];
      }
      function Pg(e, i, n, c) {
        var h = e == null ? 0 : e.length;
        return h ? (n && typeof n != "number" && Ne(e, i, n) && (n = 0, c = h), yd(e, i, n, c)) : [];
      }
      function Gc(e, i, n) {
        var c = e == null ? 0 : e.length;
        if (!c) return -1;
        var h = n == null ? 0 : z(n);
        return h < 0 && (h = we(c + h, 0)), Fi(e, j(i, 3), h);
      }
      function Qc(e, i, n) {
        var c = e == null ? 0 : e.length;
        if (!c) return -1;
        var h = c - 1;
        return n !== r && (h = z(n), h = n < 0 ? we(c + h, 0) : Se(h, c - 1)), Fi(e, j(i, 3), h, !0);
      }
      function Jc(e) {
        var i = e == null ? 0 : e.length;
        return i ? Ie(e, 1) : [];
      }
      function Sg(e) {
        var i = e == null ? 0 : e.length;
        return i ? Ie(e, Si) : [];
      }
      function Og(e, i) {
        var n = e == null ? 0 : e.length;
        return n ? (i = i === r ? 1 : z(i), Ie(e, i)) : [];
      }
      function Rg(e) {
        for (var i = -1, n = e == null ? 0 : e.length, c = {}; ++i < n; ) {
          var h = e[i];
          c[h[0]] = h[1];
        }
        return c;
      }
      function Yc(e) {
        return e && e.length ? e[0] : r;
      }
      function $g(e, i, n) {
        var c = e == null ? 0 : e.length;
        if (!c) return -1;
        var h = n == null ? 0 : z(n);
        return h < 0 && (h = we(c + h, 0)), mr(e, i, h);
      }
      function Cg(e) {
        var i = e == null ? 0 : e.length;
        return i ? tt(e, 0, -1) : [];
      }
      var Ng = K(function(e) {
        var i = ae(e, Nn);
        return i.length && i[0] === e[0] ? _n(i) : [];
      }), Tg = K(function(e) {
        var i = rt(e), n = ae(e, Nn);
        return i === rt(n) ? i = r : n.pop(), n.length && n[0] === e[0] ? _n(n, j(i, 2)) : [];
      }), Ag = K(function(e) {
        var i = rt(e), n = ae(e, Nn);
        return i = typeof i == "function" ? i : r, i && n.pop(), n.length && n[0] === e[0] ? _n(n, r, i) : [];
      });
      function xg(e, i) {
        return e == null ? "" : Cf.call(e, i);
      }
      function rt(e) {
        var i = e == null ? 0 : e.length;
        return i ? e[i - 1] : r;
      }
      function Dg(e, i, n) {
        var c = e == null ? 0 : e.length;
        if (!c) return -1;
        var h = c;
        return n !== r && (h = z(n), h = h < 0 ? we(c + h, 0) : Se(h, c - 1)), i === i ? ff(e, i, h) : Fi(e, Ta, h, !0);
      }
      function Fg(e, i) {
        return e && e.length ? cc(e, z(i)) : r;
      }
      var qg = K(Zc);
      function Zc(e, i) {
        return e && e.length && i && i.length ? Pn(e, i) : e;
      }
      function jg(e, i, n) {
        return e && e.length && i && i.length ? Pn(e, i, j(n, 2)) : e;
      }
      function Ug(e, i, n) {
        return e && e.length && i && i.length ? Pn(e, i, r, n) : e;
      }
      var Mg = Rt(function(e, i) {
        var n = e == null ? 0 : e.length, c = yn(e, i);
        return lc(e, ae(i, function(h) {
          return $t(h, n) ? +h : h;
        }).sort(bc)), c;
      });
      function Lg(e, i) {
        var n = [];
        if (!(e && e.length)) return n;
        var c = -1, h = [], f = e.length;
        for (i = j(i, 3); ++c < f; ) {
          var d = e[c];
          i(d, c, e) && (n.push(d), h.push(c));
        }
        return lc(e, h), n;
      }
      function Vn(e) {
        return e == null ? e : xf.call(e);
      }
      function kg(e, i, n) {
        var c = e == null ? 0 : e.length;
        return c ? (n && typeof n != "number" && Ne(e, i, n) ? (i = 0, n = c) : (i = i == null ? 0 : z(i), n = n === r ? c : z(n)), tt(e, i, n)) : [];
      }
      function zg(e, i) {
        return ts(e, i);
      }
      function Hg(e, i, n) {
        return Rn(e, i, j(n, 2));
      }
      function Vg(e, i) {
        var n = e == null ? 0 : e.length;
        if (n) {
          var c = ts(e, i);
          if (c < n && lt(e[c], i)) return c;
        }
        return -1;
      }
      function Kg(e, i) {
        return ts(e, i, !0);
      }
      function Bg(e, i, n) {
        return Rn(e, i, j(n, 2), !0);
      }
      function Wg(e, i) {
        var n = e == null ? 0 : e.length;
        if (n) {
          var c = ts(e, i, !0) - 1;
          if (lt(e[c], i)) return c;
        }
        return -1;
      }
      function Gg(e) {
        return e && e.length ? fc(e) : [];
      }
      function Qg(e, i) {
        return e && e.length ? fc(e, j(i, 2)) : [];
      }
      function Jg(e) {
        var i = e == null ? 0 : e.length;
        return i ? tt(e, 1, i) : [];
      }
      function Yg(e, i, n) {
        return e && e.length ? (i = n || i === r ? 1 : z(i), tt(e, 0, i < 0 ? 0 : i)) : [];
      }
      function Zg(e, i, n) {
        var c = e == null ? 0 : e.length;
        return c ? (i = n || i === r ? 1 : z(i), i = c - i, tt(e, i < 0 ? 0 : i, c)) : [];
      }
      function Xg(e, i) {
        return e && e.length ? rs(e, j(i, 3), !1, !0) : [];
      }
      function ey(e, i) {
        return e && e.length ? rs(e, j(i, 3)) : [];
      }
      var ty = K(function(e) {
        return zt(Ie(e, 1, de, !0));
      }), ry = K(function(e) {
        var i = rt(e);
        return de(i) && (i = r), zt(Ie(e, 1, de, !0), j(i, 2));
      }), iy = K(function(e) {
        var i = rt(e);
        return i = typeof i == "function" ? i : r, zt(Ie(e, 1, de, !0), r, i);
      });
      function sy(e) {
        return e && e.length ? zt(e) : [];
      }
      function ny(e, i) {
        return e && e.length ? zt(e, j(i, 2)) : [];
      }
      function oy(e, i) {
        return i = typeof i == "function" ? i : r, e && e.length ? zt(e, r, i) : [];
      }
      function Kn(e) {
        if (!(e && e.length)) return [];
        var i = 0;
        return e = jt(e, function(n) {
          if (de(n)) return i = we(n.length, i), !0;
        }), cn(i, function(n) {
          return ae(e, nn(n));
        });
      }
      function Xc(e, i) {
        if (!(e && e.length)) return [];
        var n = Kn(e);
        return i == null ? n : ae(n, function(c) {
          return ze(i, r, c);
        });
      }
      var ay = K(function(e, i) {
        return de(e) ? ri(e, i) : [];
      }), cy = K(function(e) {
        return Cn(jt(e, de));
      }), uy = K(function(e) {
        var i = rt(e);
        return de(i) && (i = r), Cn(jt(e, de), j(i, 2));
      }), hy = K(function(e) {
        var i = rt(e);
        return i = typeof i == "function" ? i : r, Cn(jt(e, de), r, i);
      }), ly = K(Kn);
      function py(e, i) {
        return vc(e || [], i || [], ti);
      }
      function fy(e, i) {
        return vc(e || [], i || [], ni);
      }
      var dy = K(function(e) {
        var i = e.length, n = i > 1 ? e[i - 1] : r;
        return n = typeof n == "function" ? (e.pop(), n) : r, Xc(e, n);
      });
      function eu(e) {
        var i = p(e);
        return i.__chain__ = !0, i;
      }
      function gy(e, i) {
        return i(e), e;
      }
      function ls(e, i) {
        return i(e);
      }
      var yy = Rt(function(e) {
        var i = e.length, n = i ? e[0] : 0, c = this.__wrapped__, h = function(f) {
          return yn(f, e);
        };
        return i > 1 || this.__actions__.length || !(c instanceof W) || !$t(n) ? this.thru(h) : (c = c.slice(n, +n + (i ? 1 : 0)), c.__actions__.push({ func: ls, args: [h], thisArg: r }), new Xe(c, this.__chain__).thru(function(f) {
          return i && !f.length && f.push(r), f;
        }));
      });
      function vy() {
        return eu(this);
      }
      function my() {
        return new Xe(this.value(), this.__chain__);
      }
      function wy() {
        this.__values__ === r && (this.__values__ = du(this.value()));
        var e = this.__index__ >= this.__values__.length, i = e ? r : this.__values__[this.__index__++];
        return { done: e, value: i };
      }
      function _y() {
        return this;
      }
      function by(e) {
        for (var i, n = this; n instanceof Ji; ) {
          var c = Wc(n);
          c.__index__ = 0, c.__values__ = r, i ? h.__wrapped__ = c : i = c;
          var h = c;
          n = n.__wrapped__;
        }
        return h.__wrapped__ = e, i;
      }
      function Ey() {
        var e = this.__wrapped__;
        if (e instanceof W) {
          var i = e;
          return this.__actions__.length && (i = new W(this)), i = i.reverse(), i.__actions__.push({ func: ls, args: [Vn], thisArg: r }), new Xe(i, this.__chain__);
        }
        return this.thru(Vn);
      }
      function Iy() {
        return yc(this.__wrapped__, this.__actions__);
      }
      var Py = is(function(e, i, n) {
        te.call(e, n) ? ++e[n] : St(e, n, 1);
      });
      function Sy(e, i, n) {
        var c = k(e) ? Ca : gd;
        return n && Ne(e, i, n) && (i = r), c(e, j(i, 3));
      }
      function Oy(e, i) {
        var n = k(e) ? jt : Xa;
        return n(e, j(i, 3));
      }
      var Ry = Rc(Gc), $y = Rc(Qc);
      function Cy(e, i) {
        return Ie(ps(e, i), 1);
      }
      function Ny(e, i) {
        return Ie(ps(e, i), Si);
      }
      function Ty(e, i, n) {
        return n = n === r ? 1 : z(n), Ie(ps(e, i), n);
      }
      function tu(e, i) {
        var n = k(e) ? Ye : kt;
        return n(e, j(i, 3));
      }
      function ru(e, i) {
        var n = k(e) ? Qp : Za;
        return n(e, j(i, 3));
      }
      var Ay = is(function(e, i, n) {
        te.call(e, n) ? e[n].push(i) : St(e, n, [i]);
      });
      function xy(e, i, n, c) {
        e = qe(e) ? e : Nr(e), n = n && !c ? z(n) : 0;
        var h = e.length;
        return n < 0 && (n = we(h + n, 0)), vs(e) ? n <= h && e.indexOf(i, n) > -1 : !!h && mr(e, i, n) > -1;
      }
      var Dy = K(function(e, i, n) {
        var c = -1, h = typeof i == "function", f = qe(e) ? _(e.length) : [];
        return kt(e, function(d) {
          f[++c] = h ? ze(i, d, n) : ii(d, i, n);
        }), f;
      }), Fy = is(function(e, i, n) {
        St(e, n, i);
      });
      function ps(e, i) {
        var n = k(e) ? ae : nc;
        return n(e, j(i, 3));
      }
      function qy(e, i, n, c) {
        return e == null ? [] : (k(i) || (i = i == null ? [] : [i]), n = c ? r : n, k(n) || (n = n == null ? [] : [n]), uc(e, i, n));
      }
      var jy = is(function(e, i, n) {
        e[n ? 0 : 1].push(i);
      }, function() {
        return [[], []];
      });
      function Uy(e, i, n) {
        var c = k(e) ? rn : xa, h = arguments.length < 3;
        return c(e, j(i, 4), n, h, kt);
      }
      function My(e, i, n) {
        var c = k(e) ? Jp : xa, h = arguments.length < 3;
        return c(e, j(i, 4), n, h, Za);
      }
      function Ly(e, i) {
        var n = k(e) ? jt : Xa;
        return n(e, gs(j(i, 3)));
      }
      function ky(e) {
        var i = k(e) ? Ga : xd;
        return i(e);
      }
      function zy(e, i, n) {
        (n ? Ne(e, i, n) : i === r) ? i = 1 : i = z(i);
        var c = k(e) ? hd : Dd;
        return c(e, i);
      }
      function Hy(e) {
        var i = k(e) ? ld : qd;
        return i(e);
      }
      function Vy(e) {
        if (e == null) return 0;
        if (qe(e)) return vs(e) ? _r(e) : e.length;
        var i = Oe(e);
        return i == at || i == ct ? e.size : En(e).length;
      }
      function Ky(e, i, n) {
        var c = k(e) ? sn : jd;
        return n && Ne(e, i, n) && (i = r), c(e, j(i, 3));
      }
      var By = K(function(e, i) {
        if (e == null) return [];
        var n = i.length;
        return n > 1 && Ne(e, i[0], i[1]) ? i = [] : n > 2 && Ne(i[0], i[1], i[2]) && (i = [i[0]]), uc(e, Ie(i, 1), []);
      }), fs = Of || function() {
        return Ee.Date.now();
      };
      function Wy(e, i) {
        if (typeof i != "function") throw new Ze(l);
        return e = z(e), function() {
          if (--e < 1) return i.apply(this, arguments);
        };
      }
      function iu(e, i, n) {
        return i = n ? r : i, i = e && i == null ? e.length : i, Ot(e, fe, r, r, r, r, i);
      }
      function su(e, i) {
        var n;
        if (typeof i != "function") throw new Ze(l);
        return e = z(e), function() {
          return --e > 0 && (n = i.apply(this, arguments)), e <= 1 && (i = r), n;
        };
      }
      var Bn = K(function(e, i, n) {
        var c = x;
        if (n.length) {
          var h = Mt(n, $r(Bn));
          c |= ue;
        }
        return Ot(e, c, i, n, h);
      }), nu = K(function(e, i, n) {
        var c = x | G;
        if (n.length) {
          var h = Mt(n, $r(nu));
          c |= ue;
        }
        return Ot(i, c, e, n, h);
      });
      function ou(e, i, n) {
        i = n ? r : i;
        var c = Ot(e, J, r, r, r, r, r, i);
        return c.placeholder = ou.placeholder, c;
      }
      function au(e, i, n) {
        i = n ? r : i;
        var c = Ot(e, X, r, r, r, r, r, i);
        return c.placeholder = au.placeholder, c;
      }
      function cu(e, i, n) {
        var c, h, f, d, y, m, I = 0, P = !1, O = !1, N = !0;
        if (typeof e != "function") throw new Ze(l);
        i = it(i) || 0, he(n) && (P = !!n.leading, O = "maxWait" in n, f = O ? we(it(n.maxWait) || 0, i) : f, N = "trailing" in n ? !!n.trailing : N);
        function D(ge) {
          var pt = c, Tt = h;
          return c = h = r, I = ge, d = e.apply(Tt, pt), d;
        }
        function U(ge) {
          return I = ge, y = ci(B, i), P ? D(ge) : d;
        }
        function H(ge) {
          var pt = ge - m, Tt = ge - I, Ru = i - pt;
          return O ? Se(Ru, f - Tt) : Ru;
        }
        function M(ge) {
          var pt = ge - m, Tt = ge - I;
          return m === r || pt >= i || pt < 0 || O && Tt >= f;
        }
        function B() {
          var ge = fs();
          if (M(ge)) return Q(ge);
          y = ci(B, H(ge));
        }
        function Q(ge) {
          return y = r, N && c ? D(ge) : (c = h = r, d);
        }
        function Be() {
          y !== r && mc(y), I = 0, c = m = h = y = r;
        }
        function Te() {
          return y === r ? d : Q(fs());
        }
        function We() {
          var ge = fs(), pt = M(ge);
          if (c = arguments, h = this, m = ge, pt) {
            if (y === r) return U(m);
            if (O) return mc(y), y = ci(B, i), D(m);
          }
          return y === r && (y = ci(B, i)), d;
        }
        return We.cancel = Be, We.flush = Te, We;
      }
      var Gy = K(function(e, i) {
        return Ya(e, 1, i);
      }), Qy = K(function(e, i, n) {
        return Ya(e, it(i) || 0, n);
      });
      function Jy(e) {
        return Ot(e, qt);
      }
      function ds(e, i) {
        if (typeof e != "function" || i != null && typeof i != "function") throw new Ze(l);
        var n = function() {
          var c = arguments, h = i ? i.apply(this, c) : c[0], f = n.cache;
          if (f.has(h)) return f.get(h);
          var d = e.apply(this, c);
          return n.cache = f.set(h, d) || f, d;
        };
        return n.cache = new (ds.Cache || Pt)(), n;
      }
      ds.Cache = Pt;
      function gs(e) {
        if (typeof e != "function") throw new Ze(l);
        return function() {
          var i = arguments;
          switch (i.length) {
            case 0:
              return !e.call(this);
            case 1:
              return !e.call(this, i[0]);
            case 2:
              return !e.call(this, i[0], i[1]);
            case 3:
              return !e.call(this, i[0], i[1], i[2]);
          }
          return !e.apply(this, i);
        };
      }
      function Yy(e) {
        return su(2, e);
      }
      var Zy = Ud(function(e, i) {
        i = i.length == 1 && k(i[0]) ? ae(i[0], He(j())) : ae(Ie(i, 1), He(j()));
        var n = i.length;
        return K(function(c) {
          for (var h = -1, f = Se(c.length, n); ++h < f; ) c[h] = i[h].call(this, c[h]);
          return ze(e, this, c);
        });
      }), Wn = K(function(e, i) {
        var n = Mt(i, $r(Wn));
        return Ot(e, ue, r, i, n);
      }), uu = K(function(e, i) {
        var n = Mt(i, $r(uu));
        return Ot(e, De, r, i, n);
      }), Xy = Rt(function(e, i) {
        return Ot(e, $e, r, r, r, i);
      });
      function ev(e, i) {
        if (typeof e != "function") throw new Ze(l);
        return i = i === r ? i : z(i), K(e, i);
      }
      function tv(e, i) {
        if (typeof e != "function") throw new Ze(l);
        return i = i == null ? 0 : we(z(i), 0), K(function(n) {
          var c = n[i], h = Vt(n, 0, i);
          return c && Ut(h, c), ze(e, this, h);
        });
      }
      function rv(e, i, n) {
        var c = !0, h = !0;
        if (typeof e != "function") throw new Ze(l);
        return he(n) && (c = "leading" in n ? !!n.leading : c, h = "trailing" in n ? !!n.trailing : h), cu(e, i, { leading: c, maxWait: i, trailing: h });
      }
      function iv(e) {
        return iu(e, 1);
      }
      function sv(e, i) {
        return Wn(Tn(i), e);
      }
      function nv() {
        if (!arguments.length) return [];
        var e = arguments[0];
        return k(e) ? e : [e];
      }
      function ov(e) {
        return et(e, q);
      }
      function av(e, i) {
        return i = typeof i == "function" ? i : r, et(e, q, i);
      }
      function cv(e) {
        return et(e, S | q);
      }
      function uv(e, i) {
        return i = typeof i == "function" ? i : r, et(e, S | q, i);
      }
      function hv(e, i) {
        return i == null || Ja(e, i, _e(i));
      }
      function lt(e, i) {
        return e === i || e !== e && i !== i;
      }
      var lv = as(wn), pv = as(function(e, i) {
        return e >= i;
      }), nr = rc(/* @__PURE__ */ function() {
        return arguments;
      }()) ? rc : function(e) {
        return le(e) && te.call(e, "callee") && !za.call(e, "callee");
      }, k = _.isArray, fv = Ia ? He(Ia) : bd;
      function qe(e) {
        return e != null && ys(e.length) && !Ct(e);
      }
      function de(e) {
        return le(e) && qe(e);
      }
      function dv(e) {
        return e === !0 || e === !1 || le(e) && Ce(e) == zr;
      }
      var Kt = $f || so, gv = Pa ? He(Pa) : Ed;
      function yv(e) {
        return le(e) && e.nodeType === 1 && !ui(e);
      }
      function vv(e) {
        if (e == null) return !0;
        if (qe(e) && (k(e) || typeof e == "string" || typeof e.splice == "function" || Kt(e) || Cr(e) || nr(e))) return !e.length;
        var i = Oe(e);
        if (i == at || i == ct) return !e.size;
        if (ai(e)) return !En(e).length;
        for (var n in e) if (te.call(e, n)) return !1;
        return !0;
      }
      function mv(e, i) {
        return si(e, i);
      }
      function wv(e, i, n) {
        n = typeof n == "function" ? n : r;
        var c = n ? n(e, i) : r;
        return c === r ? si(e, i, r, n) : !!c;
      }
      function Gn(e) {
        if (!le(e)) return !1;
        var i = Ce(e);
        return i == $i || i == kl || typeof e.message == "string" && typeof e.name == "string" && !ui(e);
      }
      function _v(e) {
        return typeof e == "number" && Va(e);
      }
      function Ct(e) {
        if (!he(e)) return !1;
        var i = Ce(e);
        return i == Ci || i == Yo || i == Ll || i == Hl;
      }
      function hu(e) {
        return typeof e == "number" && e == z(e);
      }
      function ys(e) {
        return typeof e == "number" && e > -1 && e % 1 == 0 && e <= dr;
      }
      function he(e) {
        var i = typeof e;
        return e != null && (i == "object" || i == "function");
      }
      function le(e) {
        return e != null && typeof e == "object";
      }
      var lu = Sa ? He(Sa) : Pd;
      function bv(e, i) {
        return e === i || bn(e, i, Un(i));
      }
      function Ev(e, i, n) {
        return n = typeof n == "function" ? n : r, bn(e, i, Un(i), n);
      }
      function Iv(e) {
        return pu(e) && e != +e;
      }
      function Pv(e) {
        if (ag(e)) throw new L(u);
        return ic(e);
      }
      function Sv(e) {
        return e === null;
      }
      function Ov(e) {
        return e == null;
      }
      function pu(e) {
        return typeof e == "number" || le(e) && Ce(e) == Vr;
      }
      function ui(e) {
        if (!le(e) || Ce(e) != Et) return !1;
        var i = Hi(e);
        if (i === null) return !0;
        var n = te.call(i, "constructor") && i.constructor;
        return typeof n == "function" && n instanceof n && Mi.call(n) == Ef;
      }
      var Qn = Oa ? He(Oa) : Sd;
      function Rv(e) {
        return hu(e) && e >= -9007199254740991 && e <= dr;
      }
      var fu = Ra ? He(Ra) : Od;
      function vs(e) {
        return typeof e == "string" || !k(e) && le(e) && Ce(e) == Br;
      }
      function Ke(e) {
        return typeof e == "symbol" || le(e) && Ce(e) == Ni;
      }
      var Cr = $a ? He($a) : Rd;
      function $v(e) {
        return e === r;
      }
      function Cv(e) {
        return le(e) && Oe(e) == Wr;
      }
      function Nv(e) {
        return le(e) && Ce(e) == Kl;
      }
      var Tv = as(In), Av = as(function(e, i) {
        return e <= i;
      });
      function du(e) {
        if (!e) return [];
        if (qe(e)) return vs(e) ? ut(e) : Fe(e);
        if (Jr && e[Jr]) return hf(e[Jr]());
        var i = Oe(e), n = i == at ? hn : i == ct ? qi : Nr;
        return n(e);
      }
      function Nt(e) {
        if (!e) return e === 0 ? e : 0;
        if (e = it(e), e === Si || e === -1 / 0) {
          var i = e < 0 ? -1 : 1;
          return i * ql;
        }
        return e === e ? e : 0;
      }
      function z(e) {
        var i = Nt(e), n = i % 1;
        return i === i ? n ? i - n : i : 0;
      }
      function gu(e) {
        return e ? tr(z(e), 0, yt) : 0;
      }
      function it(e) {
        if (typeof e == "number") return e;
        if (Ke(e)) return Oi;
        if (he(e)) {
          var i = typeof e.valueOf == "function" ? e.valueOf() : e;
          e = he(i) ? i + "" : i;
        }
        if (typeof e != "string") return e === 0 ? e : +e;
        e = Da(e);
        var n = pp.test(e);
        return n || dp.test(e) ? Bp(e.slice(2), n ? 2 : 8) : lp.test(e) ? Oi : +e;
      }
      function yu(e) {
        return mt(e, je(e));
      }
      function xv(e) {
        return e ? tr(z(e), -9007199254740991, dr) : e === 0 ? e : 0;
      }
      function ee(e) {
        return e == null ? "" : Ve(e);
      }
      var Dv = Or(function(e, i) {
        if (ai(i) || qe(i)) {
          mt(i, _e(i), e);
          return;
        }
        for (var n in i) te.call(i, n) && ti(e, n, i[n]);
      }), vu = Or(function(e, i) {
        mt(i, je(i), e);
      }), ms = Or(function(e, i, n, c) {
        mt(i, je(i), e, c);
      }), Fv = Or(function(e, i, n, c) {
        mt(i, _e(i), e, c);
      }), qv = Rt(yn);
      function jv(e, i) {
        var n = Sr(e);
        return i == null ? n : Qa(n, i);
      }
      var Uv = K(function(e, i) {
        e = re(e);
        var n = -1, c = i.length, h = c > 2 ? i[2] : r;
        for (h && Ne(i[0], i[1], h) && (c = 1); ++n < c; ) for (var f = i[n], d = je(f), y = -1, m = d.length; ++y < m; ) {
          var I = d[y], P = e[I];
          (P === r || lt(P, Er[I]) && !te.call(e, I)) && (e[I] = f[I]);
        }
        return e;
      }), Mv = K(function(e) {
        return e.push(r, Dc), ze(mu, r, e);
      });
      function Lv(e, i) {
        return Na(e, j(i, 3), vt);
      }
      function kv(e, i) {
        return Na(e, j(i, 3), mn);
      }
      function zv(e, i) {
        return e == null ? e : vn(e, j(i, 3), je);
      }
      function Hv(e, i) {
        return e == null ? e : ec(e, j(i, 3), je);
      }
      function Vv(e, i) {
        return e && vt(e, j(i, 3));
      }
      function Kv(e, i) {
        return e && mn(e, j(i, 3));
      }
      function Bv(e) {
        return e == null ? [] : Xi(e, _e(e));
      }
      function Wv(e) {
        return e == null ? [] : Xi(e, je(e));
      }
      function Jn(e, i, n) {
        var c = e == null ? r : rr(e, i);
        return c === r ? n : c;
      }
      function Gv(e, i) {
        return e != null && jc(e, i, vd);
      }
      function Yn(e, i) {
        return e != null && jc(e, i, md);
      }
      var Qv = Cc(function(e, i, n) {
        i != null && typeof i.toString != "function" && (i = Li.call(i)), e[i] = n;
      }, Xn(Ue)), Jv = Cc(function(e, i, n) {
        i != null && typeof i.toString != "function" && (i = Li.call(i)), te.call(e, i) ? e[i].push(n) : e[i] = [n];
      }, j), Yv = K(ii);
      function _e(e) {
        return qe(e) ? Wa(e) : En(e);
      }
      function je(e) {
        return qe(e) ? Wa(e, !0) : $d(e);
      }
      function Zv(e, i) {
        var n = {};
        return i = j(i, 3), vt(e, function(c, h, f) {
          St(n, i(c, h, f), c);
        }), n;
      }
      function Xv(e, i) {
        var n = {};
        return i = j(i, 3), vt(e, function(c, h, f) {
          St(n, h, i(c, h, f));
        }), n;
      }
      var em = Or(function(e, i, n) {
        es(e, i, n);
      }), mu = Or(function(e, i, n, c) {
        es(e, i, n, c);
      }), tm = Rt(function(e, i) {
        var n = {};
        if (e == null) return n;
        var c = !1;
        i = ae(i, function(f) {
          return f = Ht(f, e), c || (c = f.length > 1), f;
        }), mt(e, qn(e), n), c && (n = et(n, S | R | q, Qd));
        for (var h = i.length; h--; ) $n(n, i[h]);
        return n;
      });
      function rm(e, i) {
        return wu(e, gs(j(i)));
      }
      var im = Rt(function(e, i) {
        return e == null ? {} : Nd(e, i);
      });
      function wu(e, i) {
        if (e == null) return {};
        var n = ae(qn(e), function(c) {
          return [c];
        });
        return i = j(i), hc(e, n, function(c, h) {
          return i(c, h[0]);
        });
      }
      function sm(e, i, n) {
        i = Ht(i, e);
        var c = -1, h = i.length;
        for (h || (h = 1, e = r); ++c < h; ) {
          var f = e == null ? r : e[wt(i[c])];
          f === r && (c = h, f = n), e = Ct(f) ? f.call(e) : f;
        }
        return e;
      }
      function nm(e, i, n) {
        return e == null ? e : ni(e, i, n);
      }
      function om(e, i, n, c) {
        return c = typeof c == "function" ? c : r, e == null ? e : ni(e, i, n, c);
      }
      var _u = Ac(_e), bu = Ac(je);
      function am(e, i, n) {
        var c = k(e), h = c || Kt(e) || Cr(e);
        if (i = j(i, 4), n == null) {
          var f = e && e.constructor;
          h ? n = c ? new f() : [] : he(e) ? n = Ct(f) ? Sr(Hi(e)) : {} : n = {};
        }
        return (h ? Ye : vt)(e, function(d, y, m) {
          return i(n, d, y, m);
        }), n;
      }
      function cm(e, i) {
        return e == null ? !0 : $n(e, i);
      }
      function um(e, i, n) {
        return e == null ? e : gc(e, i, Tn(n));
      }
      function hm(e, i, n, c) {
        return c = typeof c == "function" ? c : r, e == null ? e : gc(e, i, Tn(n), c);
      }
      function Nr(e) {
        return e == null ? [] : un(e, _e(e));
      }
      function lm(e) {
        return e == null ? [] : un(e, je(e));
      }
      function pm(e, i, n) {
        return n === r && (n = i, i = r), n !== r && (n = it(n), n = n === n ? n : 0), i !== r && (i = it(i), i = i === i ? i : 0), tr(it(e), i, n);
      }
      function fm(e, i, n) {
        return i = Nt(i), n === r ? (n = i, i = 0) : n = Nt(n), e = it(e), wd(e, i, n);
      }
      function dm(e, i, n) {
        if (n && typeof n != "boolean" && Ne(e, i, n) && (i = n = r), n === r && (typeof i == "boolean" ? (n = i, i = r) : typeof e == "boolean" && (n = e, e = r)), e === r && i === r ? (e = 0, i = 1) : (e = Nt(e), i === r ? (i = e, e = 0) : i = Nt(i)), e > i) {
          var c = e;
          e = i, i = c;
        }
        if (n || e % 1 || i % 1) {
          var h = Ka();
          return Se(e + h * (i - e + Kp("1e-" + ((h + "").length - 1))), i);
        }
        return Sn(e, i);
      }
      var gm = Rr(function(e, i, n) {
        return i = i.toLowerCase(), e + (n ? Eu(i) : i);
      });
      function Eu(e) {
        return Zn(ee(e).toLowerCase());
      }
      function Iu(e) {
        return e = ee(e), e && e.replace(yp, nf).replace(Fp, "");
      }
      function ym(e, i, n) {
        e = ee(e), i = Ve(i);
        var c = e.length;
        n = n === r ? c : tr(z(n), 0, c);
        var h = n;
        return n -= i.length, n >= 0 && e.slice(n, h) == i;
      }
      function vm(e) {
        return e = ee(e), e && Jl.test(e) ? e.replace(ea, of) : e;
      }
      function mm(e) {
        return e = ee(e), e && rp.test(e) ? e.replace(Bs, "\\$&") : e;
      }
      var wm = Rr(function(e, i, n) {
        return e + (n ? "-" : "") + i.toLowerCase();
      }), _m = Rr(function(e, i, n) {
        return e + (n ? " " : "") + i.toLowerCase();
      }), bm = Oc("toLowerCase");
      function Em(e, i, n) {
        e = ee(e), i = z(i);
        var c = i ? _r(e) : 0;
        if (!i || c >= i) return e;
        var h = (i - c) / 2;
        return os(Wi(h), n) + e + os(Bi(h), n);
      }
      function Im(e, i, n) {
        e = ee(e), i = z(i);
        var c = i ? _r(e) : 0;
        return i && c < i ? e + os(i - c, n) : e;
      }
      function Pm(e, i, n) {
        e = ee(e), i = z(i);
        var c = i ? _r(e) : 0;
        return i && c < i ? os(i - c, n) + e : e;
      }
      function Sm(e, i, n) {
        return n || i == null ? i = 0 : i && (i = +i), Af(ee(e).replace(Ws, ""), i || 0);
      }
      function Om(e, i, n) {
        return (n ? Ne(e, i, n) : i === r) ? i = 1 : i = z(i), On(ee(e), i);
      }
      function Rm() {
        var e = arguments, i = ee(e[0]);
        return e.length < 3 ? i : i.replace(e[1], e[2]);
      }
      var $m = Rr(function(e, i, n) {
        return e + (n ? "_" : "") + i.toLowerCase();
      });
      function Cm(e, i, n) {
        return n && typeof n != "number" && Ne(e, i, n) && (i = n = r), n = n === r ? yt : n >>> 0, n ? (e = ee(e), e && (typeof i == "string" || i != null && !Qn(i)) && (i = Ve(i), !i && wr(e)) ? Vt(ut(e), 0, n) : e.split(i, n)) : [];
      }
      var Nm = Rr(function(e, i, n) {
        return e + (n ? " " : "") + Zn(i);
      });
      function Tm(e, i, n) {
        return e = ee(e), n = n == null ? 0 : tr(z(n), 0, e.length), i = Ve(i), e.slice(n, n + i.length) == i;
      }
      function Am(e, i, n) {
        var c = p.templateSettings;
        n && Ne(e, i, n) && (i = r), e = ee(e), i = ms({}, i, c, xc);
        var h = ms({}, i.imports, c.imports, xc), f = _e(h), d = un(h, f), y, m, I = 0, P = i.interpolate || Ti, O = "__p += '", N = ln((i.escape || Ti).source + "|" + P.source + "|" + (P === ta ? hp : Ti).source + "|" + (i.evaluate || Ti).source + "|$", "g"), D = "//# sourceURL=" + (te.call(i, "sourceURL") ? (i.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Lp + "]") + `
`;
        e.replace(N, function(M, B, Q, Be, Te, We) {
          return Q || (Q = Be), O += e.slice(I, We).replace(vp, af), B && (y = !0, O += `' +
__e(` + B + `) +
'`), Te && (m = !0, O += `';
` + Te + `;
__p += '`), Q && (O += `' +
((__t = (` + Q + `)) == null ? '' : __t) +
'`), I = We + M.length, M;
        }), O += `';
`;
        var U = te.call(i, "variable") && i.variable;
        if (!U) O = `with (obj) {
` + O + `
}
`;
        else if (cp.test(U)) throw new L(g);
        O = (m ? O.replace(Bl, "") : O).replace(Wl, "$1").replace(Gl, "$1;"), O = "function(" + (U || "obj") + `) {
` + (U ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (y ? ", __e = _.escape" : "") + (m ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + O + `return __p
}`;
        var H = Su(function() {
          return Y(f, D + "return " + O).apply(r, d);
        });
        if (H.source = O, Gn(H)) throw H;
        return H;
      }
      function xm(e) {
        return ee(e).toLowerCase();
      }
      function Dm(e) {
        return ee(e).toUpperCase();
      }
      function Fm(e, i, n) {
        if (e = ee(e), e && (n || i === r)) return Da(e);
        if (!e || !(i = Ve(i))) return e;
        var c = ut(e), h = ut(i), f = Fa(c, h), d = qa(c, h) + 1;
        return Vt(c, f, d).join("");
      }
      function qm(e, i, n) {
        if (e = ee(e), e && (n || i === r)) return e.slice(0, Ua(e) + 1);
        if (!e || !(i = Ve(i))) return e;
        var c = ut(e), h = qa(c, ut(i)) + 1;
        return Vt(c, 0, h).join("");
      }
      function jm(e, i, n) {
        if (e = ee(e), e && (n || i === r)) return e.replace(Ws, "");
        if (!e || !(i = Ve(i))) return e;
        var c = ut(e), h = Fa(c, ut(i));
        return Vt(c, h).join("");
      }
      function Um(e, i) {
        var n = Nl, c = Tl;
        if (he(i)) {
          var h = "separator" in i ? i.separator : h;
          n = "length" in i ? z(i.length) : n, c = "omission" in i ? Ve(i.omission) : c;
        }
        e = ee(e);
        var f = e.length;
        if (wr(e)) {
          var d = ut(e);
          f = d.length;
        }
        if (n >= f) return e;
        var y = n - _r(c);
        if (y < 1) return c;
        var m = d ? Vt(d, 0, y).join("") : e.slice(0, y);
        if (h === r) return m + c;
        if (d && (y += m.length - y), Qn(h)) {
          if (e.slice(y).search(h)) {
            var I, P = m;
            for (h.global || (h = ln(h.source, ee(ra.exec(h)) + "g")), h.lastIndex = 0; I = h.exec(P); ) var O = I.index;
            m = m.slice(0, O === r ? y : O);
          }
        } else if (e.indexOf(Ve(h), y) != y) {
          var N = m.lastIndexOf(h);
          N > -1 && (m = m.slice(0, N));
        }
        return m + c;
      }
      function Mm(e) {
        return e = ee(e), e && Ql.test(e) ? e.replace(Xo, df) : e;
      }
      var Lm = Rr(function(e, i, n) {
        return e + (n ? " " : "") + i.toUpperCase();
      }), Zn = Oc("toUpperCase");
      function Pu(e, i, n) {
        return e = ee(e), i = n ? r : i, i === r ? uf(e) ? vf(e) : Xp(e) : e.match(i) || [];
      }
      var Su = K(function(e, i) {
        try {
          return ze(e, r, i);
        } catch (n) {
          return Gn(n) ? n : new L(n);
        }
      }), km = Rt(function(e, i) {
        return Ye(i, function(n) {
          n = wt(n), St(e, n, Bn(e[n], e));
        }), e;
      });
      function zm(e) {
        var i = e == null ? 0 : e.length, n = j();
        return e = i ? ae(e, function(c) {
          if (typeof c[1] != "function") throw new Ze(l);
          return [n(c[0]), c[1]];
        }) : [], K(function(c) {
          for (var h = -1; ++h < i; ) {
            var f = e[h];
            if (ze(f[0], this, c)) return ze(f[1], this, c);
          }
        });
      }
      function Hm(e) {
        return dd(et(e, S));
      }
      function Xn(e) {
        return function() {
          return e;
        };
      }
      function Vm(e, i) {
        return e == null || e !== e ? i : e;
      }
      var Km = $c(), Bm = $c(!0);
      function Ue(e) {
        return e;
      }
      function eo(e) {
        return sc(typeof e == "function" ? e : et(e, S));
      }
      function Wm(e) {
        return oc(et(e, S));
      }
      function Gm(e, i) {
        return ac(e, et(i, S));
      }
      var Qm = K(function(e, i) {
        return function(n) {
          return ii(n, e, i);
        };
      }), Jm = K(function(e, i) {
        return function(n) {
          return ii(e, n, i);
        };
      });
      function to(e, i, n) {
        var c = _e(i), h = Xi(i, c);
        n == null && !(he(i) && (h.length || !c.length)) && (n = i, i = e, e = this, h = Xi(i, _e(i)));
        var f = !(he(n) && "chain" in n) || !!n.chain, d = Ct(e);
        return Ye(h, function(y) {
          var m = i[y];
          e[y] = m, d && (e.prototype[y] = function() {
            var I = this.__chain__;
            if (f || I) {
              var P = e(this.__wrapped__), O = P.__actions__ = Fe(this.__actions__);
              return O.push({ func: m, args: arguments, thisArg: e }), P.__chain__ = I, P;
            }
            return m.apply(e, Ut([this.value()], arguments));
          });
        }), e;
      }
      function Ym() {
        return Ee._ === this && (Ee._ = If), this;
      }
      function ro() {
      }
      function Zm(e) {
        return e = z(e), K(function(i) {
          return cc(i, e);
        });
      }
      var Xm = xn(ae), ew = xn(Ca), tw = xn(sn);
      function Ou(e) {
        return Ln(e) ? nn(wt(e)) : Td(e);
      }
      function rw(e) {
        return function(i) {
          return e == null ? r : rr(e, i);
        };
      }
      var iw = Nc(), sw = Nc(!0);
      function io() {
        return [];
      }
      function so() {
        return !1;
      }
      function nw() {
        return {};
      }
      function ow() {
        return "";
      }
      function aw() {
        return !0;
      }
      function cw(e, i) {
        if (e = z(e), e < 1 || e > dr) return [];
        var n = yt, c = Se(e, yt);
        i = j(i), e -= yt;
        for (var h = cn(c, i); ++n < e; ) i(n);
        return h;
      }
      function uw(e) {
        return k(e) ? ae(e, wt) : Ke(e) ? [e] : Fe(Bc(ee(e)));
      }
      function hw(e) {
        var i = ++bf;
        return ee(e) + i;
      }
      var lw = ns(function(e, i) {
        return e + i;
      }, 0), pw = Dn("ceil"), fw = ns(function(e, i) {
        return e / i;
      }, 1), dw = Dn("floor");
      function gw(e) {
        return e && e.length ? Zi(e, Ue, wn) : r;
      }
      function yw(e, i) {
        return e && e.length ? Zi(e, j(i, 2), wn) : r;
      }
      function vw(e) {
        return Aa(e, Ue);
      }
      function mw(e, i) {
        return Aa(e, j(i, 2));
      }
      function ww(e) {
        return e && e.length ? Zi(e, Ue, In) : r;
      }
      function _w(e, i) {
        return e && e.length ? Zi(e, j(i, 2), In) : r;
      }
      var bw = ns(function(e, i) {
        return e * i;
      }, 1), Ew = Dn("round"), Iw = ns(function(e, i) {
        return e - i;
      }, 0);
      function Pw(e) {
        return e && e.length ? an(e, Ue) : 0;
      }
      function Sw(e, i) {
        return e && e.length ? an(e, j(i, 2)) : 0;
      }
      return p.after = Wy, p.ary = iu, p.assign = Dv, p.assignIn = vu, p.assignInWith = ms, p.assignWith = Fv, p.at = qv, p.before = su, p.bind = Bn, p.bindAll = km, p.bindKey = nu, p.castArray = nv, p.chain = eu, p.chunk = dg, p.compact = gg, p.concat = yg, p.cond = zm, p.conforms = Hm, p.constant = Xn, p.countBy = Py, p.create = jv, p.curry = ou, p.curryRight = au, p.debounce = cu, p.defaults = Uv, p.defaultsDeep = Mv, p.defer = Gy, p.delay = Qy, p.difference = vg, p.differenceBy = mg, p.differenceWith = wg, p.drop = _g, p.dropRight = bg, p.dropRightWhile = Eg, p.dropWhile = Ig, p.fill = Pg, p.filter = Oy, p.flatMap = Cy, p.flatMapDeep = Ny, p.flatMapDepth = Ty, p.flatten = Jc, p.flattenDeep = Sg, p.flattenDepth = Og, p.flip = Jy, p.flow = Km, p.flowRight = Bm, p.fromPairs = Rg, p.functions = Bv, p.functionsIn = Wv, p.groupBy = Ay, p.initial = Cg, p.intersection = Ng, p.intersectionBy = Tg, p.intersectionWith = Ag, p.invert = Qv, p.invertBy = Jv, p.invokeMap = Dy, p.iteratee = eo, p.keyBy = Fy, p.keys = _e, p.keysIn = je, p.map = ps, p.mapKeys = Zv, p.mapValues = Xv, p.matches = Wm, p.matchesProperty = Gm, p.memoize = ds, p.merge = em, p.mergeWith = mu, p.method = Qm, p.methodOf = Jm, p.mixin = to, p.negate = gs, p.nthArg = Zm, p.omit = tm, p.omitBy = rm, p.once = Yy, p.orderBy = qy, p.over = Xm, p.overArgs = Zy, p.overEvery = ew, p.overSome = tw, p.partial = Wn, p.partialRight = uu, p.partition = jy, p.pick = im, p.pickBy = wu, p.property = Ou, p.propertyOf = rw, p.pull = qg, p.pullAll = Zc, p.pullAllBy = jg, p.pullAllWith = Ug, p.pullAt = Mg, p.range = iw, p.rangeRight = sw, p.rearg = Xy, p.reject = Ly, p.remove = Lg, p.rest = ev, p.reverse = Vn, p.sampleSize = zy, p.set = nm, p.setWith = om, p.shuffle = Hy, p.slice = kg, p.sortBy = By, p.sortedUniq = Gg, p.sortedUniqBy = Qg, p.split = Cm, p.spread = tv, p.tail = Jg, p.take = Yg, p.takeRight = Zg, p.takeRightWhile = Xg, p.takeWhile = ey, p.tap = gy, p.throttle = rv, p.thru = ls, p.toArray = du, p.toPairs = _u, p.toPairsIn = bu, p.toPath = uw, p.toPlainObject = yu, p.transform = am, p.unary = iv, p.union = ty, p.unionBy = ry, p.unionWith = iy, p.uniq = sy, p.uniqBy = ny, p.uniqWith = oy, p.unset = cm, p.unzip = Kn, p.unzipWith = Xc, p.update = um, p.updateWith = hm, p.values = Nr, p.valuesIn = lm, p.without = ay, p.words = Pu, p.wrap = sv, p.xor = cy, p.xorBy = uy, p.xorWith = hy, p.zip = ly, p.zipObject = py, p.zipObjectDeep = fy, p.zipWith = dy, p.entries = _u, p.entriesIn = bu, p.extend = vu, p.extendWith = ms, to(p, p), p.add = lw, p.attempt = Su, p.camelCase = gm, p.capitalize = Eu, p.ceil = pw, p.clamp = pm, p.clone = ov, p.cloneDeep = cv, p.cloneDeepWith = uv, p.cloneWith = av, p.conformsTo = hv, p.deburr = Iu, p.defaultTo = Vm, p.divide = fw, p.endsWith = ym, p.eq = lt, p.escape = vm, p.escapeRegExp = mm, p.every = Sy, p.find = Ry, p.findIndex = Gc, p.findKey = Lv, p.findLast = $y, p.findLastIndex = Qc, p.findLastKey = kv, p.floor = dw, p.forEach = tu, p.forEachRight = ru, p.forIn = zv, p.forInRight = Hv, p.forOwn = Vv, p.forOwnRight = Kv, p.get = Jn, p.gt = lv, p.gte = pv, p.has = Gv, p.hasIn = Yn, p.head = Yc, p.identity = Ue, p.includes = xy, p.indexOf = $g, p.inRange = fm, p.invoke = Yv, p.isArguments = nr, p.isArray = k, p.isArrayBuffer = fv, p.isArrayLike = qe, p.isArrayLikeObject = de, p.isBoolean = dv, p.isBuffer = Kt, p.isDate = gv, p.isElement = yv, p.isEmpty = vv, p.isEqual = mv, p.isEqualWith = wv, p.isError = Gn, p.isFinite = _v, p.isFunction = Ct, p.isInteger = hu, p.isLength = ys, p.isMap = lu, p.isMatch = bv, p.isMatchWith = Ev, p.isNaN = Iv, p.isNative = Pv, p.isNil = Ov, p.isNull = Sv, p.isNumber = pu, p.isObject = he, p.isObjectLike = le, p.isPlainObject = ui, p.isRegExp = Qn, p.isSafeInteger = Rv, p.isSet = fu, p.isString = vs, p.isSymbol = Ke, p.isTypedArray = Cr, p.isUndefined = $v, p.isWeakMap = Cv, p.isWeakSet = Nv, p.join = xg, p.kebabCase = wm, p.last = rt, p.lastIndexOf = Dg, p.lowerCase = _m, p.lowerFirst = bm, p.lt = Tv, p.lte = Av, p.max = gw, p.maxBy = yw, p.mean = vw, p.meanBy = mw, p.min = ww, p.minBy = _w, p.stubArray = io, p.stubFalse = so, p.stubObject = nw, p.stubString = ow, p.stubTrue = aw, p.multiply = bw, p.nth = Fg, p.noConflict = Ym, p.noop = ro, p.now = fs, p.pad = Em, p.padEnd = Im, p.padStart = Pm, p.parseInt = Sm, p.random = dm, p.reduce = Uy, p.reduceRight = My, p.repeat = Om, p.replace = Rm, p.result = sm, p.round = Ew, p.runInContext = v, p.sample = ky, p.size = Vy, p.snakeCase = $m, p.some = Ky, p.sortedIndex = zg, p.sortedIndexBy = Hg, p.sortedIndexOf = Vg, p.sortedLastIndex = Kg, p.sortedLastIndexBy = Bg, p.sortedLastIndexOf = Wg, p.startCase = Nm, p.startsWith = Tm, p.subtract = Iw, p.sum = Pw, p.sumBy = Sw, p.template = Am, p.times = cw, p.toFinite = Nt, p.toInteger = z, p.toLength = gu, p.toLower = xm, p.toNumber = it, p.toSafeInteger = xv, p.toString = ee, p.toUpper = Dm, p.trim = Fm, p.trimEnd = qm, p.trimStart = jm, p.truncate = Um, p.unescape = Mm, p.uniqueId = hw, p.upperCase = Lm, p.upperFirst = Zn, p.each = tu, p.eachRight = ru, p.first = Yc, to(p, function() {
        var e = {};
        return vt(p, function(i, n) {
          te.call(p.prototype, n) || (e[n] = i);
        }), e;
      }(), { chain: !1 }), p.VERSION = s, Ye(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(e) {
        p[e].placeholder = p;
      }), Ye(["drop", "take"], function(e, i) {
        W.prototype[e] = function(n) {
          n = n === r ? 1 : we(z(n), 0);
          var c = this.__filtered__ && !i ? new W(this) : this.clone();
          return c.__filtered__ ? c.__takeCount__ = Se(n, c.__takeCount__) : c.__views__.push({ size: Se(n, yt), type: e + (c.__dir__ < 0 ? "Right" : "") }), c;
        }, W.prototype[e + "Right"] = function(n) {
          return this.reverse()[e](n).reverse();
        };
      }), Ye(["filter", "map", "takeWhile"], function(e, i) {
        var n = i + 1, c = n == Jo || n == Fl;
        W.prototype[e] = function(h) {
          var f = this.clone();
          return f.__iteratees__.push({ iteratee: j(h, 3), type: n }), f.__filtered__ = f.__filtered__ || c, f;
        };
      }), Ye(["head", "last"], function(e, i) {
        var n = "take" + (i ? "Right" : "");
        W.prototype[e] = function() {
          return this[n](1).value()[0];
        };
      }), Ye(["initial", "tail"], function(e, i) {
        var n = "drop" + (i ? "" : "Right");
        W.prototype[e] = function() {
          return this.__filtered__ ? new W(this) : this[n](1);
        };
      }), W.prototype.compact = function() {
        return this.filter(Ue);
      }, W.prototype.find = function(e) {
        return this.filter(e).head();
      }, W.prototype.findLast = function(e) {
        return this.reverse().find(e);
      }, W.prototype.invokeMap = K(function(e, i) {
        return typeof e == "function" ? new W(this) : this.map(function(n) {
          return ii(n, e, i);
        });
      }), W.prototype.reject = function(e) {
        return this.filter(gs(j(e)));
      }, W.prototype.slice = function(e, i) {
        e = z(e);
        var n = this;
        return n.__filtered__ && (e > 0 || i < 0) ? new W(n) : (e < 0 ? n = n.takeRight(-e) : e && (n = n.drop(e)), i !== r && (i = z(i), n = i < 0 ? n.dropRight(-i) : n.take(i - e)), n);
      }, W.prototype.takeRightWhile = function(e) {
        return this.reverse().takeWhile(e).reverse();
      }, W.prototype.toArray = function() {
        return this.take(yt);
      }, vt(W.prototype, function(e, i) {
        var n = /^(?:filter|find|map|reject)|While$/.test(i), c = /^(?:head|last)$/.test(i), h = p[c ? "take" + (i == "last" ? "Right" : "") : i], f = c || /^find/.test(i);
        h && (p.prototype[i] = function() {
          var d = this.__wrapped__, y = c ? [1] : arguments, m = d instanceof W, I = y[0], P = m || k(d), O = function(B) {
            var Q = h.apply(p, Ut([B], y));
            return c && N ? Q[0] : Q;
          };
          P && n && typeof I == "function" && I.length != 1 && (m = P = !1);
          var N = this.__chain__, D = !!this.__actions__.length, U = f && !N, H = m && !D;
          if (!f && P) {
            d = H ? d : new W(this);
            var M = e.apply(d, y);
            return M.__actions__.push({ func: ls, args: [O], thisArg: r }), new Xe(M, N);
          }
          return U && H ? e.apply(this, y) : (M = this.thru(O), U ? c ? M.value()[0] : M.value() : M);
        });
      }), Ye(["pop", "push", "shift", "sort", "splice", "unshift"], function(e) {
        var i = ji[e], n = /^(?:push|sort|unshift)$/.test(e) ? "tap" : "thru", c = /^(?:pop|shift)$/.test(e);
        p.prototype[e] = function() {
          var h = arguments;
          if (c && !this.__chain__) {
            var f = this.value();
            return i.apply(k(f) ? f : [], h);
          }
          return this[n](function(d) {
            return i.apply(k(d) ? d : [], h);
          });
        };
      }), vt(W.prototype, function(e, i) {
        var n = p[i];
        if (n) {
          var c = n.name + "";
          te.call(Pr, c) || (Pr[c] = []), Pr[c].push({ name: i, func: n });
        }
      }), Pr[ss(r, G).name] = [{ name: "wrapper", func: r }], W.prototype.clone = Mf, W.prototype.reverse = Lf, W.prototype.value = kf, p.prototype.at = yy, p.prototype.chain = vy, p.prototype.commit = my, p.prototype.next = wy, p.prototype.plant = by, p.prototype.reverse = Ey, p.prototype.toJSON = p.prototype.valueOf = p.prototype.value = Iy, p.prototype.first = p.prototype.head, Jr && (p.prototype[Jr] = _y), p;
    }, br = mf();
    Yt ? ((Yt.exports = br)._ = br, Xs._ = br) : Ee._ = br;
  }).call(yi);
})(No, No.exports);
var EI = Object.defineProperty, II = Object.defineProperties, PI = Object.getOwnPropertyDescriptors, Ah = Object.getOwnPropertySymbols, SI = Object.prototype.hasOwnProperty, OI = Object.prototype.propertyIsEnumerable, xh = (a, t, r) => t in a ? EI(a, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : a[t] = r, bs = (a, t) => {
  for (var r in t || (t = {})) SI.call(t, r) && xh(a, r, t[r]);
  if (Ah) for (var r of Ah(t)) OI.call(t, r) && xh(a, r, t[r]);
  return a;
}, RI = (a, t) => II(a, PI(t));
function Qt(a, t, r) {
  var s;
  const o = Q_(a);
  return ((s = t.rpcMap) == null ? void 0 : s[o.reference]) || `${bI}?chainId=${o.namespace}:${o.reference}&projectId=${r}`;
}
function fr(a) {
  return a.includes(":") ? a.split(":")[1] : a;
}
function $l(a) {
  return a.map((t) => `${t.split(":")[0]}:${t.split(":")[1]}`);
}
function $I(a, t) {
  const r = Object.keys(t.namespaces).filter((o) => o.includes(a));
  if (!r.length) return [];
  const s = [];
  return r.forEach((o) => {
    const u = t.namespaces[o].accounts;
    s.push(...u);
  }), s;
}
function CI(a = {}, t = {}) {
  const r = Dh(a), s = Dh(t);
  return No.exports.merge(r, s);
}
function Dh(a) {
  var t, r, s, o;
  const u = {};
  if (!Fr(a)) return u;
  for (const [l, g] of Object.entries(a)) {
    const w = Vo(l) ? [l] : g.chains, b = g.methods || [], $ = g.events || [], S = g.rpcMap || {}, R = vi(l);
    u[R] = RI(bs(bs({}, u[R]), g), { chains: ao(w, (t = u[R]) == null ? void 0 : t.chains), methods: ao(b, (r = u[R]) == null ? void 0 : r.methods), events: ao($, (s = u[R]) == null ? void 0 : s.events), rpcMap: bs(bs({}, S), (o = u[R]) == null ? void 0 : o.rpcMap) });
  }
  return u;
}
function NI(a) {
  return a.includes(":") ? a.split(":")[2] : a;
}
function TI(a) {
  const t = {};
  for (const [r, s] of Object.entries(a)) {
    const o = s.methods || [], u = s.events || [], l = s.accounts || [], g = Vo(r) ? [r] : s.chains ? s.chains : $l(s.accounts);
    t[r] = { chains: g, methods: o, events: u, accounts: l };
  }
  return t;
}
function go(a) {
  return typeof a == "number" ? a : a.includes("0x") ? parseInt(a, 16) : a.includes(":") ? Number(a.split(":")[1]) : Number(a);
}
const Cl = {}, ce = (a) => Cl[a], yo = (a, t) => {
  Cl[a] = t;
};
class AI {
  constructor(t) {
    this.name = "polkadot", this.namespace = t.namespace, this.events = ce("events"), this.client = ce("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, r) {
    this.httpProviders[t] || this.setHttpProvider(t, r), this.chainId = t, this.events.emit(Ft.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((r) => {
      var s;
      const o = fr(r);
      t[o] = this.createHttpProvider(o, (s = this.namespace.rpcMap) == null ? void 0 : s[r]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, r = this.httpProviders[t];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return r;
  }
  setHttpProvider(t, r) {
    const s = this.createHttpProvider(t, r);
    s && (this.httpProviders[t] = s);
  }
  createHttpProvider(t, r) {
    const s = r || Qt(t, this.namespace, this.client.core.projectId);
    if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new Dt(new Jt(s, ce("disableProviderPing")));
  }
}
class xI {
  constructor(t) {
    this.name = "eip155", this.namespace = t.namespace, this.events = ce("events"), this.client = ce("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(t) {
    switch (t.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(t);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
    }
    return this.namespace.methods.includes(t.request.method) ? await this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  setDefaultChain(t, r) {
    this.httpProviders[t] || this.setHttpProvider(parseInt(t), r), this.chainId = parseInt(t), this.events.emit(Ft.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  createHttpProvider(t, r) {
    const s = r || Qt(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
    if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new Dt(new Jt(s, ce("disableProviderPing")));
  }
  setHttpProvider(t, r) {
    const s = this.createHttpProvider(t, r);
    s && (this.httpProviders[t] = s);
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((r) => {
      var s;
      const o = parseInt(fr(r));
      t[o] = this.createHttpProvider(o, (s = this.namespace.rpcMap) == null ? void 0 : s[r]);
    }), t;
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const t = this.chainId, r = this.httpProviders[t];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return r;
  }
  async handleSwitchChain(t) {
    var r, s;
    let o = t.request.params ? (r = t.request.params[0]) == null ? void 0 : r.chainId : "0x0";
    o = o.startsWith("0x") ? o : `0x${o}`;
    const u = parseInt(o, 16);
    if (this.isChainApproved(u)) this.setDefaultChain(`${u}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: t.topic, request: { method: t.request.method, params: [{ chainId: o }] }, chainId: (s = this.namespace.chains) == null ? void 0 : s[0] }), this.setDefaultChain(`${u}`);
    else throw new Error(`Failed to switch to chain 'eip155:${u}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(t) {
    return this.namespace.chains.includes(`${this.name}:${t}`);
  }
}
class DI {
  constructor(t) {
    this.name = "solana", this.namespace = t.namespace, this.events = ce("events"), this.client = ce("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, r) {
    this.httpProviders[t] || this.setHttpProvider(t, r), this.chainId = t, this.events.emit(Ft.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((r) => {
      var s;
      const o = fr(r);
      t[o] = this.createHttpProvider(o, (s = this.namespace.rpcMap) == null ? void 0 : s[r]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, r = this.httpProviders[t];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return r;
  }
  setHttpProvider(t, r) {
    const s = this.createHttpProvider(t, r);
    s && (this.httpProviders[t] = s);
  }
  createHttpProvider(t, r) {
    const s = r || Qt(t, this.namespace, this.client.core.projectId);
    if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new Dt(new Jt(s, ce("disableProviderPing")));
  }
}
class FI {
  constructor(t) {
    this.name = "cosmos", this.namespace = t.namespace, this.events = ce("events"), this.client = ce("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, r) {
    this.httpProviders[t] || this.setHttpProvider(t, r), this.chainId = t, this.events.emit(Ft.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((r) => {
      var s;
      const o = fr(r);
      t[o] = this.createHttpProvider(o, (s = this.namespace.rpcMap) == null ? void 0 : s[r]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, r = this.httpProviders[t];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return r;
  }
  setHttpProvider(t, r) {
    const s = this.createHttpProvider(t, r);
    s && (this.httpProviders[t] = s);
  }
  createHttpProvider(t, r) {
    const s = r || Qt(t, this.namespace, this.client.core.projectId);
    if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new Dt(new Jt(s, ce("disableProviderPing")));
  }
}
class qI {
  constructor(t) {
    this.name = "cip34", this.namespace = t.namespace, this.events = ce("events"), this.client = ce("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, r) {
    this.httpProviders[t] || this.setHttpProvider(t, r), this.chainId = t, this.events.emit(Ft.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((r) => {
      const s = this.getCardanoRPCUrl(r), o = fr(r);
      t[o] = this.createHttpProvider(o, s);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, r = this.httpProviders[t];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return r;
  }
  getCardanoRPCUrl(t) {
    const r = this.namespace.rpcMap;
    if (r) return r[t];
  }
  setHttpProvider(t, r) {
    const s = this.createHttpProvider(t, r);
    s && (this.httpProviders[t] = s);
  }
  createHttpProvider(t, r) {
    const s = r || this.getCardanoRPCUrl(t);
    if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new Dt(new Jt(s, ce("disableProviderPing")));
  }
}
class jI {
  constructor(t) {
    this.name = "elrond", this.namespace = t.namespace, this.events = ce("events"), this.client = ce("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, r) {
    this.httpProviders[t] || this.setHttpProvider(t, r), this.chainId = t, this.events.emit(Ft.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((r) => {
      var s;
      const o = fr(r);
      t[o] = this.createHttpProvider(o, (s = this.namespace.rpcMap) == null ? void 0 : s[r]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, r = this.httpProviders[t];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return r;
  }
  setHttpProvider(t, r) {
    const s = this.createHttpProvider(t, r);
    s && (this.httpProviders[t] = s);
  }
  createHttpProvider(t, r) {
    const s = r || Qt(t, this.namespace, this.client.core.projectId);
    if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new Dt(new Jt(s, ce("disableProviderPing")));
  }
}
class UI {
  constructor(t) {
    this.name = "multiversx", this.namespace = t.namespace, this.events = ce("events"), this.client = ce("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, r) {
    this.httpProviders[t] || this.setHttpProvider(t, r), this.chainId = t, this.events.emit(Ft.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((r) => {
      var s;
      const o = fr(r);
      t[o] = this.createHttpProvider(o, (s = this.namespace.rpcMap) == null ? void 0 : s[r]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, r = this.httpProviders[t];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return r;
  }
  setHttpProvider(t, r) {
    const s = this.createHttpProvider(t, r);
    s && (this.httpProviders[t] = s);
  }
  createHttpProvider(t, r) {
    const s = r || Qt(t, this.namespace, this.client.core.projectId);
    if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new Dt(new Jt(s, ce("disableProviderPing")));
  }
}
class MI {
  constructor(t) {
    this.name = "near", this.namespace = t.namespace, this.events = ce("events"), this.client = ce("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, r) {
    if (this.chainId = t, !this.httpProviders[t]) {
      const s = r || Qt(`${this.name}:${t}`, this.namespace);
      if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, s);
    }
    this.events.emit(Ft.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((r) => {
      var s;
      t[r] = this.createHttpProvider(r, (s = this.namespace.rpcMap) == null ? void 0 : s[r]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, r = this.httpProviders[t];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return r;
  }
  setHttpProvider(t, r) {
    const s = this.createHttpProvider(t, r);
    s && (this.httpProviders[t] = s);
  }
  createHttpProvider(t, r) {
    const s = r || Qt(t, this.namespace);
    return typeof s > "u" ? void 0 : new Dt(new Jt(s, ce("disableProviderPing")));
  }
}
var LI = Object.defineProperty, kI = Object.defineProperties, zI = Object.getOwnPropertyDescriptors, Fh = Object.getOwnPropertySymbols, HI = Object.prototype.hasOwnProperty, VI = Object.prototype.propertyIsEnumerable, qh = (a, t, r) => t in a ? LI(a, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : a[t] = r, Es = (a, t) => {
  for (var r in t || (t = {})) HI.call(t, r) && qh(a, r, t[r]);
  if (Fh) for (var r of Fh(t)) VI.call(t, r) && qh(a, r, t[r]);
  return a;
}, vo = (a, t) => kI(a, zI(t));
class Go {
  constructor(t) {
    this.events = new Do(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = !1, this.maxPairingAttempts = 10, this.disableProviderPing = !1, this.providerOpts = t, this.logger = typeof (t == null ? void 0 : t.logger) < "u" && typeof (t == null ? void 0 : t.logger) != "string" ? t.logger : Ts(As({ level: (t == null ? void 0 : t.logger) || Nh })), this.disableProviderPing = (t == null ? void 0 : t.disableProviderPing) || !1;
  }
  static async init(t) {
    const r = new Go(t);
    return await r.initialize(), r;
  }
  async request(t, r) {
    const [s, o] = this.validateChain(r);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(s).request({ request: Es({}, t), chainId: `${s}:${o}`, topic: this.session.topic });
  }
  sendAsync(t, r, s) {
    const o = (/* @__PURE__ */ new Date()).getTime();
    this.request(t, s).then((u) => r(null, xs(o, u))).catch((u) => r(u, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var t;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (t = this.session) == null ? void 0 : t.topic, reason: ye("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(t) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(t), await this.cleanupPendingPairings(), !t.skipPairing) return await this.pair(t.pairingTopic);
  }
  on(t, r) {
    this.events.on(t, r);
  }
  once(t, r) {
    this.events.once(t, r);
  }
  removeListener(t, r) {
    this.events.removeListener(t, r);
  }
  off(t, r) {
    this.events.off(t, r);
  }
  get isWalletConnect() {
    return !0;
  }
  async pair(t) {
    this.shouldAbortPairingAttempt = !1;
    let r = 0;
    do {
      if (this.shouldAbortPairingAttempt) throw new Error("Pairing aborted");
      if (r >= this.maxPairingAttempts) throw new Error("Max auto pairing attempts reached");
      const { uri: s, approval: o } = await this.client.connect({ pairingTopic: t, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
      s && (this.uri = s, this.events.emit("display_uri", s)), await o().then((u) => {
        this.session = u, this.namespaces || (this.namespaces = TI(u.namespaces), this.persist("namespaces", this.namespaces));
      }).catch((u) => {
        if (u.message !== Ol) throw u;
        r++;
      });
    } while (!this.session);
    return this.onConnect(), this.session;
  }
  setDefaultChain(t, r) {
    try {
      if (!this.session) return;
      const [s, o] = this.validateChain(t);
      this.getProvider(s).setDefaultChain(o, r);
    } catch (s) {
      if (!/Please call connect/.test(s.message)) throw s;
    }
  }
  async cleanupPendingPairings(t = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const r = this.client.pairing.getAll();
    if (cr(r)) {
      for (const s of r) t.deletePairings ? this.client.core.expirer.set(s.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(s.topic);
      this.logger.info(`Inactive pairings cleared: ${r.length}`);
    }
  }
  abortPairingAttempt() {
    this.shouldAbortPairingAttempt = !0;
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const t = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[t]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await aI.init({ logger: this.providerOpts.logger || Nh, relayUrl: this.providerOpts.relayUrl || mI, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const t = [...new Set(Object.keys(this.session.namespaces).map((r) => vi(r)))];
    yo("client", this.client), yo("events", this.events), yo("disableProviderPing", this.disableProviderPing), t.forEach((r) => {
      if (!this.session) return;
      const s = $I(r, this.session), o = $l(s), u = CI(this.namespaces, this.optionalNamespaces), l = vo(Es({}, u[r]), { accounts: s, chains: o });
      switch (r) {
        case "eip155":
          this.rpcProviders[r] = new xI({ namespace: l });
          break;
        case "solana":
          this.rpcProviders[r] = new DI({ namespace: l });
          break;
        case "cosmos":
          this.rpcProviders[r] = new FI({ namespace: l });
          break;
        case "polkadot":
          this.rpcProviders[r] = new AI({ namespace: l });
          break;
        case "cip34":
          this.rpcProviders[r] = new qI({ namespace: l });
          break;
        case "elrond":
          this.rpcProviders[r] = new jI({ namespace: l });
          break;
        case "multiversx":
          this.rpcProviders[r] = new UI({ namespace: l });
          break;
        case "near":
          this.rpcProviders[r] = new MI({ namespace: l });
          break;
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (t) => {
      this.events.emit("session_ping", t);
    }), this.client.on("session_event", (t) => {
      const { params: r } = t, { event: s } = r;
      if (s.name === "accountsChanged") {
        const o = s.data;
        o && cr(o) && this.events.emit("accountsChanged", o.map(NI));
      } else if (s.name === "chainChanged") {
        const o = r.chainId, u = r.event.data, l = vi(o), g = go(o) !== go(u) ? `${l}:${go(u)}` : o;
        this.onChainChanged(g);
      } else this.events.emit(s.name, s.data);
      this.events.emit("session_event", t);
    }), this.client.on("session_update", ({ topic: t, params: r }) => {
      var s;
      const { namespaces: o } = r, u = (s = this.client) == null ? void 0 : s.session.get(t);
      this.session = vo(Es({}, u), { namespaces: o }), this.onSessionUpdate(), this.events.emit("session_update", { topic: t, params: r });
    }), this.client.on("session_delete", async (t) => {
      await this.cleanup(), this.events.emit("session_delete", t), this.events.emit("disconnect", vo(Es({}, ye("USER_DISCONNECTED")), { data: t.topic }));
    }), this.on(Ft.DEFAULT_CHAIN_CHANGED, (t) => {
      this.onChainChanged(t, !0);
    });
  }
  getProvider(t) {
    if (!this.rpcProviders[t]) throw new Error(`Provider not found: ${t}`);
    return this.rpcProviders[t];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((t) => {
      var r;
      this.getProvider(t).updateNamespace((r = this.session) == null ? void 0 : r.namespaces[t]);
    });
  }
  setNamespaces(t) {
    const { namespaces: r, optionalNamespaces: s, sessionProperties: o } = t;
    r && Object.keys(r).length && (this.namespaces = r), s && Object.keys(s).length && (this.optionalNamespaces = s), this.sessionProperties = o, this.persist("namespaces", r), this.persist("optionalNamespaces", s);
  }
  validateChain(t) {
    const [r, s] = (t == null ? void 0 : t.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [r, s];
    if (r && !Object.keys(this.namespaces || {}).map((l) => vi(l)).includes(r)) throw new Error(`Namespace '${r}' is not configured. Please call connect() first with namespace config.`);
    if (r && s) return [r, s];
    const o = vi(Object.keys(this.namespaces)[0]), u = this.rpcProviders[o].getDefaultChain();
    return [o, u];
  }
  async requestAccounts() {
    const [t] = this.validateChain();
    return await this.getProvider(t).requestAccounts();
  }
  onChainChanged(t, r = !1) {
    var s;
    if (!this.namespaces) return;
    const [o, u] = this.validateChain(t);
    r || this.getProvider(o).setDefaultChain(u), ((s = this.namespaces[o]) != null ? s : this.namespaces[`${o}:${u}`]).defaultChain = u, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", u);
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: !0 });
  }
  persist(t, r) {
    this.client.core.storage.setItem(`${Th}/${t}`, r);
  }
  async getFromStore(t) {
    return await this.client.core.storage.getItem(`${Th}/${t}`);
  }
}
const KI = Go, BI = "wc", WI = "ethereum_provider", GI = `${BI}@2:${WI}:`, QI = "https://rpc.walletconnect.com/v1/", To = ["eth_sendTransaction", "personal_sign"], JI = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode"], Ao = ["chainChanged", "accountsChanged"], YI = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
var ZI = Object.defineProperty, XI = Object.defineProperties, eP = Object.getOwnPropertyDescriptors, jh = Object.getOwnPropertySymbols, tP = Object.prototype.hasOwnProperty, rP = Object.prototype.propertyIsEnumerable, Uh = (a, t, r) => t in a ? ZI(a, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : a[t] = r, wi = (a, t) => {
  for (var r in t || (t = {})) tP.call(t, r) && Uh(a, r, t[r]);
  if (jh) for (var r of jh(t)) rP.call(t, r) && Uh(a, r, t[r]);
  return a;
}, Mh = (a, t) => XI(a, eP(t));
function $s(a) {
  return Number(a[0].split(":")[1]);
}
function mo(a) {
  return `0x${a.toString(16)}`;
}
function iP(a) {
  const { chains: t, optionalChains: r, methods: s, optionalMethods: o, events: u, optionalEvents: l, rpcMap: g } = a;
  if (!wo(t)) throw new Error("Invalid chains");
  const w = { chains: t, methods: s || To, events: u || Ao, rpcMap: wi({}, t.length ? { [$s(t)]: g[$s(t)] } : {}) }, b = u == null ? void 0 : u.filter((q) => !Ao.includes(q)), $ = s == null ? void 0 : s.filter((q) => !To.includes(q));
  if (!r && !l && !o && !(b != null && b.length) && !($ != null && $.length)) return { required: t.length ? w : void 0 };
  const S = (b == null ? void 0 : b.length) && ($ == null ? void 0 : $.length) || !r, R = { chains: [...new Set(S ? w.chains.concat(r || []) : r)], methods: [...new Set(w.methods.concat(o != null && o.length ? o : JI))], events: [...new Set(w.events.concat(l != null && l.length ? l : YI))], rpcMap: g };
  return { required: t.length ? w : void 0, optional: r.length ? R : void 0 };
}
class Qo {
  constructor() {
    this.events = new ot.EventEmitter(), this.namespace = "eip155", this.accounts = [], this.chainId = 1, this.STORAGE_KEY = GI, this.on = (t, r) => (this.events.on(t, r), this), this.once = (t, r) => (this.events.once(t, r), this), this.removeListener = (t, r) => (this.events.removeListener(t, r), this), this.off = (t, r) => (this.events.off(t, r), this), this.parseAccount = (t) => this.isCompatibleChainId(t) ? this.parseAccountId(t).address : t, this.signer = {}, this.rpc = {};
  }
  static async init(t) {
    const r = new Qo();
    return await r.initialize(t), r;
  }
  async request(t) {
    return await this.signer.request(t, this.formatChainId(this.chainId));
  }
  sendAsync(t, r) {
    this.signer.sendAsync(t, r, this.formatChainId(this.chainId));
  }
  get connected() {
    return this.signer.client ? this.signer.client.core.relayer.connected : !1;
  }
  get connecting() {
    return this.signer.client ? this.signer.client.core.relayer.connecting : !1;
  }
  async enable() {
    return this.session || await this.connect(), await this.request({ method: "eth_requestAccounts" });
  }
  async connect(t) {
    if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts(t);
    const { required: r, optional: s } = iP(this.rpc);
    try {
      const o = await new Promise(async (l, g) => {
        var w;
        this.rpc.showQrModal && ((w = this.modal) == null || w.subscribeModal((b) => {
          !b.open && !this.signer.session && (this.signer.abortPairingAttempt(), g(new Error("Connection request reset. Please try again.")));
        })), await this.signer.connect(Mh(wi({ namespaces: wi({}, r && { [this.namespace]: r }) }, s && { optionalNamespaces: { [this.namespace]: s } }), { pairingTopic: t == null ? void 0 : t.pairingTopic })).then((b) => {
          l(b);
        }).catch((b) => {
          g(new Error(b.message));
        });
      });
      if (!o) return;
      const u = Qw(o.namespaces, [this.namespace]);
      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : u), this.setAccounts(u), this.events.emit("connect", { chainId: mo(this.chainId) });
    } catch (o) {
      throw this.signer.logger.error(o), o;
    } finally {
      this.modal && this.modal.closeModal();
    }
  }
  async disconnect() {
    this.session && await this.signer.disconnect(), this.reset();
  }
  get isWalletConnect() {
    return !0;
  }
  get session() {
    return this.signer.session;
  }
  registerEventListeners() {
    this.signer.on("session_event", (t) => {
      const { params: r } = t, { event: s } = r;
      s.name === "accountsChanged" ? (this.accounts = this.parseAccounts(s.data), this.events.emit("accountsChanged", this.accounts)) : s.name === "chainChanged" ? this.setChainId(this.formatChainId(s.data)) : this.events.emit(s.name, s.data), this.events.emit("session_event", t);
    }), this.signer.on("chainChanged", (t) => {
      const r = parseInt(t);
      this.chainId = r, this.events.emit("chainChanged", mo(this.chainId)), this.persist();
    }), this.signer.on("session_update", (t) => {
      this.events.emit("session_update", t);
    }), this.signer.on("session_delete", (t) => {
      this.reset(), this.events.emit("session_delete", t), this.events.emit("disconnect", Mh(wi({}, Yw("USER_DISCONNECTED")), { data: t.topic, name: "USER_DISCONNECTED" }));
    }), this.signer.on("display_uri", (t) => {
      var r, s;
      this.rpc.showQrModal && ((r = this.modal) == null || r.closeModal(), (s = this.modal) == null || s.openModal({ uri: t })), this.events.emit("display_uri", t);
    });
  }
  switchEthereumChain(t) {
    this.request({ method: "wallet_switchEthereumChain", params: [{ chainId: t.toString(16) }] });
  }
  isCompatibleChainId(t) {
    return typeof t == "string" ? t.startsWith(`${this.namespace}:`) : !1;
  }
  formatChainId(t) {
    return `${this.namespace}:${t}`;
  }
  parseChainId(t) {
    return Number(t.split(":")[1]);
  }
  setChainIds(t) {
    const r = t.filter((s) => this.isCompatibleChainId(s)).map((s) => this.parseChainId(s));
    r.length && (this.chainId = r[0], this.events.emit("chainChanged", mo(this.chainId)), this.persist());
  }
  setChainId(t) {
    if (this.isCompatibleChainId(t)) {
      const r = this.parseChainId(t);
      this.chainId = r, this.switchEthereumChain(r);
    }
  }
  parseAccountId(t) {
    const [r, s, o] = t.split(":");
    return { chainId: `${r}:${s}`, address: o };
  }
  setAccounts(t) {
    this.accounts = t.filter((r) => this.parseChainId(this.parseAccountId(r).chainId) === this.chainId).map((r) => this.parseAccountId(r).address), this.events.emit("accountsChanged", this.accounts);
  }
  getRpcConfig(t) {
    var r, s;
    const o = (r = t == null ? void 0 : t.chains) != null ? r : [], u = (s = t == null ? void 0 : t.optionalChains) != null ? s : [], l = o.concat(u);
    if (!l.length) throw new Error("No chains specified in either `chains` or `optionalChains`");
    const g = o.length ? (t == null ? void 0 : t.methods) || To : [], w = o.length ? (t == null ? void 0 : t.events) || Ao : [], b = (t == null ? void 0 : t.optionalMethods) || [], $ = (t == null ? void 0 : t.optionalEvents) || [], S = (t == null ? void 0 : t.rpcMap) || this.buildRpcMap(l, t.projectId), R = (t == null ? void 0 : t.qrModalOptions) || void 0;
    return { chains: o == null ? void 0 : o.map((q) => this.formatChainId(q)), optionalChains: u.map((q) => this.formatChainId(q)), methods: g, events: w, optionalMethods: b, optionalEvents: $, rpcMap: S, showQrModal: !!(t != null && t.showQrModal), qrModalOptions: R, projectId: t.projectId, metadata: t.metadata };
  }
  buildRpcMap(t, r) {
    const s = {};
    return t.forEach((o) => {
      s[o] = this.getRpcUrl(o, r);
    }), s;
  }
  async initialize(t) {
    if (this.rpc = this.getRpcConfig(t), this.chainId = this.rpc.chains.length ? $s(this.rpc.chains) : $s(this.rpc.optionalChains), this.signer = await KI.init({ projectId: this.rpc.projectId, metadata: this.rpc.metadata, disableProviderPing: t.disableProviderPing, relayUrl: t.relayUrl, storageOptions: t.storageOptions }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
      let r;
      try {
        const { WalletConnectModal: s } = await import("./index-CDBL7oHs.mjs").then((o) => o.i);
        r = s;
      } catch {
        throw new Error("To use QR modal, please install @walletconnect/modal package");
      }
      if (r) try {
        this.modal = new r(wi({ projectId: this.rpc.projectId }, this.rpc.qrModalOptions));
      } catch (s) {
        throw this.signer.logger.error(s), new Error("Could not generate WalletConnectModal Instance");
      }
    }
  }
  loadConnectOpts(t) {
    if (!t) return;
    const { chains: r, optionalChains: s, rpcMap: o } = t;
    r && wo(r) && (this.rpc.chains = r.map((u) => this.formatChainId(u)), r.forEach((u) => {
      this.rpc.rpcMap[u] = (o == null ? void 0 : o[u]) || this.getRpcUrl(u);
    })), s && wo(s) && (this.rpc.optionalChains = [], this.rpc.optionalChains = s == null ? void 0 : s.map((u) => this.formatChainId(u)), s.forEach((u) => {
      this.rpc.rpcMap[u] = (o == null ? void 0 : o[u]) || this.getRpcUrl(u);
    }));
  }
  getRpcUrl(t, r) {
    var s;
    return ((s = this.rpc.rpcMap) == null ? void 0 : s[t]) || `${QI}?chainId=eip155:${t}&projectId=${r || this.rpc.projectId}`;
  }
  async loadPersistedSession() {
    if (!this.session) return;
    const t = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`), r = this.session.namespaces[`${this.namespace}:${t}`] ? this.session.namespaces[`${this.namespace}:${t}`] : this.session.namespaces[this.namespace];
    this.setChainIds(t ? [this.formatChainId(t)] : r == null ? void 0 : r.accounts), this.setAccounts(r == null ? void 0 : r.accounts);
  }
  reset() {
    this.chainId = 1, this.accounts = [];
  }
  persist() {
    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);
  }
  parseAccounts(t) {
    return typeof t == "string" || t instanceof String ? [this.parseAccount(t)] : t.map((r) => this.parseAccount(r));
  }
}
const EP = Qo;
export {
  EP as EthereumProvider,
  YI as OPTIONAL_EVENTS,
  JI as OPTIONAL_METHODS,
  Ao as REQUIRED_EVENTS,
  To as REQUIRED_METHODS,
  Qo as default
};
