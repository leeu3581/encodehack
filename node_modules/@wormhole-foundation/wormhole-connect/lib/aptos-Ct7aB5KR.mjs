var Uf = Object.defineProperty;
var Cf = (t, e, n) => e in t ? Uf(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var Jn = (t, e, n) => Cf(t, typeof e != "symbol" ? e + "" : e, n);
import { O as Je, av as zf, aw as St, Q as Iu, ax as kf, as as Of, ay as ss, az as kn, T as Lf, aA as Va, U as Za, Z as qa, a3 as jf, aB as Pf, a7 as _f } from "./index-CGIqRhuR.mjs";
import { B as Xo, l as $e, f as mn, E as Ke, m as pr, d as Fn, a as as, e as Ye, r as ar, n as Gn, z as ii, b as Mu, c as un, g as on, I as Bf, h as Es, j as Rf, i as oi, k as Ff, p as Nu, q as gr, y as Jo, u as Ai, s as cr, v as xu, w as Wf, L as cs, x as Qf, A as mo, t as is, C as Kf, D as Su, F as Hf, G as Yf, H as Gf, J as Vf, K as Zf, M as qf } from "./chunk-IMTC3J2M-ldki5kWL.mjs";
import { g as Xf } from "./wallets-B2tqS5lZ.mjs";
function Bs(t, e) {
  if (!!!t)
    throw new Error(e);
}
function Jf(t) {
  return typeof t == "object" && t !== null;
}
function $f(t, e) {
  if (!!!t)
    throw new Error(
      "Unexpected invariant triggered."
    );
}
const ep = /\r\n|[\n\r]/g;
function vo(t, e) {
  let n = 0, r = 1;
  for (const s of t.body.matchAll(ep)) {
    if (typeof s.index == "number" || $f(!1), s.index >= e)
      break;
    n = s.index + s[0].length, r += 1;
  }
  return {
    line: r,
    column: e + 1 - n
  };
}
function tp(t) {
  return Du(
    t.source,
    vo(t.source, t.start)
  );
}
function Du(t, e) {
  const n = t.locationOffset.column - 1, r = "".padStart(n) + t.body, s = e.line - 1, o = t.locationOffset.line - 1, c = e.line + o, l = e.line === 1 ? n : 0, f = e.column + l, p = `${t.name}:${c}:${f}
`, y = r.split(/\r\n|[\n\r]/g), w = y[s];
  if (w.length > 120) {
    const b = Math.floor(f / 80), x = f % 80, I = [];
    for (let z = 0; z < w.length; z += 80)
      I.push(w.slice(z, z + 80));
    return p + Xa([
      [`${c} |`, I[0]],
      ...I.slice(1, b + 1).map((z) => ["|", z]),
      ["|", "^".padStart(x)],
      ["|", I[b + 1]]
    ]);
  }
  return p + Xa([
    // Lines specified like this: ["prefix", "string"],
    [`${c - 1} |`, y[s - 1]],
    [`${c} |`, w],
    ["|", "^".padStart(f)],
    [`${c + 1} |`, y[s + 1]]
  ]);
}
function Xa(t) {
  const e = t.filter(([r, s]) => s !== void 0), n = Math.max(...e.map(([r]) => r.length));
  return e.map(([r, s]) => r.padStart(n) + (s ? " " + s : "")).join(`
`);
}
function np(t) {
  const e = t[0];
  return e == null || "kind" in e || "length" in e ? {
    nodes: e,
    source: t[1],
    positions: t[2],
    path: t[3],
    originalError: t[4],
    extensions: t[5]
  } : e;
}
class $o extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(e, ...n) {
    var r, s, o;
    const { nodes: c, source: l, positions: f, path: p, originalError: y, extensions: w } = np(n);
    super(e), this.name = "GraphQLError", this.path = p ?? void 0, this.originalError = y ?? void 0, this.nodes = Ja(
      Array.isArray(c) ? c : c ? [c] : void 0
    );
    const b = Ja(
      (r = this.nodes) === null || r === void 0 ? void 0 : r.map((I) => I.loc).filter((I) => I != null)
    );
    this.source = l ?? (b == null || (s = b[0]) === null || s === void 0 ? void 0 : s.source), this.positions = f ?? (b == null ? void 0 : b.map((I) => I.start)), this.locations = f && l ? f.map((I) => vo(l, I)) : b == null ? void 0 : b.map((I) => vo(I.source, I.start));
    const x = Jf(
      y == null ? void 0 : y.extensions
    ) ? y == null ? void 0 : y.extensions : void 0;
    this.extensions = (o = w ?? x) !== null && o !== void 0 ? o : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), y != null && y.stack ? Object.defineProperty(this, "stack", {
      value: y.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, $o) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let e = this.message;
    if (this.nodes)
      for (const n of this.nodes)
        n.loc && (e += `

` + tp(n.loc));
    else if (this.source && this.locations)
      for (const n of this.locations)
        e += `

` + Du(this.source, n);
    return e;
  }
  toJSON() {
    const e = {
      message: this.message
    };
    return this.locations != null && (e.locations = this.locations), this.path != null && (e.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (e.extensions = this.extensions), e;
  }
}
function Ja(t) {
  return t === void 0 || t.length === 0 ? void 0 : t;
}
function it(t, e, n) {
  return new $o(`Syntax Error: ${n}`, {
    source: t,
    positions: [e]
  });
}
class rp {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(e, n, r) {
    this.start = e.start, this.end = n.end, this.startToken = e, this.endToken = n, this.source = r;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
let Uu = class {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(e, n, r, s, o, c) {
    this.kind = e, this.start = n, this.end = r, this.line = s, this.column = o, this.value = c, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
const Cu = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, sp = new Set(Object.keys(Cu));
function $a(t) {
  const e = t == null ? void 0 : t.kind;
  return typeof e == "string" && sp.has(e);
}
var jn;
(function(t) {
  t.QUERY = "query", t.MUTATION = "mutation", t.SUBSCRIPTION = "subscription";
})(jn || (jn = {}));
var Eo;
(function(t) {
  t.QUERY = "QUERY", t.MUTATION = "MUTATION", t.SUBSCRIPTION = "SUBSCRIPTION", t.FIELD = "FIELD", t.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", t.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", t.INLINE_FRAGMENT = "INLINE_FRAGMENT", t.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", t.SCHEMA = "SCHEMA", t.SCALAR = "SCALAR", t.OBJECT = "OBJECT", t.FIELD_DEFINITION = "FIELD_DEFINITION", t.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", t.INTERFACE = "INTERFACE", t.UNION = "UNION", t.ENUM = "ENUM", t.ENUM_VALUE = "ENUM_VALUE", t.INPUT_OBJECT = "INPUT_OBJECT", t.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
})(Eo || (Eo = {}));
var be;
(function(t) {
  t.NAME = "Name", t.DOCUMENT = "Document", t.OPERATION_DEFINITION = "OperationDefinition", t.VARIABLE_DEFINITION = "VariableDefinition", t.SELECTION_SET = "SelectionSet", t.FIELD = "Field", t.ARGUMENT = "Argument", t.FRAGMENT_SPREAD = "FragmentSpread", t.INLINE_FRAGMENT = "InlineFragment", t.FRAGMENT_DEFINITION = "FragmentDefinition", t.VARIABLE = "Variable", t.INT = "IntValue", t.FLOAT = "FloatValue", t.STRING = "StringValue", t.BOOLEAN = "BooleanValue", t.NULL = "NullValue", t.ENUM = "EnumValue", t.LIST = "ListValue", t.OBJECT = "ObjectValue", t.OBJECT_FIELD = "ObjectField", t.DIRECTIVE = "Directive", t.NAMED_TYPE = "NamedType", t.LIST_TYPE = "ListType", t.NON_NULL_TYPE = "NonNullType", t.SCHEMA_DEFINITION = "SchemaDefinition", t.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", t.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", t.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", t.FIELD_DEFINITION = "FieldDefinition", t.INPUT_VALUE_DEFINITION = "InputValueDefinition", t.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", t.UNION_TYPE_DEFINITION = "UnionTypeDefinition", t.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", t.ENUM_VALUE_DEFINITION = "EnumValueDefinition", t.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", t.DIRECTIVE_DEFINITION = "DirectiveDefinition", t.SCHEMA_EXTENSION = "SchemaExtension", t.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", t.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", t.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", t.UNION_TYPE_EXTENSION = "UnionTypeExtension", t.ENUM_TYPE_EXTENSION = "EnumTypeExtension", t.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(be || (be = {}));
function bo(t) {
  return t === 9 || t === 32;
}
function us(t) {
  return t >= 48 && t <= 57;
}
function zu(t) {
  return t >= 97 && t <= 122 || // A-Z
  t >= 65 && t <= 90;
}
function ku(t) {
  return zu(t) || t === 95;
}
function ip(t) {
  return zu(t) || us(t) || t === 95;
}
function op(t) {
  var e;
  let n = Number.MAX_SAFE_INTEGER, r = null, s = -1;
  for (let c = 0; c < t.length; ++c) {
    var o;
    const l = t[c], f = ap(l);
    f !== l.length && (r = (o = r) !== null && o !== void 0 ? o : c, s = c, c !== 0 && f < n && (n = f));
  }
  return t.map((c, l) => l === 0 ? c : c.slice(n)).slice(
    (e = r) !== null && e !== void 0 ? e : 0,
    s + 1
  );
}
function ap(t) {
  let e = 0;
  for (; e < t.length && bo(t.charCodeAt(e)); )
    ++e;
  return e;
}
function cp(t, e) {
  const n = t.replace(/"""/g, '\\"""'), r = n.split(/\r\n|[\n\r]/g), s = r.length === 1, o = r.length > 1 && r.slice(1).every((x) => x.length === 0 || bo(x.charCodeAt(0))), c = n.endsWith('\\"""'), l = t.endsWith('"') && !c, f = t.endsWith("\\"), p = l || f, y = (
    // add leading and trailing new lines only if it improves readability
    !s || t.length > 70 || p || o || c
  );
  let w = "";
  const b = s && bo(t.charCodeAt(0));
  return (y && !b || o) && (w += `
`), w += n, (y || p) && (w += `
`), '"""' + w + '"""';
}
var H;
(function(t) {
  t.SOF = "<SOF>", t.EOF = "<EOF>", t.BANG = "!", t.DOLLAR = "$", t.AMP = "&", t.PAREN_L = "(", t.PAREN_R = ")", t.SPREAD = "...", t.COLON = ":", t.EQUALS = "=", t.AT = "@", t.BRACKET_L = "[", t.BRACKET_R = "]", t.BRACE_L = "{", t.PIPE = "|", t.BRACE_R = "}", t.NAME = "Name", t.INT = "Int", t.FLOAT = "Float", t.STRING = "String", t.BLOCK_STRING = "BlockString", t.COMMENT = "Comment";
})(H || (H = {}));
class up {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(e) {
    const n = new Uu(H.SOF, 0, 0, 0, 0);
    this.source = e, this.lastToken = n, this.token = n, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let e = this.token;
    if (e.kind !== H.EOF)
      do
        if (e.next)
          e = e.next;
        else {
          const n = dp(this, e.end);
          e.next = n, n.prev = e, e = n;
        }
      while (e.kind === H.COMMENT);
    return e;
  }
}
function lp(t) {
  return t === H.BANG || t === H.DOLLAR || t === H.AMP || t === H.PAREN_L || t === H.PAREN_R || t === H.SPREAD || t === H.COLON || t === H.EQUALS || t === H.AT || t === H.BRACKET_L || t === H.BRACKET_R || t === H.BRACE_L || t === H.PIPE || t === H.BRACE_R;
}
function Er(t) {
  return t >= 0 && t <= 55295 || t >= 57344 && t <= 1114111;
}
function mi(t, e) {
  return Ou(t.charCodeAt(e)) && Lu(t.charCodeAt(e + 1));
}
function Ou(t) {
  return t >= 55296 && t <= 56319;
}
function Lu(t) {
  return t >= 56320 && t <= 57343;
}
function Wn(t, e) {
  const n = t.source.body.codePointAt(e);
  if (n === void 0)
    return H.EOF;
  if (n >= 32 && n <= 126) {
    const r = String.fromCodePoint(n);
    return r === '"' ? `'"'` : `"${r}"`;
  }
  return "U+" + n.toString(16).toUpperCase().padStart(4, "0");
}
function nt(t, e, n, r, s) {
  const o = t.line, c = 1 + n - t.lineStart;
  return new Uu(e, n, r, o, c, s);
}
function dp(t, e) {
  const n = t.source.body, r = n.length;
  let s = e;
  for (; s < r; ) {
    const o = n.charCodeAt(s);
    switch (o) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++s;
        continue;
      case 10:
        ++s, ++t.line, t.lineStart = s;
        continue;
      case 13:
        n.charCodeAt(s + 1) === 10 ? s += 2 : ++s, ++t.line, t.lineStart = s;
        continue;
      case 35:
        return hp(t, s);
      case 33:
        return nt(t, H.BANG, s, s + 1);
      case 36:
        return nt(t, H.DOLLAR, s, s + 1);
      case 38:
        return nt(t, H.AMP, s, s + 1);
      case 40:
        return nt(t, H.PAREN_L, s, s + 1);
      case 41:
        return nt(t, H.PAREN_R, s, s + 1);
      case 46:
        if (n.charCodeAt(s + 1) === 46 && n.charCodeAt(s + 2) === 46)
          return nt(t, H.SPREAD, s, s + 3);
        break;
      case 58:
        return nt(t, H.COLON, s, s + 1);
      case 61:
        return nt(t, H.EQUALS, s, s + 1);
      case 64:
        return nt(t, H.AT, s, s + 1);
      case 91:
        return nt(t, H.BRACKET_L, s, s + 1);
      case 93:
        return nt(t, H.BRACKET_R, s, s + 1);
      case 123:
        return nt(t, H.BRACE_L, s, s + 1);
      case 124:
        return nt(t, H.PIPE, s, s + 1);
      case 125:
        return nt(t, H.BRACE_R, s, s + 1);
      case 34:
        return n.charCodeAt(s + 1) === 34 && n.charCodeAt(s + 2) === 34 ? Ap(t, s) : pp(t, s);
    }
    if (us(o) || o === 45)
      return fp(t, s, o);
    if (ku(o))
      return mp(t, s);
    throw it(
      t.source,
      s,
      o === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : Er(o) || mi(n, s) ? `Unexpected character: ${Wn(t, s)}.` : `Invalid character: ${Wn(t, s)}.`
    );
  }
  return nt(t, H.EOF, r, r);
}
function hp(t, e) {
  const n = t.source.body, r = n.length;
  let s = e + 1;
  for (; s < r; ) {
    const o = n.charCodeAt(s);
    if (o === 10 || o === 13)
      break;
    if (Er(o))
      ++s;
    else if (mi(n, s))
      s += 2;
    else
      break;
  }
  return nt(
    t,
    H.COMMENT,
    e,
    s,
    n.slice(e + 1, s)
  );
}
function fp(t, e, n) {
  const r = t.source.body;
  let s = e, o = n, c = !1;
  if (o === 45 && (o = r.charCodeAt(++s)), o === 48) {
    if (o = r.charCodeAt(++s), us(o))
      throw it(
        t.source,
        s,
        `Invalid number, unexpected digit after 0: ${Wn(
          t,
          s
        )}.`
      );
  } else
    s = Zi(t, s, o), o = r.charCodeAt(s);
  if (o === 46 && (c = !0, o = r.charCodeAt(++s), s = Zi(t, s, o), o = r.charCodeAt(s)), (o === 69 || o === 101) && (c = !0, o = r.charCodeAt(++s), (o === 43 || o === 45) && (o = r.charCodeAt(++s)), s = Zi(t, s, o), o = r.charCodeAt(s)), o === 46 || ku(o))
    throw it(
      t.source,
      s,
      `Invalid number, expected digit but got: ${Wn(
        t,
        s
      )}.`
    );
  return nt(
    t,
    c ? H.FLOAT : H.INT,
    e,
    s,
    r.slice(e, s)
  );
}
function Zi(t, e, n) {
  if (!us(n))
    throw it(
      t.source,
      e,
      `Invalid number, expected digit but got: ${Wn(
        t,
        e
      )}.`
    );
  const r = t.source.body;
  let s = e + 1;
  for (; us(r.charCodeAt(s)); )
    ++s;
  return s;
}
function pp(t, e) {
  const n = t.source.body, r = n.length;
  let s = e + 1, o = s, c = "";
  for (; s < r; ) {
    const l = n.charCodeAt(s);
    if (l === 34)
      return c += n.slice(o, s), nt(t, H.STRING, e, s + 1, c);
    if (l === 92) {
      c += n.slice(o, s);
      const f = n.charCodeAt(s + 1) === 117 ? n.charCodeAt(s + 2) === 123 ? gp(t, s) : yp(t, s) : wp(t, s);
      c += f.value, s += f.size, o = s;
      continue;
    }
    if (l === 10 || l === 13)
      break;
    if (Er(l))
      ++s;
    else if (mi(n, s))
      s += 2;
    else
      throw it(
        t.source,
        s,
        `Invalid character within String: ${Wn(
          t,
          s
        )}.`
      );
  }
  throw it(t.source, s, "Unterminated string.");
}
function gp(t, e) {
  const n = t.source.body;
  let r = 0, s = 3;
  for (; s < 12; ) {
    const o = n.charCodeAt(e + s++);
    if (o === 125) {
      if (s < 5 || !Er(r))
        break;
      return {
        value: String.fromCodePoint(r),
        size: s
      };
    }
    if (r = r << 4 | Xr(o), r < 0)
      break;
  }
  throw it(
    t.source,
    e,
    `Invalid Unicode escape sequence: "${n.slice(
      e,
      e + s
    )}".`
  );
}
function yp(t, e) {
  const n = t.source.body, r = ec(n, e + 2);
  if (Er(r))
    return {
      value: String.fromCodePoint(r),
      size: 6
    };
  if (Ou(r) && n.charCodeAt(e + 6) === 92 && n.charCodeAt(e + 7) === 117) {
    const s = ec(n, e + 8);
    if (Lu(s))
      return {
        value: String.fromCodePoint(r, s),
        size: 12
      };
  }
  throw it(
    t.source,
    e,
    `Invalid Unicode escape sequence: "${n.slice(e, e + 6)}".`
  );
}
function ec(t, e) {
  return Xr(t.charCodeAt(e)) << 12 | Xr(t.charCodeAt(e + 1)) << 8 | Xr(t.charCodeAt(e + 2)) << 4 | Xr(t.charCodeAt(e + 3));
}
function Xr(t) {
  return t >= 48 && t <= 57 ? t - 48 : t >= 65 && t <= 70 ? t - 55 : t >= 97 && t <= 102 ? t - 87 : -1;
}
function wp(t, e) {
  const n = t.source.body;
  switch (n.charCodeAt(e + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw it(
    t.source,
    e,
    `Invalid character escape sequence: "${n.slice(
      e,
      e + 2
    )}".`
  );
}
function Ap(t, e) {
  const n = t.source.body, r = n.length;
  let s = t.lineStart, o = e + 3, c = o, l = "";
  const f = [];
  for (; o < r; ) {
    const p = n.charCodeAt(o);
    if (p === 34 && n.charCodeAt(o + 1) === 34 && n.charCodeAt(o + 2) === 34) {
      l += n.slice(c, o), f.push(l);
      const y = nt(
        t,
        H.BLOCK_STRING,
        e,
        o + 3,
        // Return a string of the lines joined with U+000A.
        op(f).join(`
`)
      );
      return t.line += f.length - 1, t.lineStart = s, y;
    }
    if (p === 92 && n.charCodeAt(o + 1) === 34 && n.charCodeAt(o + 2) === 34 && n.charCodeAt(o + 3) === 34) {
      l += n.slice(c, o), c = o + 1, o += 4;
      continue;
    }
    if (p === 10 || p === 13) {
      l += n.slice(c, o), f.push(l), p === 13 && n.charCodeAt(o + 1) === 10 ? o += 2 : ++o, l = "", c = o, s = o;
      continue;
    }
    if (Er(p))
      ++o;
    else if (mi(n, o))
      o += 2;
    else
      throw it(
        t.source,
        o,
        `Invalid character within String: ${Wn(
          t,
          o
        )}.`
      );
  }
  throw it(t.source, o, "Unterminated string.");
}
function mp(t, e) {
  const n = t.source.body, r = n.length;
  let s = e + 1;
  for (; s < r; ) {
    const o = n.charCodeAt(s);
    if (ip(o))
      ++s;
    else
      break;
  }
  return nt(
    t,
    H.NAME,
    e,
    s,
    n.slice(e, s)
  );
}
const vp = 10, ju = 2;
function ea(t) {
  return vi(t, []);
}
function vi(t, e) {
  switch (typeof t) {
    case "string":
      return JSON.stringify(t);
    case "function":
      return t.name ? `[function ${t.name}]` : "[function]";
    case "object":
      return Ep(t, e);
    default:
      return String(t);
  }
}
function Ep(t, e) {
  if (t === null)
    return "null";
  if (e.includes(t))
    return "[Circular]";
  const n = [...e, t];
  if (bp(t)) {
    const r = t.toJSON();
    if (r !== t)
      return typeof r == "string" ? r : vi(r, n);
  } else if (Array.isArray(t))
    return Ip(t, n);
  return Tp(t, n);
}
function bp(t) {
  return typeof t.toJSON == "function";
}
function Tp(t, e) {
  const n = Object.entries(t);
  return n.length === 0 ? "{}" : e.length > ju ? "[" + Mp(t) + "]" : "{ " + n.map(
    ([s, o]) => s + ": " + vi(o, e)
  ).join(", ") + " }";
}
function Ip(t, e) {
  if (t.length === 0)
    return "[]";
  if (e.length > ju)
    return "[Array]";
  const n = Math.min(vp, t.length), r = t.length - n, s = [];
  for (let o = 0; o < n; ++o)
    s.push(vi(t[o], e));
  return r === 1 ? s.push("... 1 more item") : r > 1 && s.push(`... ${r} more items`), "[" + s.join(", ") + "]";
}
function Mp(t) {
  const e = Object.prototype.toString.call(t).replace(/^\[object /, "").replace(/]$/, "");
  if (e === "Object" && typeof t.constructor == "function") {
    const n = t.constructor.name;
    if (typeof n == "string" && n !== "")
      return n;
  }
  return e;
}
const Np = globalThis.process && // eslint-disable-next-line no-undef
Je.process.env.NODE_ENV === "production", xp = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  Np ? function(e, n) {
    return e instanceof n;
  } : function(e, n) {
    if (e instanceof n)
      return !0;
    if (typeof e == "object" && e !== null) {
      var r;
      const s = n.prototype[Symbol.toStringTag], o = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in e ? e[Symbol.toStringTag] : (r = e.constructor) === null || r === void 0 ? void 0 : r.name
      );
      if (s === o) {
        const c = ea(e);
        throw new Error(`Cannot use ${s} "${c}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return !1;
  }
);
class Pu {
  constructor(e, n = "GraphQL request", r = {
    line: 1,
    column: 1
  }) {
    typeof e == "string" || Bs(!1, `Body must be a string. Received: ${ea(e)}.`), this.body = e, this.name = n, this.locationOffset = r, this.locationOffset.line > 0 || Bs(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || Bs(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function Sp(t) {
  return xp(t, Pu);
}
function Dp(t, e) {
  const n = new Up(t, e), r = n.parseDocument();
  return Object.defineProperty(r, "tokenCount", {
    enumerable: !1,
    value: n.tokenCount
  }), r;
}
class Up {
  constructor(e, n = {}) {
    const r = Sp(e) ? e : new Pu(e);
    this._lexer = new up(r), this._options = n, this._tokenCounter = 0;
  }
  get tokenCount() {
    return this._tokenCounter;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const e = this.expectToken(H.NAME);
    return this.node(e, {
      kind: be.NAME,
      value: e.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: be.DOCUMENT,
      definitions: this.many(
        H.SOF,
        this.parseDefinition,
        H.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(H.BRACE_L))
      return this.parseOperationDefinition();
    const e = this.peekDescription(), n = e ? this._lexer.lookahead() : this._lexer.token;
    if (n.kind === H.NAME) {
      switch (n.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (e)
        throw it(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      switch (n.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(n);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const e = this._lexer.token;
    if (this.peek(H.BRACE_L))
      return this.node(e, {
        kind: be.OPERATION_DEFINITION,
        operation: jn.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    const n = this.parseOperationType();
    let r;
    return this.peek(H.NAME) && (r = this.parseName()), this.node(e, {
      kind: be.OPERATION_DEFINITION,
      operation: n,
      name: r,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const e = this.expectToken(H.NAME);
    switch (e.value) {
      case "query":
        return jn.QUERY;
      case "mutation":
        return jn.MUTATION;
      case "subscription":
        return jn.SUBSCRIPTION;
    }
    throw this.unexpected(e);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      H.PAREN_L,
      this.parseVariableDefinition,
      H.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: be.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(H.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(H.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const e = this._lexer.token;
    return this.expectToken(H.DOLLAR), this.node(e, {
      kind: be.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: be.SELECTION_SET,
      selections: this.many(
        H.BRACE_L,
        this.parseSelection,
        H.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(H.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const e = this._lexer.token, n = this.parseName();
    let r, s;
    return this.expectOptionalToken(H.COLON) ? (r = n, s = this.parseName()) : s = n, this.node(e, {
      kind: be.FIELD,
      alias: r,
      name: s,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(H.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(e) {
    const n = e ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(H.PAREN_L, n, H.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(e = !1) {
    const n = this._lexer.token, r = this.parseName();
    return this.expectToken(H.COLON), this.node(n, {
      kind: be.ARGUMENT,
      name: r,
      value: this.parseValueLiteral(e)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const e = this._lexer.token;
    this.expectToken(H.SPREAD);
    const n = this.expectOptionalKeyword("on");
    return !n && this.peek(H.NAME) ? this.node(e, {
      kind: be.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1)
    }) : this.node(e, {
      kind: be.INLINE_FRAGMENT,
      typeCondition: n ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const e = this._lexer.token;
    return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(e, {
      kind: be.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    }) : this.node(e, {
      kind: be.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(e) {
    const n = this._lexer.token;
    switch (n.kind) {
      case H.BRACKET_L:
        return this.parseList(e);
      case H.BRACE_L:
        return this.parseObject(e);
      case H.INT:
        return this.advanceLexer(), this.node(n, {
          kind: be.INT,
          value: n.value
        });
      case H.FLOAT:
        return this.advanceLexer(), this.node(n, {
          kind: be.FLOAT,
          value: n.value
        });
      case H.STRING:
      case H.BLOCK_STRING:
        return this.parseStringLiteral();
      case H.NAME:
        switch (this.advanceLexer(), n.value) {
          case "true":
            return this.node(n, {
              kind: be.BOOLEAN,
              value: !0
            });
          case "false":
            return this.node(n, {
              kind: be.BOOLEAN,
              value: !1
            });
          case "null":
            return this.node(n, {
              kind: be.NULL
            });
          default:
            return this.node(n, {
              kind: be.ENUM,
              value: n.value
            });
        }
      case H.DOLLAR:
        if (e)
          if (this.expectToken(H.DOLLAR), this._lexer.token.kind === H.NAME) {
            const r = this._lexer.token.value;
            throw it(
              this._lexer.source,
              n.start,
              `Unexpected variable "$${r}" in constant value.`
            );
          } else
            throw this.unexpected(n);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const e = this._lexer.token;
    return this.advanceLexer(), this.node(e, {
      kind: be.STRING,
      value: e.value,
      block: e.kind === H.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(e) {
    const n = () => this.parseValueLiteral(e);
    return this.node(this._lexer.token, {
      kind: be.LIST,
      values: this.any(H.BRACKET_L, n, H.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(e) {
    const n = () => this.parseObjectField(e);
    return this.node(this._lexer.token, {
      kind: be.OBJECT,
      fields: this.any(H.BRACE_L, n, H.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(e) {
    const n = this._lexer.token, r = this.parseName();
    return this.expectToken(H.COLON), this.node(n, {
      kind: be.OBJECT_FIELD,
      name: r,
      value: this.parseValueLiteral(e)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(e) {
    const n = [];
    for (; this.peek(H.AT); )
      n.push(this.parseDirective(e));
    return n;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(e) {
    const n = this._lexer.token;
    return this.expectToken(H.AT), this.node(n, {
      kind: be.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(e)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const e = this._lexer.token;
    let n;
    if (this.expectOptionalToken(H.BRACKET_L)) {
      const r = this.parseTypeReference();
      this.expectToken(H.BRACKET_R), n = this.node(e, {
        kind: be.LIST_TYPE,
        type: r
      });
    } else
      n = this.parseNamedType();
    return this.expectOptionalToken(H.BANG) ? this.node(e, {
      kind: be.NON_NULL_TYPE,
      type: n
    }) : n;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: be.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(H.STRING) || this.peek(H.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const e = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("schema");
    const r = this.parseConstDirectives(), s = this.many(
      H.BRACE_L,
      this.parseOperationTypeDefinition,
      H.BRACE_R
    );
    return this.node(e, {
      kind: be.SCHEMA_DEFINITION,
      description: n,
      directives: r,
      operationTypes: s
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const e = this._lexer.token, n = this.parseOperationType();
    this.expectToken(H.COLON);
    const r = this.parseNamedType();
    return this.node(e, {
      kind: be.OPERATION_TYPE_DEFINITION,
      operation: n,
      type: r
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const e = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("scalar");
    const r = this.parseName(), s = this.parseConstDirectives();
    return this.node(e, {
      kind: be.SCALAR_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: s
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const e = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("type");
    const r = this.parseName(), s = this.parseImplementsInterfaces(), o = this.parseConstDirectives(), c = this.parseFieldsDefinition();
    return this.node(e, {
      kind: be.OBJECT_TYPE_DEFINITION,
      description: n,
      name: r,
      interfaces: s,
      directives: o,
      fields: c
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(H.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      H.BRACE_L,
      this.parseFieldDefinition,
      H.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const e = this._lexer.token, n = this.parseDescription(), r = this.parseName(), s = this.parseArgumentDefs();
    this.expectToken(H.COLON);
    const o = this.parseTypeReference(), c = this.parseConstDirectives();
    return this.node(e, {
      kind: be.FIELD_DEFINITION,
      description: n,
      name: r,
      arguments: s,
      type: o,
      directives: c
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      H.PAREN_L,
      this.parseInputValueDef,
      H.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const e = this._lexer.token, n = this.parseDescription(), r = this.parseName();
    this.expectToken(H.COLON);
    const s = this.parseTypeReference();
    let o;
    this.expectOptionalToken(H.EQUALS) && (o = this.parseConstValueLiteral());
    const c = this.parseConstDirectives();
    return this.node(e, {
      kind: be.INPUT_VALUE_DEFINITION,
      description: n,
      name: r,
      type: s,
      defaultValue: o,
      directives: c
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const e = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("interface");
    const r = this.parseName(), s = this.parseImplementsInterfaces(), o = this.parseConstDirectives(), c = this.parseFieldsDefinition();
    return this.node(e, {
      kind: be.INTERFACE_TYPE_DEFINITION,
      description: n,
      name: r,
      interfaces: s,
      directives: o,
      fields: c
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const e = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("union");
    const r = this.parseName(), s = this.parseConstDirectives(), o = this.parseUnionMemberTypes();
    return this.node(e, {
      kind: be.UNION_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: s,
      types: o
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(H.EQUALS) ? this.delimitedMany(H.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const e = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("enum");
    const r = this.parseName(), s = this.parseConstDirectives(), o = this.parseEnumValuesDefinition();
    return this.node(e, {
      kind: be.ENUM_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: s,
      values: o
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      H.BRACE_L,
      this.parseEnumValueDefinition,
      H.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const e = this._lexer.token, n = this.parseDescription(), r = this.parseEnumValueName(), s = this.parseConstDirectives();
    return this.node(e, {
      kind: be.ENUM_VALUE_DEFINITION,
      description: n,
      name: r,
      directives: s
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
      throw it(
        this._lexer.source,
        this._lexer.token.start,
        `${zs(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const e = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("input");
    const r = this.parseName(), s = this.parseConstDirectives(), o = this.parseInputFieldsDefinition();
    return this.node(e, {
      kind: be.INPUT_OBJECT_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: s,
      fields: o
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      H.BRACE_L,
      this.parseInputValueDef,
      H.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const e = this._lexer.lookahead();
    if (e.kind === H.NAME)
      switch (e.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(e);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    const n = this.parseConstDirectives(), r = this.optionalMany(
      H.BRACE_L,
      this.parseOperationTypeDefinition,
      H.BRACE_R
    );
    if (n.length === 0 && r.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: be.SCHEMA_EXTENSION,
      directives: n,
      operationTypes: r
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    const n = this.parseName(), r = this.parseConstDirectives();
    if (r.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: be.SCALAR_TYPE_EXTENSION,
      name: n,
      directives: r
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    const n = this.parseName(), r = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    if (r.length === 0 && s.length === 0 && o.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: be.OBJECT_TYPE_EXTENSION,
      name: n,
      interfaces: r,
      directives: s,
      fields: o
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    const n = this.parseName(), r = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    if (r.length === 0 && s.length === 0 && o.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: be.INTERFACE_TYPE_EXTENSION,
      name: n,
      interfaces: r,
      directives: s,
      fields: o
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    const n = this.parseName(), r = this.parseConstDirectives(), s = this.parseUnionMemberTypes();
    if (r.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: be.UNION_TYPE_EXTENSION,
      name: n,
      directives: r,
      types: s
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    const n = this.parseName(), r = this.parseConstDirectives(), s = this.parseEnumValuesDefinition();
    if (r.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: be.ENUM_TYPE_EXTENSION,
      name: n,
      directives: r,
      values: s
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    const n = this.parseName(), r = this.parseConstDirectives(), s = this.parseInputFieldsDefinition();
    if (r.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: be.INPUT_OBJECT_TYPE_EXTENSION,
      name: n,
      directives: r,
      fields: s
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const e = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(H.AT);
    const r = this.parseName(), s = this.parseArgumentDefs(), o = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const c = this.parseDirectiveLocations();
    return this.node(e, {
      kind: be.DIRECTIVE_DEFINITION,
      description: n,
      name: r,
      arguments: s,
      repeatable: o,
      locations: c
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(H.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const e = this._lexer.token, n = this.parseName();
    if (Object.prototype.hasOwnProperty.call(Eo, n.value))
      return n;
    throw this.unexpected(e);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(e, n) {
    return this._options.noLocation !== !0 && (n.loc = new rp(
      e,
      this._lexer.lastToken,
      this._lexer.source
    )), n;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(e) {
    return this._lexer.token.kind === e;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(e) {
    const n = this._lexer.token;
    if (n.kind === e)
      return this.advanceLexer(), n;
    throw it(
      this._lexer.source,
      n.start,
      `Expected ${_u(e)}, found ${zs(n)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(e) {
    return this._lexer.token.kind === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(e) {
    const n = this._lexer.token;
    if (n.kind === H.NAME && n.value === e)
      this.advanceLexer();
    else
      throw it(
        this._lexer.source,
        n.start,
        `Expected "${e}", found ${zs(n)}.`
      );
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(e) {
    const n = this._lexer.token;
    return n.kind === H.NAME && n.value === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(e) {
    const n = e ?? this._lexer.token;
    return it(
      this._lexer.source,
      n.start,
      `Unexpected ${zs(n)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(e, n, r) {
    this.expectToken(e);
    const s = [];
    for (; !this.expectOptionalToken(r); )
      s.push(n.call(this));
    return s;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(e, n, r) {
    if (this.expectOptionalToken(e)) {
      const s = [];
      do
        s.push(n.call(this));
      while (!this.expectOptionalToken(r));
      return s;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(e, n, r) {
    this.expectToken(e);
    const s = [];
    do
      s.push(n.call(this));
    while (!this.expectOptionalToken(r));
    return s;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(e, n) {
    this.expectOptionalToken(e);
    const r = [];
    do
      r.push(n.call(this));
    while (this.expectOptionalToken(e));
    return r;
  }
  advanceLexer() {
    const { maxTokens: e } = this._options, n = this._lexer.advance();
    if (n.kind !== H.EOF && (++this._tokenCounter, e !== void 0 && this._tokenCounter > e))
      throw it(
        this._lexer.source,
        n.start,
        `Document contains more that ${e} tokens. Parsing aborted.`
      );
  }
}
function zs(t) {
  const e = t.value;
  return _u(t.kind) + (e != null ? ` "${e}"` : "");
}
function _u(t) {
  return lp(t) ? `"${t}"` : t;
}
function Cp(t) {
  return `"${t.replace(zp, kp)}"`;
}
const zp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function kp(t) {
  return Op[t.charCodeAt(0)];
}
const Op = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], Lp = Object.freeze({});
function jp(t, e, n = Cu) {
  const r = /* @__PURE__ */ new Map();
  for (const Z of Object.values(be))
    r.set(Z, Pp(e, Z));
  let s, o = Array.isArray(t), c = [t], l = -1, f = [], p = t, y, w;
  const b = [], x = [];
  do {
    l++;
    const Z = l === c.length, le = Z && f.length !== 0;
    if (Z) {
      if (y = x.length === 0 ? void 0 : b[b.length - 1], p = w, w = x.pop(), le)
        if (o) {
          p = p.slice();
          let ve = 0;
          for (const [ye, De] of f) {
            const Re = ye - ve;
            De === null ? (p.splice(Re, 1), ve++) : p[Re] = De;
          }
        } else {
          p = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(p)
          );
          for (const [ve, ye] of f)
            p[ve] = ye;
        }
      l = s.index, c = s.keys, f = s.edits, o = s.inArray, s = s.prev;
    } else if (w) {
      if (y = o ? l : c[l], p = w[y], p == null)
        continue;
      b.push(y);
    }
    let L;
    if (!Array.isArray(p)) {
      var I, z;
      $a(p) || Bs(!1, `Invalid AST Node: ${ea(p)}.`);
      const ve = Z ? (I = r.get(p.kind)) === null || I === void 0 ? void 0 : I.leave : (z = r.get(p.kind)) === null || z === void 0 ? void 0 : z.enter;
      if (L = ve == null ? void 0 : ve.call(e, p, y, w, b, x), L === Lp)
        break;
      if (L === !1) {
        if (!Z) {
          b.pop();
          continue;
        }
      } else if (L !== void 0 && (f.push([y, L]), !Z))
        if ($a(L))
          p = L;
        else {
          b.pop();
          continue;
        }
    }
    if (L === void 0 && le && f.push([y, p]), Z)
      b.pop();
    else {
      var S;
      s = {
        inArray: o,
        index: l,
        keys: c,
        edits: f,
        prev: s
      }, o = Array.isArray(p), c = o ? p : (S = n[p.kind]) !== null && S !== void 0 ? S : [], l = -1, f = [], w && x.push(w), w = p;
    }
  } while (s !== void 0);
  return f.length !== 0 ? f[f.length - 1][1] : t;
}
function Pp(t, e) {
  const n = t[e];
  return typeof n == "object" ? n : typeof n == "function" ? {
    enter: n,
    leave: void 0
  } : {
    enter: t.enter,
    leave: t.leave
  };
}
function _p(t) {
  return jp(t, Rp);
}
const Bp = 80, Rp = {
  Name: {
    leave: (t) => t.value
  },
  Variable: {
    leave: (t) => "$" + t.name
  },
  // Document
  Document: {
    leave: (t) => we(t.definitions, `

`)
  },
  OperationDefinition: {
    leave(t) {
      const e = ke("(", we(t.variableDefinitions, ", "), ")"), n = we(
        [
          t.operation,
          we([t.name, e]),
          we(t.directives, " ")
        ],
        " "
      );
      return (n === "query" ? "" : n + " ") + t.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: t, type: e, defaultValue: n, directives: r }) => t + ": " + e + ke(" = ", n) + ke(" ", we(r, " "))
  },
  SelectionSet: {
    leave: ({ selections: t }) => Ot(t)
  },
  Field: {
    leave({ alias: t, name: e, arguments: n, directives: r, selectionSet: s }) {
      const o = ke("", t, ": ") + e;
      let c = o + ke("(", we(n, ", "), ")");
      return c.length > Bp && (c = o + ke(`(
`, Rs(we(n, `
`)), `
)`)), we([c, we(r, " "), s], " ");
    }
  },
  Argument: {
    leave: ({ name: t, value: e }) => t + ": " + e
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: t, directives: e }) => "..." + t + ke(" ", we(e, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: t, directives: e, selectionSet: n }) => we(
      [
        "...",
        ke("on ", t),
        we(e, " "),
        n
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: t, typeCondition: e, variableDefinitions: n, directives: r, selectionSet: s }) => (
      // or removed in the future.
      `fragment ${t}${ke("(", we(n, ", "), ")")} on ${e} ${ke("", we(r, " "), " ")}` + s
    )
  },
  // Value
  IntValue: {
    leave: ({ value: t }) => t
  },
  FloatValue: {
    leave: ({ value: t }) => t
  },
  StringValue: {
    leave: ({ value: t, block: e }) => e ? cp(t) : Cp(t)
  },
  BooleanValue: {
    leave: ({ value: t }) => t ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: t }) => t
  },
  ListValue: {
    leave: ({ values: t }) => "[" + we(t, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: t }) => "{" + we(t, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: t, value: e }) => t + ": " + e
  },
  // Directive
  Directive: {
    leave: ({ name: t, arguments: e }) => "@" + t + ke("(", we(e, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: t }) => t
  },
  ListType: {
    leave: ({ type: t }) => "[" + t + "]"
  },
  NonNullType: {
    leave: ({ type: t }) => t + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: t, directives: e, operationTypes: n }) => ke("", t, `
`) + we(["schema", we(e, " "), Ot(n)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: t, type: e }) => t + ": " + e
  },
  ScalarTypeDefinition: {
    leave: ({ description: t, name: e, directives: n }) => ke("", t, `
`) + we(["scalar", e, we(n, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: t, name: e, interfaces: n, directives: r, fields: s }) => ke("", t, `
`) + we(
      [
        "type",
        e,
        ke("implements ", we(n, " & ")),
        we(r, " "),
        Ot(s)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: t, name: e, arguments: n, type: r, directives: s }) => ke("", t, `
`) + e + (tc(n) ? ke(`(
`, Rs(we(n, `
`)), `
)`) : ke("(", we(n, ", "), ")")) + ": " + r + ke(" ", we(s, " "))
  },
  InputValueDefinition: {
    leave: ({ description: t, name: e, type: n, defaultValue: r, directives: s }) => ke("", t, `
`) + we(
      [e + ": " + n, ke("= ", r), we(s, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: t, name: e, interfaces: n, directives: r, fields: s }) => ke("", t, `
`) + we(
      [
        "interface",
        e,
        ke("implements ", we(n, " & ")),
        we(r, " "),
        Ot(s)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: t, name: e, directives: n, types: r }) => ke("", t, `
`) + we(
      ["union", e, we(n, " "), ke("= ", we(r, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: t, name: e, directives: n, values: r }) => ke("", t, `
`) + we(["enum", e, we(n, " "), Ot(r)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: t, name: e, directives: n }) => ke("", t, `
`) + we([e, we(n, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: t, name: e, directives: n, fields: r }) => ke("", t, `
`) + we(["input", e, we(n, " "), Ot(r)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: t, name: e, arguments: n, repeatable: r, locations: s }) => ke("", t, `
`) + "directive @" + e + (tc(n) ? ke(`(
`, Rs(we(n, `
`)), `
)`) : ke("(", we(n, ", "), ")")) + (r ? " repeatable" : "") + " on " + we(s, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: t, operationTypes: e }) => we(
      ["extend schema", we(t, " "), Ot(e)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: t, directives: e }) => we(["extend scalar", t, we(e, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: t, interfaces: e, directives: n, fields: r }) => we(
      [
        "extend type",
        t,
        ke("implements ", we(e, " & ")),
        we(n, " "),
        Ot(r)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: t, interfaces: e, directives: n, fields: r }) => we(
      [
        "extend interface",
        t,
        ke("implements ", we(e, " & ")),
        we(n, " "),
        Ot(r)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: t, directives: e, types: n }) => we(
      [
        "extend union",
        t,
        we(e, " "),
        ke("= ", we(n, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: t, directives: e, values: n }) => we(["extend enum", t, we(e, " "), Ot(n)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: t, directives: e, fields: n }) => we(["extend input", t, we(e, " "), Ot(n)], " ")
  }
};
function we(t, e = "") {
  var n;
  return (n = t == null ? void 0 : t.filter((r) => r).join(e)) !== null && n !== void 0 ? n : "";
}
function Ot(t) {
  return ke(`{
`, Rs(we(t, `
`)), `
}`);
}
function ke(t, e, n = "") {
  return e != null && e !== "" ? t + e + n : "";
}
function Rs(t) {
  return ke("  ", t.replace(/\n/g, `
  `));
}
function tc(t) {
  var e;
  return (e = t == null ? void 0 : t.some((n) => n.includes(`
`))) !== null && e !== void 0 ? e : !1;
}
var Fp = function(t, e, n, r) {
  if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t);
}, Wp = function(t, e, n, r, s) {
  if (r === "m") throw new TypeError("Private method is not writable");
  if (r === "a" && !s) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !s : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return r === "a" ? s.call(t, n) : s ? s.value = n : e.set(t, n), n;
}, Fs;
function Qp(t) {
  const e = ({ register: n }) => n(t);
  try {
    window.dispatchEvent(new Kp(e));
  } catch (n) {
    console.error(`wallet-standard:register-wallet event could not be dispatched
`, n);
  }
  try {
    window.addEventListener("wallet-standard:app-ready", ({ detail: n }) => e(n));
  } catch (n) {
    console.error(`wallet-standard:app-ready event listener could not be added
`, n);
  }
}
class Kp extends Event {
  get detail() {
    return Fp(this, Fs, "f");
  }
  get type() {
    return "wallet-standard:register-wallet";
  }
  constructor(e) {
    super("wallet-standard:register-wallet", {
      bubbles: !1,
      cancelable: !1,
      composed: !1
    }), Fs.set(this, void 0), Wp(this, Fs, e, "f");
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
}
Fs = /* @__PURE__ */ new WeakMap();
function Bn(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error(`Wrong positive integer: ${t}`);
}
function Hp(t) {
  return t instanceof Uint8Array || t != null && typeof t == "object" && t.constructor.name === "Uint8Array";
}
function ta(t, ...e) {
  if (!Hp(t))
    throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`);
}
function Bu(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Bn(t.outputLen), Bn(t.blockLen);
}
function yr(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function Ru(t, e) {
  ta(t);
  const n = e.outputLen;
  if (t.length < n)
    throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Yp = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
function Fu(t) {
  return t instanceof Uint8Array || t != null && typeof t == "object" && t.constructor.name === "Uint8Array";
}
const Ws = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), Qt = (t, e) => t << 32 - e | t >>> e, Gp = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Gp)
  throw new Error("Non little-endian hardware is not supported");
const Vp = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Wu(t) {
  if (!Fu(t))
    throw new Error("Uint8Array expected");
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += Vp[t[n]];
  return e;
}
const tn = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function nc(t) {
  if (t >= tn._0 && t <= tn._9)
    return t - tn._0;
  if (t >= tn._A && t <= tn._F)
    return t - (tn._A - 10);
  if (t >= tn._a && t <= tn._f)
    return t - (tn._a - 10);
}
function Qu(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  const e = t.length, n = e / 2;
  if (e % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(n);
  for (let s = 0, o = 0; s < n; s++, o += 2) {
    const c = nc(t.charCodeAt(o)), l = nc(t.charCodeAt(o + 1));
    if (c === void 0 || l === void 0) {
      const f = t[o] + t[o + 1];
      throw new Error('hex string expected, got non-hex character "' + f + '" at index ' + o);
    }
    r[s] = c * 16 + l;
  }
  return r;
}
function Zp(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function wr(t) {
  if (typeof t == "string" && (t = Zp(t)), !Fu(t))
    throw new Error(`expected Uint8Array, got ${typeof t}`);
  return t;
}
class na {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
const qp = {}.toString;
function Xp(t, e) {
  if (e !== void 0 && qp.call(e) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  return Object.assign(t, e);
}
function ra(t) {
  const e = (r) => t().update(wr(r)).digest(), n = t();
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;
}
class Ku extends na {
  constructor(e, n) {
    super(), this.finished = !1, this.destroyed = !1, Bu(e);
    const r = wr(n);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, o = new Uint8Array(s);
    o.set(r.length > s ? e.create().update(r).digest() : r);
    for (let c = 0; c < o.length; c++)
      o[c] ^= 54;
    this.iHash.update(o), this.oHash = e.create();
    for (let c = 0; c < o.length; c++)
      o[c] ^= 106;
    this.oHash.update(o), o.fill(0);
  }
  update(e) {
    return yr(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    yr(this), ta(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: s, destroyed: o, blockLen: c, outputLen: l } = this;
    return e = e, e.finished = s, e.destroyed = o, e.blockLen = c, e.outputLen = l, e.oHash = n._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const Ei = (t, e, n) => new Ku(t, e).update(n).digest();
Ei.create = (t, e) => new Ku(t, e);
function Jp(t, e, n, r) {
  Bu(t);
  const s = Xp({ dkLen: 32, asyncTick: 10 }, r), { c: o, dkLen: c, asyncTick: l } = s;
  if (Bn(o), Bn(c), Bn(l), o < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const f = wr(e), p = wr(n), y = new Uint8Array(c), w = Ei.create(t, f), b = w._cloneInto().update(p);
  return { c: o, dkLen: c, asyncTick: l, DK: y, PRF: w, PRFSalt: b };
}
function $p(t, e, n, r, s) {
  return t.destroy(), e.destroy(), r && r.destroy(), s.fill(0), n;
}
function eg(t, e, n, r) {
  const { c: s, dkLen: o, DK: c, PRF: l, PRFSalt: f } = Jp(t, e, n, r);
  let p;
  const y = new Uint8Array(4), w = Ws(y), b = new Uint8Array(l.outputLen);
  for (let x = 1, I = 0; I < o; x++, I += l.outputLen) {
    const z = c.subarray(I, I + l.outputLen);
    w.setInt32(0, x, !1), (p = f._cloneInto(p)).update(y).digestInto(b), z.set(b.subarray(0, z.length));
    for (let S = 1; S < s; S++) {
      l._cloneInto(p).update(b).digestInto(b);
      for (let Z = 0; Z < z.length; Z++)
        z[Z] ^= b[Z];
    }
  }
  return $p(l, f, c, p, b);
}
function tg(t, e, n, r) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, n, r);
  const s = BigInt(32), o = BigInt(4294967295), c = Number(n >> s & o), l = Number(n & o), f = r ? 4 : 0, p = r ? 0 : 4;
  t.setUint32(e + f, c, r), t.setUint32(e + p, l, r);
}
class Hu extends na {
  constructor(e, n, r, s) {
    super(), this.blockLen = e, this.outputLen = n, this.padOffset = r, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Ws(this.buffer);
  }
  update(e) {
    yr(this);
    const { view: n, buffer: r, blockLen: s } = this;
    e = wr(e);
    const o = e.length;
    for (let c = 0; c < o; ) {
      const l = Math.min(s - this.pos, o - c);
      if (l === s) {
        const f = Ws(e);
        for (; s <= o - c; c += s)
          this.process(f, c);
        continue;
      }
      r.set(e.subarray(c, c + l), this.pos), this.pos += l, c += l, this.pos === s && (this.process(n, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    yr(this), Ru(e, this), this.finished = !0;
    const { buffer: n, view: r, blockLen: s, isLE: o } = this;
    let { pos: c } = this;
    n[c++] = 128, this.buffer.subarray(c).fill(0), this.padOffset > s - c && (this.process(r, 0), c = 0);
    for (let w = c; w < s; w++)
      n[w] = 0;
    tg(r, s - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const l = Ws(e), f = this.outputLen;
    if (f % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const p = f / 4, y = this.get();
    if (p > y.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let w = 0; w < p; w++)
      l.setUint32(4 * w, y[w], o);
  }
  digest() {
    const { buffer: e, outputLen: n } = this;
    this.digestInto(e);
    const r = e.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n, buffer: r, length: s, finished: o, destroyed: c, pos: l } = this;
    return e.length = s, e.pos = l, e.finished = o, e.destroyed = c, s % n && e.buffer.set(r), e;
  }
}
const ng = (t, e, n) => t & e ^ ~t & n, rg = (t, e, n) => t & e ^ t & n ^ e & n, sg = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), ln = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), dn = /* @__PURE__ */ new Uint32Array(64);
class ig extends Hu {
  constructor() {
    super(64, 32, 8, !1), this.A = ln[0] | 0, this.B = ln[1] | 0, this.C = ln[2] | 0, this.D = ln[3] | 0, this.E = ln[4] | 0, this.F = ln[5] | 0, this.G = ln[6] | 0, this.H = ln[7] | 0;
  }
  get() {
    const { A: e, B: n, C: r, D: s, E: o, F: c, G: l, H: f } = this;
    return [e, n, r, s, o, c, l, f];
  }
  // prettier-ignore
  set(e, n, r, s, o, c, l, f) {
    this.A = e | 0, this.B = n | 0, this.C = r | 0, this.D = s | 0, this.E = o | 0, this.F = c | 0, this.G = l | 0, this.H = f | 0;
  }
  process(e, n) {
    for (let w = 0; w < 16; w++, n += 4)
      dn[w] = e.getUint32(n, !1);
    for (let w = 16; w < 64; w++) {
      const b = dn[w - 15], x = dn[w - 2], I = Qt(b, 7) ^ Qt(b, 18) ^ b >>> 3, z = Qt(x, 17) ^ Qt(x, 19) ^ x >>> 10;
      dn[w] = z + dn[w - 7] + I + dn[w - 16] | 0;
    }
    let { A: r, B: s, C: o, D: c, E: l, F: f, G: p, H: y } = this;
    for (let w = 0; w < 64; w++) {
      const b = Qt(l, 6) ^ Qt(l, 11) ^ Qt(l, 25), x = y + b + ng(l, f, p) + sg[w] + dn[w] | 0, z = (Qt(r, 2) ^ Qt(r, 13) ^ Qt(r, 22)) + rg(r, s, o) | 0;
      y = p, p = f, f = l, l = c + x | 0, c = o, o = s, s = r, r = x + z | 0;
    }
    r = r + this.A | 0, s = s + this.B | 0, o = o + this.C | 0, c = c + this.D | 0, l = l + this.E | 0, f = f + this.F | 0, p = p + this.G | 0, y = y + this.H | 0, this.set(r, s, o, c, l, f, p, y);
  }
  roundClean() {
    dn.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const og = /* @__PURE__ */ ra(() => new ig()), ks = /* @__PURE__ */ BigInt(2 ** 32 - 1), To = /* @__PURE__ */ BigInt(32);
function Yu(t, e = !1) {
  return e ? { h: Number(t & ks), l: Number(t >> To & ks) } : { h: Number(t >> To & ks) | 0, l: Number(t & ks) | 0 };
}
function Gu(t, e = !1) {
  let n = new Uint32Array(t.length), r = new Uint32Array(t.length);
  for (let s = 0; s < t.length; s++) {
    const { h: o, l: c } = Yu(t[s], e);
    [n[s], r[s]] = [o, c];
  }
  return [n, r];
}
const ag = (t, e) => BigInt(t >>> 0) << To | BigInt(e >>> 0), cg = (t, e, n) => t >>> n, ug = (t, e, n) => t << 32 - n | e >>> n, lg = (t, e, n) => t >>> n | e << 32 - n, dg = (t, e, n) => t << 32 - n | e >>> n, hg = (t, e, n) => t << 64 - n | e >>> n - 32, fg = (t, e, n) => t >>> n - 32 | e << 64 - n, pg = (t, e) => e, gg = (t, e) => t, Vu = (t, e, n) => t << n | e >>> 32 - n, Zu = (t, e, n) => e << n | t >>> 32 - n, qu = (t, e, n) => e << n - 32 | t >>> 64 - n, Xu = (t, e, n) => t << n - 32 | e >>> 64 - n;
function yg(t, e, n, r) {
  const s = (e >>> 0) + (r >>> 0);
  return { h: t + n + (s / 2 ** 32 | 0) | 0, l: s | 0 };
}
const wg = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0), Ag = (t, e, n, r) => e + n + r + (t / 2 ** 32 | 0) | 0, mg = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0), vg = (t, e, n, r, s) => e + n + r + s + (t / 2 ** 32 | 0) | 0, Eg = (t, e, n, r, s) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (s >>> 0), bg = (t, e, n, r, s, o) => e + n + r + s + o + (t / 2 ** 32 | 0) | 0, Se = {
  fromBig: Yu,
  split: Gu,
  toBig: ag,
  shrSH: cg,
  shrSL: ug,
  rotrSH: lg,
  rotrSL: dg,
  rotrBH: hg,
  rotrBL: fg,
  rotr32H: pg,
  rotr32L: gg,
  rotlSH: Vu,
  rotlSL: Zu,
  rotlBH: qu,
  rotlBL: Xu,
  add: yg,
  add3L: wg,
  add3H: Ag,
  add4L: mg,
  add4H: vg,
  add5H: bg,
  add5L: Eg
}, [Tg, Ig] = Se.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((t) => BigInt(t))), hn = /* @__PURE__ */ new Uint32Array(80), fn = /* @__PURE__ */ new Uint32Array(80);
class Mg extends Hu {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: n, Bh: r, Bl: s, Ch: o, Cl: c, Dh: l, Dl: f, Eh: p, El: y, Fh: w, Fl: b, Gh: x, Gl: I, Hh: z, Hl: S } = this;
    return [e, n, r, s, o, c, l, f, p, y, w, b, x, I, z, S];
  }
  // prettier-ignore
  set(e, n, r, s, o, c, l, f, p, y, w, b, x, I, z, S) {
    this.Ah = e | 0, this.Al = n | 0, this.Bh = r | 0, this.Bl = s | 0, this.Ch = o | 0, this.Cl = c | 0, this.Dh = l | 0, this.Dl = f | 0, this.Eh = p | 0, this.El = y | 0, this.Fh = w | 0, this.Fl = b | 0, this.Gh = x | 0, this.Gl = I | 0, this.Hh = z | 0, this.Hl = S | 0;
  }
  process(e, n) {
    for (let L = 0; L < 16; L++, n += 4)
      hn[L] = e.getUint32(n), fn[L] = e.getUint32(n += 4);
    for (let L = 16; L < 80; L++) {
      const ve = hn[L - 15] | 0, ye = fn[L - 15] | 0, De = Se.rotrSH(ve, ye, 1) ^ Se.rotrSH(ve, ye, 8) ^ Se.shrSH(ve, ye, 7), Re = Se.rotrSL(ve, ye, 1) ^ Se.rotrSL(ve, ye, 8) ^ Se.shrSL(ve, ye, 7), Le = hn[L - 2] | 0, tt = fn[L - 2] | 0, ae = Se.rotrSH(Le, tt, 19) ^ Se.rotrBH(Le, tt, 61) ^ Se.shrSH(Le, tt, 6), ce = Se.rotrSL(Le, tt, 19) ^ Se.rotrBL(Le, tt, 61) ^ Se.shrSL(Le, tt, 6), Y = Se.add4L(Re, ce, fn[L - 7], fn[L - 16]), K = Se.add4H(Y, De, ae, hn[L - 7], hn[L - 16]);
      hn[L] = K | 0, fn[L] = Y | 0;
    }
    let { Ah: r, Al: s, Bh: o, Bl: c, Ch: l, Cl: f, Dh: p, Dl: y, Eh: w, El: b, Fh: x, Fl: I, Gh: z, Gl: S, Hh: Z, Hl: le } = this;
    for (let L = 0; L < 80; L++) {
      const ve = Se.rotrSH(w, b, 14) ^ Se.rotrSH(w, b, 18) ^ Se.rotrBH(w, b, 41), ye = Se.rotrSL(w, b, 14) ^ Se.rotrSL(w, b, 18) ^ Se.rotrBL(w, b, 41), De = w & x ^ ~w & z, Re = b & I ^ ~b & S, Le = Se.add5L(le, ye, Re, Ig[L], fn[L]), tt = Se.add5H(Le, Z, ve, De, Tg[L], hn[L]), ae = Le | 0, ce = Se.rotrSH(r, s, 28) ^ Se.rotrBH(r, s, 34) ^ Se.rotrBH(r, s, 39), Y = Se.rotrSL(r, s, 28) ^ Se.rotrBL(r, s, 34) ^ Se.rotrBL(r, s, 39), K = r & o ^ r & l ^ o & l, ze = s & c ^ s & f ^ c & f;
      Z = z | 0, le = S | 0, z = x | 0, S = I | 0, x = w | 0, I = b | 0, { h: w, l: b } = Se.add(p | 0, y | 0, tt | 0, ae | 0), p = l | 0, y = f | 0, l = o | 0, f = c | 0, o = r | 0, c = s | 0;
      const Ee = Se.add3L(ae, Y, ze);
      r = Se.add3H(Ee, tt, ce, K), s = Ee | 0;
    }
    ({ h: r, l: s } = Se.add(this.Ah | 0, this.Al | 0, r | 0, s | 0)), { h: o, l: c } = Se.add(this.Bh | 0, this.Bl | 0, o | 0, c | 0), { h: l, l: f } = Se.add(this.Ch | 0, this.Cl | 0, l | 0, f | 0), { h: p, l: y } = Se.add(this.Dh | 0, this.Dl | 0, p | 0, y | 0), { h: w, l: b } = Se.add(this.Eh | 0, this.El | 0, w | 0, b | 0), { h: x, l: I } = Se.add(this.Fh | 0, this.Fl | 0, x | 0, I | 0), { h: z, l: S } = Se.add(this.Gh | 0, this.Gl | 0, z | 0, S | 0), { h: Z, l: le } = Se.add(this.Hh | 0, this.Hl | 0, Z | 0, le | 0), this.set(r, s, o, c, l, f, p, y, w, b, x, I, z, S, Z, le);
  }
  roundClean() {
    hn.fill(0), fn.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sa = /* @__PURE__ */ ra(() => new Mg());
function Ju(t) {
  if (typeof t != "string")
    throw new TypeError(`Invalid mnemonic type: ${typeof t}`);
  return t.normalize("NFKD");
}
function Ng(t) {
  const e = Ju(t), n = e.split(" ");
  if (![12, 15, 18, 21, 24].includes(n.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: e, words: n };
}
const xg = (t) => Ju(`mnemonic${t}`);
function Sg(t, e = "") {
  return eg(sa, Ng(t).nfkd, xg(e), { c: 2048, dkLen: 64 });
}
const [$u, el, tl] = [[], [], []], Dg = /* @__PURE__ */ BigInt(0), Qr = /* @__PURE__ */ BigInt(1), Ug = /* @__PURE__ */ BigInt(2), Cg = /* @__PURE__ */ BigInt(7), zg = /* @__PURE__ */ BigInt(256), kg = /* @__PURE__ */ BigInt(113);
for (let t = 0, e = Qr, n = 1, r = 0; t < 24; t++) {
  [n, r] = [r, (2 * n + 3 * r) % 5], $u.push(2 * (5 * r + n)), el.push((t + 1) * (t + 2) / 2 % 64);
  let s = Dg;
  for (let o = 0; o < 7; o++)
    e = (e << Qr ^ (e >> Cg) * kg) % zg, e & Ug && (s ^= Qr << (Qr << /* @__PURE__ */ BigInt(o)) - Qr);
  tl.push(s);
}
const [Og, Lg] = /* @__PURE__ */ Gu(tl, !0), rc = (t, e, n) => n > 32 ? qu(t, e, n) : Vu(t, e, n), sc = (t, e, n) => n > 32 ? Xu(t, e, n) : Zu(t, e, n);
function jg(t, e = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let c = 0; c < 10; c++)
      n[c] = t[c] ^ t[c + 10] ^ t[c + 20] ^ t[c + 30] ^ t[c + 40];
    for (let c = 0; c < 10; c += 2) {
      const l = (c + 8) % 10, f = (c + 2) % 10, p = n[f], y = n[f + 1], w = rc(p, y, 1) ^ n[l], b = sc(p, y, 1) ^ n[l + 1];
      for (let x = 0; x < 50; x += 10)
        t[c + x] ^= w, t[c + x + 1] ^= b;
    }
    let s = t[2], o = t[3];
    for (let c = 0; c < 24; c++) {
      const l = el[c], f = rc(s, o, l), p = sc(s, o, l), y = $u[c];
      s = t[y], o = t[y + 1], t[y] = f, t[y + 1] = p;
    }
    for (let c = 0; c < 50; c += 10) {
      for (let l = 0; l < 10; l++)
        n[l] = t[c + l];
      for (let l = 0; l < 10; l++)
        t[c + l] ^= ~n[(l + 2) % 10] & n[(l + 4) % 10];
    }
    t[0] ^= Og[r], t[1] ^= Lg[r];
  }
  n.fill(0);
}
class ia extends na {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, n, r, s = !1, o = 24) {
    if (super(), this.blockLen = e, this.suffix = n, this.outputLen = r, this.enableXOF = s, this.rounds = o, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Bn(r), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = Yp(this.state);
  }
  keccak() {
    jg(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    yr(this);
    const { blockLen: n, state: r } = this;
    e = wr(e);
    const s = e.length;
    for (let o = 0; o < s; ) {
      const c = Math.min(n - this.pos, s - o);
      for (let l = 0; l < c; l++)
        r[this.pos++] ^= e[o++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: n, pos: r, blockLen: s } = this;
    e[r] ^= n, n & 128 && r === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    yr(this, !1), ta(e), this.finish();
    const n = this.state, { blockLen: r } = this;
    for (let s = 0, o = e.length; s < o; ) {
      this.posOut >= r && this.keccak();
      const c = Math.min(r - this.posOut, o - s);
      e.set(n.subarray(this.posOut, this.posOut + c), s), this.posOut += c, s += c;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Bn(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Ru(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: n, suffix: r, outputLen: s, rounds: o, enableXOF: c } = this;
    return e || (e = new ia(n, r, s, c, o)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = o, e.suffix = r, e.outputLen = s, e.enableXOF = c, e.destroyed = this.destroyed, e;
  }
}
const Pg = (t, e, n) => ra(() => new ia(e, t, n)), Ar = /* @__PURE__ */ Pg(6, 136, 256 / 8);
async function _g(t) {
  var e;
  const { params: n, method: r, url: s, headers: o, body: c, overrides: l } = t, f = {
    headers: o,
    method: r,
    url: s,
    params: n,
    data: c,
    withCredentials: (e = l == null ? void 0 : l.WITH_CREDENTIALS) != null ? e : !0
  };
  try {
    const p = await zf(f);
    return {
      status: p.status,
      statusText: p.statusText,
      data: p.data,
      headers: p.headers,
      config: p.config
    };
  } catch (p) {
    const y = p;
    if (y.response)
      return y.response;
    throw p;
  }
}
var nl = Object.defineProperty, Bg = Object.getOwnPropertyDescriptor, bi = (t, e) => {
  for (var n in e)
    nl(t, n, { get: e[n], enumerable: !0 });
}, Fe = (t, e, n, r) => {
  for (var s = Bg(e, n), o = t.length - 1, c; o >= 0; o--)
    (c = t[o]) && (s = c(e, n, s) || s);
  return s && nl(e, n, s), s;
}, Rg = /^m(\/[0-9]+')+$/, rl = (t) => t.replace("'", ""), Fg = "ed25519 seed", Wg = 2147483648, Qg = (t) => {
  const n = Ei.create(sa, Fg).update(Qu(t)).digest(), r = n.slice(0, 32), s = n.slice(32);
  return {
    key: r,
    chainCode: s
  };
}, Kg = ({ key: t, chainCode: e }, n) => {
  const r = new ArrayBuffer(4);
  new DataView(r).setUint32(0, n);
  const s = new Uint8Array(r), o = new Uint8Array([0]), c = new Uint8Array([...o, ...t, ...s]), l = Ei.create(sa, e).update(c).digest(), f = l.slice(0, 32), p = l.slice(32);
  return {
    key: f,
    chainCode: p
  };
}, Hg = (t) => Rg.test(t) ? !t.split("/").slice(1).map(rl).some(Number.isNaN) : !1, Yg = (t, e, n = Wg) => {
  if (!Hg(t))
    throw new Error("Invalid derivation path");
  const { key: r, chainCode: s } = Qg(e);
  return t.split("/").slice(1).map(rl).map((c) => parseInt(c, 10)).reduce((c, l) => Kg(c, l + n), { key: r, chainCode: s });
}, Gg = "1.21.0";
async function Vg(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
var ic = "/v1";
function Zg(t) {
  let e = `${t}`;
  return e.endsWith("/") && (e = e.substring(0, e.length - 1)), e.endsWith(ic) || (e = `${e}${ic}`), e;
}
var sl = 2e5, il = 20, qg = 20, Xg = "0x1::aptos_coin::AptosCoin";
function Ti(t) {
  let e, n, r;
  return typeof t == "object" ? (e = t.hashFunction, n = t.ttlMs, r = t.tags) : e = t, (s, o, c) => {
    if (c.value != null)
      c.value = oc(c.value, e, n, r);
    else if (c.get != null)
      c.get = oc(c.get, e, n, r);
    else
      throw new Error("Only put a Memoize() decorator on a method or get accessor.");
  };
}
function ol(t, e) {
  return Ti({
    ttlMs: t,
    hashFunction: e
  });
}
var Qs = /* @__PURE__ */ new Map();
function Jg(t) {
  const e = /* @__PURE__ */ new Set();
  for (const n of t) {
    const r = Qs.get(n);
    if (r)
      for (const s of r)
        e.has(s) || (s.clear(), e.add(s));
  }
  return e.size;
}
function oc(t, e, n = 0, r) {
  const s = Symbol("__memoized_map__");
  return function(...o) {
    let c;
    const l = this;
    l.hasOwnProperty(s) || Object.defineProperty(l, s, {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: /* @__PURE__ */ new Map()
    });
    const f = l[s];
    if (Array.isArray(r))
      for (const p of r)
        Qs.has(p) ? Qs.get(p).push(f) : Qs.set(p, [f]);
    if (e || o.length > 0 || n > 0) {
      let p;
      e === !0 ? p = o.map((b) => b.toString()).join("!") : e ? p = e.apply(l, o) : p = o[0];
      const y = `${p}__timestamp`;
      let w = !1;
      if (n > 0)
        if (!f.has(y))
          w = !0;
        else {
          const b = f.get(y);
          w = Date.now() - b > n;
        }
      f.has(p) && !w ? c = f.get(p) : (c = t.apply(l, o), f.set(p, c), n > 0 && f.set(y, Date.now()));
    } else {
      const p = l;
      f.has(p) ? c = f.get(p) : (c = t.apply(l, o), f.set(p, c));
    }
    return c;
  };
}
var al = class extends Error {
  constructor(t, e, n) {
    super(n), this.name = "AptosApiError", this.url = e.url, this.status = e.status, this.statusText = e.statusText, this.data = e.data, this.request = t;
  }
}, $g = {
  400: "Bad Request",
  401: "Unauthorized",
  403: "Forbidden",
  404: "Not Found",
  429: "Too Many Requests",
  500: "Internal Server Error",
  502: "Bad Gateway",
  503: "Service Unavailable"
};
async function e0(t, e, n, r, s, o) {
  const c = {
    ...o == null ? void 0 : o.HEADERS,
    "x-aptos-client": `aptos-ts-sdk/${Gg}`,
    "content-type": r ?? "application/json"
  };
  return o != null && o.TOKEN && (c.Authorization = `Bearer ${o == null ? void 0 : o.TOKEN}`), await _g({ url: t, method: e, body: n, params: s, headers: c, overrides: o });
}
async function cl(t) {
  const { url: e, endpoint: n, method: r, body: s, contentType: o, params: c, overrides: l } = t, f = `${e}/${n ?? ""}`, p = await e0(f, r, s, o, c, l), y = {
    status: p.status,
    statusText: p.statusText,
    data: p.data,
    headers: p.headers,
    config: p.config,
    url: f
  };
  if (y.status >= 200 && y.status < 300)
    return y;
  const w = $g[y.status];
  throw new al(t, y, w ?? "Generic Error");
}
async function Et(t) {
  return await cl({ ...t, method: "GET" });
}
async function Jr(t) {
  return await cl({ ...t, method: "POST" });
}
async function ac(t) {
  const e = [];
  let n;
  const r = t.params;
  for (; ; ) {
    r.start = n;
    const s = await Et({
      url: t.url,
      endpoint: t.endpoint,
      params: r,
      originMethod: t.originMethod,
      overrides: t.overrides
    });
    if (n = s.headers["x-aptos-cursor"], delete s.headers, e.push(...s.data), n == null)
      break;
  }
  return e;
}
var t0 = {
  mainnet: "https://indexer.mainnet.aptoslabs.com/v1/graphql",
  testnet: "https://indexer-testnet.staging.gcp.aptosdev.com/v1/graphql",
  devnet: "https://indexer-devnet.staging.gcp.aptosdev.com/v1/graphql",
  local: "http://127.0.0.1:8090/v1/graphql"
}, n0 = {
  mainnet: "https://fullnode.mainnet.aptoslabs.com/v1",
  testnet: "https://fullnode.testnet.aptoslabs.com/v1",
  devnet: "https://fullnode.devnet.aptoslabs.com/v1",
  local: "http://127.0.0.1:8080/v1"
}, ul = /* @__PURE__ */ ((t) => (t.MAINNET = "mainnet", t.TESTNET = "testnet", t.DEVNET = "devnet", t.LOCAL = "local", t))(ul || {}), me = class Ks {
  /**
   * Creates new hex string from Buffer
   * @param buffer A buffer to convert
   * @returns New HexString
   */
  static fromBuffer(e) {
    return Ks.fromUint8Array(e);
  }
  /**
   * Creates new hex string from Uint8Array
   * @param arr Uint8Array to convert
   * @returns New HexString
   */
  static fromUint8Array(e) {
    return new Ks(Wu(e));
  }
  /**
   * Ensures `hexString` is instance of `HexString` class
   * @param hexString String to check
   * @returns New HexString if `hexString` is regular string or `hexString` if it is HexString instance
   * @example
   * ```
   *  const regularString = "string";
   *  const hexString = new HexString("string"); // "0xstring"
   *  HexString.ensure(regularString); // "0xstring"
   *  HexString.ensure(hexString); // "0xstring"
   * ```
   */
  static ensure(e) {
    return typeof e == "string" ? new Ks(e) : e;
  }
  /**
   * Creates new HexString instance from regular string. If specified string already starts with "0x" prefix,
   * it will not add another one
   * @param hexString String to convert
   * @example
   * ```
   *  const string = "string";
   *  new HexString(string); // "0xstring"
   * ```
   */
  constructor(e) {
    e.startsWith("0x") ? this.hexString = e : this.hexString = `0x${e}`;
  }
  /**
   * Getter for inner hexString
   * @returns Inner hex string
   */
  hex() {
    return this.hexString;
  }
  /**
   * Getter for inner hexString without prefix
   * @returns Inner hex string without prefix
   * @example
   * ```
   *  const hexString = new HexString("string"); // "0xstring"
   *  hexString.noPrefix(); // "string"
   * ```
   */
  noPrefix() {
    return this.hexString.slice(2);
  }
  /**
   * Overrides default `toString` method
   * @returns Inner hex string
   */
  toString() {
    return this.hex();
  }
  /**
   * Trimmes extra zeroes in the begining of a string
   * @returns Inner hexString without leading zeroes
   * @example
   * ```
   *  new HexString("0x000000string").toShortString(); // result = "0xstring"
   * ```
   */
  toShortString() {
    return `0x${this.hexString.replace(/^0x0*/, "")}`;
  }
  /**
   * Converts hex string to a Uint8Array
   * @returns Uint8Array from inner hexString without prefix
   */
  toUint8Array() {
    return Uint8Array.from(Qu(this.noPrefix()));
  }
}, Oe = {};
bi(Oe, {
  AccountAddress: () => We,
  AccountAuthenticator: () => An,
  AccountAuthenticatorEd25519: () => bl,
  AccountAuthenticatorMultiEd25519: () => Il,
  ArgumentABI: () => Si,
  AuthenticationKey: () => So,
  ChainId: () => wa,
  ChangeSet: () => E0,
  Ed25519PublicKey: () => Bt,
  Ed25519Signature: () => rn,
  EntryFunction: () => Mi,
  EntryFunctionABI: () => hs,
  FeePayerRawTransaction: () => pa,
  Identifier: () => pt,
  Module: () => v0,
  ModuleId: () => ds,
  MultiAgentRawTransaction: () => fa,
  MultiEd25519PublicKey: () => Ii,
  MultiEd25519Signature: () => aa,
  MultiSig: () => Hl,
  MultiSigTransactionPayload: () => Ql,
  RawTransaction: () => xr,
  RawTransactionWithData: () => ha,
  RotationProofChallenge: () => T0,
  Script: () => da,
  ScriptABI: () => Di,
  SignedTransaction: () => Ni,
  StructTag: () => Nr,
  Transaction: () => dd,
  TransactionArgument: () => Rt,
  TransactionArgumentAddress: () => Ia,
  TransactionArgumentBool: () => Na,
  TransactionArgumentU128: () => ba,
  TransactionArgumentU16: () => ma,
  TransactionArgumentU256: () => Ta,
  TransactionArgumentU32: () => va,
  TransactionArgumentU64: () => Ea,
  TransactionArgumentU8: () => Aa,
  TransactionArgumentU8Vector: () => Ma,
  TransactionAuthenticator: () => br,
  TransactionAuthenticatorEd25519: () => ca,
  TransactionAuthenticatorFeePayer: () => vl,
  TransactionAuthenticatorMultiAgent: () => Al,
  TransactionAuthenticatorMultiEd25519: () => ua,
  TransactionPayload: () => xs,
  TransactionPayloadEntryFunction: () => ya,
  TransactionPayloadMultisig: () => $l,
  TransactionPayloadScript: () => ga,
  TransactionScriptABI: () => xa,
  TypeArgumentABI: () => xi,
  TypeTag: () => lt,
  TypeTagAddress: () => Qn,
  TypeTagBool: () => Tr,
  TypeTagParser: () => Ns,
  TypeTagParserError: () => Rl,
  TypeTagSigner: () => Ll,
  TypeTagStruct: () => Kn,
  TypeTagU128: () => Mr,
  TypeTagU16: () => bs,
  TypeTagU256: () => Is,
  TypeTagU32: () => Ts,
  TypeTagU64: () => Ir,
  TypeTagU8: () => vn,
  TypeTagVector: () => Ms,
  UserTransaction: () => hd,
  WriteSet: () => b0,
  objectStructTag: () => y0,
  optionStructTag: () => g0,
  stringStructTag: () => la
});
var Vn = {};
bi(Vn, {
  Deserializer: () => oa,
  Serializer: () => Ze,
  bcsSerializeBool: () => h0,
  bcsSerializeBytes: () => pn,
  bcsSerializeFixedBytes: () => p0,
  bcsSerializeStr: () => f0,
  bcsSerializeU128: () => l0,
  bcsSerializeU16: () => c0,
  bcsSerializeU256: () => d0,
  bcsSerializeU32: () => u0,
  bcsSerializeU8: () => Io,
  bcsSerializeUint64: () => a0,
  bcsToBytes: () => an,
  deserializeVector: () => At,
  serializeVector: () => ut,
  serializeVectorWithFunc: () => o0
});
var r0 = 2 ** 8 - 1, s0 = 2 ** 16 - 1, ls = 2 ** 32 - 1, ll = BigInt(2 ** 64) - BigInt(1), dl = BigInt(2 ** 128) - BigInt(1), i0 = BigInt(2 ** 256) - BigInt(1), Ze = class {
  constructor() {
    this.buffer = new ArrayBuffer(64), this.offset = 0;
  }
  ensureBufferWillHandleSize(t) {
    for (; this.buffer.byteLength < this.offset + t; ) {
      const e = new ArrayBuffer(this.buffer.byteLength * 2);
      new Uint8Array(e).set(new Uint8Array(this.buffer)), this.buffer = e;
    }
  }
  serialize(t) {
    this.ensureBufferWillHandleSize(t.length), new Uint8Array(this.buffer, this.offset).set(t), this.offset += t.length;
  }
  serializeWithFunction(t, e, n) {
    this.ensureBufferWillHandleSize(e);
    const r = new DataView(this.buffer, this.offset);
    t.apply(r, [0, n, !0]), this.offset += e;
  }
  /**
   * Serializes a string. UTF8 string is supported. Serializes the string's bytes length "l" first,
   * and then serializes "l" bytes of the string content.
   *
   * BCS layout for "string": string_length | string_content. string_length is the bytes length of
   * the string that is uleb128 encoded. string_length is a u32 integer.
   *
   * @example
   * ```ts
   * const serializer = new Serializer();
   * serializer.serializeStr("");
   * assert(serializer.getBytes() === new Uint8Array([24, 0xc3, 0xa7, 0xc3, 0xa5, 0xe2, 0x88, 0x9e,
   * 0xe2, 0x89, 0xa0, 0xc2, 0xa2, 0xc3, 0xb5, 0xc3, 0x9f, 0xe2, 0x88, 0x82, 0xc6, 0x92, 0xe2, 0x88, 0xab]));
   * ```
   */
  serializeStr(t) {
    const e = new TextEncoder();
    this.serializeBytes(e.encode(t));
  }
  /**
   * Serializes an array of bytes.
   *
   * BCS layout for "bytes": bytes_length | bytes. bytes_length is the length of the bytes array that is
   * uleb128 encoded. bytes_length is a u32 integer.
   */
  serializeBytes(t) {
    this.serializeU32AsUleb128(t.length), this.serialize(t);
  }
  /**
   * Serializes an array of bytes with known length. Therefore length doesn't need to be
   * serialized to help deserialization.  When deserializing, the number of
   * bytes to deserialize needs to be passed in.
   */
  serializeFixedBytes(t) {
    this.serialize(t);
  }
  /**
   * Serializes a boolean value.
   *
   * BCS layout for "boolean": One byte. "0x01" for True and "0x00" for False.
   */
  serializeBool(t) {
    if (typeof t != "boolean")
      throw new Error("Value needs to be a boolean");
    const e = t ? 1 : 0;
    this.serialize(new Uint8Array([e]));
  }
  serializeU8(t) {
    this.serialize(new Uint8Array([t]));
  }
  serializeU16(t) {
    this.serializeWithFunction(DataView.prototype.setUint16, 2, t);
  }
  serializeU32(t) {
    this.serializeWithFunction(DataView.prototype.setUint32, 4, t);
  }
  serializeU64(t) {
    const e = BigInt(t.toString()) & BigInt(ls), n = BigInt(t.toString()) >> BigInt(32);
    this.serializeU32(Number(e)), this.serializeU32(Number(n));
  }
  serializeU128(t) {
    const e = BigInt(t.toString()) & ll, n = BigInt(t.toString()) >> BigInt(64);
    this.serializeU64(e), this.serializeU64(n);
  }
  serializeU256(t) {
    const e = BigInt(t.toString()) & dl, n = BigInt(t.toString()) >> BigInt(128);
    this.serializeU128(e), this.serializeU128(n);
  }
  serializeU32AsUleb128(t) {
    let e = t;
    const n = [];
    for (; e >>> 7; )
      n.push(e & 127 | 128), e >>>= 7;
    n.push(e), this.serialize(new Uint8Array(n));
  }
  /**
   * Returns the buffered bytes
   */
  getBytes() {
    return new Uint8Array(this.buffer).slice(0, this.offset);
  }
};
Fe([
  Zn(0, r0)
], Ze.prototype, "serializeU8");
Fe([
  Zn(0, s0)
], Ze.prototype, "serializeU16");
Fe([
  Zn(0, ls)
], Ze.prototype, "serializeU32");
Fe([
  Zn(BigInt(0), ll)
], Ze.prototype, "serializeU64");
Fe([
  Zn(BigInt(0), dl)
], Ze.prototype, "serializeU128");
Fe([
  Zn(BigInt(0), i0)
], Ze.prototype, "serializeU256");
Fe([
  Zn(0, ls)
], Ze.prototype, "serializeU32AsUleb128");
function Zn(t, e, n) {
  return (r, s, o) => {
    const c = o.value;
    return o.value = function(f) {
      const p = BigInt(f.toString());
      if (p > BigInt(e.toString()) || p < BigInt(t.toString()))
        throw new Error("Value is out of range");
      c.apply(this, [f]);
    }, o;
  };
}
var oa = class {
  constructor(t) {
    this.buffer = new ArrayBuffer(t.length), new Uint8Array(this.buffer).set(t, 0), this.offset = 0;
  }
  read(t) {
    if (this.offset + t > this.buffer.byteLength)
      throw new Error("Reached to the end of buffer");
    const e = this.buffer.slice(this.offset, this.offset + t);
    return this.offset += t, e;
  }
  /**
   * Deserializes a string. UTF8 string is supported. Reads the string's bytes length "l" first,
   * and then reads "l" bytes of content. Decodes the byte array into a string.
   *
   * BCS layout for "string": string_length | string_content. string_length is the bytes length of
   * the string that is uleb128 encoded. string_length is a u32 integer.
   *
   * @example
   * ```ts
   * const deserializer = new Deserializer(new Uint8Array([24, 0xc3, 0xa7, 0xc3, 0xa5, 0xe2, 0x88, 0x9e,
   * 0xe2, 0x89, 0xa0, 0xc2, 0xa2, 0xc3, 0xb5, 0xc3, 0x9f, 0xe2, 0x88, 0x82, 0xc6, 0x92, 0xe2, 0x88, 0xab]));
   * assert(deserializer.deserializeStr() === "");
   * ```
   */
  deserializeStr() {
    const t = this.deserializeBytes();
    return new TextDecoder().decode(t);
  }
  /**
   * Deserializes an array of bytes.
   *
   * BCS layout for "bytes": bytes_length | bytes. bytes_length is the length of the bytes array that is
   * uleb128 encoded. bytes_length is a u32 integer.
   */
  deserializeBytes() {
    const t = this.deserializeUleb128AsU32();
    return new Uint8Array(this.read(t));
  }
  /**
   * Deserializes an array of bytes. The number of bytes to read is already known.
   *
   */
  deserializeFixedBytes(t) {
    return new Uint8Array(this.read(t));
  }
  /**
   * Deserializes a boolean value.
   *
   * BCS layout for "boolean": One byte. "0x01" for True and "0x00" for False.
   */
  deserializeBool() {
    const t = new Uint8Array(this.read(1))[0];
    if (t !== 1 && t !== 0)
      throw new Error("Invalid boolean value");
    return t === 1;
  }
  /**
   * Deserializes a uint8 number.
   *
   * BCS layout for "uint8": One byte. Binary format in little-endian representation.
   */
  deserializeU8() {
    return new DataView(this.read(1)).getUint8(0);
  }
  /**
   * Deserializes a uint16 number.
   *
   * BCS layout for "uint16": Two bytes. Binary format in little-endian representation.
   * @example
   * ```ts
   * const deserializer = new Deserializer(new Uint8Array([0x34, 0x12]));
   * assert(deserializer.deserializeU16() === 4660);
   * ```
   */
  deserializeU16() {
    return new DataView(this.read(2)).getUint16(0, !0);
  }
  /**
   * Deserializes a uint32 number.
   *
   * BCS layout for "uint32": Four bytes. Binary format in little-endian representation.
   * @example
   * ```ts
   * const deserializer = new Deserializer(new Uint8Array([0x78, 0x56, 0x34, 0x12]));
   * assert(deserializer.deserializeU32() === 305419896);
   * ```
   */
  deserializeU32() {
    return new DataView(this.read(4)).getUint32(0, !0);
  }
  /**
   * Deserializes a uint64 number.
   *
   * BCS layout for "uint64": Eight bytes. Binary format in little-endian representation.
   * @example
   * ```ts
   * const deserializer = new Deserializer(new Uint8Array([0x00, 0xEF, 0xCD, 0xAB, 0x78, 0x56, 0x34, 0x12]));
   * assert(deserializer.deserializeU64() === 1311768467750121216);
   * ```
   */
  deserializeU64() {
    const t = this.deserializeU32(), e = this.deserializeU32();
    return BigInt(BigInt(e) << BigInt(32) | BigInt(t));
  }
  /**
   * Deserializes a uint128 number.
   *
   * BCS layout for "uint128": Sixteen bytes. Binary format in little-endian representation.
   */
  deserializeU128() {
    const t = this.deserializeU64(), e = this.deserializeU64();
    return BigInt(e << BigInt(64) | t);
  }
  /**
   * Deserializes a uint256 number.
   *
   * BCS layout for "uint256": Thirty-two bytes. Binary format in little-endian representation.
   */
  deserializeU256() {
    const t = this.deserializeU128(), e = this.deserializeU128();
    return BigInt(e << BigInt(128) | t);
  }
  /**
   * Deserializes a uleb128 encoded uint32 number.
   *
   * BCS use uleb128 encoding in two cases: (1) lengths of variable-length sequences and (2) tags of enum values
   */
  deserializeUleb128AsU32() {
    let t = BigInt(0), e = 0;
    for (; t < ls; ) {
      const n = this.deserializeU8();
      if (t |= BigInt(n & 127) << BigInt(e), !(n & 128))
        break;
      e += 7;
    }
    if (t > ls)
      throw new Error("Overflow while parsing uleb128-encoded uint32 value");
    return Number(t);
  }
};
function ut(t, e) {
  e.serializeU32AsUleb128(t.length), t.forEach((n) => {
    n.serialize(e);
  });
}
function o0(t, e) {
  const n = new Ze();
  n.serializeU32AsUleb128(t.length);
  const r = n[e];
  return t.forEach((s) => {
    r.call(n, s);
  }), n.getBytes();
}
function At(t, e) {
  const n = t.deserializeUleb128AsU32(), r = [];
  for (let s = 0; s < n; s += 1)
    r.push(e.deserialize(t));
  return r;
}
function an(t) {
  const e = new Ze();
  return t.serialize(e), e.getBytes();
}
function a0(t) {
  const e = new Ze();
  return e.serializeU64(t), e.getBytes();
}
function Io(t) {
  const e = new Ze();
  return e.serializeU8(t), e.getBytes();
}
function c0(t) {
  const e = new Ze();
  return e.serializeU16(t), e.getBytes();
}
function u0(t) {
  const e = new Ze();
  return e.serializeU32(t), e.getBytes();
}
function l0(t) {
  const e = new Ze();
  return e.serializeU128(t), e.getBytes();
}
function d0(t) {
  const e = new Ze();
  return e.serializeU256(t), e.getBytes();
}
function h0(t) {
  const e = new Ze();
  return e.serializeBool(t), e.getBytes();
}
function f0(t) {
  const e = new Ze();
  return e.serializeStr(t), e.getBytes();
}
function pn(t) {
  const e = new Ze();
  return e.serializeBytes(t), e.getBytes();
}
function p0(t) {
  const e = new Ze();
  return e.serializeFixedBytes(t), e.getBytes();
}
var ai = class Pt {
  constructor(e) {
    if (e.length !== Pt.LENGTH)
      throw new Error("Expected address of length 32");
    this.address = e;
  }
  /**
   * Creates AccountAddress from a hex string.
   * @param addr Hex string can be with a prefix or without a prefix,
   *   e.g. '0x1aa' or '1aa'. Hex string will be left padded with 0s if too short.
   */
  static fromHex(e) {
    let n = me.ensure(e);
    n.noPrefix().length % 2 !== 0 && (n = new me(`0${n.noPrefix()}`));
    const r = n.toUint8Array();
    if (r.length > Pt.LENGTH)
      throw new Error("Hex string is too long. Address's length is 32 bytes.");
    if (r.length === Pt.LENGTH)
      return new Pt(r);
    const s = new Uint8Array(Pt.LENGTH);
    return s.set(r, Pt.LENGTH - r.length), new Pt(s);
  }
  /**
   * Checks if the string is a valid AccountAddress
   * @param addr Hex string can be with a prefix or without a prefix,
   *   e.g. '0x1aa' or '1aa'. Hex string will be left padded with 0s if too short.
   */
  static isValid(e) {
    if (e === "")
      return !1;
    let n = me.ensure(e);
    return n.noPrefix().length % 2 !== 0 && (n = new me(`0${n.noPrefix()}`)), n.toUint8Array().length <= Pt.LENGTH;
  }
  /**
   * Return a hex string from account Address.
   */
  toHexString() {
    return me.fromUint8Array(this.address).hex();
  }
  serialize(e) {
    e.serializeFixedBytes(this.address);
  }
  static deserialize(e) {
    return new Pt(e.deserializeFixedBytes(Pt.LENGTH));
  }
  /**
   * Standardizes an address to the format "0x" followed by 64 lowercase hexadecimal digits.
   */
  static standardizeAddress(e) {
    const n = e.toLowerCase();
    return `0x${(n.startsWith("0x") ? n.slice(2) : n).padStart(64, "0")}`;
  }
};
ai.LENGTH = 32;
ai.CORE_CODE_ADDRESS = ai.fromHex("0x1");
var We = ai, hl = class Hs {
  constructor(e) {
    if (e.length !== Hs.LENGTH)
      throw new Error(`Ed25519PublicKey length should be ${Hs.LENGTH}`);
    this.value = e;
  }
  toBytes() {
    return this.value;
  }
  serialize(e) {
    e.serializeBytes(this.value);
  }
  static deserialize(e) {
    const n = e.deserializeBytes();
    return new Hs(n);
  }
};
hl.LENGTH = 32;
var Bt = hl, fl = class Ys {
  constructor(e) {
    if (this.value = e, e.length !== Ys.LENGTH)
      throw new Error(`Ed25519Signature length should be ${Ys.LENGTH}`);
  }
  serialize(e) {
    e.serializeBytes(this.value);
  }
  static deserialize(e) {
    const n = e.deserializeBytes();
    return new Ys(n);
  }
};
fl.LENGTH = 64;
var rn = fl, Mo = 32, Ii = class pl {
  /**
   * Public key for a K-of-N multisig transaction. A K-of-N multisig transaction means that for such a
   * transaction to be executed, at least K out of the N authorized signers have signed the transaction
   * and passed the check conducted by the chain.
   *
   * @see {@link
   * https://aptos.dev/guides/creating-a-signed-transaction#multisignature-transactions | Creating a Signed Transaction}
   *
   * @param public_keys A list of public keys
   * @param threshold At least "threshold" signatures must be valid
   */
  constructor(e, n) {
    if (this.public_keys = e, this.threshold = n, n > Mo)
      throw new Error(`"threshold" cannot be larger than ${Mo}`);
  }
  /**
   * Converts a MultiEd25519PublicKey into bytes with: bytes = p1_bytes | ... | pn_bytes | threshold
   */
  toBytes() {
    const e = new Uint8Array(this.public_keys.length * Bt.LENGTH + 1);
    return this.public_keys.forEach((n, r) => {
      e.set(n.value, r * Bt.LENGTH);
    }), e[this.public_keys.length * Bt.LENGTH] = this.threshold, e;
  }
  serialize(e) {
    e.serializeBytes(this.toBytes());
  }
  static deserialize(e) {
    const n = e.deserializeBytes(), r = n[n.length - 1], s = [];
    for (let o = 0; o < n.length - 1; o += Bt.LENGTH) {
      const c = o;
      s.push(new Bt(n.subarray(c, c + Bt.LENGTH)));
    }
    return new pl(s, r);
  }
}, gl = class $r {
  /**
   * Signature for a K-of-N multisig transaction.
   *
   * @see {@link
   * https://aptos.dev/guides/creating-a-signed-transaction#multisignature-transactions | Creating a Signed Transaction}
   *
   * @param signatures A list of ed25519 signatures
   * @param bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth
   * signature should be provided in `signatures`. Bits are read from left to right
   */
  constructor(e, n) {
    if (this.signatures = e, this.bitmap = n, n.length !== $r.BITMAP_LEN)
      throw new Error(`"bitmap" length should be ${$r.BITMAP_LEN}`);
  }
  /**
   * Converts a MultiEd25519Signature into bytes with `bytes = s1_bytes | ... | sn_bytes | bitmap`
   */
  toBytes() {
    const e = new Uint8Array(this.signatures.length * rn.LENGTH + $r.BITMAP_LEN);
    return this.signatures.forEach((n, r) => {
      e.set(n.value, r * rn.LENGTH);
    }), e.set(this.bitmap, this.signatures.length * rn.LENGTH), e;
  }
  /**
   * Helper method to create a bitmap out of the specified bit positions
   * @param bits The bitmap positions that should be set. A position starts at index 0.
   * Valid position should range between 0 and 31.
   * @example
   * Here's an example of valid `bits`
   * ```
   * [0, 2, 31]
   * ```
   * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.
   * The result bitmap should be 0b1010000000000000000000000000001
   *
   * @returns bitmap that is 32bit long
   */
  static createBitmap(e) {
    const r = new Uint8Array([0, 0, 0, 0]), s = /* @__PURE__ */ new Set();
    return e.forEach((o) => {
      if (o >= Mo)
        throw new Error(`Invalid bit value ${o}.`);
      if (s.has(o))
        throw new Error("Duplicated bits detected.");
      s.add(o);
      const c = Math.floor(o / 8);
      let l = r[c];
      l |= 128 >> o % 8, r[c] = l;
    }), r;
  }
  serialize(e) {
    e.serializeBytes(this.toBytes());
  }
  static deserialize(e) {
    const n = e.deserializeBytes(), r = n.subarray(n.length - 4), s = [];
    for (let o = 0; o < n.length - r.length; o += rn.LENGTH) {
      const c = o;
      s.push(new rn(n.subarray(c, c + rn.LENGTH)));
    }
    return new $r(s, r);
  }
};
gl.BITMAP_LEN = 4;
var aa = gl, br = class {
  static deserialize(t) {
    const e = t.deserializeUleb128AsU32();
    switch (e) {
      case 0:
        return ca.load(t);
      case 1:
        return ua.load(t);
      case 2:
        return Al.load(t);
      case 3:
        return vl.load(t);
      default:
        throw new Error(`Unknown variant index for TransactionAuthenticator: ${e}`);
    }
  }
}, ca = class yl extends br {
  /**
   * An authenticator for single signature.
   *
   * @param public_key Client's public key.
   * @param signature Signature of a raw transaction.
   * @see {@link https://aptos.dev/guides/creating-a-signed-transaction/ | Creating a Signed Transaction}
   * for details about generating a signature.
   */
  constructor(e, n) {
    super(), this.public_key = e, this.signature = n;
  }
  serialize(e) {
    e.serializeU32AsUleb128(0), this.public_key.serialize(e), this.signature.serialize(e);
  }
  static load(e) {
    const n = Bt.deserialize(e), r = rn.deserialize(e);
    return new yl(n, r);
  }
}, ua = class wl extends br {
  /**
   * An authenticator for multiple signatures.
   *
   * @param public_key
   * @param signature
   *
   */
  constructor(e, n) {
    super(), this.public_key = e, this.signature = n;
  }
  serialize(e) {
    e.serializeU32AsUleb128(1), this.public_key.serialize(e), this.signature.serialize(e);
  }
  static load(e) {
    const n = Ii.deserialize(e), r = aa.deserialize(e);
    return new wl(n, r);
  }
}, Al = class ml extends br {
  constructor(e, n, r) {
    super(), this.sender = e, this.secondary_signer_addresses = n, this.secondary_signers = r;
  }
  serialize(e) {
    e.serializeU32AsUleb128(2), this.sender.serialize(e), ut(this.secondary_signer_addresses, e), ut(this.secondary_signers, e);
  }
  static load(e) {
    const n = An.deserialize(e), r = At(e, We), s = At(e, An);
    return new ml(n, r, s);
  }
}, vl = class El extends br {
  constructor(e, n, r, s) {
    super(), this.sender = e, this.secondary_signer_addresses = n, this.secondary_signers = r, this.fee_payer = s;
  }
  serialize(e) {
    e.serializeU32AsUleb128(3), this.sender.serialize(e), ut(this.secondary_signer_addresses, e), ut(this.secondary_signers, e), this.fee_payer.address.serialize(e), this.fee_payer.authenticator.serialize(e);
  }
  static load(e) {
    const n = An.deserialize(e), r = At(e, We), s = At(e, An), o = We.deserialize(e), c = An.deserialize(e), l = { address: o, authenticator: c };
    return new El(n, r, s, l);
  }
}, An = class {
  static deserialize(t) {
    const e = t.deserializeUleb128AsU32();
    switch (e) {
      case 0:
        return bl.load(t);
      case 1:
        return Il.load(t);
      default:
        throw new Error(`Unknown variant index for AccountAuthenticator: ${e}`);
    }
  }
}, bl = class Tl extends An {
  constructor(e, n) {
    super(), this.public_key = e, this.signature = n;
  }
  serialize(e) {
    e.serializeU32AsUleb128(0), this.public_key.serialize(e), this.signature.serialize(e);
  }
  static load(e) {
    const n = Bt.deserialize(e), r = rn.deserialize(e);
    return new Tl(n, r);
  }
}, Il = class Ml extends An {
  constructor(e, n) {
    super(), this.public_key = e, this.signature = n;
  }
  serialize(e) {
    e.serializeU32AsUleb128(1), this.public_key.serialize(e), this.signature.serialize(e);
  }
  static load(e) {
    const n = Ii.deserialize(e), r = aa.deserialize(e);
    return new Ml(n, r);
  }
}, pt = class Nl {
  constructor(e) {
    this.value = e;
  }
  serialize(e) {
    e.serializeStr(this.value);
  }
  static deserialize(e) {
    const n = e.deserializeStr();
    return new Nl(n);
  }
}, lt = class {
  static deserialize(t) {
    const e = t.deserializeUleb128AsU32();
    switch (e) {
      case 0:
        return Tr.load(t);
      case 1:
        return vn.load(t);
      case 2:
        return Ir.load(t);
      case 3:
        return Mr.load(t);
      case 4:
        return Qn.load(t);
      case 5:
        return Ll.load(t);
      case 6:
        return Ms.load(t);
      case 7:
        return Kn.load(t);
      case 8:
        return bs.load(t);
      case 9:
        return Ts.load(t);
      case 10:
        return Is.load(t);
      default:
        throw new Error(`Unknown variant index for TypeTag: ${e}`);
    }
  }
}, Tr = class xl extends lt {
  serialize(e) {
    e.serializeU32AsUleb128(0);
  }
  static load(e) {
    return new xl();
  }
}, vn = class Sl extends lt {
  serialize(e) {
    e.serializeU32AsUleb128(1);
  }
  static load(e) {
    return new Sl();
  }
}, bs = class Dl extends lt {
  serialize(e) {
    e.serializeU32AsUleb128(8);
  }
  static load(e) {
    return new Dl();
  }
}, Ts = class Ul extends lt {
  serialize(e) {
    e.serializeU32AsUleb128(9);
  }
  static load(e) {
    return new Ul();
  }
}, Ir = class Cl extends lt {
  serialize(e) {
    e.serializeU32AsUleb128(2);
  }
  static load(e) {
    return new Cl();
  }
}, Mr = class zl extends lt {
  serialize(e) {
    e.serializeU32AsUleb128(3);
  }
  static load(e) {
    return new zl();
  }
}, Is = class kl extends lt {
  serialize(e) {
    e.serializeU32AsUleb128(10);
  }
  static load(e) {
    return new kl();
  }
}, Qn = class Ol extends lt {
  serialize(e) {
    e.serializeU32AsUleb128(4);
  }
  static load(e) {
    return new Ol();
  }
}, Ll = class jl extends lt {
  serialize(e) {
    e.serializeU32AsUleb128(5);
  }
  static load(e) {
    return new jl();
  }
}, Ms = class Pl extends lt {
  constructor(e) {
    super(), this.value = e;
  }
  serialize(e) {
    e.serializeU32AsUleb128(6), this.value.serialize(e);
  }
  static load(e) {
    const n = lt.deserialize(e);
    return new Pl(n);
  }
}, Kn = class _l extends lt {
  constructor(e) {
    super(), this.value = e;
  }
  serialize(e) {
    e.serializeU32AsUleb128(7), this.value.serialize(e);
  }
  static load(e) {
    const n = Nr.deserialize(e);
    return new _l(n);
  }
  isStringTypeTag() {
    return this.value.module_name.value === "string" && this.value.name.value === "String" && this.value.address.toHexString() === We.CORE_CODE_ADDRESS.toHexString();
  }
}, Nr = class No {
  constructor(e, n, r, s) {
    this.address = e, this.module_name = n, this.name = r, this.type_args = s;
  }
  /**
   * Converts a string literal to a StructTag
   * @param structTag String literal in format "AcountAddress::module_name::ResourceName",
   *   e.g. "0x1::aptos_coin::AptosCoin"
   * @returns
   */
  static fromString(e) {
    const n = new Ns(e).parseTypeTag();
    return new No(
      n.value.address,
      n.value.module_name,
      n.value.name,
      n.value.type_args
    );
  }
  serialize(e) {
    this.address.serialize(e), this.module_name.serialize(e), this.name.serialize(e), ut(this.type_args, e);
  }
  static deserialize(e) {
    const n = We.deserialize(e), r = pt.deserialize(e), s = pt.deserialize(e), o = At(e, lt);
    return new No(n, r, s, o);
  }
}, la = new Nr(
  We.fromHex("0x1"),
  new pt("string"),
  new pt("String"),
  []
);
function g0(t) {
  return new Nr(We.fromHex("0x1"), new pt("option"), new pt("Option"), [t]);
}
function y0(t) {
  return new Nr(We.fromHex("0x1"), new pt("object"), new pt("Object"), [t]);
}
function gn(t) {
  throw new Rl(t);
}
function cc(t) {
  return !!t.match(/\s/);
}
function uc(t) {
  return !!t.match(/[_A-Za-z0-9]/g);
}
function w0(t) {
  return !!t.match(/T\d+/g);
}
function A0(t, e) {
  const n = t[e];
  if (n === ":") {
    if (t.slice(e, e + 2) === "::")
      return [["COLON", "::"], 2];
    gn("Unrecognized token.");
  } else {
    if (n === "<")
      return [["LT", "<"], 1];
    if (n === ">")
      return [["GT", ">"], 1];
    if (n === ",")
      return [["COMMA", ","], 1];
    if (cc(n)) {
      let r = "";
      for (let s = e; s < t.length; s += 1) {
        const o = t[s];
        if (cc(o))
          r = `${r}${o}`;
        else
          break;
      }
      return [["SPACE", r], r.length];
    } else if (uc(n)) {
      let r = "";
      for (let s = e; s < t.length; s += 1) {
        const o = t[s];
        if (uc(o))
          r = `${r}${o}`;
        else
          break;
      }
      return w0(r) ? [["GENERIC", r], r.length] : [["IDENT", r], r.length];
    }
  }
  throw new Error("Unrecognized token.");
}
function m0(t) {
  let e = 0;
  const n = [];
  for (; e < t.length; ) {
    const [r, s] = A0(t, e);
    r[0] !== "SPACE" && n.push(r), e += s;
  }
  return n;
}
var Ns = class Bl {
  constructor(e, n) {
    this.typeTags = [], this.tokens = m0(e), this.typeTags = n || [];
  }
  consume(e) {
    const n = this.tokens.shift();
    (!n || n[1] !== e) && gn("Invalid type tag.");
  }
  /**
   * Consumes all of an unused generic field, mostly applicable to object
   *
   * Note: This is recursive.  it can be problematic if there's bad input
   * @private
   */
  consumeWholeGeneric() {
    for (this.consume("<"); this.tokens[0][1] !== ">"; )
      this.tokens[0][1] === "<" ? this.consumeWholeGeneric() : this.tokens.shift();
    this.consume(">");
  }
  parseCommaList(e, n) {
    const r = [];
    for (this.tokens.length <= 0 && gn("Invalid type tag."); this.tokens[0][1] !== e && (r.push(this.parseTypeTag()), !(this.tokens.length > 0 && this.tokens[0][1] === e || (this.consume(","), this.tokens.length > 0 && this.tokens[0][1] === e && n))); )
      this.tokens.length <= 0 && gn("Invalid type tag.");
    return r;
  }
  parseTypeTag() {
    this.tokens.length === 0 && gn("Invalid type tag.");
    const [e, n] = this.tokens.shift();
    if (n === "u8")
      return new vn();
    if (n === "u16")
      return new bs();
    if (n === "u32")
      return new Ts();
    if (n === "u64")
      return new Ir();
    if (n === "u128")
      return new Mr();
    if (n === "u256")
      return new Is();
    if (n === "bool")
      return new Tr();
    if (n === "address")
      return new Qn();
    if (n === "vector") {
      this.consume("<");
      const r = this.parseTypeTag();
      return this.consume(">"), new Ms(r);
    }
    if (n === "string")
      return new Kn(la);
    if (e === "IDENT" && (n.startsWith("0x") || n.startsWith("0X"))) {
      const r = We.fromHex(n);
      this.consume("::");
      const [s, o] = this.tokens.shift();
      s !== "IDENT" && gn("Invalid type tag."), this.consume("::");
      const [c, l] = this.tokens.shift();
      if (c !== "IDENT" && gn("Invalid type tag."), We.CORE_CODE_ADDRESS.toHexString() === r.toHexString() && o === "object" && l === "Object")
        return this.consumeWholeGeneric(), new Qn();
      let f = [];
      this.tokens.length > 0 && this.tokens[0][1] === "<" && (this.consume("<"), f = this.parseCommaList(">", !0), this.consume(">"));
      const p = new Nr(r, new pt(o), new pt(l), f);
      return new Kn(p);
    }
    if (e === "GENERIC") {
      this.typeTags.length === 0 && gn("Can't convert generic type since no typeTags were specified.");
      const r = parseInt(n.substring(1), 10);
      return new Bl(this.typeTags[r]).parseTypeTag();
    }
    throw new Error("Invalid type tag.");
  }
}, Rl = class extends Error {
  constructor(t) {
    super(t), this.name = "TypeTagParserError";
  }
}, xr = class Fl {
  /**
   * RawTransactions contain the metadata and payloads that can be submitted to Aptos chain for execution.
   * RawTransactions must be signed before Aptos chain can execute them.
   *
   * @param sender Account address of the sender.
   * @param sequence_number Sequence number of this transaction. This must match the sequence number stored in
   *   the sender's account at the time the transaction executes.
   * @param payload Instructions for the Aptos Blockchain, including publishing a module,
   *   execute a entry function or execute a script payload.
   * @param max_gas_amount Maximum total gas to spend for this transaction. The account must have more
   *   than this gas or the transaction will be discarded during validation.
   * @param gas_unit_price Price to be paid per gas unit.
   * @param expiration_timestamp_secs The blockchain timestamp at which the blockchain would discard this transaction.
   * @param chain_id The chain ID of the blockchain that this transaction is intended to be run on.
   */
  constructor(e, n, r, s, o, c, l) {
    this.sender = e, this.sequence_number = n, this.payload = r, this.max_gas_amount = s, this.gas_unit_price = o, this.expiration_timestamp_secs = c, this.chain_id = l;
  }
  serialize(e) {
    this.sender.serialize(e), e.serializeU64(this.sequence_number), this.payload.serialize(e), e.serializeU64(this.max_gas_amount), e.serializeU64(this.gas_unit_price), e.serializeU64(this.expiration_timestamp_secs), this.chain_id.serialize(e);
  }
  static deserialize(e) {
    const n = We.deserialize(e), r = e.deserializeU64(), s = xs.deserialize(e), o = e.deserializeU64(), c = e.deserializeU64(), l = e.deserializeU64(), f = wa.deserialize(e);
    return new Fl(
      n,
      r,
      s,
      o,
      c,
      l,
      f
    );
  }
}, da = class Wl {
  /**
   * Scripts contain the Move bytecodes payload that can be submitted to Aptos chain for execution.
   * @param code Move bytecode
   * @param ty_args Type arguments that bytecode requires.
   *
   * @example
   * A coin transfer function has one type argument "CoinType".
   * ```
   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
   * ```
   * @param args Arugments to bytecode function.
   *
   * @example
   * A coin transfer function has three arugments "from", "to" and "amount".
   * ```
   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
   * ```
   */
  constructor(e, n, r) {
    this.code = e, this.ty_args = n, this.args = r;
  }
  serialize(e) {
    e.serializeBytes(this.code), ut(this.ty_args, e), ut(this.args, e);
  }
  static deserialize(e) {
    const n = e.deserializeBytes(), r = At(e, lt), s = At(e, Rt);
    return new Wl(n, r, s);
  }
}, Mi = class Gs {
  /**
   * Contains the payload to run a function within a module.
   * @param module_name Fully qualified module name. ModuleId consists of account address and module name.
   * @param function_name The function to run.
   * @param ty_args Type arguments that move function requires.
   *
   * @example
   * A coin transfer function has one type argument "CoinType".
   * ```
   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
   * ```
   * @param args Arugments to the move function.
   *
   * @example
   * A coin transfer function has three arugments "from", "to" and "amount".
   * ```
   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
   * ```
   */
  constructor(e, n, r, s) {
    this.module_name = e, this.function_name = n, this.ty_args = r, this.args = s;
  }
  /**
   *
   * @param module Fully qualified module name in format "AccountAddress::module_name" e.g. "0x1::coin"
   * @param func Function name
   * @param ty_args Type arguments that move function requires.
   *
   * @example
   * A coin transfer function has one type argument "CoinType".
   * ```
   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
   * ```
   * @param args Arugments to the move function.
   *
   * @example
   * A coin transfer function has three arugments "from", "to" and "amount".
   * ```
   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
   * ```
   * @returns
   */
  static natural(e, n, r, s) {
    return new Gs(ds.fromStr(e), new pt(n), r, s);
  }
  /**
   * `natual` is deprecated, please use `natural`
   *
   * @deprecated.
   */
  static natual(e, n, r, s) {
    return Gs.natural(e, n, r, s);
  }
  serialize(e) {
    this.module_name.serialize(e), this.function_name.serialize(e), ut(this.ty_args, e), e.serializeU32AsUleb128(this.args.length), this.args.forEach((n) => {
      e.serializeBytes(n);
    });
  }
  static deserialize(e) {
    const n = ds.deserialize(e), r = pt.deserialize(e), s = At(e, lt), o = e.deserializeUleb128AsU32(), c = [];
    for (let f = 0; f < o; f += 1)
      c.push(e.deserializeBytes());
    const l = c;
    return new Gs(n, r, s, l);
  }
}, Ql = class Kl {
  /**
   * Contains the payload to run a multisig account transaction.
   * @param transaction_payload The payload of the multisig transaction. This can only be EntryFunction for now but
   * Script might be supported in the future.
   */
  constructor(e) {
    this.transaction_payload = e;
  }
  serialize(e) {
    e.serializeU32AsUleb128(0), this.transaction_payload.serialize(e);
  }
  static deserialize(e) {
    return e.deserializeUleb128AsU32(), new Kl(Mi.deserialize(e));
  }
}, Hl = class Yl {
  /**
   * Contains the payload to run a multisig account transaction.
   * @param multisig_address The multisig account address the transaction will be executed as.
   * @param transaction_payload The payload of the multisig transaction. This is optional when executing a multisig
   *  transaction whose payload is already stored on chain.
   */
  constructor(e, n) {
    this.multisig_address = e, this.transaction_payload = n;
  }
  serialize(e) {
    this.multisig_address.serialize(e), this.transaction_payload === void 0 ? e.serializeBool(!1) : (e.serializeBool(!0), this.transaction_payload.serialize(e));
  }
  static deserialize(e) {
    const n = We.deserialize(e), r = e.deserializeBool();
    let s;
    return r && (s = Ql.deserialize(e)), new Yl(n, s);
  }
}, v0 = class Gl {
  /**
   * Contains the bytecode of a Move module that can be published to the Aptos chain.
   * @param code Move bytecode of a module.
   */
  constructor(e) {
    this.code = e;
  }
  serialize(e) {
    e.serializeBytes(this.code);
  }
  static deserialize(e) {
    const n = e.deserializeBytes();
    return new Gl(n);
  }
}, ds = class xo {
  /**
   * Full name of a module.
   * @param address The account address.
   * @param name The name of the module under the account at "address".
   */
  constructor(e, n) {
    this.address = e, this.name = n;
  }
  /**
   * Converts a string literal to a ModuleId
   * @param moduleId String literal in format "AccountAddress::module_name", e.g. "0x1::coin"
   * @returns
   */
  static fromStr(e) {
    const n = e.split("::");
    if (n.length !== 2)
      throw new Error("Invalid module id.");
    return new xo(We.fromHex(new me(n[0])), new pt(n[1]));
  }
  serialize(e) {
    this.address.serialize(e), this.name.serialize(e);
  }
  static deserialize(e) {
    const n = We.deserialize(e), r = pt.deserialize(e);
    return new xo(n, r);
  }
}, E0 = class {
  serialize(t) {
    throw new Error("Not implemented.");
  }
  static deserialize(t) {
    throw new Error("Not implemented.");
  }
}, b0 = class {
  serialize(t) {
    throw new Error("Not implmented.");
  }
  static deserialize(t) {
    throw new Error("Not implmented.");
  }
}, Ni = class Vl {
  /**
   * A SignedTransaction consists of a raw transaction and an authenticator. The authenticator
   * contains a client's public key and the signature of the raw transaction.
   *
   * @see {@link https://aptos.dev/guides/creating-a-signed-transaction/ | Creating a Signed Transaction}
   *
   * @param raw_txn
   * @param authenticator Contains a client's public key and the signature of the raw transaction.
   *   Authenticator has 3 flavors: single signature, multi-signature and multi-agent.
   *   @see authenticator.ts for details.
   */
  constructor(e, n) {
    this.raw_txn = e, this.authenticator = n;
  }
  serialize(e) {
    this.raw_txn.serialize(e), this.authenticator.serialize(e);
  }
  static deserialize(e) {
    const n = xr.deserialize(e), r = br.deserialize(e);
    return new Vl(n, r);
  }
}, ha = class {
  static deserialize(t) {
    const e = t.deserializeUleb128AsU32();
    switch (e) {
      case 0:
        return fa.load(t);
      case 1:
        return pa.load(t);
      default:
        throw new Error(`Unknown variant index for RawTransactionWithData: ${e}`);
    }
  }
}, fa = class Zl extends ha {
  constructor(e, n) {
    super(), this.raw_txn = e, this.secondary_signer_addresses = n;
  }
  serialize(e) {
    e.serializeU32AsUleb128(0), this.raw_txn.serialize(e), ut(this.secondary_signer_addresses, e);
  }
  static load(e) {
    const n = xr.deserialize(e), r = At(e, We);
    return new Zl(n, r);
  }
}, pa = class ql extends ha {
  constructor(e, n, r) {
    super(), this.raw_txn = e, this.secondary_signer_addresses = n, this.fee_payer_address = r;
  }
  serialize(e) {
    e.serializeU32AsUleb128(1), this.raw_txn.serialize(e), ut(this.secondary_signer_addresses, e), this.fee_payer_address.serialize(e);
  }
  static load(e) {
    const n = xr.deserialize(e), r = At(e, We), s = We.deserialize(e);
    return new ql(n, r, s);
  }
}, xs = class {
  static deserialize(t) {
    const e = t.deserializeUleb128AsU32();
    switch (e) {
      case 0:
        return ga.load(t);
      case 2:
        return ya.load(t);
      case 3:
        return $l.load(t);
      default:
        throw new Error(`Unknown variant index for TransactionPayload: ${e}`);
    }
  }
}, ga = class Xl extends xs {
  constructor(e) {
    super(), this.value = e;
  }
  serialize(e) {
    e.serializeU32AsUleb128(0), this.value.serialize(e);
  }
  static load(e) {
    const n = da.deserialize(e);
    return new Xl(n);
  }
}, ya = class Jl extends xs {
  constructor(e) {
    super(), this.value = e;
  }
  serialize(e) {
    e.serializeU32AsUleb128(2), this.value.serialize(e);
  }
  static load(e) {
    const n = Mi.deserialize(e);
    return new Jl(n);
  }
}, $l = class ed extends xs {
  constructor(e) {
    super(), this.value = e;
  }
  serialize(e) {
    e.serializeU32AsUleb128(3), this.value.serialize(e);
  }
  static load(e) {
    const n = Hl.deserialize(e);
    return new ed(n);
  }
}, wa = class td {
  constructor(e) {
    this.value = e;
  }
  serialize(e) {
    e.serializeU8(this.value);
  }
  static deserialize(e) {
    const n = e.deserializeU8();
    return new td(n);
  }
}, Rt = class {
  static deserialize(t) {
    const e = t.deserializeUleb128AsU32();
    switch (e) {
      case 0:
        return Aa.load(t);
      case 1:
        return Ea.load(t);
      case 2:
        return ba.load(t);
      case 3:
        return Ia.load(t);
      case 4:
        return Ma.load(t);
      case 5:
        return Na.load(t);
      case 6:
        return ma.load(t);
      case 7:
        return va.load(t);
      case 8:
        return Ta.load(t);
      default:
        throw new Error(`Unknown variant index for TransactionArgument: ${e}`);
    }
  }
}, Aa = class nd extends Rt {
  constructor(e) {
    super(), this.value = e;
  }
  serialize(e) {
    e.serializeU32AsUleb128(0), e.serializeU8(this.value);
  }
  static load(e) {
    const n = e.deserializeU8();
    return new nd(n);
  }
}, ma = class rd extends Rt {
  constructor(e) {
    super(), this.value = e;
  }
  serialize(e) {
    e.serializeU32AsUleb128(6), e.serializeU16(this.value);
  }
  static load(e) {
    const n = e.deserializeU16();
    return new rd(n);
  }
}, va = class sd extends Rt {
  constructor(e) {
    super(), this.value = e;
  }
  serialize(e) {
    e.serializeU32AsUleb128(7), e.serializeU32(this.value);
  }
  static load(e) {
    const n = e.deserializeU32();
    return new sd(n);
  }
}, Ea = class id extends Rt {
  constructor(e) {
    super(), this.value = e;
  }
  serialize(e) {
    e.serializeU32AsUleb128(1), e.serializeU64(this.value);
  }
  static load(e) {
    const n = e.deserializeU64();
    return new id(n);
  }
}, ba = class od extends Rt {
  constructor(e) {
    super(), this.value = e;
  }
  serialize(e) {
    e.serializeU32AsUleb128(2), e.serializeU128(this.value);
  }
  static load(e) {
    const n = e.deserializeU128();
    return new od(n);
  }
}, Ta = class ad extends Rt {
  constructor(e) {
    super(), this.value = e;
  }
  serialize(e) {
    e.serializeU32AsUleb128(8), e.serializeU256(this.value);
  }
  static load(e) {
    const n = e.deserializeU256();
    return new ad(n);
  }
}, Ia = class cd extends Rt {
  constructor(e) {
    super(), this.value = e;
  }
  serialize(e) {
    e.serializeU32AsUleb128(3), this.value.serialize(e);
  }
  static load(e) {
    const n = We.deserialize(e);
    return new cd(n);
  }
}, Ma = class ud extends Rt {
  constructor(e) {
    super(), this.value = e;
  }
  serialize(e) {
    e.serializeU32AsUleb128(4), e.serializeBytes(this.value);
  }
  static load(e) {
    const n = e.deserializeBytes();
    return new ud(n);
  }
}, Na = class ld extends Rt {
  constructor(e) {
    super(), this.value = e;
  }
  serialize(e) {
    e.serializeU32AsUleb128(5), e.serializeBool(this.value);
  }
  static load(e) {
    const n = e.deserializeBool();
    return new ld(n);
  }
}, dd = class {
  getHashSalt() {
    const t = Ar.create();
    return t.update("APTOS::Transaction"), t.digest();
  }
  static deserialize(t) {
    const e = t.deserializeUleb128AsU32();
    switch (e) {
      case 0:
        return hd.load(t);
      default:
        throw new Error(`Unknown variant index for Transaction: ${e}`);
    }
  }
}, hd = class fd extends dd {
  constructor(e) {
    super(), this.value = e;
  }
  hash() {
    const e = Ar.create();
    return e.update(this.getHashSalt()), e.update(an(this)), e.digest();
  }
  serialize(e) {
    e.serializeU32AsUleb128(0), this.value.serialize(e);
  }
  static load(e) {
    return new fd(Ni.deserialize(e));
  }
}, xi = class pd {
  /**
   * Constructs a TypeArgumentABI instance.
   * @param name
   */
  constructor(e) {
    this.name = e;
  }
  serialize(e) {
    e.serializeStr(this.name);
  }
  static deserialize(e) {
    const n = e.deserializeStr();
    return new pd(n);
  }
}, Si = class gd {
  /**
   * Constructs an ArgumentABI instance.
   * @param name
   * @param type_tag
   */
  constructor(e, n) {
    this.name = e, this.type_tag = n;
  }
  serialize(e) {
    e.serializeStr(this.name), this.type_tag.serialize(e);
  }
  static deserialize(e) {
    const n = e.deserializeStr(), r = lt.deserialize(e);
    return new gd(n, r);
  }
}, Di = class {
  static deserialize(t) {
    const e = t.deserializeUleb128AsU32();
    switch (e) {
      case 0:
        return xa.load(t);
      case 1:
        return hs.load(t);
      default:
        throw new Error(`Unknown variant index for TransactionPayload: ${e}`);
    }
  }
}, xa = class yd extends Di {
  /**
   * Constructs a TransactionScriptABI instance.
   * @param name Entry function name
   * @param doc
   * @param code
   * @param ty_args
   * @param args
   */
  constructor(e, n, r, s, o) {
    super(), this.name = e, this.doc = n, this.code = r, this.ty_args = s, this.args = o;
  }
  serialize(e) {
    e.serializeU32AsUleb128(0), e.serializeStr(this.name), e.serializeStr(this.doc), e.serializeBytes(this.code), ut(this.ty_args, e), ut(this.args, e);
  }
  static load(e) {
    const n = e.deserializeStr(), r = e.deserializeStr(), s = e.deserializeBytes(), o = At(e, xi), c = At(e, Si);
    return new yd(n, r, s, o, c);
  }
}, hs = class wd extends Di {
  /**
   * Constructs a EntryFunctionABI instance
   * @param name
   * @param module_name Fully qualified module id
   * @param doc
   * @param ty_args
   * @param args
   */
  constructor(e, n, r, s, o) {
    super(), this.name = e, this.module_name = n, this.doc = r, this.ty_args = s, this.args = o;
  }
  serialize(e) {
    e.serializeU32AsUleb128(1), e.serializeStr(this.name), this.module_name.serialize(e), e.serializeStr(this.doc), ut(this.ty_args, e), ut(this.args, e);
  }
  static load(e) {
    const n = e.deserializeStr(), r = ds.deserialize(e), s = e.deserializeStr(), o = At(e, xi), c = At(e, Si);
    return new wd(n, r, s, o, c);
  }
}, Ss = class rr {
  constructor(e) {
    if (e.length !== rr.LENGTH)
      throw new Error("Expected a byte array of length 32");
    this.bytes = e;
  }
  /**
   * Converts a K-of-N MultiEd25519PublicKey to AuthenticationKey with:
   * `auth_key = sha3-256(p_1 |  | p_n | K | 0x01)`. `K` represents the K-of-N required for
   * authenticating the transaction. `0x01` is the 1-byte scheme for multisig.
   */
  static fromMultiEd25519PublicKey(e) {
    const n = e.toBytes(), r = new Uint8Array(n.length + 1);
    r.set(n), r.set([rr.MULTI_ED25519_SCHEME], n.length);
    const s = Ar.create();
    return s.update(r), new rr(s.digest());
  }
  static fromEd25519PublicKey(e) {
    const n = e.value, r = new Uint8Array(n.length + 1);
    r.set(n), r.set([rr.ED25519_SCHEME], n.length);
    const s = Ar.create();
    return s.update(r), new rr(s.digest());
  }
  /**
   * Derives an account address from AuthenticationKey. Since current AccountAddress is 32 bytes,
   * AuthenticationKey bytes are directly translated to AccountAddress.
   */
  derivedAddress() {
    return me.fromUint8Array(this.bytes);
  }
};
Ss.LENGTH = 32;
Ss.MULTI_ED25519_SCHEME = 1;
Ss.ED25519_SCHEME = 0;
Ss.DERIVE_RESOURCE_ACCOUNT_SCHEME = 255;
var So = Ss, T0 = class {
  constructor(t, e, n, r, s, o, c) {
    this.accountAddress = t, this.moduleName = e, this.structName = n, this.sequenceNumber = r, this.originator = s, this.currentAuthKey = o, this.newPublicKey = c;
  }
  serialize(t) {
    this.accountAddress.serialize(t), t.serializeStr(this.moduleName), t.serializeStr(this.structName), t.serializeU64(this.sequenceNumber), this.originator.serialize(t), this.currentAuthKey.serialize(t), t.serializeBytes(this.newPublicKey);
  }
}, Ad = class Vs {
  static fromAptosAccountObject(e) {
    return new Vs(me.ensure(e.privateKeyHex).toUint8Array(), e.address);
  }
  /**
   * Check's if the derive path is valid
   */
  static isValidPath(e) {
    return /^m\/44'\/637'\/[0-9]+'\/[0-9]+'\/[0-9]+'+$/.test(e);
  }
  /**
   * Creates new account with bip44 path and mnemonics,
   * @param path. (e.g. m/44'/637'/0'/0'/0')
   * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}
   * @param mnemonics.
   * @returns AptosAccount
   */
  static fromDerivePath(e, n) {
    if (!Vs.isValidPath(e))
      throw new Error("Invalid derivation path");
    const r = n.trim().split(/\s+/).map((o) => o.toLowerCase()).join(" "), { key: s } = Yg(e, Wu(Sg(r)));
    return new Vs(s);
  }
  /**
   * Creates new account instance. Constructor allows passing in an address,
   * to handle account key rotation, where auth_key != public_key
   * @param privateKeyBytes  Private key from which account key pair will be generated.
   * If not specified, new key pair is going to be created.
   * @param address Account address (e.g. 0xe8012714cd17606cee7188a2a365eef3fe760be598750678c8c5954eb548a591).
   * If not specified, a new one will be generated from public key
   */
  constructor(e, n) {
    e ? this.signingKey = St.sign.keyPair.fromSeed(e.slice(0, 32)) : this.signingKey = St.sign.keyPair(), this.accountAddress = me.ensure(n || this.authKey().hex());
  }
  /**
   * This is the key by which Aptos account is referenced.
   * It is the 32-byte of the SHA-3 256 cryptographic hash
   * of the public key(s) concatenated with a signature scheme identifier byte
   * @returns Address associated with the given account
   */
  address() {
    return this.accountAddress;
  }
  authKey() {
    const e = new Bt(this.signingKey.publicKey);
    return So.fromEd25519PublicKey(e).derivedAddress();
  }
  /**
   * Takes source address and seeds and returns the resource account address
   * @param sourceAddress Address used to derive the resource account
   * @param seed The seed bytes
   * @returns The resource account address
   */
  static getResourceAccountAddress(e, n) {
    const r = an(We.fromHex(e)), s = new Uint8Array([...r, ...n, So.DERIVE_RESOURCE_ACCOUNT_SCHEME]), o = Ar.create();
    return o.update(s), me.fromUint8Array(o.digest());
  }
  /**
   * Takes creator address and collection name and returns the collection id hash.
   * Collection id hash are generated as sha256 hash of (`creator_address::collection_name`)
   *
   * @param creatorAddress Collection creator address
   * @param collectionName The collection name
   * @returns The collection id hash
   */
  static getCollectionID(e, n) {
    const r = new TextEncoder().encode(`${e}::${n}`), s = og.create();
    return s.update(r), me.fromUint8Array(s.digest());
  }
  /**
   * This key is generated with Ed25519 scheme.
   * Public key is used to check a signature of transaction, signed by given account
   * @returns The public key for the associated account
   */
  pubKey() {
    return me.fromUint8Array(this.signingKey.publicKey);
  }
  /**
   * Signs specified `buffer` with account's private key
   * @param buffer A buffer to sign
   * @returns A signature HexString
   */
  signBuffer(e) {
    const n = St.sign.detached(e, this.signingKey.secretKey);
    return me.fromUint8Array(n);
  }
  /**
   * Signs specified `hexString` with account's private key
   * @param hexString A regular string or HexString to sign
   * @returns A signature HexString
   */
  signHexString(e) {
    const n = me.ensure(e).toUint8Array();
    return this.signBuffer(n);
  }
  /**
   * Verifies the signature of the message with the public key of the account
   * @param message a signed message
   * @param signature the signature of the message
   */
  verifySignature(e, n) {
    const r = me.ensure(e).toUint8Array(), s = me.ensure(n).toUint8Array();
    return St.sign.detached.verify(r, s, this.signingKey.publicKey);
  }
  /**
   * Derives account address, public key and private key
   * @returns AptosAccountObject instance.
   * @example An example of the returned AptosAccountObject object
   * ```
   * {
   *    address: "0xe8012714cd17606cee7188a2a365eef3fe760be598750678c8c5954eb548a591",
   *    publicKeyHex: "0xf56d8524faf79fbc0f48c13aeed3b0ce5dd376b4db93b8130a107c0a5e04ba04",
   *    privateKeyHex: `0x009c9f7c992a06cfafe916f125d8adb7a395fca243e264a8e56a4b3e6accf940
   *      d2b11e9ece3049ce60e3c7b4a1c58aebfa9298e29a30a58a67f1998646135204`
   * }
   * ```
   */
  toPrivateKeyObject() {
    return {
      address: this.address().hex(),
      publicKeyHex: this.pubKey().hex(),
      privateKeyHex: me.fromUint8Array(this.signingKey.secretKey.slice(0, 32)).hex()
    };
  }
};
Fe([
  Ti()
], Ad.prototype, "authKey");
var lc = Ad, Ds = `
    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {
  token_standard
  token_properties_mutated_v1
  token_data_id
  table_type_v1
  storage_id
  property_version_v1
  owner_address
  last_transaction_version
  last_transaction_timestamp
  is_soulbound_v2
  is_fungible_v2
  amount
  current_token_data {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `, I0 = `
    fragment TokenDataFields on current_token_datas {
  creator_address
  collection_name
  description
  metadata_uri
  name
  token_data_id_hash
  collection_data_id_hash
}
    `, M0 = `
    fragment CollectionDataFields on current_collection_datas {
  metadata_uri
  supply
  description
  collection_name
  collection_data_id_hash
  table_handle
  creator_address
}
    `, md = `
    fragment TokenActivitiesFields on token_activities_v2 {
  after_value
  before_value
  entry_function_id_str
  event_account_address
  event_index
  from_address
  is_fungible_v2
  property_version_v1
  to_address
  token_amount
  token_data_id
  token_standard
  transaction_timestamp
  transaction_version
  type
}
    `, N0 = `
    query getAccountCoinsDataCount($address: String) {
  current_fungible_asset_balances_aggregate(
    where: {owner_address: {_eq: $address}}
  ) {
    aggregate {
      count
    }
  }
}
    `, x0 = `
    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
    metadata {
      token_standard
      symbol
      supply_aggregator_table_key_v1
      supply_aggregator_table_handle_v1
      project_uri
      name
      last_transaction_version
      last_transaction_timestamp
      icon_uri
      decimals
      creator_address
      asset_type
    }
  }
}
    `, S0 = `
    query getAccountCurrentTokens($address: String!, $offset: Int, $limit: Int) {
  current_token_ownerships(
    where: {owner_address: {_eq: $address}, amount: {_gt: 0}}
    order_by: [{last_transaction_version: desc}, {creator_address: asc}, {collection_name: asc}, {name: asc}]
    offset: $offset
    limit: $limit
  ) {
    amount
    current_token_data {
      ...TokenDataFields
    }
    current_collection_data {
      ...CollectionDataFields
    }
    last_transaction_version
    property_version
  }
}
    ${I0}
${M0}`, D0 = `
    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {
  current_token_ownerships_v2_aggregate(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    aggregate {
      count
    }
  }
}
    `, U0 = `
    query getAccountTransactionsCount($address: String) {
  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {
    aggregate {
      count
    }
  }
}
    `, C0 = `
    query getAccountTransactionsData($where_condition: account_transactions_bool_exp!, $offset: Int, $limit: Int, $order_by: [account_transactions_order_by!]) {
  account_transactions(
    where: $where_condition
    order_by: $order_by
    limit: $limit
    offset: $offset
  ) {
    token_activities_v2 {
      ...TokenActivitiesFields
    }
    transaction_version
    account_address
  }
}
    ${md}`, z0 = `
    query getCollectionData($where_condition: current_collections_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collections_v2_order_by!]) {
  current_collections_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    collection_id
    collection_name
    creator_address
    current_supply
    description
    last_transaction_timestamp
    last_transaction_version
    max_supply
    mutable_description
    mutable_uri
    table_handle_v1
    token_standard
    total_minted_v2
    uri
  }
}
    `, k0 = `
    query getCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {
  current_collection_ownership_v2_view(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      mutable_description
      max_supply
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
    collection_id
    collection_name
    collection_uri
    creator_address
    distinct_tokens
    last_transaction_version
    owner_address
    single_token_uri
  }
}
    `, O0 = `
    query getCurrentObjects($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {
  current_objects(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    allow_ungated_transfer
    state_key_hash
    owner_address
    object_address
    last_transaction_version
    last_guid_creation_num
    is_deleted
  }
}
    `, L0 = `
    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {
  delegated_staking_activities(
    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}
  ) {
    amount
    delegator_address
    event_index
    event_type
    pool_address
    transaction_version
  }
}
    `, j0 = `
    query getIndexerLedgerInfo {
  ledger_infos {
    chain_id
  }
}
    `, P0 = `
    query getNumberOfDelegators($poolAddress: String) {
  num_active_delegator_per_pool(
    where: {pool_address: {_eq: $poolAddress}, num_active_delegator: {_gt: "0"}}
    distinct_on: pool_address
  ) {
    num_active_delegator
    pool_address
  }
}
    `, _0 = `
    query getOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${Ds}`, B0 = `
    query getOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${Ds}`, R0 = `
    query getTokenActivities($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {
  token_activities_v2(
    where: $where_condition
    order_by: $order_by
    offset: $offset
    limit: $limit
  ) {
    ...TokenActivitiesFields
  }
}
    ${md}`, F0 = `
    query getTokenActivitiesCount($token_id: String) {
  token_activities_v2_aggregate(where: {token_data_id: {_eq: $token_id}}) {
    aggregate {
      count
    }
  }
}
    `, W0 = `
    query getTokenCurrentOwnerData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${Ds}`, Q0 = `
    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {
  current_token_datas_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `, K0 = `
    query getTokenOwnedFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${Ds}`, H0 = `
    query getTokenOwnersData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${Ds}`, Y0 = `
    query getTopUserTransactions($limit: Int) {
  user_transactions(limit: $limit, order_by: {version: desc}) {
    version
  }
}
    `, G0 = `
    query getUserTransactions($where_condition: user_transactions_bool_exp!, $offset: Int, $limit: Int, $order_by: [user_transactions_order_by!]) {
  user_transactions(
    order_by: $order_by
    where: $where_condition
    limit: $limit
    offset: $offset
  ) {
    version
  }
}
    `;
function Ui(t, e, n) {
  if (!(e != null && e.includes(typeof t)))
    throw new Error(
      `Invalid arg: ${t} type should be ${e instanceof Array ? e.join(" or ") : e}`
    );
}
function vd(t) {
  if (Ui(t, ["boolean", "string"]), typeof t == "boolean")
    return t;
  if (t === "true")
    return !0;
  if (t === "false")
    return !1;
  throw new Error("Invalid boolean string.");
}
function ur(t) {
  if (Ui(t, ["number", "string"]), typeof t == "number")
    return t;
  const e = Number.parseInt(t, 10);
  if (Number.isNaN(e))
    throw new Error("Invalid number string.");
  return e;
}
function lr(t) {
  return Ui(t, ["number", "bigint", "string"]), BigInt(t);
}
function V0(t, e, n) {
  Sa(t, e, n);
}
function Sa(t, e, n, r) {
  if (e instanceof Tr)
    n.serializeBool(vd(t));
  else if (e instanceof vn)
    n.serializeU8(ur(t));
  else if (e instanceof bs)
    n.serializeU16(ur(t));
  else if (e instanceof Ts)
    n.serializeU32(ur(t));
  else if (e instanceof Ir)
    n.serializeU64(lr(t));
  else if (e instanceof Mr)
    n.serializeU128(lr(t));
  else if (e instanceof Is)
    n.serializeU256(lr(t));
  else if (e instanceof Qn)
    Ed(t, n);
  else if (e instanceof Ms)
    Z0(t, e, n);
  else if (e instanceof Kn)
    q0(t, e, n);
  else
    throw new Error("Unsupported arg type.");
}
function Ed(t, e) {
  let n;
  if (typeof t == "string" || t instanceof me)
    n = We.fromHex(t);
  else if (t instanceof We)
    n = t;
  else
    throw new Error("Invalid account address.");
  n.serialize(e);
}
function Z0(t, e, n, r) {
  if (e.value instanceof vn) {
    if (t instanceof Uint8Array) {
      n.serializeBytes(t);
      return;
    }
    if (t instanceof me) {
      n.serializeBytes(t.toUint8Array());
      return;
    }
    if (typeof t == "string") {
      n.serializeStr(t);
      return;
    }
  }
  if (!Array.isArray(t))
    throw new Error("Invalid vector args.");
  n.serializeU32AsUleb128(t.length), t.forEach((s) => Sa(s, e.value, n));
}
function q0(t, e, n, r) {
  const { address: s, module_name: o, name: c, type_args: l } = e.value, f = `${me.fromUint8Array(s.address).toShortString()}::${o.value}::${c.value}`;
  if (f === "0x1::string::String")
    Ui(t, ["string"]), n.serializeStr(t);
  else if (f === "0x1::object::Object")
    Ed(t, n);
  else if (f === "0x1::option::Option") {
    if (l.length !== 1)
      throw new Error(`Option has the wrong number of type arguments ${l.length}`);
    X0(t, l[0], n);
  } else
    throw new Error("Unsupported struct type in function argument");
}
function X0(t, e, n, r) {
  t == null ? n.serializeU32AsUleb128(0) : (n.serializeU32AsUleb128(1), Sa(t, e, n));
}
function J0(t, e) {
  if (e instanceof Tr)
    return new Na(vd(t));
  if (e instanceof vn)
    return new Aa(ur(t));
  if (e instanceof bs)
    return new ma(ur(t));
  if (e instanceof Ts)
    return new va(ur(t));
  if (e instanceof Ir)
    return new Ea(lr(t));
  if (e instanceof Mr)
    return new ba(lr(t));
  if (e instanceof Is)
    return new Ta(lr(t));
  if (e instanceof Qn) {
    let n;
    if (typeof t == "string" || t instanceof me)
      n = We.fromHex(t);
    else if (t instanceof We)
      n = t;
    else
      throw new Error("Invalid account address.");
    return new Ia(n);
  }
  if (e instanceof Ms && e.value instanceof vn) {
    if (!(t instanceof Uint8Array))
      throw new Error(`${t} should be an instance of Uint8Array`);
    return new Ma(t);
  }
  throw new Error("Unknown type for TransactionArgument.");
}
var $0 = "APTOS::RawTransaction", dc = "APTOS::RawTransactionWithData", fs = class {
  constructor(t, e) {
    this.rawTxnBuilder = e, this.signingFunction = t;
  }
  /**
   * Builds a RawTransaction. Relays the call to TransactionBuilderABI.build
   * @param func
   * @param ty_tags
   * @param args
   */
  build(t, e, n) {
    if (!this.rawTxnBuilder)
      throw new Error("this.rawTxnBuilder doesn't exist.");
    return this.rawTxnBuilder.build(t, e, n);
  }
  /** Generates a Signing Message out of a raw transaction. */
  static getSigningMessage(t) {
    const e = Ar.create();
    if (t instanceof xr)
      e.update($0);
    else if (t instanceof fa)
      e.update(dc);
    else if (t instanceof pa)
      e.update(dc);
    else
      throw new Error("Unknown transaction type.");
    const n = e.digest(), r = an(t), s = new Uint8Array(n.length + r.length);
    return s.set(n), s.set(r, n.length), s;
  }
}, qi = class extends fs {
  constructor(t, e, n) {
    super(t, n), this.publicKey = e;
  }
  rawToSigned(t) {
    const e = fs.getSigningMessage(t), n = this.signingFunction(e), r = new ca(
      new Bt(this.publicKey),
      n
    );
    return new Ni(t, r);
  }
  /** Signs a raw transaction and returns a bcs serialized transaction. */
  sign(t) {
    return an(this.rawToSigned(t));
  }
}, e5 = class extends fs {
  constructor(t, e) {
    super(t), this.publicKey = e;
  }
  rawToSigned(t) {
    const e = fs.getSigningMessage(t), n = this.signingFunction(e), r = new ua(this.publicKey, n);
    return new Ni(t, r);
  }
  /** Signs a raw transaction and returns a bcs serialized transaction. */
  sign(t) {
    return an(this.rawToSigned(t));
  }
}, t5 = class Do {
  /**
   * Constructs a TransactionBuilderABI instance
   * @param abis List of binary ABIs.
   * @param builderConfig Configs for creating a raw transaction.
   */
  constructor(e, n) {
    this.abiMap = /* @__PURE__ */ new Map(), e.forEach((r) => {
      const s = new oa(r), o = Di.deserialize(s);
      let c;
      if (o instanceof hs) {
        const l = o, { address: f, name: p } = l.module_name;
        c = `${me.fromUint8Array(f.address).toShortString()}::${p.value}::${l.name}`;
      } else
        c = o.name;
      if (this.abiMap.has(c))
        throw new Error("Found conflicting ABI interfaces");
      this.abiMap.set(c, o);
    }), this.builderConfig = {
      maxGasAmount: BigInt(sl),
      expSecFromNow: il,
      ...n
    };
  }
  static toBCSArgs(e, n) {
    if (e.length !== n.length)
      throw new Error("Wrong number of args provided.");
    return n.map((r, s) => {
      const o = new Ze();
      return V0(r, e[s].type_tag, o), o.getBytes();
    });
  }
  static toTransactionArguments(e, n) {
    if (e.length !== n.length)
      throw new Error("Wrong number of args provided.");
    return n.map((r, s) => J0(r, e[s].type_tag));
  }
  setSequenceNumber(e) {
    this.builderConfig.sequenceNumber = BigInt(e);
  }
  /**
   * Builds a TransactionPayload. For dApps, chain ID and account sequence numbers are only known to the wallet.
   * Instead of building a RawTransaction (requires chainID and sequenceNumber), dApps can build a TransactionPayload
   * and pass the payload to the wallet for signing and sending.
   * @param func Fully qualified func names, e.g. 0x1::aptos_account::transfer
   * @param ty_tags TypeTag strings
   * @param args Function arguments
   * @returns TransactionPayload
   */
  buildTransactionPayload(e, n, r) {
    const s = n.map((l) => new Ns(l).parseTypeTag());
    let o;
    if (!this.abiMap.has(e))
      throw new Error(`Cannot find function: ${e}`);
    const c = this.abiMap.get(e);
    if (c instanceof hs) {
      const l = c, f = Do.toBCSArgs(l.args, r);
      o = new ya(
        new Mi(l.module_name, new pt(l.name), s, f)
      );
    } else if (c instanceof xa) {
      const l = c, f = Do.toTransactionArguments(l.args, r);
      o = new ga(new da(l.code, s, f));
    } else
      throw new Error("Unknown ABI format.");
    return o;
  }
  /**
   * Builds a RawTransaction
   * @param func Fully qualified func names, e.g. 0x1::aptos_account::transfer
   * @param ty_tags TypeTag strings.
   * @example Below are valid value examples
   * ```
   * // Structs are in format `AccountAddress::ModuleName::StructName`
   * 0x1::aptos_coin::AptosCoin
   * // Vectors are in format `vector<other_tag_string>`
   * vector<0x1::aptos_coin::AptosCoin>
   * bool
   * u8
   * u16
   * u32
   * u64
   * u128
   * u256
   * address
   * ```
   * @param args Function arguments
   * @returns RawTransaction
   */
  build(e, n, r) {
    const { sender: s, sequenceNumber: o, gasUnitPrice: c, maxGasAmount: l, expSecFromNow: f, chainId: p } = this.builderConfig;
    if (!c)
      throw new Error("No gasUnitPrice provided.");
    const y = s instanceof We ? s : We.fromHex(s), w = BigInt(Math.floor(Date.now() / 1e3) + Number(f)), b = this.buildTransactionPayload(e, n, r);
    if (b)
      return new xr(
        y,
        BigInt(o),
        b,
        BigInt(l),
        BigInt(c),
        w,
        new wa(Number(p))
      );
    throw new Error("Invalid ABI.");
  }
}, bd = class {
  // We don't want the builder to depend on the actual AptosClient. There might be circular dependencies.
  constructor(t, e) {
    this.aptosClient = t, this.builderConfig = e;
  }
  async fetchABI(t) {
    const n = (await this.aptosClient.getAccountModules(t)).map((s) => s.abi).flatMap(
      (s) => s.exposed_functions.filter((o) => o.is_entry).map(
        (o) => ({
          fullName: `${s.address}::${s.name}::${o.name}`,
          ...o
        })
      )
    ), r = /* @__PURE__ */ new Map();
    return n.forEach((s) => {
      r.set(s.fullName, s);
    }), r;
  }
  /**
   * Builds a raw transaction. Only support script function a.k.a entry function payloads
   *
   * @param func fully qualified function name in format <address>::<module>::<function>, e.g. 0x1::coin::transfer
   * @param ty_tags
   * @param args
   * @returns RawTransaction
   */
  async build(t, e, n) {
    if (t = ((L) => L.replace(/^0[xX]0*/g, "0x"))(t), t.split("::").length !== 3)
      throw new Error(
        // eslint-disable-next-line max-len
        "'func' needs to be a fully qualified function name in format <address>::<module>::<function>, e.g. 0x1::coin::transfer"
      );
    const [o, c] = t.split("::"), l = await this.fetchABI(o);
    if (!l.has(t))
      throw new Error(`${t} doesn't exist.`);
    const f = l.get(t), y = f.params.filter((L) => L !== "signer" && L !== "&signer").map(
      (L, ve) => new Si(`var${ve}`, new Ns(L, e).parseTypeTag())
    ), w = new hs(
      f.name,
      ds.fromStr(`${o}::${c}`),
      "",
      // Doc string
      f.generic_type_params.map((L, ve) => new xi(`${ve}`)),
      y
    ), { sender: b, ...x } = this.builderConfig, I = b instanceof We ? me.fromUint8Array(b.address) : b, [{ sequence_number: z }, S, { gas_estimate: Z }] = await Promise.all([
      x != null && x.sequenceNumber ? Promise.resolve({ sequence_number: x == null ? void 0 : x.sequenceNumber }) : this.aptosClient.getAccount(I),
      x != null && x.chainId ? Promise.resolve(x == null ? void 0 : x.chainId) : this.aptosClient.getChainId(),
      x != null && x.gasUnitPrice ? Promise.resolve({ gas_estimate: x == null ? void 0 : x.gasUnitPrice }) : this.aptosClient.estimateGasPrice()
    ]);
    return new t5([an(w)], {
      sender: b,
      sequenceNumber: z,
      chainId: S,
      gasUnitPrice: BigInt(Z),
      ...x
    }).build(t, e, n);
  }
};
Fe([
  ol(10 * 60 * 1e3)
], bd.prototype, "fetchABI");
var qe = class sr {
  /**
   * Build a client configured to connect to an Aptos node at the given URL.
   *
   * Note: If you forget to append `/v1` to the URL, the client constructor
   * will automatically append it. If you don't want this URL processing to
   * take place, set doNotFixNodeUrl to true.
   *
   * @param nodeUrl URL of the Aptos Node API endpoint.
   * @param config Additional configuration options for the generated Axios client.
   */
  constructor(e, n, r = !1) {
    if (!e)
      throw new Error("Node URL cannot be empty.");
    r ? this.nodeUrl = e : this.nodeUrl = Zg(e), this.config = n == null ? {} : { ...n };
  }
  async getAccount(e) {
    const { data: n } = await Et({
      url: this.nodeUrl,
      endpoint: `accounts/${me.ensure(e).hex()}`,
      originMethod: "getAccount",
      overrides: { ...this.config }
    });
    return n;
  }
  async getAccountTransactions(e, n) {
    const { data: r } = await Et({
      url: this.nodeUrl,
      endpoint: `accounts/${me.ensure(e).hex()}/transactions`,
      originMethod: "getAccountTransactions",
      params: { start: n == null ? void 0 : n.start, limit: n == null ? void 0 : n.limit },
      overrides: { ...this.config }
    });
    return r;
  }
  async getAccountModules(e, n) {
    return await ac({
      url: this.nodeUrl,
      endpoint: `accounts/${e}/modules`,
      params: { ledger_version: n == null ? void 0 : n.ledgerVersion, limit: 1e3 },
      originMethod: "getAccountModules",
      overrides: { ...this.config }
    });
  }
  async getAccountModule(e, n, r) {
    const { data: s } = await Et({
      url: this.nodeUrl,
      endpoint: `accounts/${me.ensure(e).hex()}/module/${n}`,
      originMethod: "getAccountModule",
      params: { ledger_version: r == null ? void 0 : r.ledgerVersion },
      overrides: { ...this.config }
    });
    return s;
  }
  async getAccountResources(e, n) {
    return await ac({
      url: this.nodeUrl,
      endpoint: `accounts/${e}/resources`,
      params: { ledger_version: n == null ? void 0 : n.ledgerVersion, limit: 9999 },
      originMethod: "getAccountResources",
      overrides: { ...this.config }
    });
  }
  async getAccountResource(e, n, r) {
    const { data: s } = await Et({
      url: this.nodeUrl,
      endpoint: `accounts/${me.ensure(e).hex()}/resource/${n}`,
      originMethod: "getAccountResource",
      params: { ledger_version: r == null ? void 0 : r.ledgerVersion },
      overrides: { ...this.config }
    });
    return s;
  }
  /** Generates a signed transaction that can be submitted to the chain for execution. */
  static generateBCSTransaction(e, n) {
    return new qi((s) => {
      const o = e.signBuffer(s);
      return new Oe.Ed25519Signature(o.toUint8Array());
    }, e.pubKey().toUint8Array()).sign(n);
  }
  /**
   * Note: Unless you have a specific reason for using this, it'll probably be simpler
   * to use `simulateTransaction`.
   *
   * Generates a BCS transaction that can be submitted to the chain for simulation.
   *
   * @param accountFrom The account that will be used to send the transaction
   * for simulation.
   * @param rawTxn The raw transaction to be simulated, likely created by calling
   * the `generateTransaction` function.
   * @returns The BCS encoded signed transaction, which you should then pass into
   * the `submitBCSSimulation` function.
   */
  static generateBCSSimulation(e, n) {
    return new qi((s) => {
      const o = new Uint8Array(64);
      return new Oe.Ed25519Signature(o);
    }, e.pubKey().toUint8Array()).sign(n);
  }
  /** Generates an entry function transaction request that can be submitted to produce a raw transaction that
   * can be signed, which upon being signed can be submitted to the blockchain
   * This function fetches the remote ABI and uses it to serialized the data, therefore
   * users don't need to handle serialization by themselves.
   * @param sender Hex-encoded 32 byte Aptos account address of transaction sender
   * @param payload Entry function transaction payload type
   * @param options Options allow to overwrite default transaction options.
   * @returns A raw transaction object
   */
  async generateTransaction(e, n, r) {
    const s = { sender: e };
    if (r != null && r.sequence_number && (s.sequenceNumber = r.sequence_number), r != null && r.gas_unit_price && (s.gasUnitPrice = r.gas_unit_price), r != null && r.max_gas_amount && (s.maxGasAmount = r.max_gas_amount), r != null && r.expiration_timestamp_secs) {
      const c = Number.parseInt(r.expiration_timestamp_secs, 10);
      s.expSecFromNow = c - Math.floor(Date.now() / 1e3);
    }
    return new bd(this, s).build(n.function, n.type_arguments, n.arguments);
  }
  /**
   * Generates a fee payer transaction that can be signed and submitted to chain
   *
   * @param sender the sender's account address
   * @param payload the transaction payload
   * @param fee_payer the fee payer account
   * @param secondarySignerAccounts an optional array of the secondary signers accounts
   * @returns a fee payer raw transaction that can be signed and submitted to chain
   */
  async generateFeePayerTransaction(e, n, r, s = [], o) {
    const c = await this.generateTransaction(e, n, o), l = s.map((p) => We.fromHex(p));
    return new Oe.FeePayerRawTransaction(c, l, We.fromHex(r));
  }
  /**
   * Submits fee payer transaction to chain
   *
   * @param feePayerTransaction the raw transaction to be submitted, of type FeePayerRawTransaction
   * @param senderAuthenticator the sender account authenticator (can get from signMultiTransaction() method)
   * @param feePayerAuthenticator the feepayer account authenticator (can get from signMultiTransaction() method)
   * @param signersAuthenticators an optional array of the signer account authenticators
   * @returns The pending transaction
   */
  async submitFeePayerTransaction(e, n, r, s = []) {
    const o = new Oe.TransactionAuthenticatorFeePayer(
      n,
      e.secondary_signer_addresses,
      s,
      { address: e.fee_payer_address, authenticator: r }
    ), c = an(
      new Oe.SignedTransaction(e.raw_txn, o)
    );
    return await this.submitSignedBCSTransaction(c);
  }
  /**
   * Signs a multi transaction type (multi agent / fee payer) and returns the
   * signer authenticator to be used to submit the transaction.
   *
   * @param signer the account to sign on the transaction
   * @param rawTxn a MultiAgentRawTransaction or FeePayerRawTransaction
   * @returns signer authenticator
   */
  // eslint-disable-next-line class-methods-use-this
  async signMultiTransaction(e, n) {
    const r = new Oe.Ed25519Signature(
      e.signBuffer(fs.getSigningMessage(n)).toUint8Array()
    ), s = new Oe.AccountAuthenticatorEd25519(
      new Oe.Ed25519PublicKey(e.signingKey.publicKey),
      r
    );
    return Promise.resolve(s);
  }
  /** Converts a transaction request produced by `generateTransaction` into a properly
   * signed transaction, which can then be submitted to the blockchain
   * @param accountFrom AptosAccount of transaction sender
   * @param rawTransaction A raw transaction generated by `generateTransaction` method
   * @returns A transaction, signed with sender account
   */
  // eslint-disable-next-line class-methods-use-this
  async signTransaction(e, n) {
    return Promise.resolve(sr.generateBCSTransaction(e, n));
  }
  async getEventsByCreationNumber(e, n, r) {
    const { data: s } = await Et({
      url: this.nodeUrl,
      endpoint: `accounts/${me.ensure(e).hex()}/events/${n}`,
      originMethod: "getEventsByCreationNumber",
      params: { start: r == null ? void 0 : r.start, limit: r == null ? void 0 : r.limit },
      overrides: { ...this.config }
    });
    return s;
  }
  async getEventsByEventHandle(e, n, r, s) {
    const { data: o } = await Et({
      url: this.nodeUrl,
      endpoint: `accounts/${me.ensure(e).hex()}/events/${n}/${r}`,
      originMethod: "getEventsByEventHandle",
      params: { start: s == null ? void 0 : s.start, limit: s == null ? void 0 : s.limit },
      overrides: { ...this.config }
    });
    return o;
  }
  /**
   * Submits a signed transaction to the transaction endpoint.
   * @param signedTxn A transaction, signed by `signTransaction` method
   * @returns Transaction that is accepted and submitted to mempool
   */
  async submitTransaction(e) {
    return this.submitSignedBCSTransaction(e);
  }
  /**
   * Generates and submits a transaction to the transaction simulation
   * endpoint. For this we generate a transaction with a fake signature.
   *
   * @param accountOrPubkey The sender or sender's public key. When private key is available, `AptosAccount` instance
   * can be used to send the transaction for simulation. If private key is not available, sender's public key can be
   * used to send the transaction for simulation.
   * @param rawTransaction The raw transaction to be simulated, likely created
   * by calling the `generateTransaction` function.
   * @param query.estimateGasUnitPrice If set to true, the gas unit price in the
   * transaction will be ignored and the estimated value will be used.
   * @param query.estimateMaxGasAmount If set to true, the max gas value in the
   * transaction will be ignored and the maximum possible gas will be used.
   * @param query.estimatePrioritizedGasUnitPrice If set to true, the transaction will use a higher price than the
   * original estimate.
   * @returns The BCS encoded signed transaction, which you should then provide
   *
   */
  async simulateTransaction(e, n, r) {
    let s;
    return e instanceof lc ? s = sr.generateBCSSimulation(e, n) : e instanceof Ii ? s = new e5(() => {
      const { threshold: c } = e, l = [], f = [];
      for (let y = 0; y < c; y += 1)
        l.push(y), f.push(new Oe.Ed25519Signature(new Uint8Array(64)));
      const p = Oe.MultiEd25519Signature.createBitmap(l);
      return new Oe.MultiEd25519Signature(f, p);
    }, e).sign(n) : s = new qi(() => {
      const c = new Uint8Array(64);
      return new Oe.Ed25519Signature(c);
    }, e.toBytes()).sign(n), this.submitBCSSimulation(s, r);
  }
  async submitSignedBCSTransaction(e) {
    const { data: n } = await Jr({
      url: this.nodeUrl,
      body: e,
      endpoint: "transactions",
      originMethod: "submitSignedBCSTransaction",
      contentType: "application/x.aptos.signed_transaction+bcs",
      overrides: { ...this.config }
    });
    return n;
  }
  async submitBCSSimulation(e, n) {
    var r, s, o;
    const c = {
      estimate_gas_unit_price: (r = n == null ? void 0 : n.estimateGasUnitPrice) != null ? r : !1,
      estimate_max_gas_amount: (s = n == null ? void 0 : n.estimateMaxGasAmount) != null ? s : !1,
      estimate_prioritized_gas_unit_price: (o = n == null ? void 0 : n.estimatePrioritizedGasUnitPrice) != null ? o : !1
    }, { data: l } = await Jr({
      url: this.nodeUrl,
      body: e,
      endpoint: "transactions/simulate",
      params: c,
      originMethod: "submitBCSSimulation",
      contentType: "application/x.aptos.signed_transaction+bcs",
      overrides: { ...this.config }
    });
    return l;
  }
  async getTransactions(e) {
    var n;
    const { data: r } = await Et({
      url: this.nodeUrl,
      endpoint: "transactions",
      originMethod: "getTransactions",
      params: { start: (n = e == null ? void 0 : e.start) == null ? void 0 : n.toString(), limit: e == null ? void 0 : e.limit },
      overrides: { ...this.config }
    });
    return r;
  }
  async getTransactionByHash(e) {
    const { data: n } = await Et({
      url: this.nodeUrl,
      endpoint: `transactions/by_hash/${e}`,
      originMethod: "getTransactionByHash",
      overrides: { ...this.config }
    });
    return n;
  }
  async getTransactionByVersion(e) {
    const { data: n } = await Et({
      url: this.nodeUrl,
      endpoint: `transactions/by_version/${e}`,
      originMethod: "getTransactionByVersion",
      overrides: { ...this.config }
    });
    return n;
  }
  /**
   * Defines if specified transaction is currently in pending state
   * @param txnHash A hash of transaction
   *
   * To create a transaction hash:
   *
   * 1. Create hash message bytes: "Aptos::Transaction" bytes + BCS bytes of Transaction.
   * 2. Apply hash algorithm SHA3-256 to the hash message bytes.
   * 3. Hex-encode the hash bytes with 0x prefix.
   *
   * @returns `true` if transaction is in pending state and `false` otherwise
   */
  async transactionPending(e) {
    try {
      return (await this.getTransactionByHash(e)).type === "pending_transaction";
    } catch (n) {
      if ((n == null ? void 0 : n.status) === 404)
        return !0;
      throw n;
    }
  }
  /**
   * Wait for a transaction to move past pending state.
   *
   * There are 4 possible outcomes:
   * 1. Transaction is processed and successfully committed to the blockchain.
   * 2. Transaction is rejected for some reason, and is therefore not committed
   *    to the blockchain.
   * 3. Transaction is committed but execution failed, meaning no changes were
   *    written to the blockchain state.
   * 4. Transaction is not processed within the specified timeout.
   *
   * In case 1, this function resolves with the transaction response returned
   * by the API.
   *
   * In case 2, the function will throw an ApiError, likely with an HTTP status
   * code indicating some problem with the request (e.g. 400).
   *
   * In case 3, if `checkSuccess` is false (the default), this function returns
   * the transaction response just like in case 1, in which the `success` field
   * will be false. If `checkSuccess` is true, it will instead throw a
   * FailedTransactionError.
   *
   * In case 4, this function throws a WaitForTransactionError.
   *
   * @param txnHash The hash of a transaction previously submitted to the blockchain.
   * @param extraArgs.timeoutSecs Timeout in seconds. Defaults to 20 seconds.
   * @param extraArgs.checkSuccess See above. Defaults to false.
   * @returns See above.
   *
   * @example
   * ```
   * const rawTransaction = await this.generateRawTransaction(sender.address(), payload, extraArgs);
   * const bcsTxn = AptosClient.generateBCSTransaction(sender, rawTransaction);
   * const pendingTransaction = await this.submitSignedBCSTransaction(bcsTxn);
   * const transasction = await this.aptosClient.waitForTransactionWithResult(pendingTransaction.hash);
   * ```
   */
  async waitForTransactionWithResult(e, n) {
    var r, s;
    const o = (r = n == null ? void 0 : n.timeoutSecs) != null ? r : qg, c = (s = n == null ? void 0 : n.checkSuccess) != null ? s : !1;
    let l = !0, f = 0, p;
    for (; l && !(f >= o); ) {
      try {
        if (p = await this.getTransactionByHash(e), l = p.type === "pending_transaction", !l)
          break;
      } catch (y) {
        const w = y instanceof Da, b = w && y.status !== 404 && y.status >= 400 && y.status < 500;
        if (!w || b)
          throw y;
      }
      await Vg(1e3), f += 1;
    }
    if (p === void 0)
      throw new Error(`Waiting for transaction ${e} failed`);
    if (l)
      throw new n5(
        `Waiting for transaction ${e} timed out after ${o} seconds`,
        p
      );
    if (!c)
      return p;
    if (!(p != null && p.success))
      throw new r5(
        `Transaction ${e} failed with an error: ${p.vm_status}`,
        p
      );
    return p;
  }
  /**
   * This function works the same as `waitForTransactionWithResult` except it
   * doesn't return the transaction in those cases, it returns nothing. For
   * more information, see the documentation for `waitForTransactionWithResult`.
   */
  async waitForTransaction(e, n) {
    await this.waitForTransactionWithResult(e, n);
  }
  async getLedgerInfo() {
    const { data: e } = await Et({
      url: this.nodeUrl,
      originMethod: "getLedgerInfo",
      overrides: { ...this.config }
    });
    return e;
  }
  async getChainId() {
    return (await this.getLedgerInfo()).chain_id;
  }
  async getTableItem(e, n, r) {
    var s;
    return (await Jr({
      url: this.nodeUrl,
      body: n,
      endpoint: `tables/${e}/item`,
      originMethod: "getTableItem",
      params: { ledger_version: (s = r == null ? void 0 : r.ledgerVersion) == null ? void 0 : s.toString() },
      overrides: { ...this.config }
    })).data;
  }
  /**
   * Generates a raw transaction out of a transaction payload
   * @param accountFrom
   * @param payload
   * @param extraArgs
   * @returns A raw transaction object
   */
  async generateRawTransaction(e, n, r) {
    const [{ sequence_number: s }, o, { gas_estimate: c }] = await Promise.all([
      r != null && r.providedSequenceNumber ? Promise.resolve({ sequence_number: r.providedSequenceNumber }) : this.getAccount(e),
      this.getChainId(),
      r != null && r.gasUnitPrice ? Promise.resolve({ gas_estimate: r.gasUnitPrice }) : this.estimateGasPrice()
    ]), { maxGasAmount: l, gasUnitPrice: f, expireTimestamp: p } = {
      maxGasAmount: BigInt(sl),
      gasUnitPrice: BigInt(c),
      expireTimestamp: BigInt(Math.floor(Date.now() / 1e3) + il),
      ...r
    };
    return new Oe.RawTransaction(
      Oe.AccountAddress.fromHex(e),
      BigInt(s),
      n,
      l,
      f,
      p,
      new Oe.ChainId(o)
    );
  }
  /**
   * Helper for generating, signing, and submitting a transaction.
   *
   * @param sender AptosAccount of transaction sender.
   * @param payload Transaction payload.
   * @param extraArgs Extra args for building the transaction payload.
   * @returns The transaction response from the API.
   */
  async generateSignSubmitTransaction(e, n, r) {
    const s = await this.generateRawTransaction(e.address(), n, r), o = sr.generateBCSTransaction(e, s);
    return (await this.submitSignedBCSTransaction(o)).hash;
  }
  /**
   * Helper for signing and submitting a transaction.
   *
   * @param sender AptosAccount of transaction sender.
   * @param transaction A generated Raw transaction payload.
   * @returns The transaction response from the API.
   */
  async signAndSubmitTransaction(e, n) {
    const r = sr.generateBCSTransaction(e, n);
    return (await this.submitSignedBCSTransaction(r)).hash;
  }
  /**
   * Publishes a move package. `packageMetadata` and `modules` can be generated with command
   * `aptos move compile --save-metadata [ --included-artifacts=<...> ]`.
   * @param sender
   * @param packageMetadata package metadata bytes
   * @param modules bytecodes of modules
   * @param extraArgs
   * @returns Transaction hash
   */
  async publishPackage(e, n, r, s) {
    const o = new Ze();
    ut(r, o);
    const c = new Oe.TransactionPayloadEntryFunction(
      Oe.EntryFunction.natural(
        "0x1::code",
        "publish_package_txn",
        [],
        [pn(n), o.getBytes()]
      )
    );
    return this.generateSignSubmitTransaction(e, c, s);
  }
  /**
   * Publishes a move packages by creating a resource account.
   * The package cannot be upgraded since it is deployed by resource account
   * `packageMetadata` and `modules` can be generated with command
   * `aptos move compile --save-metadata [ --included-artifacts=<...> ]`.
   * @param sender
   * @param seed seeds for creation of resource address
   * @param packageMetadata package metadata bytes
   * @param modules bytecodes of modules
   * @param extraArgs
   * @returns Transaction hash
   */
  async createResourceAccountAndPublishPackage(e, n, r, s, o) {
    const c = new Ze();
    ut(s, c);
    const l = new Oe.TransactionPayloadEntryFunction(
      Oe.EntryFunction.natural(
        "0x1::resource_account",
        "create_resource_account_and_publish_package",
        [],
        [pn(n), pn(r), c.getBytes()]
      )
    );
    return this.generateSignSubmitTransaction(e, l, o);
  }
  /**
   * Helper for generating, submitting, and waiting for a transaction, and then
   * checking whether it was committed successfully. Under the hood this is just
   * `generateSignSubmitTransaction` and then `waitForTransactionWithResult`, see
   * those for information about the return / error semantics of this function.
   */
  async generateSignSubmitWaitForTransaction(e, n, r) {
    const s = await this.generateSignSubmitTransaction(e, n, r);
    return this.waitForTransactionWithResult(s, r);
  }
  async estimateGasPrice() {
    const { data: e } = await Et({
      url: this.nodeUrl,
      endpoint: "estimate_gas_price",
      originMethod: "estimateGasPrice",
      overrides: { ...this.config }
    });
    return e;
  }
  async estimateMaxGasAmount(e) {
    const n = `0x1::coin::CoinStore<${Xg}>`, [{ gas_estimate: r }, s] = await Promise.all([
      this.estimateGasPrice(),
      this.getAccountResources(e)
    ]), o = s.find((l) => l.type === n);
    return BigInt(o.data.coin.value) / BigInt(r);
  }
  /**
   * Rotate an account's auth key. After rotation, only the new private key can be used to sign txns for
   * the account.
   * WARNING: You must create a new instance of AptosAccount after using this function.
   * @param forAccount Account of which the auth key will be rotated
   * @param toPrivateKeyBytes New private key
   * @param extraArgs Extra args for building the transaction payload.
   * @returns PendingTransaction
   */
  async rotateAuthKeyEd25519(e, n, r) {
    const { sequence_number: s, authentication_key: o } = await this.getAccount(
      e.address()
    ), c = new lc(n), l = new Oe.RotationProofChallenge(
      Oe.AccountAddress.CORE_CODE_ADDRESS,
      "account",
      "RotationProofChallenge",
      BigInt(s),
      Oe.AccountAddress.fromHex(e.address()),
      new Oe.AccountAddress(new me(o).toUint8Array()),
      c.pubKey().toUint8Array()
    ), f = me.fromUint8Array(an(l)), p = e.signHexString(f), y = c.signHexString(f), w = new Oe.TransactionPayloadEntryFunction(
      Oe.EntryFunction.natural(
        "0x1::account",
        "rotate_authentication_key",
        [],
        [
          Io(0),
          // ed25519 scheme
          pn(e.pubKey().toUint8Array()),
          Io(0),
          // ed25519 scheme
          pn(c.pubKey().toUint8Array()),
          pn(p.toUint8Array()),
          pn(y.toUint8Array())
        ]
      )
    ), b = await this.generateRawTransaction(e.address(), w, r), x = sr.generateBCSTransaction(e, b);
    return this.submitSignedBCSTransaction(x);
  }
  /**
   * Lookup the original address by the current derived address
   * @param addressOrAuthKey
   * @returns original address
   */
  async lookupOriginalAddress(e) {
    const n = await this.getAccountResource("0x1", "0x1::account::OriginatingAddress"), {
      address_map: { handle: r }
    } = n.data, s = await this.getTableItem(r, {
      key_type: "address",
      value_type: "address",
      key: me.ensure(e).hex()
    });
    return new me(s);
  }
  async getBlockByHeight(e, n) {
    const { data: r } = await Et({
      url: this.nodeUrl,
      endpoint: `blocks/by_height/${e}`,
      originMethod: "getBlockByHeight",
      params: { with_transactions: n },
      overrides: { ...this.config }
    });
    return r;
  }
  async getBlockByVersion(e, n) {
    const { data: r } = await Et({
      url: this.nodeUrl,
      endpoint: `blocks/by_version/${e}`,
      originMethod: "getBlockByVersion",
      params: { with_transactions: n },
      overrides: { ...this.config }
    });
    return r;
  }
  async view(e, n) {
    const { data: r } = await Jr({
      url: this.nodeUrl,
      body: e,
      endpoint: "view",
      originMethod: "getTableItem",
      params: { ledger_version: n },
      overrides: { ...this.config }
    });
    return r;
  }
  // eslint-disable-next-line class-methods-use-this
  clearCache(e) {
    Jg(e);
  }
};
Fe([
  rt
], qe.prototype, "getAccount");
Fe([
  rt
], qe.prototype, "getAccountTransactions");
Fe([
  rt,
  ol(10 * 60 * 1e3)
], qe.prototype, "getAccountModules");
Fe([
  rt
], qe.prototype, "getAccountModule");
Fe([
  rt
], qe.prototype, "getAccountResources");
Fe([
  rt
], qe.prototype, "getAccountResource");
Fe([
  rt
], qe.prototype, "getEventsByCreationNumber");
Fe([
  rt
], qe.prototype, "getEventsByEventHandle");
Fe([
  rt
], qe.prototype, "submitSignedBCSTransaction");
Fe([
  rt
], qe.prototype, "submitBCSSimulation");
Fe([
  rt
], qe.prototype, "getTransactions");
Fe([
  rt
], qe.prototype, "getTransactionByHash");
Fe([
  rt
], qe.prototype, "getTransactionByVersion");
Fe([
  rt
], qe.prototype, "getLedgerInfo");
Fe([
  Ti()
], qe.prototype, "getChainId");
Fe([
  rt
], qe.prototype, "getTableItem");
Fe([
  rt,
  Ti({
    ttlMs: 5 * 60 * 1e3,
    // cache result for 5min
    tags: ["gas_estimates"]
  })
], qe.prototype, "estimateGasPrice");
Fe([
  rt
], qe.prototype, "estimateMaxGasAmount");
Fe([
  rt
], qe.prototype, "getBlockByHeight");
Fe([
  rt
], qe.prototype, "getBlockByVersion");
Fe([
  rt
], qe.prototype, "view");
var Td = qe, n5 = class extends Error {
  constructor(t, e) {
    super(t), this.lastSubmittedTransaction = e;
  }
}, r5 = class extends Error {
  constructor(t, e) {
    super(t), this.transaction = e;
  }
}, Da = class extends Error {
  constructor(t, e, n, r) {
    super(e), this.status = t, this.message = e, this.errorCode = n, this.vmErrorCode = r;
  }
};
function rt(t, e, n) {
  const r = n.value;
  return n.value = async function(...o) {
    var c, l;
    try {
      return await r.apply(this, [...o]);
    } catch (f) {
      throw f instanceof al ? new Da(
        f.status,
        JSON.stringify({ message: f.message, ...f.data }),
        (c = f.data) == null ? void 0 : c.error_code,
        (l = f.data) == null ? void 0 : l.vm_error_code
      ) : f;
    }
  }, n;
}
var Id = class Xe {
  /**
   * @param endpoint URL of the Aptos Indexer API endpoint.
   */
  constructor(e, n) {
    this.endpoint = e, this.config = n;
  }
  /**
   * Indexer only accepts address in the long format, i.e a 66 chars long -> 0x<64 chars>
   * This method makes sure address is 66 chars long.
   * @param address
   */
  static validateAddress(e) {
    if (e.length < 66)
      throw new Error(`${e} is less than 66 chars long.`);
  }
  /**
   * Makes axios client call to fetch data from Aptos Indexer.
   *
   * @param graphqlQuery A GraphQL query to pass in the `data` axios call.
   */
  async queryIndexer(e) {
    const n = await Jr({
      url: this.endpoint,
      body: e,
      overrides: { WITH_CREDENTIALS: !1, ...this.config }
    });
    if (n.data.errors)
      throw new Da(
        n.data.errors[0].extensions.code,
        JSON.stringify({
          message: n.data.errors[0].message,
          error_code: n.data.errors[0].extensions.code
        })
      );
    return n.data.data;
  }
  /**
   * Queries Indexer Ledger Info
   *
   * @returns GetLedgerInfoQuery response type
   */
  async getIndexerLedgerInfo() {
    const e = {
      query: j0
    };
    return this.queryIndexer(e);
  }
  // TOKENS //
  /**
   * @deprecated please use `getOwnedTokens` query
   *
   * Queries an Aptos account's NFTs by owner address
   *
   * @param ownerAddress Hex-encoded 32 byte Aptos account address
   * @returns GetAccountCurrentTokensQuery response type
   */
  async getAccountNFTs(e, n) {
    const r = me.ensure(e).hex();
    Xe.validateAddress(r);
    const s = {
      query: S0,
      variables: { address: r, offset: n == null ? void 0 : n.offset, limit: n == null ? void 0 : n.limit }
    };
    return this.queryIndexer(s);
  }
  /**
   * Queries a token activities by token address (v2) or token data id (v1)
   *
   * @param idHash token address (v2) or token data id (v1)
   * @returns GetTokenActivitiesQuery response type
   */
  async getTokenActivities(e, n) {
    var r, s;
    const o = me.ensure(e).hex();
    Xe.validateAddress(o);
    const c = {
      token_data_id: { _eq: o }
    };
    n != null && n.tokenStandard && (c.token_standard = { _eq: n == null ? void 0 : n.tokenStandard });
    const l = {
      query: R0,
      variables: {
        where_condition: c,
        offset: (r = n == null ? void 0 : n.options) == null ? void 0 : r.offset,
        limit: (s = n == null ? void 0 : n.options) == null ? void 0 : s.limit,
        order_by: n == null ? void 0 : n.orderBy
      }
    };
    return this.queryIndexer(l);
  }
  /**
   * Gets the count of token's activities by token address (v2) or token data id (v1)
   *
   * @param token token address (v2) or token data id (v1)
   * @returns GetTokenActivitiesCountQuery response type
   */
  async getTokenActivitiesCount(e) {
    const n = {
      query: F0,
      variables: { token_id: e }
    };
    return this.queryIndexer(n);
  }
  /**
   * Gets the count of tokens owned by an account
   *
   * @param ownerAddress Owner address
   * @returns AccountTokensCountQuery response type
   */
  async getAccountTokensCount(e, n) {
    var r, s;
    const o = {
      owner_address: { _eq: e },
      amount: { _gt: "0" }
    };
    n != null && n.tokenStandard && (o.token_standard = { _eq: n == null ? void 0 : n.tokenStandard });
    const c = me.ensure(e).hex();
    Xe.validateAddress(c);
    const l = {
      query: D0,
      variables: {
        where_condition: o,
        offset: (r = n == null ? void 0 : n.options) == null ? void 0 : r.offset,
        limit: (s = n == null ? void 0 : n.options) == null ? void 0 : s.limit
      }
    };
    return this.queryIndexer(l);
  }
  /**
   * Queries token data by token address (v2) or token data id (v1)
   *
   * @param token token address (v2) or token data id (v1)
   * @returns GetTokenDataQuery response type
   */
  // :!:>getTokenData
  async getTokenData(e, n) {
    var r, s;
    const o = me.ensure(e).hex();
    Xe.validateAddress(o);
    const c = {
      token_data_id: { _eq: o }
    };
    n != null && n.tokenStandard && (c.token_standard = { _eq: n == null ? void 0 : n.tokenStandard });
    const l = {
      query: Q0,
      variables: {
        where_condition: c,
        offset: (r = n == null ? void 0 : n.options) == null ? void 0 : r.offset,
        limit: (s = n == null ? void 0 : n.options) == null ? void 0 : s.limit,
        order_by: n == null ? void 0 : n.orderBy
      }
    };
    return this.queryIndexer(l);
  }
  // <:!:getTokenData
  /**
   * Queries token owners data by token address (v2) or token data id (v1).
   * This query returns historical owners data.
   *
   * To fetch token v2 standard, pass in the optional `tokenStandard` parameter and
   * dont pass `propertyVersion` parameter (as propertyVersion only compatible with v1 standard)
   *
   * @param token token address (v2) or token data id (v1)
   * @param propertyVersion Property version (optional) - only compatible with token v1 standard
   * @returns GetTokenOwnersDataQuery response type
   */
  async getTokenOwnersData(e, n, r) {
    var s, o;
    const c = me.ensure(e).hex();
    Xe.validateAddress(c);
    const l = {
      token_data_id: { _eq: c },
      amount: { _gt: "0" }
    };
    n && (l.property_version_v1 = { _eq: n }), r != null && r.tokenStandard && (l.token_standard = { _eq: r == null ? void 0 : r.tokenStandard });
    const f = {
      query: H0,
      variables: {
        where_condition: l,
        offset: (s = r == null ? void 0 : r.options) == null ? void 0 : s.offset,
        limit: (o = r == null ? void 0 : r.options) == null ? void 0 : o.limit,
        order_by: r == null ? void 0 : r.orderBy
      }
    };
    return this.queryIndexer(f);
  }
  /**
   * Queries current token owner data by token address (v2) or token data id (v1).
   * This query returns the current token owner data.
   *
   * To fetch token v2 standard, pass in the optional `tokenStandard` parameter and
   * dont pass `propertyVersion` parameter (as propertyVersion only compatible with v1 standard)
   *
   * @param token token address (v2) or token data id (v1)
   * @param propertyVersion Property version (optional) - only compatible with token v1 standard
   * @returns GetTokenCurrentOwnerDataQuery response type
   */
  async getTokenCurrentOwnerData(e, n, r) {
    var s, o;
    const c = me.ensure(e).hex();
    Xe.validateAddress(c);
    const l = {
      token_data_id: { _eq: c },
      amount: { _gt: "0" }
    };
    n && (l.property_version_v1 = { _eq: n }), r != null && r.tokenStandard && (l.token_standard = { _eq: r == null ? void 0 : r.tokenStandard });
    const f = {
      query: W0,
      variables: {
        where_condition: l,
        offset: (s = r == null ? void 0 : r.options) == null ? void 0 : s.offset,
        limit: (o = r == null ? void 0 : r.options) == null ? void 0 : o.limit,
        order_by: r == null ? void 0 : r.orderBy
      }
    };
    return this.queryIndexer(f);
  }
  /**
   * Queries account's current owned tokens.
   * This query returns all tokens (v1 and v2 standards) an account owns, including NFTs, fungible, soulbound, etc.
   * If you want to get only the token from a specific standrd, you can pass an optional tokenStandard param
   *
   * @param ownerAddress The token owner address we want to get the tokens for
   * @returns GetOwnedTokensQuery response type
   */
  async getOwnedTokens(e, n) {
    var r, s;
    const o = me.ensure(e).hex();
    Xe.validateAddress(o);
    const c = {
      owner_address: { _eq: o },
      amount: { _gt: 0 }
    };
    n != null && n.tokenStandard && (c.token_standard = { _eq: n == null ? void 0 : n.tokenStandard });
    const l = {
      query: _0,
      variables: {
        where_condition: c,
        offset: (r = n == null ? void 0 : n.options) == null ? void 0 : r.offset,
        limit: (s = n == null ? void 0 : n.options) == null ? void 0 : s.limit,
        order_by: n == null ? void 0 : n.orderBy
      }
    };
    return this.queryIndexer(l);
  }
  /**
   * Queries account's current owned tokens by token address (v2) or token data id (v1).
   *
   * @param token token address (v2) or token data id (v1)
   * @returns GetOwnedTokensByTokenDataQuery response type
   */
  async getOwnedTokensByTokenData(e, n) {
    var r, s;
    const o = me.ensure(e).hex();
    Xe.validateAddress(o);
    const c = {
      token_data_id: { _eq: o },
      amount: { _gt: 0 }
    };
    n != null && n.tokenStandard && (c.token_standard = { _eq: n == null ? void 0 : n.tokenStandard });
    const l = {
      query: B0,
      variables: {
        where_condition: c,
        offset: (r = n == null ? void 0 : n.options) == null ? void 0 : r.offset,
        limit: (s = n == null ? void 0 : n.options) == null ? void 0 : s.limit,
        order_by: n == null ? void 0 : n.orderBy
      }
    };
    return this.queryIndexer(l);
  }
  /**
   * Queries all tokens of a specific collection that an account owns by the collection address
   *
   * @param ownerAddress owner address that owns the tokens
   * @param collectionAddress the collection address
   * @returns GetTokenOwnedFromCollectionQuery response type
   */
  async getTokenOwnedFromCollectionAddress(e, n, r) {
    var s, o;
    const c = me.ensure(e).hex();
    Xe.validateAddress(c);
    const l = me.ensure(n).hex();
    Xe.validateAddress(l);
    const f = {
      owner_address: { _eq: c },
      current_token_data: { collection_id: { _eq: l } },
      amount: { _gt: 0 }
    };
    r != null && r.tokenStandard && (f.token_standard = { _eq: r == null ? void 0 : r.tokenStandard });
    const p = {
      query: K0,
      variables: {
        where_condition: f,
        offset: (s = r == null ? void 0 : r.options) == null ? void 0 : s.offset,
        limit: (o = r == null ? void 0 : r.options) == null ? void 0 : o.limit,
        order_by: r == null ? void 0 : r.orderBy
      }
    };
    return this.queryIndexer(p);
  }
  /**
   * Queries all tokens of a specific collection that an account owns by the collection name and collection
   * creator address
   *
   * @param ownerAddress owner address that owns the tokens
   * @param collectionName the collection name
   * @param creatorAddress the collection creator address
   * @returns GetTokenOwnedFromCollectionQuery response type
   */
  async getTokenOwnedFromCollectionNameAndCreatorAddress(e, n, r, s) {
    const o = await this.getCollectionAddress(r, n, s);
    return await this.getTokenOwnedFromCollectionAddress(e, o, s);
  }
  /**
   * Queries data of a specific collection by the collection creator address and the collection name.
   *
   * if, for some reason, a creator account has 2 collections with the same name in v1 and v2,
   * can pass an optional `tokenStandard` parameter to query a specific standard
   *
   * @param creatorAddress the collection creator address
   * @param collectionName the collection name
   * @returns GetCollectionDataQuery response type
   */
  async getCollectionData(e, n, r) {
    var s, o;
    const c = me.ensure(e).hex();
    Xe.validateAddress(c);
    const l = {
      collection_name: { _eq: n },
      creator_address: { _eq: c }
    };
    r != null && r.tokenStandard && (l.token_standard = { _eq: r == null ? void 0 : r.tokenStandard });
    const f = {
      query: z0,
      variables: {
        where_condition: l,
        offset: (s = r == null ? void 0 : r.options) == null ? void 0 : s.offset,
        limit: (o = r == null ? void 0 : r.options) == null ? void 0 : o.limit,
        order_by: r == null ? void 0 : r.orderBy
      }
    };
    return this.queryIndexer(f);
  }
  /**
   * Queries a collection address.
   *
   * @param creatorAddress the collection creator address
   * @param collectionName the collection name
   * @returns the collection address
   */
  async getCollectionAddress(e, n, r) {
    return (await this.getCollectionData(e, n, r)).current_collections_v2[0].collection_id;
  }
  /**
   * Queries for all collections that an account has tokens for.
   *
   * @param ownerAddress the account address that owns the tokens
   * @returns GetCollectionsWithOwnedTokensQuery response type
   */
  async getCollectionsWithOwnedTokens(e, n) {
    var r, s;
    const o = me.ensure(e).hex();
    Xe.validateAddress(o);
    const c = {
      owner_address: { _eq: o }
    };
    n != null && n.tokenStandard && (c.current_collection = { token_standard: { _eq: n == null ? void 0 : n.tokenStandard } });
    const l = {
      query: k0,
      variables: {
        where_condition: c,
        offset: (r = n == null ? void 0 : n.options) == null ? void 0 : r.offset,
        limit: (s = n == null ? void 0 : n.options) == null ? void 0 : s.limit,
        order_by: n == null ? void 0 : n.orderBy
      }
    };
    return this.queryIndexer(l);
  }
  // TRANSACTIONS //
  /**
   * Gets the count of transactions submitted by an account
   *
   * @param address Account address
   * @returns GetAccountTransactionsCountQuery response type
   */
  async getAccountTransactionsCount(e) {
    const n = me.ensure(e).hex();
    Xe.validateAddress(n);
    const r = {
      query: U0,
      variables: { address: n }
    };
    return this.queryIndexer(r);
  }
  /**
   * Queries an account transactions data
   *
   * @param address Account address
   * @returns GetAccountTransactionsDataQuery response type
   */
  async getAccountTransactionsData(e, n) {
    var r, s;
    const o = me.ensure(e).hex();
    Xe.validateAddress(o);
    const l = {
      query: C0,
      variables: {
        where_condition: {
          account_address: { _eq: o }
        },
        offset: (r = n == null ? void 0 : n.options) == null ? void 0 : r.offset,
        limit: (s = n == null ? void 0 : n.options) == null ? void 0 : s.limit,
        order_by: n == null ? void 0 : n.orderBy
      }
    };
    return this.queryIndexer(l);
  }
  /**
   * Queries top user transactions
   *
   * @param limit
   * @returns GetTopUserTransactionsQuery response type
   */
  async getTopUserTransactions(e) {
    const n = {
      query: Y0,
      variables: { limit: e }
    };
    return this.queryIndexer(n);
  }
  /**
   * Queries top user transactions
   *
   * @param startVersion optional - can be set to tell indexer what version to start from
   * @returns GetUserTransactionsQuery response type
   */
  async getUserTransactions(e) {
    var n, r;
    const s = {
      version: { _lte: e == null ? void 0 : e.startVersion }
    }, o = {
      query: G0,
      variables: {
        where_condition: s,
        offset: (n = e == null ? void 0 : e.options) == null ? void 0 : n.offset,
        limit: (r = e == null ? void 0 : e.options) == null ? void 0 : r.limit,
        order_by: e == null ? void 0 : e.orderBy
      }
    };
    return this.queryIndexer(o);
  }
  // STAKING //
  /**
   * Queries delegated staking activities
   *
   * @param delegatorAddress Delegator address
   * @param poolAddress Pool address
   * @returns GetDelegatedStakingActivitiesQuery response type
   */
  async getDelegatedStakingActivities(e, n) {
    const r = me.ensure(e).hex(), s = me.ensure(n).hex();
    Xe.validateAddress(r), Xe.validateAddress(s);
    const o = {
      query: L0,
      variables: {
        delegatorAddress: r,
        poolAddress: s
      }
    };
    return this.queryIndexer(o);
  }
  /**
   * Queries current number of delegators in a pool
   *
   * @returns GetNumberOfDelegatorsQuery response type
   */
  async getNumberOfDelegators(e) {
    const n = me.ensure(e).hex();
    Xe.validateAddress(n);
    const r = {
      query: P0,
      variables: { poolAddress: n }
    };
    return this.queryIndexer(r);
  }
  // ACCOUNT //
  /**
   * Queries an account coin data
   *
   * @param ownerAddress Owner address
   * @returns GetAccountCoinsDataQuery response type
   */
  async getAccountCoinsData(e, n) {
    var r, s;
    const o = me.ensure(e).hex();
    Xe.validateAddress(o);
    const l = {
      query: x0,
      variables: {
        where_condition: {
          owner_address: { _eq: o }
        },
        offset: (r = n == null ? void 0 : n.options) == null ? void 0 : r.offset,
        limit: (s = n == null ? void 0 : n.options) == null ? void 0 : s.limit,
        order_by: n == null ? void 0 : n.orderBy
      }
    };
    return this.queryIndexer(l);
  }
  /**
   * Queries an account coin data count
   *
   * @param ownerAddress Owner address
   * @returns GetAccountCoinsDataCountQuery response type
   */
  async getAccountCoinsDataCount(e) {
    const n = me.ensure(e).hex();
    Xe.validateAddress(n);
    const r = {
      query: N0,
      variables: {
        address: n
      }
    };
    return this.queryIndexer(r);
  }
  /**
   * Queries an account owned objects
   *
   * @param ownerAddress Owner address
   * @returns GetCurrentObjectsQuery response type
   */
  async getAccountOwnedObjects(e, n) {
    var r, s;
    const o = me.ensure(e).hex();
    Xe.validateAddress(o);
    const l = {
      query: O0,
      variables: {
        where_condition: {
          owner_address: { _eq: o }
        },
        offset: (r = n == null ? void 0 : n.options) == null ? void 0 : r.offset,
        limit: (s = n == null ? void 0 : n.options) == null ? void 0 : s.limit,
        order_by: n == null ? void 0 : n.orderBy
      }
    };
    return this.queryIndexer(l);
  }
}, Md = class {
  constructor(t, e, n = !1) {
    let r = null, s = null;
    if (typeof t == "object" && s5(t) ? (r = t.fullnodeUrl, s = t.indexerUrl, this.network = "CUSTOM") : (r = n0[t], s = t0[t], this.network = t), this.network === "CUSTOM" && !r)
      throw new Error("fullnode url is not provided");
    s && (this.indexerClient = new Id(s, e)), this.aptosClient = new Td(r, e, n);
  }
};
function Nd(t, e, n) {
  Object.getOwnPropertyNames(e.prototype).forEach((r) => {
    const s = Object.getOwnPropertyDescriptor(e.prototype, r);
    s && (s.value = function(...o) {
      return this[n][r](...o);
    }, Object.defineProperty(t.prototype, r, s));
  }), Object.getOwnPropertyNames(e).forEach((r) => {
    const s = Object.getOwnPropertyDescriptor(e, r);
    s && (s.value = function(...o) {
      return this[n][r](...o);
    }, !t.hasOwnProperty.call(t, r) && Object.defineProperty(t, r, s));
  });
}
Nd(Md, Td, "aptosClient");
Nd(Md, Id, "indexerClient");
function s5(t) {
  return t.fullnodeUrl !== void 0 && typeof t.fullnodeUrl == "string";
}
var xd = class {
  constructor(t, e) {
    this.type = t, this.value = e;
  }
}, Sd = class {
  constructor() {
    this.data = {};
  }
  setProperty(t, e) {
    this.data[t] = e;
  }
};
function i5(t) {
  let e;
  return t === "string" || t === "String" ? e = new Kn(la) : e = new Ns(t).parseTypeTag(), e;
}
function Dd(t) {
  const e = t.map.data, n = new Sd();
  return e.forEach((r) => {
    const { key: s } = r, o = r.value.value, c = r.value.type, l = i5(c), f = o5(l, o), p = new xd(c, f);
    n.setProperty(s, p);
  }), n;
}
function o5(t, e) {
  const n = new oa(new me(e).toUint8Array());
  let r = "";
  return t instanceof vn ? r = n.deserializeU8().toString() : t instanceof Ir ? r = n.deserializeU64().toString() : t instanceof Mr ? r = n.deserializeU128().toString() : t instanceof Tr ? r = n.deserializeBool() ? "true" : "false" : t instanceof Qn ? r = me.fromUint8Array(n.deserializeFixedBytes(32)).hex() : t instanceof Kn && t.isStringTypeTag() ? r = n.deserializeStr() : r = e, r;
}
var a5 = {};
bi(a5, {
  PropertyMap: () => Sd,
  PropertyValue: () => xd,
  Token: () => u5,
  TokenData: () => c5
});
var c5 = class {
  constructor(t, e, n, r, s, o, c, l) {
    this.collection = t, this.description = e, this.name = n, this.maximum = r, this.supply = s, this.uri = o, this.default_properties = Dd(c), this.mutability_config = l;
  }
}, u5 = class {
  constructor(t, e, n) {
    this.id = t, this.amount = e, this.token_properties = Dd(n);
  }
}, l5 = {};
bi(l5, {
  AptosErrorCode: () => Ud,
  MoveFunctionVisibility: () => Cd,
  RoleType: () => zd
});
var Ud = /* @__PURE__ */ ((t) => (t.ACCOUNT_NOT_FOUND = "account_not_found", t.RESOURCE_NOT_FOUND = "resource_not_found", t.MODULE_NOT_FOUND = "module_not_found", t.STRUCT_FIELD_NOT_FOUND = "struct_field_not_found", t.VERSION_NOT_FOUND = "version_not_found", t.TRANSACTION_NOT_FOUND = "transaction_not_found", t.TABLE_ITEM_NOT_FOUND = "table_item_not_found", t.BLOCK_NOT_FOUND = "block_not_found", t.STATE_VALUE_NOT_FOUND = "state_value_not_found", t.VERSION_PRUNED = "version_pruned", t.BLOCK_PRUNED = "block_pruned", t.INVALID_INPUT = "invalid_input", t.INVALID_TRANSACTION_UPDATE = "invalid_transaction_update", t.SEQUENCE_NUMBER_TOO_OLD = "sequence_number_too_old", t.VM_ERROR = "vm_error", t.HEALTH_CHECK_FAILED = "health_check_failed", t.MEMPOOL_IS_FULL = "mempool_is_full", t.INTERNAL_ERROR = "internal_error", t.WEB_FRAMEWORK_ERROR = "web_framework_error", t.BCS_NOT_SUPPORTED = "bcs_not_supported", t.API_DISABLED = "api_disabled", t))(Ud || {}), Cd = /* @__PURE__ */ ((t) => (t.PRIVATE = "private", t.PUBLIC = "public", t.FRIEND = "friend", t))(Cd || {}), zd = /* @__PURE__ */ ((t) => (t.VALIDATOR = "validator", t.FULL_NODE = "full_node", t))(zd || {}), kd = { exports: {} };
(function(t) {
  var e = Object.prototype.hasOwnProperty, n = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));
  function s(f, p, y) {
    this.fn = f, this.context = p, this.once = y || !1;
  }
  function o(f, p, y, w, b) {
    if (typeof y != "function")
      throw new TypeError("The listener must be a function");
    var x = new s(y, w || f, b), I = n ? n + p : p;
    return f._events[I] ? f._events[I].fn ? f._events[I] = [f._events[I], x] : f._events[I].push(x) : (f._events[I] = x, f._eventsCount++), f;
  }
  function c(f, p) {
    --f._eventsCount === 0 ? f._events = new r() : delete f._events[p];
  }
  function l() {
    this._events = new r(), this._eventsCount = 0;
  }
  l.prototype.eventNames = function() {
    var p = [], y, w;
    if (this._eventsCount === 0) return p;
    for (w in y = this._events)
      e.call(y, w) && p.push(n ? w.slice(1) : w);
    return Object.getOwnPropertySymbols ? p.concat(Object.getOwnPropertySymbols(y)) : p;
  }, l.prototype.listeners = function(p) {
    var y = n ? n + p : p, w = this._events[y];
    if (!w) return [];
    if (w.fn) return [w.fn];
    for (var b = 0, x = w.length, I = new Array(x); b < x; b++)
      I[b] = w[b].fn;
    return I;
  }, l.prototype.listenerCount = function(p) {
    var y = n ? n + p : p, w = this._events[y];
    return w ? w.fn ? 1 : w.length : 0;
  }, l.prototype.emit = function(p, y, w, b, x, I) {
    var z = n ? n + p : p;
    if (!this._events[z]) return !1;
    var S = this._events[z], Z = arguments.length, le, L;
    if (S.fn) {
      switch (S.once && this.removeListener(p, S.fn, void 0, !0), Z) {
        case 1:
          return S.fn.call(S.context), !0;
        case 2:
          return S.fn.call(S.context, y), !0;
        case 3:
          return S.fn.call(S.context, y, w), !0;
        case 4:
          return S.fn.call(S.context, y, w, b), !0;
        case 5:
          return S.fn.call(S.context, y, w, b, x), !0;
        case 6:
          return S.fn.call(S.context, y, w, b, x, I), !0;
      }
      for (L = 1, le = new Array(Z - 1); L < Z; L++)
        le[L - 1] = arguments[L];
      S.fn.apply(S.context, le);
    } else {
      var ve = S.length, ye;
      for (L = 0; L < ve; L++)
        switch (S[L].once && this.removeListener(p, S[L].fn, void 0, !0), Z) {
          case 1:
            S[L].fn.call(S[L].context);
            break;
          case 2:
            S[L].fn.call(S[L].context, y);
            break;
          case 3:
            S[L].fn.call(S[L].context, y, w);
            break;
          case 4:
            S[L].fn.call(S[L].context, y, w, b);
            break;
          default:
            if (!le) for (ye = 1, le = new Array(Z - 1); ye < Z; ye++)
              le[ye - 1] = arguments[ye];
            S[L].fn.apply(S[L].context, le);
        }
    }
    return !0;
  }, l.prototype.on = function(p, y, w) {
    return o(this, p, y, w, !1);
  }, l.prototype.once = function(p, y, w) {
    return o(this, p, y, w, !0);
  }, l.prototype.removeListener = function(p, y, w, b) {
    var x = n ? n + p : p;
    if (!this._events[x]) return this;
    if (!y)
      return c(this, x), this;
    var I = this._events[x];
    if (I.fn)
      I.fn === y && (!b || I.once) && (!w || I.context === w) && c(this, x);
    else {
      for (var z = 0, S = [], Z = I.length; z < Z; z++)
        (I[z].fn !== y || b && !I[z].once || w && I[z].context !== w) && S.push(I[z]);
      S.length ? this._events[x] = S.length === 1 ? S[0] : S : c(this, x);
    }
    return this;
  }, l.prototype.removeAllListeners = function(p) {
    var y;
    return p ? (y = n ? n + p : p, this._events[y] && c(this, y)) : (this._events = new r(), this._eventsCount = 0), this;
  }, l.prototype.off = l.prototype.removeListener, l.prototype.addListener = l.prototype.on, l.prefixed = n, l.EventEmitter = l, t.exports = l;
})(kd);
var d5 = kd.exports;
const Od = /* @__PURE__ */ Iu(d5);
var Ld = "aptos:signAndSubmitTransaction", jd = "aptos:signMessage", Pd = "aptos:signTransaction", _d = "aptos:connect", Bd = "aptos:disconnect", Rd = "aptos:account", Fd = "aptos:network", Wd = "aptos:onAccountChange", Qd = "aptos:onNetworkChange", Kd = class Hd extends Xo {
  constructor({ address: e, publicKey: n, ansName: r }) {
    super(), this.address = $e.from(e), this.publicKey = n, this.ansName = r;
  }
  serialize(e) {
    if (this.address.serialize(e), this.publicKey instanceof mn) e.serializeU32AsUleb128(Ke.Ed25519);
    else if (this.publicKey instanceof pr) e.serializeU32AsUleb128(Ke.MultiEd25519);
    else if (this.publicKey instanceof Fn) e.serializeU32AsUleb128(Ke.SingleKey);
    else if (this.publicKey instanceof as) e.serializeU32AsUleb128(Ke.MultiKey);
    else throw new Error("Unsupported public key");
    this.publicKey.serialize(e), e.serializeStr(this.ansName ?? "");
  }
  static deserialize(e) {
    let n = $e.deserialize(e), r = e.deserializeUleb128AsU32(), s;
    switch (r) {
      case Ke.Ed25519:
        s = mn.deserialize(e);
        break;
      case Ke.MultiEd25519:
        s = pr.deserialize(e);
        break;
      case Ke.SingleKey:
        s = Fn.deserialize(e);
        break;
      case Ke.MultiKey:
        s = as.deserialize(e);
        break;
      default:
        throw new Error(`Unknown variant index for WrappedPublicKey: ${r}`);
    }
    let o = e.deserializeStr() || void 0;
    return new Hd({ address: n, publicKey: s, ansName: o });
  }
}, h5 = "aptos:devnet", f5 = "aptos:testnet", p5 = "aptos:localnet", g5 = "aptos:mainnet", Yd = [h5, f5, p5, g5], y5 = ["aptos:account", "aptos:connect", "aptos:disconnect", "aptos:network", "aptos:onAccountChange", "aptos:onNetworkChange", "aptos:signMessage", "aptos:signTransaction"];
function Gd(t, e = []) {
  return [...y5, ...e].every((n) => n in t.features);
}
function Xi() {
  let { get: t, on: e } = Xf(), n = t(), r = [];
  return n.map((s) => {
    Gd(s) && r.push(s);
  }), { aptosWallets: r, on: e };
}
var es = ((t) => (t[t.Unauthorized = 4100] = "Unauthorized", t[t.Unsupported = 4200] = "Unsupported", t[t.InternalError = -30001] = "InternalError", t))(es || {}), hc = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." }, 4200: { status: "Unsupported", message: "The requested feature is not supported." } }), Os = class Vd extends Error {
  constructor(e, n) {
    var r, s;
    super(n ?? ((r = hc[e]) == null ? void 0 : r.message) ?? "Unknown error occurred"), this.code = e, this.status = ((s = hc[e]) == null ? void 0 : s.status) ?? "Unknown error", this.name = "AptosWalletError", Object.setPrototypeOf(this, Vd.prototype);
  }
}, ot = ((t) => (t.APPROVED = "Approved", t.REJECTED = "Rejected", t))(ot || {}), Zd = { exports: {} };
(function(t) {
  (function(e, n) {
    t.exports ? t.exports = n(kf) : e.ed2curve = n(e.nacl);
  })(Of, function(e) {
    if (!e) throw new Error("tweetnacl not loaded");
    var n = function(ae) {
      var ce, Y = new Float64Array(16);
      if (ae) for (ce = 0; ce < ae.length; ce++) Y[ce] = ae[ce];
      return Y;
    }, r = n(), s = n([1]), o = n([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), c = n([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function l(ae) {
      var ce, Y;
      for (Y = 0; Y < 16; Y++)
        ae[Y] += 65536, ce = Math.floor(ae[Y] / 65536), ae[(Y + 1) * (Y < 15 ? 1 : 0)] += ce - 1 + 37 * (ce - 1) * (Y === 15 ? 1 : 0), ae[Y] -= ce * 65536;
    }
    function f(ae, ce, Y) {
      for (var K, ze = ~(Y - 1), Ee = 0; Ee < 16; Ee++)
        K = ze & (ae[Ee] ^ ce[Ee]), ae[Ee] ^= K, ce[Ee] ^= K;
    }
    function p(ae, ce) {
      var Y;
      for (Y = 0; Y < 16; Y++) ae[Y] = ce[2 * Y] + (ce[2 * Y + 1] << 8);
      ae[15] &= 32767;
    }
    function y(ae, ce, Y) {
      var K;
      for (K = 0; K < 16; K++) ae[K] = ce[K] + Y[K] | 0;
    }
    function w(ae, ce, Y) {
      var K;
      for (K = 0; K < 16; K++) ae[K] = ce[K] - Y[K] | 0;
    }
    function b(ae, ce, Y) {
      var K, ze, Ee = new Float64Array(31);
      for (K = 0; K < 31; K++) Ee[K] = 0;
      for (K = 0; K < 16; K++)
        for (ze = 0; ze < 16; ze++)
          Ee[K + ze] += ce[K] * Y[ze];
      for (K = 0; K < 15; K++)
        Ee[K] += 38 * Ee[K + 16];
      for (K = 0; K < 16; K++) ae[K] = Ee[K];
      l(ae), l(ae);
    }
    function x(ae, ce) {
      b(ae, ce, ce);
    }
    function I(ae, ce) {
      var Y = n(), K;
      for (K = 0; K < 16; K++) Y[K] = ce[K];
      for (K = 253; K >= 0; K--)
        x(Y, Y), K !== 2 && K !== 4 && b(Y, Y, ce);
      for (K = 0; K < 16; K++) ae[K] = Y[K];
    }
    function z(ae, ce) {
      var Y, K, ze, Ee = n(), Ce = n();
      for (Y = 0; Y < 16; Y++) Ce[Y] = ce[Y];
      for (l(Ce), l(Ce), l(Ce), K = 0; K < 2; K++) {
        for (Ee[0] = Ce[0] - 65517, Y = 1; Y < 15; Y++)
          Ee[Y] = Ce[Y] - 65535 - (Ee[Y - 1] >> 16 & 1), Ee[Y - 1] &= 65535;
        Ee[15] = Ce[15] - 32767 - (Ee[14] >> 16 & 1), ze = Ee[15] >> 16 & 1, Ee[14] &= 65535, f(Ce, Ee, 1 - ze);
      }
      for (Y = 0; Y < 16; Y++)
        ae[2 * Y] = Ce[Y] & 255, ae[2 * Y + 1] = Ce[Y] >> 8;
    }
    function S(ae) {
      var ce = new Uint8Array(32);
      return z(ce, ae), ce[0] & 1;
    }
    function Z(ae, ce, Y, K, ze) {
      var Ee, Ce = 0;
      for (Ee = 0; Ee < ze; Ee++) Ce |= ae[ce + Ee] ^ Y[K + Ee];
      return (1 & Ce - 1 >>> 8) - 1;
    }
    function le(ae, ce, Y, K) {
      return Z(ae, ce, Y, K, 32);
    }
    function L(ae, ce) {
      var Y = new Uint8Array(32), K = new Uint8Array(32);
      return z(Y, ae), z(K, ce), le(Y, 0, K, 0);
    }
    function ve(ae, ce) {
      var Y = n(), K;
      for (K = 0; K < 16; K++) Y[K] = ce[K];
      for (K = 250; K >= 0; K--)
        x(Y, Y), K !== 1 && b(Y, Y, ce);
      for (K = 0; K < 16; K++) ae[K] = Y[K];
    }
    function ye(ae, ce) {
      var Y;
      for (Y = 0; Y < 16; Y++) ae[Y] = ce[Y] | 0;
    }
    function De(ae, ce) {
      var Y = n(), K = n(), ze = n(), Ee = n(), Ce = n(), Wt = n(), dt = n();
      return ye(ae[2], s), p(ae[1], ce), x(ze, ae[1]), b(Ee, ze, o), w(ze, ze, ae[2]), y(Ee, ae[2], Ee), x(Ce, Ee), x(Wt, Ce), b(dt, Wt, Ce), b(Y, dt, ze), b(Y, Y, Ee), ve(Y, Y), b(Y, Y, ze), b(Y, Y, Ee), b(Y, Y, Ee), b(ae[0], Y, Ee), x(K, ae[0]), b(K, K, Ee), L(K, ze) && b(ae[0], ae[0], c), x(K, ae[0]), b(K, K, Ee), L(K, ze) ? -1 : (S(ae[0]) === ce[31] >> 7 && w(ae[0], r, ae[0]), b(ae[3], ae[0], ae[1]), 0);
    }
    function Re(ae) {
      var ce = new Uint8Array(32), Y = [n(), n(), n(), n()], K = n(), ze = n();
      if (De(Y, ae)) return null;
      var Ee = Y[1];
      return y(K, s, Ee), w(ze, s, Ee), I(ze, ze), b(K, K, ze), z(ce, K), ce;
    }
    function Le(ae) {
      var ce = new Uint8Array(64), Y = new Uint8Array(32), K;
      for (e.lowlevel.crypto_hash(ce, ae, 32), ce[0] &= 248, ce[31] &= 127, ce[31] |= 64, K = 0; K < 32; K++) Y[K] = ce[K];
      for (K = 0; K < 64; K++) ce[K] = 0;
      return Y;
    }
    function tt(ae) {
      var ce = Re(ae.publicKey);
      return ce ? {
        publicKey: ce,
        secretKey: Le(ae.secretKey)
      } : null;
    }
    return {
      convertPublicKey: Re,
      convertSecretKey: Le,
      convertKeyPair: tt
    };
  });
})(Zd);
var w5 = Zd.exports;
const qd = /* @__PURE__ */ Iu(w5);
function Ua(t) {
  const e = atob(t);
  return Uint8Array.from(e, (n) => n.charCodeAt(0));
}
function cn(t) {
  const e = String.fromCharCode(...t);
  return btoa(e);
}
function Ca(t) {
  return cn(t).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function Xd(t) {
  switch (t) {
    case ar.mainnet:
      return Ye.MAINNET;
    case ar.testnet:
      return Ye.TESTNET;
    default:
      return Ye.DEVNET;
  }
}
function mr(t) {
  return [Ye.MAINNET, Ye.TESTNET, Ye.DEVNET].includes(t);
}
function A5(t, e) {
  t.serialize(e.address), t.serialize(e.authenticator);
}
function m5(t) {
  const e = t.deserialize($e), n = t.deserialize(Es);
  return { address: e, authenticator: n };
}
function za(t, e) {
  if (e instanceof mn)
    t.serializeU32AsUleb128(Ke.Ed25519);
  else if (e instanceof pr)
    t.serializeU32AsUleb128(Ke.MultiEd25519);
  else if (e instanceof Fn)
    t.serializeU32AsUleb128(Ke.SingleKey);
  else if (e instanceof as)
    t.serializeU32AsUleb128(Ke.MultiKey);
  else
    throw new Error("Unexpected public key type");
  t.serialize(e);
}
function ka(t) {
  const e = t.deserializeUleb128AsU32();
  switch (e) {
    case Ke.Ed25519:
      return t.deserialize(mn);
    case Ke.MultiEd25519:
      return t.deserialize(pr);
    case Ke.SingleKey:
      return t.deserialize(Fn);
    case Ke.MultiKey:
      return t.deserialize(as);
    default:
      throw new Error(`Unknown signing scheme: ${e}`);
  }
}
function ci(t, e) {
  t.serialize(e.address), za(t, e.publicKey), t.serializeStr(e.name ?? "");
}
function Oa(t) {
  const e = t.deserialize($e), n = ka(t), r = t.deserializeStr();
  return {
    address: e,
    publicKey: n,
    ...r.length > 0 ? { name: r } : void 0
  };
}
function Ji(t, e) {
  t.serialize(e.address), t.serializeBool(e.publicKey !== void 0), e.publicKey && za(t, e.publicKey);
}
function $i(t) {
  const e = t.deserialize($e), r = t.deserializeBool() ? ka(t) : void 0;
  return { address: e, publicKey: r };
}
function Jd(t, e) {
  t.serializeStr(e.domain), t.serializeStr(e.name), t.serializeBool(e.imageURI !== void 0), e.imageURI !== void 0 && t.serializeStr(e.imageURI);
}
function $d(t) {
  const e = t.deserializeStr(), n = t.deserializeStr(), s = t.deserializeBool() ? t.deserializeStr() : void 0;
  return { domain: e, imageURI: s, name: n };
}
function Uo(t, e) {
  if (e == null) {
    t.serializeU32AsUleb128(
      0
      /* Undefined */
    );
    return;
  }
  if (Array.isArray(e)) {
    t.serializeU32AsUleb128(
      1
      /* Array */
    ), t.serializeU32AsUleb128(e.length);
    for (const n of e)
      Uo(t, n);
    return;
  }
  if (typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "bigint") {
    t.serializeU32AsUleb128(
      2
      /* String */
    ), t.serializeStr(e.toString());
    return;
  }
  if (e instanceof Uint8Array) {
    t.serializeU32AsUleb128(
      3
      /* Uint8Array */
    ), t.serializeBytes(e);
    return;
  }
  if (e instanceof ArrayBuffer) {
    t.serializeU32AsUleb128(
      3
      /* Uint8Array */
    ), t.serializeBytes(new Uint8Array(e));
    return;
  }
  if ("values" in e) {
    t.serializeU32AsUleb128(
      1
      /* Array */
    ), t.serializeU32AsUleb128(e.values.length);
    for (const n of e.values)
      Uo(t, n);
    return;
  }
  if ("data" in e) {
    t.serializeU32AsUleb128(
      4
      /* AccountAddress */
    ), t.serialize(e);
    return;
  }
  if (e.value === void 0) {
    t.serializeU32AsUleb128(
      0
      /* Undefined */
    ), t.serialize(e);
    return;
  }
  if (e.value instanceof Uint8Array) {
    t.serializeU32AsUleb128(
      5
      /* FixedBytes */
    ), t.serializeBytes(e.value);
    return;
  }
  t.serializeU32AsUleb128(
    2
    /* String */
  ), t.serializeStr(e.value.toString());
}
function eh(t) {
  switch (t.deserializeUleb128AsU32()) {
    case 0:
      return;
    case 1: {
      const n = t.deserializeUleb128AsU32(), r = [];
      for (let s = 0; s < n; s += 1) {
        const o = eh(t);
        r.push(o);
      }
      return r;
    }
    case 3:
      return t.deserializeBytes();
    case 4:
      return t.deserialize($e);
    case 2:
      return t.deserializeStr();
    case 5: {
      const n = t.deserializeBytes();
      return new Ff(n);
    }
    default:
      throw new Error("Unexpected variant");
  }
}
function v5(t, e) {
  if (e instanceof gr)
    t.serializeU32AsUleb128(Ke.Ed25519);
  else if (e instanceof Jo)
    t.serializeU32AsUleb128(Ke.MultiEd25519);
  else if (e instanceof Ai)
    t.serializeU32AsUleb128(Ke.SingleKey);
  else
    throw new Error("Unexpected signature type");
  t.serialize(e);
}
function E5(t) {
  const e = t.deserializeUleb128AsU32();
  switch (e) {
    case Ke.Ed25519:
      return t.deserialize(gr);
    case Ke.MultiEd25519:
      return t.deserialize(Jo);
    case Ke.SingleKey:
      return t.deserialize(Ai);
    default:
      throw new Error(`Unknown signing scheme: ${e}`);
  }
}
function eo(t, e) {
  t.serializeU32AsUleb128(e.length);
  for (const n of e) {
    const r = typeof n == "string" ? Rf(n, { allowGenerics: !0 }) : n;
    t.serialize(r);
  }
}
function to(t) {
  const e = [], n = t.deserializeUleb128AsU32();
  for (let r = 0; r < n; r += 1) {
    const s = t.deserialize(oi);
    e.push(s);
  }
  return e;
}
function fc(t, e) {
  t.serializeU32AsUleb128(e.length);
  for (const n of e)
    Uo(t, n);
}
function pc(t) {
  const e = t.deserializeUleb128AsU32(), n = [];
  for (let r = 0; r < e; r += 1) {
    const s = eh(t);
    n.push(s);
  }
  return n;
}
function th(t, e) {
  if ("multisigAddress" in e) {
    t.serializeU32AsUleb128(
      2
      /* Multisig */
    ), t.serializeStr(e.function), fc(t, e.functionArguments), eo(t, e.typeArguments ?? []);
    const n = $e.from(e.multisigAddress);
    t.serialize(n);
  } else if ("function" in e)
    t.serializeU32AsUleb128(
      0
      /* EntryFunction */
    ), t.serializeStr(e.function), fc(t, e.functionArguments), eo(t, e.typeArguments ?? []);
  else {
    t.serializeU32AsUleb128(
      1
      /* Script */
    );
    const n = on.fromHexInput(e.bytecode);
    t.serializeBytes(n.toUint8Array()), t.serializeU32AsUleb128(e.functionArguments.length);
    for (const r of e.functionArguments)
      r.serializeForScriptFunction(t);
    eo(t, e.typeArguments ?? []);
  }
}
function nh(t) {
  switch (t.deserializeUleb128AsU32()) {
    case 2: {
      const n = t.deserializeStr(), r = pc(t), s = to(t), o = t.deserialize($e);
      return {
        function: n,
        functionArguments: r,
        multisigAddress: o,
        typeArguments: s
      };
    }
    case 0: {
      const n = t.deserializeStr(), r = pc(t), s = to(t);
      return {
        function: n,
        functionArguments: r,
        typeArguments: s
      };
    }
    case 1: {
      const n = t.deserializeBytes(), r = t.deserializeUleb128AsU32(), s = [];
      for (let c = 0; c < r; c += 1) {
        const l = Bf(t);
        s.push(l);
      }
      const o = to(t);
      return {
        bytecode: n,
        functionArguments: s,
        typeArguments: o
      };
    }
    default:
      throw new Error("Unexpected variant");
  }
}
function La({
  dappInfo: t,
  name: e,
  version: n
}) {
  const r = new Gn();
  return Jd(r, t), { data: r.toUint8Array(), name: e, version: n };
}
function ja({
  data: t,
  name: e,
  version: n
}) {
  const r = new un(t);
  return { dappInfo: $d(r), name: e, version: n };
}
function Ci({ args: t, dappInfo: e, name: n, version: r }, s) {
  const o = new Gn();
  return Jd(o, e), s(o, t), { data: o.toUint8Array(), name: n, version: r };
}
function zi({ data: t, name: e, version: n }, r) {
  const s = new un(t), o = $d(s);
  return { args: r(s), dappInfo: o, name: e, version: n };
}
var ui;
((t) => {
  t.name = "connect", t.supportedVersions = [1, 2, 3, 4], t.currentVersion = 4;
  function e(c, l) {
    if (c.serializeOptionStr(l.dappId), c.serializeOptionStr(l.dappEd25519PublicKeyB64), c.serializeOptionStr(l.preferredWalletName), c.serializeBool(l.claimOptions !== void 0), l.claimOptions && (c.serialize(l.claimOptions.secretKey), c.serializeStr(l.claimOptions.network), c.serializeOptionStr(l.claimOptions.asset), !mr(l.claimOptions.network)))
      throw new Error(`Unsupported network '${l.claimOptions.network}'`);
  }
  t.serializeArgs = e;
  function n(c, l) {
    if (l === 1)
      return {};
    const f = c.deserializeOption("string"), p = c.deserializeOption("string"), y = l >= 3 ? c.deserializeOption("string") : void 0, w = l >= 4 ? c.deserializeBool() : !1;
    let b;
    if (w) {
      const x = c.deserialize(ii), I = c.deserializeStr(), z = c.deserializeOption("string");
      if (!mr(I))
        throw new Error(`Unsupported network '${I}'`);
      b = { asset: z, network: I, secretKey: x };
    }
    return { claimOptions: b, dappEd25519PublicKeyB64: p, dappId: f, preferredWalletName: y };
  }
  t.deserializeArgs = n;
  function r(c, l = {}) {
    return Ci({ args: l, dappInfo: c, name: t.name, version: t.currentVersion }, e);
  }
  t.serialize = r;
  function s(c) {
    return zi(c, (l) => n(l, c.version));
  }
  t.deserialize = s;
  function o(c) {
    return c.name === t.name && t.supportedVersions.includes(c.version);
  }
  t.isSerialized = o;
})(ui || (ui = {}));
function Ls(t) {
  return { args: t, status: "approved" };
}
function ps(t) {
  return (e, n) => {
    e.serializeBool(n.status === "approved"), n.status === "approved" && t(e, n.args);
  };
}
function ki(t) {
  return (e) => e.deserializeBool() ? { args: t(e), status: "approved" } : { status: "dismissed" };
}
function qn(t, e) {
  const n = new Gn();
  return e(n, t), { data: n.toUint8Array() };
}
function Xn({ data: t }, e) {
  const n = new un(t);
  return { args: e(n) };
}
var gs;
((t) => {
  t.supportedVersions = [1, 2], t.currentVersion = 2;
  function e(p, y) {
    ci(p, y.account);
  }
  function n(p, y) {
    ci(p, y.account), p.serializeOptionStr(y.pairing !== void 0 ? JSON.stringify(y.pairing) : void 0);
  }
  function r(p) {
    const y = Oa(p), w = p.deserializeOption("string"), b = w !== void 0 ? JSON.parse(w) : void 0;
    return { account: y, pairing: b };
  }
  const s = ps(e), o = ps(n), c = ki(r);
  function l(p, y = t.currentVersion) {
    return qn(p, y === 1 ? s : o);
  }
  t.serialize = l;
  function f(p) {
    return Xn(p, c);
  }
  t.deserialize = f;
})(gs || (gs = {}));
var li;
((t) => {
  t.name = "disconnect", t.currentVersion = 1;
  function e(s) {
    return La({ dappInfo: s, name: t.name, version: t.currentVersion });
  }
  t.serialize = e;
  function n(s) {
    return ja(s);
  }
  t.deserialize = n;
  function r(s) {
    return s.name === t.name && s.version === t.currentVersion;
  }
  t.isSerialized = r;
})(li || (li = {}));
var Co;
((t) => {
  function e(r) {
    return qn(r, () => {
    });
  }
  t.serialize = e;
  function n(r) {
    return Xn(r, () => ({}));
  }
  t.deserialize = n;
})(Co || (Co = {}));
var di;
((t) => {
  t.name = "getConnectedAccounts", t.currentVersion = 1;
  function e(s) {
    return La({ dappInfo: s, name: t.name, version: t.currentVersion });
  }
  t.serialize = e;
  function n(s) {
    return ja(s);
  }
  t.deserialize = n;
  function r(s) {
    return s.name === t.name && s.version === t.currentVersion;
  }
  t.isSerialized = r;
})(di || (di = {}));
var hi;
((t) => {
  function e(o, c) {
    o.serializeU32AsUleb128(c.length);
    for (const l of c)
      ci(o, l);
  }
  function n(o) {
    const c = o.deserializeUleb128AsU32(), l = [];
    for (let f = 0; f < c; f += 1)
      l.push(Oa(o));
    return l;
  }
  function r(o) {
    return qn(o, e);
  }
  t.serialize = r;
  function s(o) {
    return Xn(o, n);
  }
  t.deserialize = s;
})(hi || (hi = {}));
var zo;
((t) => {
  t.name = "isConnected", t.currentVersion = 1;
  function e(s) {
    return La({ dappInfo: s, name: t.name, version: t.currentVersion });
  }
  t.serialize = e;
  function n(s) {
    return ja(s);
  }
  t.deserialize = n;
  function r(s) {
    return s.name === t.name && s.version === t.currentVersion;
  }
  t.isSerialized = r;
})(zo || (zo = {}));
var ko;
((t) => {
  function e(o, c) {
    o.serializeBool(c);
  }
  function n(o) {
    return o.deserializeBool();
  }
  function r(o) {
    return qn(o, e);
  }
  t.serialize = r;
  function s(o) {
    return Xn(o, n);
  }
  t.deserialize = s;
})(ko || (ko = {}));
var fi;
((t) => {
  t.name = "signAndSubmitTransaction", t.supportedVersions = [1, 2, 3], t.currentVersion = 3;
  function e(c, l) {
    if (l.network !== void 0 && !mr(l.network))
      throw new Error(`Unsupported network '${l.network}'`);
    c.serializeBool(l.signerAddress !== void 0), l.signerAddress !== void 0 && c.serialize(l.signerAddress), c.serializeOptionStr(l.network), "bcsToBytes" in l.payload ? (c.serializeBool(!0), c.serialize(l.payload)) : (c.serializeBool(!1), th(c, l.payload)), c.serializeU64(l.expirationTimestamp ?? 0), c.serializeU32AsUleb128(l.gasUnitPrice ?? 0), c.serializeU32AsUleb128(l.maxGasAmount ?? 0), c.serializeU32AsUleb128(l.feePayer ? 1 : 0), l.feePayer && A5(c, l.feePayer);
  }
  t.serializeArgs = e;
  function n(c, l) {
    const p = l >= 3 && c.deserializeBool() ? c.deserialize($e) : void 0, y = l === 1 ? c.deserializeStr() : c.deserializeOption("string");
    if (y !== void 0 && !mr(y))
      throw new Error(`Unsupported network '${y}'`);
    const b = l === 1 || c.deserializeBool() ? c.deserialize(Mu) : nh(c), x = Number(c.deserializeU64()), I = c.deserializeUleb128AsU32(), z = c.deserializeUleb128AsU32(), Z = c.deserializeUleb128AsU32() ? m5(c) : void 0;
    return {
      expirationTimestamp: x > 0 ? x : void 0,
      feePayer: Z,
      gasUnitPrice: I > 0 ? I : void 0,
      maxGasAmount: z > 0 ? z : void 0,
      network: y,
      payload: b,
      signerAddress: p
    };
  }
  t.deserializeArgs = n;
  function r(c, l) {
    const f = { args: l, dappInfo: c, name: t.name, version: t.currentVersion };
    return Ci(f, e);
  }
  t.serialize = r;
  function s(c) {
    return zi(
      c,
      (l) => n(l, c.version)
    );
  }
  t.deserialize = s;
  function o(c) {
    return c.name === t.name && t.supportedVersions.includes(c.version);
  }
  t.isSerialized = o;
})(fi || (fi = {}));
var Oo;
((t) => {
  function e(l, f) {
    l.serializeStr(f.txnHash);
  }
  function n(l) {
    return { txnHash: l.deserializeStr() };
  }
  const r = ps(e), s = ki(n);
  function o(l) {
    return qn(l, r);
  }
  t.serialize = o;
  function c(l) {
    return Xn(l, s);
  }
  t.deserialize = c;
})(Oo || (Oo = {}));
var pi;
((t) => {
  t.name = "signMessage", t.supportedVersions = [1, 2], t.currentVersion = 2;
  function e(c, l) {
    c.serializeBool(l.signerAddress !== void 0), l.signerAddress !== void 0 && c.serialize(l.signerAddress), c.serializeU8(l.chainId), c.serializeBytes(l.nonce), c.serializeBytes(l.message);
  }
  function n(c, l) {
    const p = l >= 2 && c.deserializeBool() ? c.deserialize($e) : void 0, y = c.deserializeU8(), w = c.deserializeBytes(), b = c.deserializeBytes();
    return { chainId: y, message: b, nonce: w, signerAddress: p };
  }
  function r(c, l) {
    const f = { args: l, dappInfo: c, name: t.name, version: t.currentVersion };
    return Ci(f, e);
  }
  t.serialize = r;
  function s(c) {
    return zi(c, (l) => n(l, c.version));
  }
  t.deserialize = s;
  function o(c) {
    return c.name === t.name && c.version === t.currentVersion;
  }
  t.isSerialized = o;
})(pi || (pi = {}));
var Lo;
((t) => {
  function e(l, f) {
    l.serializeStr(f.fullMessage), v5(l, f.signature);
  }
  function n(l) {
    const f = l.deserializeStr(), p = E5(l);
    return { fullMessage: f, signature: p };
  }
  const r = ps(e), s = ki(n);
  function o(l) {
    return qn(l, r);
  }
  t.serialize = o;
  function c(l) {
    return Xn(l, s);
  }
  t.deserialize = c;
})(Lo || (Lo = {}));
var ys;
((t) => {
  t.name = "signTransaction", t.supportedVersions = [1, 2, 3, 4], t.currentVersion = 4;
  function e(l) {
    const { feePayer: f, secondarySigners: p, senderPublicKey: y, signerAddress: w, transaction: b } = l, x = {
      address: b.sender,
      publicKey: y
    }, I = Xd(l.transaction.chain_id.chainId);
    return {
      expirationTimestamp: Number(b.expiration_timestamp_secs),
      feePayer: f,
      gasUnitPrice: Number(b.gas_unit_price),
      maxGasAmount: Number(b.max_gas_amount),
      network: I,
      payload: b.payload,
      secondarySigners: p,
      sender: x,
      signerAddress: w
    };
  }
  t.normalizeArgs = e;
  function n(l, f) {
    if (f.network !== void 0 && !mr(f.network))
      throw new Error(`Unsupported network '${f.network}'`);
    l.serializeBool(f.signerAddress !== void 0), f.signerAddress !== void 0 && l.serialize(f.signerAddress), l.serializeOptionStr(f.network), l.serializeBool(f.sender !== void 0), f.sender !== void 0 && Ji(l, f.sender), "bcsToBytes" in f.payload ? (l.serializeBool(!0), l.serialize(f.payload)) : (l.serializeBool(!1), th(l, f.payload)), l.serializeU32AsUleb128(f.expirationSecondsFromNow ?? 0), l.serializeU64(f.expirationTimestamp ?? 0), l.serializeU32AsUleb128(f.gasUnitPrice ?? 0), l.serializeU32AsUleb128(f.maxGasAmount ?? 0), l.serializeBool(f.feePayer !== void 0), f.feePayer !== void 0 && Ji(l, f.feePayer);
    const p = f.secondarySigners ?? [];
    l.serializeU32AsUleb128(p.length);
    for (const y of p)
      Ji(l, y);
  }
  function r(l, f) {
    const y = f >= 3 && l.deserializeBool() ? l.deserialize($e) : void 0, w = f === 1 ? l.deserializeStr() : l.deserializeOption("string");
    if (w !== void 0 && !mr(w))
      throw new Error(`Unsupported network '${w}'`);
    const x = l.deserializeBool() ? $i(l) : void 0, z = f < 4 || l.deserializeBool() ? l.deserialize(Mu) : nh(l), S = l.deserializeUleb128AsU32(), Z = Number(l.deserializeU64()), le = l.deserializeUleb128AsU32(), L = l.deserializeUleb128AsU32(), ye = l.deserializeBool() ? $i(l) : void 0, De = l.deserializeUleb128AsU32(), Re = [];
    for (let Le = 0; Le < De; Le += 1)
      Re.push($i(l));
    return {
      expirationSecondsFromNow: S > 0 ? S : void 0,
      expirationTimestamp: Z > 0 ? Z : void 0,
      feePayer: ye,
      gasUnitPrice: le > 0 ? le : void 0,
      maxGasAmount: L > 0 ? L : void 0,
      network: w,
      payload: z,
      secondarySigners: Re,
      sender: x,
      signerAddress: y
    };
  }
  function s(l, f) {
    const p = { args: f, dappInfo: l, name: t.name, version: t.currentVersion };
    return Ci(p, n);
  }
  t.serialize = s;
  function o(l) {
    return zi(
      l,
      (f) => r(f, l.version)
    );
  }
  t.deserialize = o;
  function c(l) {
    return l.name === t.name && t.supportedVersions.includes(l.version);
  }
  t.isSerialized = c;
})(ys || (ys = {}));
var jo;
((t) => {
  function e(l, f) {
    l.serialize(f.authenticator), l.serializeBool(f.rawTransaction !== void 0), f.rawTransaction !== void 0 && l.serialize(f.rawTransaction);
  }
  function n(l) {
    const f = l.deserialize(Es), y = l.deserializeBool() ? l.deserialize(Nu) : void 0;
    return {
      authenticator: f,
      rawTransaction: y
    };
  }
  const r = ps(e), s = ki(n);
  function o(l) {
    return qn(l, r);
  }
  t.serialize = o;
  function c(l) {
    return Xn(l, s);
  }
  t.deserialize = c;
})(jo || (jo = {}));
function no(t, e) {
  return (e == null ? void 0 : e.__messageType) === t.TYPE;
}
var rh = class sh {
  constructor() {
    this.__messageType = sh.TYPE;
  }
};
rh.TYPE = "PromptOpenerPingRequest";
var b5 = rh, ih = class oh {
  constructor() {
    this.__messageType = oh.TYPE;
  }
};
ih.TYPE = "PromptOpenerPingResponse";
var T5 = ih, ah = class ch {
  constructor(e) {
    this.serializedValue = e, this.__messageType = ch.TYPE;
  }
};
ah.TYPE = "PromptApprovalResponse";
var I5 = ah, uh = class lh {
  constructor() {
    this.__messageType = lh.TYPE;
  }
};
uh.TYPE = "PromptUnauthorizedError";
var M5 = uh;
function N5(t) {
  const e = new Gn();
  return e.serializeStr(t.name), e.serializeBytes(t.data), e.serializeStr(t.version.toString()), cn(e.toUint8Array());
}
function dh({ data: t, ...e }) {
  const n = JSON.stringify({ data: t, ...e }, (s, o) => s === "data" ? cn(o) : o), r = new TextEncoder().encode(n);
  return cn(r);
}
function gc(t) {
  const e = JSON.stringify(t, (r, s) => {
    switch (r) {
      case "body":
        return dh(s);
      case "clientIdentityKey":
        return cn(s.toUint8Array());
      case "signature":
        return cn(s.toUint8Array());
      default:
        return s;
    }
  }), n = new TextEncoder().encode(e);
  return Ca(n);
}
function x5({
  accountAddress: t,
  body: e,
  id: n,
  timestamp: r
}) {
  const s = new Gn();
  return s.serializeStr("SignedPopupWalletRequest"), s.serializeStr(n), s.serializeU64(r), s.serializeBool(t !== void 0), t !== void 0 && s.serialize($e.from(t)), s.serializeStr(e.name), s.serializeU8(e.version), s.serializeBytes(e.data), s.toUint8Array();
}
var hh = class extends Error {
}, Oi = class fh extends hh {
  constructor(e, n) {
    super(e), this.field = n, this.name = "EnvelopeMessageMismatchError", Object.setPrototypeOf(this, fh.prototype);
  }
}, yc = class ph extends hh {
  constructor(e) {
    super(e), this.name = "DecryptionError", Object.setPrototypeOf(this, ph.prototype);
  }
}, _t = /* @__PURE__ */ ((t) => (t.Ed25519PublicKey = "Ed25519PublicKey", t.Ed25519SecretKey = "Ed25519SecretKey", t.X25519PublicKey = "X25519PublicKey", t.X25519SecretKey = "X25519SecretKey", t))(_t || {});
function S5() {
  return C5(St.box.keyPair());
}
function D5() {
  return U5(St.sign.keyPair());
}
function ct(t, e) {
  return {
    key: t,
    type: e
  };
}
function U5(t) {
  return {
    publicKey: ct(
      t.publicKey,
      "Ed25519PublicKey"
      /* Ed25519PublicKey */
    ),
    secretKey: ct(
      t.secretKey,
      "Ed25519SecretKey"
      /* Ed25519SecretKey */
    )
  };
}
function C5(t) {
  return {
    publicKey: ct(
      t.publicKey,
      "X25519PublicKey"
      /* X25519PublicKey */
    ),
    secretKey: ct(
      t.secretKey,
      "X25519SecretKey"
      /* X25519SecretKey */
    )
  };
}
function ht(t) {
  return globalThis.Buffer ? new Uint8Array(Je.Buffer.from(t, "base64")) : Uint8Array.from(atob(t), (e) => e.codePointAt(0));
}
function sn(t) {
  return globalThis.Buffer ? Je.Buffer.from(t).toString("base64") : btoa(Array.from(t, (e) => String.fromCodePoint(e)).join(""));
}
function z5(t, e) {
  const n = new Uint8Array(t.length + e.length);
  return n.set(t), n.set(e, t.length), n;
}
var k5 = "APTOS::IDENTITY_CONNECT";
function O5(t, e) {
  const n = qd.convertPublicKey(t.key.slice(0, 32));
  if (!n)
    throw new Error(`${e} is not a valid Ed25519 public key`);
  return ct(
    n,
    "X25519PublicKey"
    /* X25519PublicKey */
  );
}
function L5(t) {
  const e = qd.convertSecretKey(t.key.slice(0, 32));
  return ct(
    e,
    "X25519SecretKey"
    /* X25519SecretKey */
  );
}
function j5(t) {
  return {
    nonceB64: sn(t.nonce),
    securedB64: sn(t.secured)
  };
}
function P5(t) {
  return {
    nonce: ht(t.nonceB64),
    secured: ht(t.securedB64)
  };
}
function _5(t, e, n) {
  const r = St.randomBytes(St.box.nonceLength), s = new TextEncoder().encode(n), o = St.box(s, r, e.key, t.key.slice(0, 32));
  return { nonce: r, secured: o };
}
function B5(t, e, n) {
  const r = O5(
    e,
    "receiver public key"
  );
  return R5(t, r, n);
}
function R5(t, e, n) {
  return _5(t, e, JSON.stringify(n));
}
function F5(t, e, n, r) {
  let s;
  try {
    s = St.box.open(
      n,
      r,
      t.key.slice(0, 32),
      e.key.slice(0, 32)
    );
  } catch (o) {
    throw new yc(`Could not decrypt message: ${o.message}`);
  }
  if (!s)
    throw new yc("Could not decrypt message");
  return new TextDecoder().decode(s);
}
function W5(t, e, n, r) {
  const s = L5(e);
  return Q5(t, s, n, r);
}
function Q5(t, e, n, r) {
  const s = F5(t, e, n, r);
  return JSON.parse(s);
}
function gh(t, e) {
  const n = new Uint8Array(ss(`${k5}::${e}::`));
  return new Uint8Array(ss(z5(n, t)));
}
function K5(t, e, n) {
  return St.sign.detached(gh(t, n), e.key);
}
function H5(t, e, n, r) {
  return n.verifySignature({ message: gh(t, r), signature: e });
}
var wc = [
  "receiverEd25519PublicKeyB64",
  "senderEd25519PublicKeyB64",
  "senderX25519PublicKeyB64",
  "sequence",
  "timestampMillis"
].sort();
function yh(t, e) {
  const n = Object.keys(t).filter((r) => Object.keys(e).includes(r));
  if (n.length > 0) {
    const r = n[0];
    throw new Oi(`Field ${r} appears in both private and public message fields`, r);
  }
}
function wh(t) {
  const e = Object.keys(t).sort(), n = e.filter((s) => !wc.includes(s)), r = wc.filter((s) => !e.includes(s));
  if (n.length > 0 || r.length > 0) {
    let s = n.length > 0 ? `extra(${n.join(", ")})` : "";
    const o = r.length > 0 ? `missing(${r.join(", ")})` : "";
    throw s = s.length > 0 && o.length > 0 ? `${s}, ` : s, new Oi(
      `PublicMessage metadata fields do not conform to spec: ${s}${o}`,
      "_metadata"
    );
  }
}
function ro(t, e, n, r, s, o) {
  const c = S5(), l = Y5(
    e,
    n,
    r,
    c.publicKey
  );
  return wh(l), yh(o, s), G5(
    t,
    n,
    l,
    o,
    s,
    c
  );
}
function Y5(t, e, n, r) {
  return {
    receiverEd25519PublicKeyB64: sn(e.key),
    senderEd25519PublicKeyB64: sn(t.key),
    senderX25519PublicKeyB64: sn(r.key),
    sequence: n,
    timestampMillis: Date.now()
  };
}
function G5(t, e, n, r, s, o) {
  const c = B5(
    o.secretKey,
    e,
    r
  ), l = j5(c), f = ht(l.securedB64), p = JSON.stringify({ ...s, _metadata: n }), y = new TextEncoder().encode(p), w = V5(y, f, t);
  return {
    encryptedPrivateMessage: l,
    messageSignature: w,
    serializedPublicMessage: p
  };
}
function Ah(t, e) {
  const n = ss(t), r = ss(e), s = new Uint8Array(n.length + r.length);
  return s.set(n), s.set(r, n.length), ss(s);
}
function V5(t, e, n) {
  const r = Ah(t, e), s = K5(r, n, "SECURED_ENVELOPE");
  return on.fromHexInput(s).toString();
}
function Z5(t, e, n, r) {
  const s = new gr(on.fromHexInput(n).toUint8Array()), o = new mn(r.key), c = Ah(t, e);
  if (!H5(c, s, o, "SECURED_ENVELOPE"))
    throw new Oi("Could not verify SecuredEnvelope signature", "messageSignature");
}
function q5(t, e, n) {
  const { encryptedPrivateMessage: r, messageSignature: s, serializedPublicMessage: o } = n, c = JSON.parse(o), l = ht(r.securedB64), f = new TextEncoder().encode(o);
  Z5(f, l, s, t);
  const p = sn(t.key), y = c._metadata.senderEd25519PublicKeyB64;
  if (p !== y)
    throw new Oi(
      "senderEd25519PublicKey in envelope does not match provided receiverEd25519SecretKey",
      "senderPublicKey"
    );
  const w = ht(c._metadata.senderX25519PublicKeyB64), b = ct(
    w,
    "X25519PublicKey"
    /* X25519PublicKey */
  ), x = P5(r), I = W5(
    b,
    e,
    x.secured,
    x.nonce
  );
  return wh(c._metadata), yh(I, c), {
    messageSignature: s,
    privateMessage: I,
    publicMessage: c
  };
}
function X5(t) {
  const e = new Gn();
  return za(e, t), cn(e.toUint8Array());
}
function mh(t) {
  const e = Ua(t), n = new un(e);
  return ka(n);
}
function J5(t) {
  return new mn(ht(t));
}
class Hn extends Error {
  constructor(e, n, r) {
    super(
      typeof n == "object" ? n.message : n || e,
      {
        cause: typeof n == "object" ? n.cause : r
      }
    ), this.type = e, this.name = "TypedError", Object.setPrototypeOf(this, Hn.prototype);
  }
}
const $5 = "ERR_INVALID_VALUE", ey = "ERR_UNEXPECTED_VALUE", ty = "ERR_UNEXPECTED_TYPE", vh = "ERR_PARSE";
function ny(t, e) {
  const n = {};
  for (const r in t) {
    const s = t[r];
    if (!s)
      continue;
    let o, c;
    typeof s == "function" ? (o = r, c = s) : [o, c] = s;
    try {
      const l = c(e(o));
      l !== void 0 && (n[r] = l);
    } catch (l) {
      throw new Hn(
        vh,
        `Parser for "${r}" property failed${o === r ? "" : `. Source field: "${o}"`}`,
        l
      );
    }
  }
  return n;
}
function ry(t) {
  let e = t;
  if (typeof e == "string")
    try {
      e = JSON.parse(e);
    } catch (n) {
      throw new Hn($5, { cause: n });
    }
  if (typeof e != "object" || !e || Array.isArray(e))
    throw new Hn(ey);
  return e;
}
function Eh(t, e) {
  return (n) => {
    const r = (s) => {
      if (!(n && s === void 0))
        try {
          return e(s);
        } catch (o) {
          throw new Hn(vh, {
            message: `"${t}" transformer failed to parse the value`,
            cause: o
          });
        }
    };
    return /* @__PURE__ */ Object.assign(
      r,
      {
        isValid(s) {
          try {
            return r(s), !0;
          } catch {
            return !1;
          }
        }
      }
    );
  };
}
function Po(t, e) {
  return Eh(e || "object", (n) => {
    const r = ry(n);
    return ny(t, (s) => r[s]);
  });
}
function sy(t) {
  throw new Hn(ty, `Unexpected value received: ${JSON.stringify(t)}`);
}
const bh = Eh("fn", (t) => {
  if (typeof t == "function")
    return t;
  sy(t);
}), iy = Po({
  TelegramWebviewProxy: Po({ postEvent: bh() })()
});
function oy(t) {
  return iy().isValid(t);
}
function ay() {
  try {
    return window.self !== window.top;
  } catch {
    return !0;
  }
}
class Pa extends Error {
  constructor(e, n, r) {
    super(
      typeof n == "object" ? n.message : n || e,
      {
        cause: typeof n == "object" ? n.cause : r
      }
    ), this.type = e, this.name = "TypedError", Object.setPrototypeOf(this, Pa.prototype);
  }
}
// @__NO_SIDE_EFFECTS__
function cy(t, e) {
  e || (e = {});
  const {
    textColor: n,
    bgColor: r,
    shouldLog: s = !0
  } = e;
  function o(c, ...l) {
    if (!s || typeof s == "function" && !s())
      return;
    const f = "font-weight:bold;padding:0 5px;border-radius:5px";
    console[c](
      `%c${Intl.DateTimeFormat("en-GB", {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        fractionalSecondDigits: 3,
        timeZone: "UTC"
      }).format(/* @__PURE__ */ new Date())}%c / %c${t}`,
      `${f};background-color: lightblue;color:black`,
      "",
      `${f};${n ? `color:${n};` : ""}${r ? `background-color:${r}` : ""}`,
      ...l
    );
  }
  return [
    function(...c) {
      o("log", ...c);
    },
    function(...c) {
      o("error", ...c);
    }
  ];
}
function uy(t, e) {
  e();
}
// @__NO_SIDE_EFFECTS__
function Th(t, e) {
  e || (e = {});
  const n = e.equals || Object.is;
  let r = [], s = t;
  const o = (p) => {
    if (!n(s, p)) {
      const y = s;
      s = p, uy(f, () => {
        [...r].forEach(([w, b]) => {
          w(p, y), b && l(w, !0);
        });
      });
    }
  };
  function c(p) {
    const y = typeof p != "object" ? { once: p } : p;
    return {
      once: y.once || !1,
      signal: y.signal || !1
    };
  }
  const l = (p, y) => {
    const w = c(y), b = r.findIndex(([x, I]) => x === p && I.once === w.once && I.signal === w.signal);
    b >= 0 && r.splice(b, 1);
  }, f = Object.assign(
    function() {
      return ly(f), s;
    },
    {
      destroy() {
        r = [];
      },
      set: o,
      reset() {
        o(t);
      },
      sub(p, y) {
        return r.push([p, c(y)]), () => l(p, y);
      },
      unsub: l,
      unsubAll() {
        r = r.filter((p) => p[1].signal);
      }
    }
  );
  return f;
}
const so = [];
function ly(t) {
  so.length && so[so.length - 1].add(t);
}
const dy = /* @__PURE__ */ Th(!1), [hy, Pm] = /* @__PURE__ */ cy("Bridge", {
  bgColor: "#9147ff",
  textColor: "white",
  shouldLog: dy
}), fy = "ERR_UNKNOWN_ENV", py = /* @__PURE__ */ Th("https://web.telegram.org");
function gy(t, e) {
  hy("Posting event:", e ? { eventType: t, eventData: e } : { eventType: t });
  const n = window;
  if (oy(n)) {
    n.TelegramWebviewProxy.postEvent(t, JSON.stringify(e));
    return;
  }
  const r = JSON.stringify({ eventType: t, eventData: e });
  if (ay())
    return n.parent.postMessage(r, py());
  const { external: s } = n;
  if (Po({ notify: bh() })().isValid(s)) {
    s.notify(r);
    return;
  }
  throw new Pa(fy);
}
let js;
const yy = new Uint8Array(16);
function wy() {
  if (!js && (js = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !js))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return js(yy);
}
const at = [];
for (let t = 0; t < 256; ++t)
  at.push((t + 256).toString(16).slice(1));
function Ay(t, e = 0) {
  return at[t[e + 0]] + at[t[e + 1]] + at[t[e + 2]] + at[t[e + 3]] + "-" + at[t[e + 4]] + at[t[e + 5]] + "-" + at[t[e + 6]] + at[t[e + 7]] + "-" + at[t[e + 8]] + at[t[e + 9]] + "-" + at[t[e + 10]] + at[t[e + 11]] + at[t[e + 12]] + at[t[e + 13]] + at[t[e + 14]] + at[t[e + 15]];
}
const my = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Ac = {
  randomUUID: my
};
function vy(t, e, n) {
  if (Ac.randomUUID && !t)
    return Ac.randomUUID();
  t = t || {};
  const r = t.random || (t.rng || wy)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Ay(r);
}
var Ey = { height: 695, width: 465 }, by = 500, Ty = gs.serialize({ status: "dismissed" }), Iy = class extends Error {
  constructor() {
    super("Unauthorized");
  }
};
function My(t, e = Ey) {
  const { height: n, width: r } = e, s = {
    height: n,
    left: window.screenLeft + Math.round((window.outerWidth - r) / 2),
    popup: !0,
    top: window.screenTop + Math.round((window.outerHeight - n) / 2),
    width: r
  }, o = Object.entries(s).map(([f, p]) => `${f}=${JSON.stringify(p)}`).reduce((f, p) => `${f}, ${p}`), c = t instanceof URL ? t.href : t, l = window.open(c, void 0, o);
  if (l === null)
    throw new Error("Couldn't open prompt");
  return l;
}
async function Ny(t, e) {
  return new Promise((n, r) => {
    const s = {
      onMessage: (o) => {
        if (!(o.source !== e || o.origin !== t)) {
          if (no(M5, o.data)) {
            window.removeEventListener("message", s.onMessage), clearTimeout(s.promptPollerId), r(new Iy());
            return;
          }
          if (no(b5, o.data)) {
            e.postMessage(new T5(), t);
            return;
          }
          no(I5, o.data) && (window.removeEventListener("message", s.onMessage), clearTimeout(s.promptPollerId), n(o.data.serializedValue));
        }
      },
      promptPollerId: setInterval(() => {
        e.closed && (window.removeEventListener("message", s.onMessage), clearTimeout(s.promptPollerId), n(Ty));
      }, by)
    };
    window.addEventListener("message", s.onMessage);
  });
}
var Ih = "@aptos-connect/dapp-local-state";
function xy(t) {
  const e = new Gn();
  e.serializeU32AsUleb128(t.connectedAccounts.length);
  for (const n of t.connectedAccounts)
    ci(e, n);
  return e.toUint8Array();
}
function Sy(t) {
  const e = new un(t), n = e.deserializeUleb128AsU32(), r = [];
  for (let s = 0; s < n; s += 1)
    r.push(Oa(e));
  return { connectedAccounts: r };
}
function _a() {
  const t = window.localStorage.getItem(Ih);
  return t ? Sy(Ua(t)) : { connectedAccounts: [] };
}
function Mh(t) {
  const e = xy(t), n = cn(e);
  window.localStorage.setItem(Ih, n);
}
function io() {
  return _a().connectedAccounts;
}
function Dy(t) {
  const { connectedAccounts: e, ...n } = _a();
  e.push(t), Mh({ ...n, connectedAccounts: e });
}
function Uy(t) {
  const { connectedAccounts: e, ...n } = _a(), r = e.findIndex((s) => s.address.equals(t));
  r >= 0 && e.splice(r, 1), Mh({ ...n, connectedAccounts: e });
}
async function Cy(t, e) {
  const n = Ca(e.clientIdentityKey.toUint8Array());
  if (!(await fetch(`${t}/v1/dapp/clients/${n}/requests/`, {
    body: JSON.stringify({
      body: dh(e.body),
      id: e.id,
      signature: cn(e.signature.toUint8Array()),
      timestamp: e.timestamp
    }),
    headers: { Accept: "application/json", "Content-Type": "application/json" },
    method: "post"
  })).ok)
    throw new Error("Failed creating the wallet request");
}
var mc = "@aptos-connect/client-identity-key";
function zy() {
  const t = window.localStorage.getItem(mc);
  if (t)
    return new ii(t);
  const e = ii.generate();
  return window.localStorage.setItem(mc, e.toString()), e;
}
var ky = 300, Oy = 2e3, vc = 3e3, Ly = 5 * 6e4;
function Ec(t) {
  let e, n = () => {
  };
  const r = new Promise((s) => {
    e = setTimeout(s, t), n = () => {
      clearTimeout(e), s();
    };
  });
  return r.cancel = n, r;
}
async function jy(t) {
  let e, n = !1, r = vc;
  const s = () => {
    n = !0, r = Oy, e == null || e.cancel();
  }, o = () => {
    r = vc;
  };
  window.addEventListener("focus", s), window.addEventListener("blur", o);
  try {
    const c = Date.now();
    for (; Date.now() - c < Ly; ) {
      e = Ec(r), await e, n && (e = Ec(ky), await e);
      const l = await t();
      if (l.status === 200)
        return l;
      n = !1;
    }
    throw new Error("Timeout");
  } finally {
    window.removeEventListener("focus", s), window.removeEventListener("blur", s);
  }
}
async function Py(t, e, n) {
  const r = Ca(e.toUint8Array()), s = new URL(`${t}/v1/dapp/clients/${r}/requests/${n}/response/`), c = await (await jy(
    () => fetch(s, {
      headers: { Accept: "application/json" },
      method: "get"
    })
  )).json();
  return { data: Ua(c.data.body) };
}
async function _y(t) {
  const { baseUrl: e, request: n, tgWebAppUrl: r = "/AptosConnectBot/AptosConnect" } = t, s = zy(), o = s.publicKey(), c = vy(), l = Date.now(), f = x5({ body: n, id: c, timestamp: l }), p = s.sign(f), y = {
    body: n,
    clientIdentityKey: o,
    id: c,
    signature: p,
    timestamp: l
  };
  let w = gc(y);
  return w.length > 1024 && (Cy(e, y), w = gc({
    clientIdentityKey: o,
    id: c,
    signature: p,
    timestamp: l
  })), gy("web_app_open_tg_link", {
    path_full: `${r}?startapp=${w}`
  }), Py(e, o, c);
}
function By() {
  return window.TelegramWebviewProxy !== void 0;
}
var Ry = class {
  constructor(t, e = "google", n) {
    this.baseUrl = t, this.provider = e, this.tgWebAppUrl = n, this.baseUrl = t;
  }
  async sendPromptRequest(t) {
    if (By())
      return _y({
        baseUrl: this.baseUrl,
        request: t,
        tgWebAppUrl: this.tgWebAppUrl
      });
    const e = new URL(`${this.baseUrl}/prompt/`);
    e.searchParams.set("request", N5(t)), e.searchParams.set("provider", this.provider);
    const n = My(e);
    return Ny(this.baseUrl, n);
  }
  async sendRequest(t) {
    switch (t.name) {
      case zo.name: {
        const e = io();
        return ko.serialize(e.length > 0);
      }
      case di.name: {
        const e = io();
        return hi.serialize(e);
      }
      case ui.name: {
        const e = await this.sendPromptRequest(t), n = gs.deserialize(e);
        if (n.args.status === "approved") {
          const { account: r, pairing: s } = n.args.args;
          s === void 0 && Dy(r);
        }
        return e;
      }
      case li.name: {
        const [e] = io();
        return e && Uy(e.address), Co.serialize({});
      }
      case pi.name:
      case ys.name:
      case fi.name:
        return this.sendPromptRequest(t);
      default:
        throw new Error("Unexpected request");
    }
  }
}, Ba = /* @__PURE__ */ ((t) => (t.DEVNET = "devnet", t.MAINNET = "mainnet", t.TESTNET = "testnet", t))(Ba || {}), Zs = /* @__PURE__ */ ((t) => (t.SIGN_AND_SUBMIT_TRANSACTION = "SIGN_AND_SUBMIT_TRANSACTION", t.SIGN_MESSAGE = "SIGN_MESSAGE", t.SIGN_TRANSACTION = "SIGN_TRANSACTION", t))(Zs || {}), Nh = /* @__PURE__ */ ((t) => (t.APPROVED = "APPROVED", t.CANCELLED = "CANCELLED", t.INVALID = "INVALID", t.PENDING = "PENDING", t.REJECTED = "REJECTED", t))(Nh || {});
function Fy(t) {
  return (t == null ? void 0 : t.serialize) !== void 0;
}
function xh(t) {
  return (t == null ? void 0 : t.serialize) !== void 0 && (t == null ? void 0 : t.bcsToBytes) !== void 0 && (t == null ? void 0 : t.bcsToHex) !== void 0;
}
function Sh(t) {
  return Fy(t) || xh(t);
}
function gi(t) {
  if (xh(t))
    return t.bcsToHex().toString();
  const e = Vn.bcsToBytes(t);
  return on.fromHexInput(e).toString();
}
function bc(t, e) {
  const n = on.fromHexString(e).toUint8Array(), r = new un(n);
  return t.deserialize(r);
}
var Li = class Dh extends Error {
  constructor(e) {
    super(e), this.name = "UnexpectedValueError", Object.setPrototypeOf(this, Dh.prototype);
  }
};
function Uh(t) {
  return t instanceof Uint8Array ? {
    type: "Uint8Array",
    value: on.fromHexInput(t).toString()
  } : Array.isArray(t) ? t.map(Uh) : t;
}
function Tc(t) {
  const e = t.arguments.map(Uh);
  return {
    ...t,
    arguments: e,
    type: "entry_function_payload"
  };
}
function Ch(t) {
  if (t.type === "entry_function_payload" || t.type === void 0)
    return Tc(t);
  if (t.type === "multisig_payload") {
    const e = t.transaction_payload !== void 0 ? Tc(t.transaction_payload) : void 0;
    return { ...t, transaction_payload: e };
  }
  throw new Li();
}
function _o(t) {
  const e = gi(t);
  if ("fee_payer_address" in t)
    return { type: "fee_payer_raw_txn", value: e };
  if ("secondary_signer_addresses" in t)
    return { type: "multi_agent_raw_txn", value: e };
  if ("chain_id" in t)
    return { type: "raw_txn", value: e };
  throw new Li("Invalid raw transaction type");
}
function Wy(t) {
  if ("payload" in t) {
    const e = Sh(t.payload) ? gi(t.payload) : Ch(t.payload);
    return { options: t.options, payload: e };
  }
  if ("feePayerAuthenticator" in t)
    return {
      feePayerAuthenticator: gi(t.feePayerAuthenticator),
      rawTxn: _o(t.rawTxn)
    };
  if ("rawTxn" in t)
    return { rawTxn: _o(t.rawTxn) };
  throw new Li();
}
function Qy(t) {
  if ("payload" in t) {
    const e = Sh(t.payload) ? gi(t.payload) : Ch(t.payload);
    return { options: t.options, payload: e };
  }
  if ("rawTxn" in t)
    return { rawTxn: _o(t.rawTxn) };
  throw new Li();
}
function Ky(t) {
  const e = bc(Es, t.accountAuthenticator);
  if ("rawTxn" in t) {
    const n = bc(Nu, t.rawTxn);
    return { accountAuthenticator: e, rawTxn: n };
  }
  return { accountAuthenticator: e };
}
function zh(t, e) {
  return function() {
    return t.apply(e, arguments);
  };
}
const { toString: Hy } = Object.prototype, { getPrototypeOf: Ra } = Object, ji = /* @__PURE__ */ ((t) => (e) => {
  const n = Hy.call(e);
  return t[n] || (t[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Ft = (t) => (t = t.toLowerCase(), (e) => ji(e) === t), Pi = (t) => (e) => typeof e === t, { isArray: Sr } = Array, ws = Pi("undefined");
function Yy(t) {
  return t !== null && !ws(t) && t.constructor !== null && !ws(t.constructor) && Dt(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
const kh = Ft("ArrayBuffer");
function Gy(t) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && kh(t.buffer), e;
}
const Vy = Pi("string"), Dt = Pi("function"), Oh = Pi("number"), _i = (t) => t !== null && typeof t == "object", Zy = (t) => t === !0 || t === !1, qs = (t) => {
  if (ji(t) !== "object")
    return !1;
  const e = Ra(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}, qy = Ft("Date"), Xy = Ft("File"), Jy = Ft("Blob"), $y = Ft("FileList"), e1 = (t) => _i(t) && Dt(t.pipe), t1 = (t) => {
  let e;
  return t && (typeof FormData == "function" && t instanceof FormData || Dt(t.append) && ((e = ji(t)) === "formdata" || // detect form-data instance
  e === "object" && Dt(t.toString) && t.toString() === "[object FormData]"));
}, n1 = Ft("URLSearchParams"), [r1, s1, i1, o1] = ["ReadableStream", "Request", "Response", "Headers"].map(Ft), a1 = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Us(t, e, { allOwnKeys: n = !1 } = {}) {
  if (t === null || typeof t > "u")
    return;
  let r, s;
  if (typeof t != "object" && (t = [t]), Sr(t))
    for (r = 0, s = t.length; r < s; r++)
      e.call(null, t[r], r, t);
  else {
    const o = n ? Object.getOwnPropertyNames(t) : Object.keys(t), c = o.length;
    let l;
    for (r = 0; r < c; r++)
      l = o[r], e.call(null, t[l], l, t);
  }
}
function Lh(t, e) {
  e = e.toLowerCase();
  const n = Object.keys(t);
  let r = n.length, s;
  for (; r-- > 0; )
    if (s = n[r], e === s.toLowerCase())
      return s;
  return null;
}
const Pn = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Je.global, jh = (t) => !ws(t) && t !== Pn;
function Bo() {
  const { caseless: t } = jh(this) && this || {}, e = {}, n = (r, s) => {
    const o = t && Lh(e, s) || s;
    qs(e[o]) && qs(r) ? e[o] = Bo(e[o], r) : qs(r) ? e[o] = Bo({}, r) : Sr(r) ? e[o] = r.slice() : e[o] = r;
  };
  for (let r = 0, s = arguments.length; r < s; r++)
    arguments[r] && Us(arguments[r], n);
  return e;
}
const c1 = (t, e, n, { allOwnKeys: r } = {}) => (Us(e, (s, o) => {
  n && Dt(s) ? t[o] = zh(s, n) : t[o] = s;
}, { allOwnKeys: r }), t), u1 = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), l1 = (t, e, n, r) => {
  t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: e.prototype
  }), n && Object.assign(t.prototype, n);
}, d1 = (t, e, n, r) => {
  let s, o, c;
  const l = {};
  if (e = e || {}, t == null) return e;
  do {
    for (s = Object.getOwnPropertyNames(t), o = s.length; o-- > 0; )
      c = s[o], (!r || r(c, t, e)) && !l[c] && (e[c] = t[c], l[c] = !0);
    t = n !== !1 && Ra(t);
  } while (t && (!n || n(t, e)) && t !== Object.prototype);
  return e;
}, h1 = (t, e, n) => {
  t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length;
  const r = t.indexOf(e, n);
  return r !== -1 && r === n;
}, f1 = (t) => {
  if (!t) return null;
  if (Sr(t)) return t;
  let e = t.length;
  if (!Oh(e)) return null;
  const n = new Array(e);
  for (; e-- > 0; )
    n[e] = t[e];
  return n;
}, p1 = /* @__PURE__ */ ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && Ra(Uint8Array)), g1 = (t, e) => {
  const r = (t && t[Symbol.iterator]).call(t);
  let s;
  for (; (s = r.next()) && !s.done; ) {
    const o = s.value;
    e.call(t, o[0], o[1]);
  }
}, y1 = (t, e) => {
  let n;
  const r = [];
  for (; (n = t.exec(e)) !== null; )
    r.push(n);
  return r;
}, w1 = Ft("HTMLFormElement"), A1 = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, s) {
    return r.toUpperCase() + s;
  }
), Ic = (({ hasOwnProperty: t }) => (e, n) => t.call(e, n))(Object.prototype), m1 = Ft("RegExp"), Ph = (t, e) => {
  const n = Object.getOwnPropertyDescriptors(t), r = {};
  Us(n, (s, o) => {
    let c;
    (c = e(s, o, t)) !== !1 && (r[o] = c || s);
  }), Object.defineProperties(t, r);
}, v1 = (t) => {
  Ph(t, (e, n) => {
    if (Dt(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = t[n];
    if (Dt(r)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, E1 = (t, e) => {
  const n = {}, r = (s) => {
    s.forEach((o) => {
      n[o] = !0;
    });
  };
  return Sr(t) ? r(t) : r(String(t).split(e)), n;
}, b1 = () => {
}, T1 = (t, e) => t != null && Number.isFinite(t = +t) ? t : e, oo = "abcdefghijklmnopqrstuvwxyz", Mc = "0123456789", _h = {
  DIGIT: Mc,
  ALPHA: oo,
  ALPHA_DIGIT: oo + oo.toUpperCase() + Mc
}, I1 = (t = 16, e = _h.ALPHA_DIGIT) => {
  let n = "";
  const { length: r } = e;
  for (; t--; )
    n += e[Math.random() * r | 0];
  return n;
};
function M1(t) {
  return !!(t && Dt(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]);
}
const N1 = (t) => {
  const e = new Array(10), n = (r, s) => {
    if (_i(r)) {
      if (e.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        e[s] = r;
        const o = Sr(r) ? [] : {};
        return Us(r, (c, l) => {
          const f = n(c, s + 1);
          !ws(f) && (o[l] = f);
        }), e[s] = void 0, o;
      }
    }
    return r;
  };
  return n(t, 0);
}, x1 = Ft("AsyncFunction"), S1 = (t) => t && (_i(t) || Dt(t)) && Dt(t.then) && Dt(t.catch), Bh = ((t, e) => t ? setImmediate : e ? ((n, r) => (Pn.addEventListener("message", ({ source: s, data: o }) => {
  s === Pn && o === n && r.length && r.shift()();
}, !1), (s) => {
  r.push(s), Pn.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  Dt(Pn.postMessage)
), D1 = typeof queueMicrotask < "u" ? queueMicrotask.bind(Pn) : typeof Je.process < "u" && Je.process.nextTick || Bh, _ = {
  isArray: Sr,
  isArrayBuffer: kh,
  isBuffer: Yy,
  isFormData: t1,
  isArrayBufferView: Gy,
  isString: Vy,
  isNumber: Oh,
  isBoolean: Zy,
  isObject: _i,
  isPlainObject: qs,
  isReadableStream: r1,
  isRequest: s1,
  isResponse: i1,
  isHeaders: o1,
  isUndefined: ws,
  isDate: qy,
  isFile: Xy,
  isBlob: Jy,
  isRegExp: m1,
  isFunction: Dt,
  isStream: e1,
  isURLSearchParams: n1,
  isTypedArray: p1,
  isFileList: $y,
  forEach: Us,
  merge: Bo,
  extend: c1,
  trim: a1,
  stripBOM: u1,
  inherits: l1,
  toFlatObject: d1,
  kindOf: ji,
  kindOfTest: Ft,
  endsWith: h1,
  toArray: f1,
  forEachEntry: g1,
  matchAll: y1,
  isHTMLForm: w1,
  hasOwnProperty: Ic,
  hasOwnProp: Ic,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: Ph,
  freezeMethods: v1,
  toObjectSet: E1,
  toCamelCase: A1,
  noop: b1,
  toFiniteNumber: T1,
  findKey: Lh,
  global: Pn,
  isContextDefined: jh,
  ALPHABET: _h,
  generateString: I1,
  isSpecCompliantForm: M1,
  toJSONObject: N1,
  isAsyncFn: x1,
  isThenable: S1,
  setImmediate: Bh,
  asap: D1
};
function xe(t, e, n, r, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), r && (this.request = r), s && (this.response = s, this.status = s.status ? s.status : null);
}
_.inherits(xe, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: _.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const Rh = xe.prototype, Fh = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t) => {
  Fh[t] = { value: t };
});
Object.defineProperties(xe, Fh);
Object.defineProperty(Rh, "isAxiosError", { value: !0 });
xe.from = (t, e, n, r, s, o) => {
  const c = Object.create(Rh);
  return _.toFlatObject(t, c, function(f) {
    return f !== Error.prototype;
  }, (l) => l !== "isAxiosError"), xe.call(c, t.message, e, n, r, s), c.cause = t, c.name = t.name, o && Object.assign(c, o), c;
};
const U1 = null;
function Ro(t) {
  return _.isPlainObject(t) || _.isArray(t);
}
function Wh(t) {
  return _.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function Nc(t, e, n) {
  return t ? t.concat(e).map(function(s, o) {
    return s = Wh(s), !n && o ? "[" + s + "]" : s;
  }).join(n ? "." : "") : e;
}
function C1(t) {
  return _.isArray(t) && !t.some(Ro);
}
const z1 = _.toFlatObject(_, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function Bi(t, e, n) {
  if (!_.isObject(t))
    throw new TypeError("target must be an object");
  e = e || new FormData(), n = _.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(z, S) {
    return !_.isUndefined(S[z]);
  });
  const r = n.metaTokens, s = n.visitor || y, o = n.dots, c = n.indexes, f = (n.Blob || typeof Blob < "u" && Blob) && _.isSpecCompliantForm(e);
  if (!_.isFunction(s))
    throw new TypeError("visitor must be a function");
  function p(I) {
    if (I === null) return "";
    if (_.isDate(I))
      return I.toISOString();
    if (!f && _.isBlob(I))
      throw new xe("Blob is not supported. Use a Buffer instead.");
    return _.isArrayBuffer(I) || _.isTypedArray(I) ? f && typeof Blob == "function" ? new Blob([I]) : Je.Buffer.from(I) : I;
  }
  function y(I, z, S) {
    let Z = I;
    if (I && !S && typeof I == "object") {
      if (_.endsWith(z, "{}"))
        z = r ? z : z.slice(0, -2), I = JSON.stringify(I);
      else if (_.isArray(I) && C1(I) || (_.isFileList(I) || _.endsWith(z, "[]")) && (Z = _.toArray(I)))
        return z = Wh(z), Z.forEach(function(L, ve) {
          !(_.isUndefined(L) || L === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            c === !0 ? Nc([z], ve, o) : c === null ? z : z + "[]",
            p(L)
          );
        }), !1;
    }
    return Ro(I) ? !0 : (e.append(Nc(S, z, o), p(I)), !1);
  }
  const w = [], b = Object.assign(z1, {
    defaultVisitor: y,
    convertValue: p,
    isVisitable: Ro
  });
  function x(I, z) {
    if (!_.isUndefined(I)) {
      if (w.indexOf(I) !== -1)
        throw Error("Circular reference detected in " + z.join("."));
      w.push(I), _.forEach(I, function(Z, le) {
        (!(_.isUndefined(Z) || Z === null) && s.call(
          e,
          Z,
          _.isString(le) ? le.trim() : le,
          z,
          b
        )) === !0 && x(Z, z ? z.concat(le) : [le]);
      }), w.pop();
    }
  }
  if (!_.isObject(t))
    throw new TypeError("data must be an object");
  return x(t), e;
}
function xc(t) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(r) {
    return e[r];
  });
}
function Fa(t, e) {
  this._pairs = [], t && Bi(t, this, e);
}
const Qh = Fa.prototype;
Qh.append = function(e, n) {
  this._pairs.push([e, n]);
};
Qh.toString = function(e) {
  const n = e ? function(r) {
    return e.call(this, r, xc);
  } : xc;
  return this._pairs.map(function(s) {
    return n(s[0]) + "=" + n(s[1]);
  }, "").join("&");
};
function k1(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function Kh(t, e, n) {
  if (!e)
    return t;
  const r = n && n.encode || k1;
  _.isFunction(n) && (n = {
    serialize: n
  });
  const s = n && n.serialize;
  let o;
  if (s ? o = s(e, n) : o = _.isURLSearchParams(e) ? e.toString() : new Fa(e, n).toString(r), o) {
    const c = t.indexOf("#");
    c !== -1 && (t = t.slice(0, c)), t += (t.indexOf("?") === -1 ? "?" : "&") + o;
  }
  return t;
}
class Sc {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, n, r) {
    return this.handlers.push({
      fulfilled: e,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    _.forEach(this.handlers, function(r) {
      r !== null && e(r);
    });
  }
}
const Hh = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, O1 = typeof URLSearchParams < "u" ? URLSearchParams : Fa, L1 = typeof FormData < "u" ? FormData : null, j1 = typeof Blob < "u" ? Blob : null, P1 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: O1,
    FormData: L1,
    Blob: j1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Wa = typeof window < "u" && typeof document < "u", Fo = typeof navigator == "object" && navigator || void 0, _1 = Wa && (!Fo || ["ReactNative", "NativeScript", "NS"].indexOf(Fo.product) < 0), B1 = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", R1 = Wa && window.location.href || "http://localhost", F1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Wa,
  hasStandardBrowserEnv: _1,
  hasStandardBrowserWebWorkerEnv: B1,
  navigator: Fo,
  origin: R1
}, Symbol.toStringTag, { value: "Module" })), ft = {
  ...F1,
  ...P1
};
function W1(t, e) {
  return Bi(t, new ft.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, s, o) {
      return ft.isNode && _.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function Q1(t) {
  return _.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function K1(t) {
  const e = {}, n = Object.keys(t);
  let r;
  const s = n.length;
  let o;
  for (r = 0; r < s; r++)
    o = n[r], e[o] = t[o];
  return e;
}
function Yh(t) {
  function e(n, r, s, o) {
    let c = n[o++];
    if (c === "__proto__") return !0;
    const l = Number.isFinite(+c), f = o >= n.length;
    return c = !c && _.isArray(s) ? s.length : c, f ? (_.hasOwnProp(s, c) ? s[c] = [s[c], r] : s[c] = r, !l) : ((!s[c] || !_.isObject(s[c])) && (s[c] = []), e(n, r, s[c], o) && _.isArray(s[c]) && (s[c] = K1(s[c])), !l);
  }
  if (_.isFormData(t) && _.isFunction(t.entries)) {
    const n = {};
    return _.forEachEntry(t, (r, s) => {
      e(Q1(r), s, n, 0);
    }), n;
  }
  return null;
}
function H1(t, e, n) {
  if (_.isString(t))
    try {
      return (e || JSON.parse)(t), _.trim(t);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(t);
}
const Cs = {
  transitional: Hh,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, n) {
    const r = n.getContentType() || "", s = r.indexOf("application/json") > -1, o = _.isObject(e);
    if (o && _.isHTMLForm(e) && (e = new FormData(e)), _.isFormData(e))
      return s ? JSON.stringify(Yh(e)) : e;
    if (_.isArrayBuffer(e) || _.isBuffer(e) || _.isStream(e) || _.isFile(e) || _.isBlob(e) || _.isReadableStream(e))
      return e;
    if (_.isArrayBufferView(e))
      return e.buffer;
    if (_.isURLSearchParams(e))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let l;
    if (o) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return W1(e, this.formSerializer).toString();
      if ((l = _.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
        const f = this.env && this.env.FormData;
        return Bi(
          l ? { "files[]": e } : e,
          f && new f(),
          this.formSerializer
        );
      }
    }
    return o || s ? (n.setContentType("application/json", !1), H1(e)) : e;
  }],
  transformResponse: [function(e) {
    const n = this.transitional || Cs.transitional, r = n && n.forcedJSONParsing, s = this.responseType === "json";
    if (_.isResponse(e) || _.isReadableStream(e))
      return e;
    if (e && _.isString(e) && (r && !this.responseType || s)) {
      const c = !(n && n.silentJSONParsing) && s;
      try {
        return JSON.parse(e);
      } catch (l) {
        if (c)
          throw l.name === "SyntaxError" ? xe.from(l, xe.ERR_BAD_RESPONSE, this, null, this.response) : l;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: ft.classes.FormData,
    Blob: ft.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
_.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
  Cs.headers[t] = {};
});
const Y1 = _.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), G1 = (t) => {
  const e = {};
  let n, r, s;
  return t && t.split(`
`).forEach(function(c) {
    s = c.indexOf(":"), n = c.substring(0, s).trim().toLowerCase(), r = c.substring(s + 1).trim(), !(!n || e[n] && Y1[n]) && (n === "set-cookie" ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + ", " + r : r);
  }), e;
}, Dc = Symbol("internals");
function Kr(t) {
  return t && String(t).trim().toLowerCase();
}
function Xs(t) {
  return t === !1 || t == null ? t : _.isArray(t) ? t.map(Xs) : String(t);
}
function V1(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(t); )
    e[r[1]] = r[2];
  return e;
}
const Z1 = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function ao(t, e, n, r, s) {
  if (_.isFunction(r))
    return r.call(this, e, n);
  if (s && (e = n), !!_.isString(e)) {
    if (_.isString(r))
      return e.indexOf(r) !== -1;
    if (_.isRegExp(r))
      return r.test(e);
  }
}
function q1(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, r) => n.toUpperCase() + r);
}
function X1(t, e) {
  const n = _.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(t, r + n, {
      value: function(s, o, c) {
        return this[r].call(this, e, s, o, c);
      },
      configurable: !0
    });
  });
}
let Tt = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, n, r) {
    const s = this;
    function o(l, f, p) {
      const y = Kr(f);
      if (!y)
        throw new Error("header name must be a non-empty string");
      const w = _.findKey(s, y);
      (!w || s[w] === void 0 || p === !0 || p === void 0 && s[w] !== !1) && (s[w || f] = Xs(l));
    }
    const c = (l, f) => _.forEach(l, (p, y) => o(p, y, f));
    if (_.isPlainObject(e) || e instanceof this.constructor)
      c(e, n);
    else if (_.isString(e) && (e = e.trim()) && !Z1(e))
      c(G1(e), n);
    else if (_.isHeaders(e))
      for (const [l, f] of e.entries())
        o(f, l, r);
    else
      e != null && o(n, e, r);
    return this;
  }
  get(e, n) {
    if (e = Kr(e), e) {
      const r = _.findKey(this, e);
      if (r) {
        const s = this[r];
        if (!n)
          return s;
        if (n === !0)
          return V1(s);
        if (_.isFunction(n))
          return n.call(this, s, r);
        if (_.isRegExp(n))
          return n.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, n) {
    if (e = Kr(e), e) {
      const r = _.findKey(this, e);
      return !!(r && this[r] !== void 0 && (!n || ao(this, this[r], r, n)));
    }
    return !1;
  }
  delete(e, n) {
    const r = this;
    let s = !1;
    function o(c) {
      if (c = Kr(c), c) {
        const l = _.findKey(r, c);
        l && (!n || ao(r, r[l], l, n)) && (delete r[l], s = !0);
      }
    }
    return _.isArray(e) ? e.forEach(o) : o(e), s;
  }
  clear(e) {
    const n = Object.keys(this);
    let r = n.length, s = !1;
    for (; r--; ) {
      const o = n[r];
      (!e || ao(this, this[o], o, e, !0)) && (delete this[o], s = !0);
    }
    return s;
  }
  normalize(e) {
    const n = this, r = {};
    return _.forEach(this, (s, o) => {
      const c = _.findKey(r, o);
      if (c) {
        n[c] = Xs(s), delete n[o];
        return;
      }
      const l = e ? q1(o) : String(o).trim();
      l !== o && delete n[o], n[l] = Xs(s), r[l] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const n = /* @__PURE__ */ Object.create(null);
    return _.forEach(this, (r, s) => {
      r != null && r !== !1 && (n[s] = e && _.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...n) {
    const r = new this(e);
    return n.forEach((s) => r.set(s)), r;
  }
  static accessor(e) {
    const r = (this[Dc] = this[Dc] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function o(c) {
      const l = Kr(c);
      r[l] || (X1(s, c), r[l] = !0);
    }
    return _.isArray(e) ? e.forEach(o) : o(e), this;
  }
};
Tt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
_.reduceDescriptors(Tt.prototype, ({ value: t }, e) => {
  let n = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(r) {
      this[n] = r;
    }
  };
});
_.freezeMethods(Tt);
function co(t, e) {
  const n = this || Cs, r = e || n, s = Tt.from(r.headers);
  let o = r.data;
  return _.forEach(t, function(l) {
    o = l.call(n, o, s.normalize(), e ? e.status : void 0);
  }), s.normalize(), o;
}
function Gh(t) {
  return !!(t && t.__CANCEL__);
}
function Dr(t, e, n) {
  xe.call(this, t ?? "canceled", xe.ERR_CANCELED, e, n), this.name = "CanceledError";
}
_.inherits(Dr, xe, {
  __CANCEL__: !0
});
function Vh(t, e, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? t(n) : e(new xe(
    "Request failed with status code " + n.status,
    [xe.ERR_BAD_REQUEST, xe.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function J1(t) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return e && e[1] || "";
}
function $1(t, e) {
  t = t || 10;
  const n = new Array(t), r = new Array(t);
  let s = 0, o = 0, c;
  return e = e !== void 0 ? e : 1e3, function(f) {
    const p = Date.now(), y = r[o];
    c || (c = p), n[s] = f, r[s] = p;
    let w = o, b = 0;
    for (; w !== s; )
      b += n[w++], w = w % t;
    if (s = (s + 1) % t, s === o && (o = (o + 1) % t), p - c < e)
      return;
    const x = y && p - y;
    return x ? Math.round(b * 1e3 / x) : void 0;
  };
}
function ew(t, e) {
  let n = 0, r = 1e3 / e, s, o;
  const c = (p, y = Date.now()) => {
    n = y, s = null, o && (clearTimeout(o), o = null), t.apply(null, p);
  };
  return [(...p) => {
    const y = Date.now(), w = y - n;
    w >= r ? c(p, y) : (s = p, o || (o = setTimeout(() => {
      o = null, c(s);
    }, r - w)));
  }, () => s && c(s)];
}
const yi = (t, e, n = 3) => {
  let r = 0;
  const s = $1(50, 250);
  return ew((o) => {
    const c = o.loaded, l = o.lengthComputable ? o.total : void 0, f = c - r, p = s(f), y = c <= l;
    r = c;
    const w = {
      loaded: c,
      total: l,
      progress: l ? c / l : void 0,
      bytes: f,
      rate: p || void 0,
      estimated: p && l && y ? (l - c) / p : void 0,
      event: o,
      lengthComputable: l != null,
      [e ? "download" : "upload"]: !0
    };
    t(w);
  }, n);
}, Uc = (t, e) => {
  const n = t != null;
  return [(r) => e[0]({
    lengthComputable: n,
    total: t,
    loaded: r
  }), e[1]];
}, Cc = (t) => (...e) => _.asap(() => t(...e)), tw = ft.hasStandardBrowserEnv ? /* @__PURE__ */ ((t, e) => (n) => (n = new URL(n, ft.origin), t.protocol === n.protocol && t.host === n.host && (e || t.port === n.port)))(
  new URL(ft.origin),
  ft.navigator && /(msie|trident)/i.test(ft.navigator.userAgent)
) : () => !0, nw = ft.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(t, e, n, r, s, o) {
      const c = [t + "=" + encodeURIComponent(e)];
      _.isNumber(n) && c.push("expires=" + new Date(n).toGMTString()), _.isString(r) && c.push("path=" + r), _.isString(s) && c.push("domain=" + s), o === !0 && c.push("secure"), document.cookie = c.join("; ");
    },
    read(t) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(t) {
      this.write(t, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function rw(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function sw(t, e) {
  return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function Zh(t, e) {
  return t && !rw(e) ? sw(t, e) : e;
}
const zc = (t) => t instanceof Tt ? { ...t } : t;
function Yn(t, e) {
  e = e || {};
  const n = {};
  function r(p, y, w, b) {
    return _.isPlainObject(p) && _.isPlainObject(y) ? _.merge.call({ caseless: b }, p, y) : _.isPlainObject(y) ? _.merge({}, y) : _.isArray(y) ? y.slice() : y;
  }
  function s(p, y, w, b) {
    if (_.isUndefined(y)) {
      if (!_.isUndefined(p))
        return r(void 0, p, w, b);
    } else return r(p, y, w, b);
  }
  function o(p, y) {
    if (!_.isUndefined(y))
      return r(void 0, y);
  }
  function c(p, y) {
    if (_.isUndefined(y)) {
      if (!_.isUndefined(p))
        return r(void 0, p);
    } else return r(void 0, y);
  }
  function l(p, y, w) {
    if (w in e)
      return r(p, y);
    if (w in t)
      return r(void 0, p);
  }
  const f = {
    url: o,
    method: o,
    data: o,
    baseURL: c,
    transformRequest: c,
    transformResponse: c,
    paramsSerializer: c,
    timeout: c,
    timeoutMessage: c,
    withCredentials: c,
    withXSRFToken: c,
    adapter: c,
    responseType: c,
    xsrfCookieName: c,
    xsrfHeaderName: c,
    onUploadProgress: c,
    onDownloadProgress: c,
    decompress: c,
    maxContentLength: c,
    maxBodyLength: c,
    beforeRedirect: c,
    transport: c,
    httpAgent: c,
    httpsAgent: c,
    cancelToken: c,
    socketPath: c,
    responseEncoding: c,
    validateStatus: l,
    headers: (p, y, w) => s(zc(p), zc(y), w, !0)
  };
  return _.forEach(Object.keys(Object.assign({}, t, e)), function(y) {
    const w = f[y] || s, b = w(t[y], e[y], y);
    _.isUndefined(b) && w !== l || (n[y] = b);
  }), n;
}
const qh = (t) => {
  const e = Yn({}, t);
  let { data: n, withXSRFToken: r, xsrfHeaderName: s, xsrfCookieName: o, headers: c, auth: l } = e;
  e.headers = c = Tt.from(c), e.url = Kh(Zh(e.baseURL, e.url), t.params, t.paramsSerializer), l && c.set(
    "Authorization",
    "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : ""))
  );
  let f;
  if (_.isFormData(n)) {
    if (ft.hasStandardBrowserEnv || ft.hasStandardBrowserWebWorkerEnv)
      c.setContentType(void 0);
    else if ((f = c.getContentType()) !== !1) {
      const [p, ...y] = f ? f.split(";").map((w) => w.trim()).filter(Boolean) : [];
      c.setContentType([p || "multipart/form-data", ...y].join("; "));
    }
  }
  if (ft.hasStandardBrowserEnv && (r && _.isFunction(r) && (r = r(e)), r || r !== !1 && tw(e.url))) {
    const p = s && o && nw.read(o);
    p && c.set(s, p);
  }
  return e;
}, iw = typeof XMLHttpRequest < "u", ow = iw && function(t) {
  return new Promise(function(n, r) {
    const s = qh(t);
    let o = s.data;
    const c = Tt.from(s.headers).normalize();
    let { responseType: l, onUploadProgress: f, onDownloadProgress: p } = s, y, w, b, x, I;
    function z() {
      x && x(), I && I(), s.cancelToken && s.cancelToken.unsubscribe(y), s.signal && s.signal.removeEventListener("abort", y);
    }
    let S = new XMLHttpRequest();
    S.open(s.method.toUpperCase(), s.url, !0), S.timeout = s.timeout;
    function Z() {
      if (!S)
        return;
      const L = Tt.from(
        "getAllResponseHeaders" in S && S.getAllResponseHeaders()
      ), ye = {
        data: !l || l === "text" || l === "json" ? S.responseText : S.response,
        status: S.status,
        statusText: S.statusText,
        headers: L,
        config: t,
        request: S
      };
      Vh(function(Re) {
        n(Re), z();
      }, function(Re) {
        r(Re), z();
      }, ye), S = null;
    }
    "onloadend" in S ? S.onloadend = Z : S.onreadystatechange = function() {
      !S || S.readyState !== 4 || S.status === 0 && !(S.responseURL && S.responseURL.indexOf("file:") === 0) || setTimeout(Z);
    }, S.onabort = function() {
      S && (r(new xe("Request aborted", xe.ECONNABORTED, t, S)), S = null);
    }, S.onerror = function() {
      r(new xe("Network Error", xe.ERR_NETWORK, t, S)), S = null;
    }, S.ontimeout = function() {
      let ve = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
      const ye = s.transitional || Hh;
      s.timeoutErrorMessage && (ve = s.timeoutErrorMessage), r(new xe(
        ve,
        ye.clarifyTimeoutError ? xe.ETIMEDOUT : xe.ECONNABORTED,
        t,
        S
      )), S = null;
    }, o === void 0 && c.setContentType(null), "setRequestHeader" in S && _.forEach(c.toJSON(), function(ve, ye) {
      S.setRequestHeader(ye, ve);
    }), _.isUndefined(s.withCredentials) || (S.withCredentials = !!s.withCredentials), l && l !== "json" && (S.responseType = s.responseType), p && ([b, I] = yi(p, !0), S.addEventListener("progress", b)), f && S.upload && ([w, x] = yi(f), S.upload.addEventListener("progress", w), S.upload.addEventListener("loadend", x)), (s.cancelToken || s.signal) && (y = (L) => {
      S && (r(!L || L.type ? new Dr(null, t, S) : L), S.abort(), S = null);
    }, s.cancelToken && s.cancelToken.subscribe(y), s.signal && (s.signal.aborted ? y() : s.signal.addEventListener("abort", y)));
    const le = J1(s.url);
    if (le && ft.protocols.indexOf(le) === -1) {
      r(new xe("Unsupported protocol " + le + ":", xe.ERR_BAD_REQUEST, t));
      return;
    }
    S.send(o || null);
  });
}, aw = (t, e) => {
  const { length: n } = t = t ? t.filter(Boolean) : [];
  if (e || n) {
    let r = new AbortController(), s;
    const o = function(p) {
      if (!s) {
        s = !0, l();
        const y = p instanceof Error ? p : this.reason;
        r.abort(y instanceof xe ? y : new Dr(y instanceof Error ? y.message : y));
      }
    };
    let c = e && setTimeout(() => {
      c = null, o(new xe(`timeout ${e} of ms exceeded`, xe.ETIMEDOUT));
    }, e);
    const l = () => {
      t && (c && clearTimeout(c), c = null, t.forEach((p) => {
        p.unsubscribe ? p.unsubscribe(o) : p.removeEventListener("abort", o);
      }), t = null);
    };
    t.forEach((p) => p.addEventListener("abort", o));
    const { signal: f } = r;
    return f.unsubscribe = () => _.asap(l), f;
  }
}, cw = function* (t, e) {
  let n = t.byteLength;
  if (n < e) {
    yield t;
    return;
  }
  let r = 0, s;
  for (; r < n; )
    s = r + e, yield t.slice(r, s), r = s;
}, uw = async function* (t, e) {
  for await (const n of lw(t))
    yield* cw(n, e);
}, lw = async function* (t) {
  if (t[Symbol.asyncIterator]) {
    yield* t;
    return;
  }
  const e = t.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await e.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await e.cancel();
  }
}, kc = (t, e, n, r) => {
  const s = uw(t, e);
  let o = 0, c, l = (f) => {
    c || (c = !0, r && r(f));
  };
  return new ReadableStream({
    async pull(f) {
      try {
        const { done: p, value: y } = await s.next();
        if (p) {
          l(), f.close();
          return;
        }
        let w = y.byteLength;
        if (n) {
          let b = o += w;
          n(b);
        }
        f.enqueue(new Uint8Array(y));
      } catch (p) {
        throw l(p), p;
      }
    },
    cancel(f) {
      return l(f), s.return();
    }
  }, {
    highWaterMark: 2
  });
}, Ri = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", Xh = Ri && typeof ReadableStream == "function", dw = Ri && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((t) => (e) => t.encode(e))(new TextEncoder()) : async (t) => new Uint8Array(await new Response(t).arrayBuffer())), Jh = (t, ...e) => {
  try {
    return !!t(...e);
  } catch {
    return !1;
  }
}, hw = Xh && Jh(() => {
  let t = !1;
  const e = new Request(ft.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return t = !0, "half";
    }
  }).headers.has("Content-Type");
  return t && !e;
}), Oc = 64 * 1024, Wo = Xh && Jh(() => _.isReadableStream(new Response("").body)), wi = {
  stream: Wo && ((t) => t.body)
};
Ri && ((t) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !wi[e] && (wi[e] = _.isFunction(t[e]) ? (n) => n[e]() : (n, r) => {
      throw new xe(`Response type '${e}' is not supported`, xe.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const fw = async (t) => {
  if (t == null)
    return 0;
  if (_.isBlob(t))
    return t.size;
  if (_.isSpecCompliantForm(t))
    return (await new Request(ft.origin, {
      method: "POST",
      body: t
    }).arrayBuffer()).byteLength;
  if (_.isArrayBufferView(t) || _.isArrayBuffer(t))
    return t.byteLength;
  if (_.isURLSearchParams(t) && (t = t + ""), _.isString(t))
    return (await dw(t)).byteLength;
}, pw = async (t, e) => {
  const n = _.toFiniteNumber(t.getContentLength());
  return n ?? fw(e);
}, gw = Ri && (async (t) => {
  let {
    url: e,
    method: n,
    data: r,
    signal: s,
    cancelToken: o,
    timeout: c,
    onDownloadProgress: l,
    onUploadProgress: f,
    responseType: p,
    headers: y,
    withCredentials: w = "same-origin",
    fetchOptions: b
  } = qh(t);
  p = p ? (p + "").toLowerCase() : "text";
  let x = aw([s, o && o.toAbortSignal()], c), I;
  const z = x && x.unsubscribe && (() => {
    x.unsubscribe();
  });
  let S;
  try {
    if (f && hw && n !== "get" && n !== "head" && (S = await pw(y, r)) !== 0) {
      let ye = new Request(e, {
        method: "POST",
        body: r,
        duplex: "half"
      }), De;
      if (_.isFormData(r) && (De = ye.headers.get("content-type")) && y.setContentType(De), ye.body) {
        const [Re, Le] = Uc(
          S,
          yi(Cc(f))
        );
        r = kc(ye.body, Oc, Re, Le);
      }
    }
    _.isString(w) || (w = w ? "include" : "omit");
    const Z = "credentials" in Request.prototype;
    I = new Request(e, {
      ...b,
      signal: x,
      method: n.toUpperCase(),
      headers: y.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: Z ? w : void 0
    });
    let le = await fetch(I);
    const L = Wo && (p === "stream" || p === "response");
    if (Wo && (l || L && z)) {
      const ye = {};
      ["status", "statusText", "headers"].forEach((tt) => {
        ye[tt] = le[tt];
      });
      const De = _.toFiniteNumber(le.headers.get("content-length")), [Re, Le] = l && Uc(
        De,
        yi(Cc(l), !0)
      ) || [];
      le = new Response(
        kc(le.body, Oc, Re, () => {
          Le && Le(), z && z();
        }),
        ye
      );
    }
    p = p || "text";
    let ve = await wi[_.findKey(wi, p) || "text"](le, t);
    return !L && z && z(), await new Promise((ye, De) => {
      Vh(ye, De, {
        data: ve,
        headers: Tt.from(le.headers),
        status: le.status,
        statusText: le.statusText,
        config: t,
        request: I
      });
    });
  } catch (Z) {
    throw z && z(), Z && Z.name === "TypeError" && /fetch/i.test(Z.message) ? Object.assign(
      new xe("Network Error", xe.ERR_NETWORK, t, I),
      {
        cause: Z.cause || Z
      }
    ) : xe.from(Z, Z && Z.code, t, I);
  }
}), Qo = {
  http: U1,
  xhr: ow,
  fetch: gw
};
_.forEach(Qo, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
const Lc = (t) => `- ${t}`, yw = (t) => _.isFunction(t) || t === null || t === !1, $h = {
  getAdapter: (t) => {
    t = _.isArray(t) ? t : [t];
    const { length: e } = t;
    let n, r;
    const s = {};
    for (let o = 0; o < e; o++) {
      n = t[o];
      let c;
      if (r = n, !yw(n) && (r = Qo[(c = String(n)).toLowerCase()], r === void 0))
        throw new xe(`Unknown adapter '${c}'`);
      if (r)
        break;
      s[c || "#" + o] = r;
    }
    if (!r) {
      const o = Object.entries(s).map(
        ([l, f]) => `adapter ${l} ` + (f === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let c = e ? o.length > 1 ? `since :
` + o.map(Lc).join(`
`) : " " + Lc(o[0]) : "as no adapter specified";
      throw new xe(
        "There is no suitable adapter to dispatch the request " + c,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: Qo
};
function uo(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new Dr(null, t);
}
function jc(t) {
  return uo(t), t.headers = Tt.from(t.headers), t.data = co.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), $h.getAdapter(t.adapter || Cs.adapter)(t).then(function(r) {
    return uo(t), r.data = co.call(
      t,
      t.transformResponse,
      r
    ), r.headers = Tt.from(r.headers), r;
  }, function(r) {
    return Gh(r) || (uo(t), r && r.response && (r.response.data = co.call(
      t,
      t.transformResponse,
      r.response
    ), r.response.headers = Tt.from(r.response.headers))), Promise.reject(r);
  });
}
const ef = "1.7.9", Fi = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
  Fi[t] = function(r) {
    return typeof r === t || "a" + (e < 1 ? "n " : " ") + t;
  };
});
const Pc = {};
Fi.transitional = function(e, n, r) {
  function s(o, c) {
    return "[Axios v" + ef + "] Transitional option '" + o + "'" + c + (r ? ". " + r : "");
  }
  return (o, c, l) => {
    if (e === !1)
      throw new xe(
        s(c, " has been removed" + (n ? " in " + n : "")),
        xe.ERR_DEPRECATED
      );
    return n && !Pc[c] && (Pc[c] = !0, console.warn(
      s(
        c,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), e ? e(o, c, l) : !0;
  };
};
Fi.spelling = function(e) {
  return (n, r) => (console.warn(`${r} is likely a misspelling of ${e}`), !0);
};
function ww(t, e, n) {
  if (typeof t != "object")
    throw new xe("options must be an object", xe.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(t);
  let s = r.length;
  for (; s-- > 0; ) {
    const o = r[s], c = e[o];
    if (c) {
      const l = t[o], f = l === void 0 || c(l, o, t);
      if (f !== !0)
        throw new xe("option " + o + " must be " + f, xe.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new xe("Unknown option " + o, xe.ERR_BAD_OPTION);
  }
}
const Js = {
  assertOptions: ww,
  validators: Fi
}, Kt = Js.validators;
let Rn = class {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new Sc(),
      response: new Sc()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, n) {
    try {
      return await this._request(e, n);
    } catch (r) {
      if (r instanceof Error) {
        let s = {};
        Error.captureStackTrace ? Error.captureStackTrace(s) : s = new Error();
        const o = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? o && !String(r.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + o) : r.stack = o;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(e, n) {
    typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = Yn(this.defaults, n);
    const { transitional: r, paramsSerializer: s, headers: o } = n;
    r !== void 0 && Js.assertOptions(r, {
      silentJSONParsing: Kt.transitional(Kt.boolean),
      forcedJSONParsing: Kt.transitional(Kt.boolean),
      clarifyTimeoutError: Kt.transitional(Kt.boolean)
    }, !1), s != null && (_.isFunction(s) ? n.paramsSerializer = {
      serialize: s
    } : Js.assertOptions(s, {
      encode: Kt.function,
      serialize: Kt.function
    }, !0)), Js.assertOptions(n, {
      baseUrl: Kt.spelling("baseURL"),
      withXsrfToken: Kt.spelling("withXSRFToken")
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let c = o && _.merge(
      o.common,
      o[n.method]
    );
    o && _.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (I) => {
        delete o[I];
      }
    ), n.headers = Tt.concat(c, o);
    const l = [];
    let f = !0;
    this.interceptors.request.forEach(function(z) {
      typeof z.runWhen == "function" && z.runWhen(n) === !1 || (f = f && z.synchronous, l.unshift(z.fulfilled, z.rejected));
    });
    const p = [];
    this.interceptors.response.forEach(function(z) {
      p.push(z.fulfilled, z.rejected);
    });
    let y, w = 0, b;
    if (!f) {
      const I = [jc.bind(this), void 0];
      for (I.unshift.apply(I, l), I.push.apply(I, p), b = I.length, y = Promise.resolve(n); w < b; )
        y = y.then(I[w++], I[w++]);
      return y;
    }
    b = l.length;
    let x = n;
    for (w = 0; w < b; ) {
      const I = l[w++], z = l[w++];
      try {
        x = I(x);
      } catch (S) {
        z.call(this, S);
        break;
      }
    }
    try {
      y = jc.call(this, x);
    } catch (I) {
      return Promise.reject(I);
    }
    for (w = 0, b = p.length; w < b; )
      y = y.then(p[w++], p[w++]);
    return y;
  }
  getUri(e) {
    e = Yn(this.defaults, e);
    const n = Zh(e.baseURL, e.url);
    return Kh(n, e.params, e.paramsSerializer);
  }
};
_.forEach(["delete", "get", "head", "options"], function(e) {
  Rn.prototype[e] = function(n, r) {
    return this.request(Yn(r || {}, {
      method: e,
      url: n,
      data: (r || {}).data
    }));
  };
});
_.forEach(["post", "put", "patch"], function(e) {
  function n(r) {
    return function(o, c, l) {
      return this.request(Yn(l || {}, {
        method: e,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o,
        data: c
      }));
    };
  }
  Rn.prototype[e] = n(), Rn.prototype[e + "Form"] = n(!0);
});
let Aw = class tf {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(o) {
      n = o;
    });
    const r = this;
    this.promise.then((s) => {
      if (!r._listeners) return;
      let o = r._listeners.length;
      for (; o-- > 0; )
        r._listeners[o](s);
      r._listeners = null;
    }), this.promise.then = (s) => {
      let o;
      const c = new Promise((l) => {
        r.subscribe(l), o = l;
      }).then(s);
      return c.cancel = function() {
        r.unsubscribe(o);
      }, c;
    }, e(function(o, c, l) {
      r.reason || (r.reason = new Dr(o, c, l), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(e);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), n = (r) => {
      e.abort(r);
    };
    return this.subscribe(n), e.signal.unsubscribe = () => this.unsubscribe(n), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new tf(function(s) {
        e = s;
      }),
      cancel: e
    };
  }
};
function mw(t) {
  return function(n) {
    return t.apply(null, n);
  };
}
function vw(t) {
  return _.isObject(t) && t.isAxiosError === !0;
}
const Ko = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Ko).forEach(([t, e]) => {
  Ko[e] = t;
});
function nf(t) {
  const e = new Rn(t), n = zh(Rn.prototype.request, e);
  return _.extend(n, Rn.prototype, e, { allOwnKeys: !0 }), _.extend(n, e, null, { allOwnKeys: !0 }), n.create = function(s) {
    return nf(Yn(t, s));
  }, n;
}
const et = nf(Cs);
et.Axios = Rn;
et.CanceledError = Dr;
et.CancelToken = Aw;
et.isCancel = Gh;
et.VERSION = ef;
et.toFormData = Bi;
et.AxiosError = xe;
et.Cancel = et.CanceledError;
et.all = function(e) {
  return Promise.all(e);
};
et.spread = mw;
et.isAxiosError = vw;
et.mergeConfig = Yn;
et.AxiosHeaders = Tt;
et.formToJSON = (t) => Yh(_.isHTMLForm(t) ? new FormData(t) : t);
et.getAdapter = $h.getAdapter;
et.HttpStatusCode = Ko;
et.default = et;
const {
  Axios: Rm,
  AxiosError: Ew,
  CanceledError: Fm,
  isCancel: Wm,
  CancelToken: Qm,
  VERSION: Km,
  all: Hm,
  Cancel: Ym,
  isAxiosError: _c,
  spread: Gm,
  toFormData: Vm,
  AxiosHeaders: Zm,
  HttpStatusCode: qm,
  formToJSON: Xm,
  getAdapter: Jm,
  mergeConfig: $m
} = et;
var rf = "https://aptosconnect.app";
function Ho(t) {
  if (t == null)
    return t;
  if (Array.isArray(t))
    return t.map((e) => Ho(e));
  if (typeof t == "string" || typeof t == "number" || typeof t == "boolean" || t instanceof Uint8Array)
    return t;
  if (typeof t == "bigint")
    return t.toString();
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if ("values" in t)
    return t.values.map((e) => Ho(e));
  if ("data" in t)
    return $e.from(t.data).toString();
  if (t.value !== void 0) {
    if (typeof t.value == "string" || typeof t.value == "number" || typeof t.value == "boolean" || t.value instanceof Uint8Array)
      return t.value;
    if (typeof t.value == "bigint")
      return t.value.toString();
    throw new Error("Unexpected argument");
  }
}
function Bc(t, e) {
  if ("bcsToBytes" in t)
    return t;
  if ("bytecode" in t)
    return cs(t);
  if (e)
    return t.abi !== void 0 ? Qf({ ...t, abi: t.abi }) : cs({ aptosConfig: e, ...t });
  const n = {
    arguments: t.functionArguments.map(Ho),
    function: t.function,
    type: "entry_function_payload",
    type_arguments: (t.typeArguments ?? []).map((r) => r.toString())
  };
  return "multisigAddress" in t ? {
    multisig_address: $e.from(t.multisigAddress).toString(),
    transaction_payload: n,
    type: "multisig_payload"
  } : n;
}
var bw = class sf extends Error {
  constructor(e) {
    super(e), this.name = "SignatureRequestError", Object.setPrototypeOf(this, sf.prototype);
  }
}, of = class af extends Error {
  constructor(e) {
    const n = `Missing the following fields: ${e.join(", ")}`;
    super(n), this.name = "UnexpectedSignatureResponseError", Object.setPrototypeOf(this, af.prototype);
  }
}, Tw = class cf extends Error {
  constructor() {
    super(), this.name = "PairingExpiredError", Object.setPrototypeOf(this, cf.prototype);
  }
}, Rc = "icDappPairings", Iw = {
  async get(t) {
    return (await this.getAll())[t];
  },
  async getAll() {
    const t = window.localStorage.getItem(Rc);
    return t ? JSON.parse(t) : {};
  },
  async update(t, e) {
    const n = await this.getAll();
    e === void 0 ? delete n[t] : n[t] = e;
    const r = JSON.stringify(n);
    window.localStorage.setItem(Rc, r);
  }
}, Mw = [
  "address",
  "application",
  "chainId",
  "fullMessage",
  "message",
  "nonce",
  "prefix",
  "signature"
];
function Nw(t) {
  const e = new Set(Object.keys(t)), n = Mw.filter((r) => !e.has(r));
  if (n.length > 0)
    throw new of(n);
}
var xw = ["hash"];
function Sw(t) {
  const e = new Set(Object.keys(t)), n = xw.filter(
    (r) => !e.has(r)
  );
  if (n.length > 0)
    throw new of(n);
}
var Dw = "0.2.0", Uw = 2500, Cw = /^Sequence number mismatch, expected (?:\S+ to be )?(\d+)/;
async function zw(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
async function kw(t, e, n = 1) {
  for (let r = 0; r < n; r += 1)
    try {
      return await t();
    } catch (s) {
      e(s);
    }
  return t();
}
var Ow = class {
  constructor({
    accessors: t = Iw,
    axiosConfig: e,
    defaultNetworkName: n = Ba.MAINNET
  } = {}) {
    this.onDisconnectListeners = /* @__PURE__ */ new Set(), this.accessors = t, this.defaultNetworkName = n, this.axiosInstance = et.create({
      baseURL: rf,
      ...e
    });
    const r = typeof window < "u";
    this.initPromise = r ? this.syncFirstPairing() : void 0;
  }
  async getPairing(t) {
    return (await this.axiosInstance.get(`v1/pairing/${t}/`)).data.data.pairing;
  }
  async syncFirstPairing() {
    const t = await this.accessors.getAll(), e = Object.values(t)[0];
    if (e !== void 0)
      try {
        const { dappSpecificWallet: n, maxDappSequenceNumber: r } = await this.getPairing(e.pairingId);
        await this.accessors.update(e.accountAddress, {
          ...e,
          currSequenceNumber: r,
          dappWalletId: n == null ? void 0 : n.id
        });
      } catch {
        await this.accessors.update(e.accountAddress, void 0);
      }
  }
  async createSigningRequest(t, e, n, r) {
    const s = ht(t.dappEd25519SecretKeyB64), o = ht(t.dappEd25519PublicKeyB64), c = ht(t.accountTransportEd25519PublicKeyB64);
    let l = t.currSequenceNumber + 1;
    return kw(
      async () => {
        const f = await ro(
          ct(s, _t.Ed25519SecretKey),
          ct(o, _t.Ed25519PublicKey),
          ct(c, _t.Ed25519PublicKey),
          l,
          { apiVersion: Dw, networkName: n, requestType: e },
          r
        ), p = await this.axiosInstance.post(
          `v1/pairing/${t.pairingId}/signing-request/`,
          f
        );
        return await this.accessors.update(t.accountAddress, {
          ...t,
          currSequenceNumber: l
        }), p.data.data.signingRequest;
      },
      (f) => {
        var p, y, w;
        if (_c(f)) {
          const b = (y = (p = f.response) == null ? void 0 : p.data) == null ? void 0 : y.message, x = (w = b == null ? void 0 : b.match(Cw)) == null ? void 0 : w[1];
          if (x !== void 0) {
            l = Number(x);
            return;
          }
        }
        throw f;
      }
    );
  }
  async getSigningRequest(t) {
    var n, r;
    return (r = (n = (await this.axiosInstance.get(
      `v1/signing-request/${t}/`,
      {
        validateStatus: (s) => s === 200 || s === 404
      }
    )).data) == null ? void 0 : n.data) == null ? void 0 : r.signingRequest;
  }
  async deletePairing(t, e, n) {
    const r = await ro(
      e,
      n,
      n,
      0,
      // ignored
      {},
      {}
    );
    await this.axiosInstance.post(
      `v1/pairing/${t}/delete/`,
      r,
      { validateStatus: (s) => s === 204 || s === 404 }
    );
  }
  async cancelSigningRequest(t, e) {
    const n = t.currSequenceNumber, r = ht(t.dappEd25519SecretKeyB64), s = ht(t.dappEd25519PublicKeyB64), o = ht(t.accountTransportEd25519PublicKeyB64), c = await ro(
      ct(r, _t.Ed25519SecretKey),
      ct(s, _t.Ed25519PublicKey),
      ct(o, _t.Ed25519PublicKey),
      n + 1,
      {},
      {}
    ), l = await this.axiosInstance.patch(
      `v1/signing-request/${e}/cancel/`,
      c
    );
    return await this.accessors.update(t.accountAddress, {
      ...t,
      currSequenceNumber: n + 1
    }), l.data.data.signingRequest;
  }
  async signRequest(t, e, n, { cancelToken: r, networkName: s } = {}) {
    await this.initPromise;
    const o = await this.accessors.get(t);
    if (o === void 0)
      throw new Error("The requested account is not paired");
    let c;
    try {
      for (c = await this.createSigningRequest(
        o,
        e,
        s || this.defaultNetworkName,
        n
      ); c.status === "PENDING"; ) {
        if (await zw(Uw), r != null && r.cancelled) {
          c.status = Nh.CANCELLED;
          break;
        }
        c = await this.getSigningRequest(c.id) ?? c;
      }
    } catch (f) {
      if (_c(f) && f.code === "404") {
        await this.accessors.update(t, void 0);
        for (const p of this.onDisconnectListeners)
          p(t);
        throw new Tw();
      }
      throw f;
    }
    if (c.status !== "APPROVED")
      throw new bw(c.status);
    return q5(
      ct(ht(o.accountTransportEd25519PublicKeyB64), _t.Ed25519PublicKey),
      ct(ht(o.dappEd25519SecretKeyB64), _t.Ed25519SecretKey),
      c.responseEnvelope
    ).privateMessage;
  }
  // region Public API
  /**
   * Requests a connection to an account (internally known as pairing).
   * @returns either the address of the connected account, or undefined if the
   * connection was cancelled.
   */
  async addPairing({ publicKey: t, secretKey: e }, n) {
    await this.accessors.update(n.account.accountAddress, {
      accountAddress: n.account.accountAddress,
      accountAlias: n.account.userSubmittedAlias ?? void 0,
      accountPublicKeyB64: n.account.publicKeyB64,
      accountTransportEd25519PublicKeyB64: n.account.transportEd25519PublicKeyB64,
      currSequenceNumber: n.maxDappSequenceNumber,
      dappEd25519PublicKeyB64: sn(t.key),
      dappEd25519SecretKeyB64: sn(e.key),
      dappWalletId: n.dappSpecificWalletId,
      pairingId: n.id
    });
  }
  async disconnect(t) {
    const e = await this.accessors.get(t);
    if (e === void 0)
      throw new Error("The specified account is not paired");
    const n = ht(e.dappEd25519SecretKeyB64), r = ht(e.dappEd25519PublicKeyB64);
    await this.deletePairing(
      e.pairingId,
      ct(n, _t.Ed25519SecretKey),
      ct(r, _t.Ed25519PublicKey)
    ), await this.accessors.update(t, void 0);
    for (const s of this.onDisconnectListeners)
      s(t);
  }
  async signMessage(t, e, n) {
    const r = await this.signRequest(
      t,
      Zs.SIGN_MESSAGE,
      e,
      n
    );
    return Nw(r), r;
  }
  async signTransaction(t, e, n) {
    const r = Qy(e), s = await this.signRequest(t, Zs.SIGN_TRANSACTION, r, n);
    return Ky(s);
  }
  // endregion
  async signAndSubmitTransaction(t, e, n) {
    var s, o, c, l;
    const r = Wy(e);
    try {
      const f = await this.signRequest(t, Zs.SIGN_AND_SUBMIT_TRANSACTION, r, n);
      return Sw(f), f;
    } catch (f) {
      throw f instanceof Ew && ((o = (s = f.response) == null ? void 0 : s.data) != null && o.message) ? new Error((l = (c = f.response) == null ? void 0 : c.data) == null ? void 0 : l.message) : f;
    }
  }
  async getConnectedAccounts() {
    await this.initPromise;
    const t = await this.accessors.getAll();
    return Object.values(t).map(
      ({ accountAddress: e, accountEd25519PublicKeyB64: n, accountPublicKeyB64: r }) => ({
        address: $e.from(e),
        publicKey: r !== void 0 ? mh(r) : J5(n)
      })
    );
  }
  onDisconnect(t) {
    return this.onDisconnectListeners.add(t), () => this.onDisconnectListeners.delete(t);
  }
}, Lw = class {
  constructor({
    backendBaseURL: t,
    dappId: e,
    dappImageURI: n,
    dappName: r,
    defaultNetworkName: s = Ba.MAINNET,
    frontendBaseURL: o = rf,
    provider: c = "google",
    tgWebAppURL: l
  } = {}) {
    this.defaultNetworkName = s, this.dappInfo = {
      domain: window.location.origin,
      imageURI: n,
      name: r ?? document.title
    }, this.transport = new Ry(o, c, l), this.dappId = e, this.pairingClient = new Ow({
      axiosConfig: {
        baseURL: t ?? o
      },
      defaultNetworkName: s
    });
  }
  // region Public API
  async getKeylessAccounts() {
    const t = di.serialize(this.dappInfo), e = await this.transport.sendRequest(t);
    return hi.deserialize(e).args;
  }
  async getIcAccounts() {
    return this.pairingClient.getConnectedAccounts() ?? [];
  }
  async isIcAccount(t) {
    return (await this.getIcAccounts()).find((n) => n.address.equals($e.from(t))) !== void 0;
  }
  async getConnectedAccounts() {
    const t = await this.getKeylessAccounts(), e = await this.getIcAccounts();
    return [...t, ...e];
  }
  async disconnect(t) {
    if (await this.isIcAccount(t)) {
      const e = $e.from(t).toString();
      await this.pairingClient.disconnect(e);
    } else {
      const e = li.serialize(this.dappInfo);
      await this.transport.sendRequest(e);
    }
  }
  async connect({
    claimOptions: t,
    preferredWalletName: e
  } = {}) {
    const n = D5(), r = typeof window < "u" ? window.AC_PREFERRED_WALLET_NAME : void 0, s = {
      claimOptions: t,
      dappEd25519PublicKeyB64: sn(n.publicKey.key),
      dappId: this.dappId,
      preferredWalletName: e ?? r
    }, o = ui.serialize(this.dappInfo, s), c = await this.transport.sendRequest(o), l = gs.deserialize(c);
    if (l.args.status === "approved") {
      const { account: f, pairing: p } = l.args.args;
      return p && await this.pairingClient.addPairing(n, p), Ls({ account: f });
    }
    return l.args;
  }
  async signMessage(t) {
    const { signerAddress: e } = t;
    if (await this.isIcAccount(e)) {
      const { chainId: o } = t, c = Xd(o);
      let l, f;
      try {
        l = new TextDecoder().decode(t.message), f = new TextDecoder().decode(t.nonce);
      } catch {
        throw new Error("Only UTF-8 encoded text is supported when using IC");
      }
      const { fullMessage: p, signature: y } = await this.pairingClient.signMessage(
        e.toString(),
        {
          address: !0,
          application: !0,
          chainId: !0,
          message: l,
          nonce: f
        },
        { networkName: c }
      ), w = on.fromHexInput(y).toUint8Array(), b = w.length === gr.LENGTH ? new gr(w) : Ai.deserialize(new un(w));
      return Ls({
        fullMessage: p,
        signature: b
      });
    }
    const n = pi.serialize(this.dappInfo, t), r = await this.transport.sendRequest(n);
    return Lo.deserialize(r).args;
  }
  async signTransaction(t) {
    const e = "transaction" in t ? ys.normalizeArgs(t) : t, { signerAddress: n } = t;
    if (await this.isIcAccount(n)) {
      const {
        expirationSecondsFromNow: c,
        expirationTimestamp: l,
        feePayer: f,
        gasUnitPrice: p,
        maxGasAmount: y,
        network: w,
        payload: b,
        secondarySigners: x,
        sender: I,
        sequenceNumber: z
      } = e;
      if (f !== void 0)
        throw new Error("Sponsored transaction not currently supported");
      if (x && x.length > 0)
        throw new Error("Multi-agent transactions not currently supported");
      if (!("bcsToBytes" in b))
        throw new Error("Payload input format is only supported with Keyless accounts.");
      const S = await this.pairingClient.signTransaction(
        n.toString(),
        {
          options: {
            expirationSecondsFromNow: c,
            expirationTimestamp: l,
            gasUnitPrice: p,
            maxGasAmount: y,
            sender: I == null ? void 0 : I.address.toString(),
            sequenceNumber: z !== void 0 ? Number(z) : void 0
          },
          payload: b
        },
        {
          networkName: w
        }
      );
      return Ls({
        authenticator: S.accountAuthenticator,
        rawTransaction: S.rawTxn
      });
    }
    const r = ys.serialize(this.dappInfo, e), s = await this.transport.sendRequest(r);
    return jo.deserialize(s).args;
  }
  async signAndSubmitTransaction(t) {
    const { signerAddress: e } = t;
    if (await this.isIcAccount(e)) {
      const { expirationTimestamp: o, feePayer: c, gasUnitPrice: l, maxGasAmount: f, network: p } = t, y = new cr({ network: p });
      let w;
      if (c !== void 0) {
        const x = await Bc(t.payload, y), I = await xu({
          aptosConfig: y,
          feePayerAddress: c.address,
          options: {
            gasUnitPrice: l,
            maxGasAmount: f
          },
          payload: x,
          sender: e
        });
        w = {
          feePayerAuthenticator: c.authenticator,
          rawTxn: new Wf(I, [], c.address)
        };
      } else {
        const x = Bc(t.payload);
        w = {
          options: {
            expirationTimestamp: o,
            gasUnitPrice: l,
            maxGasAmount: f
          },
          payload: x
        };
      }
      const { hash: b } = await this.pairingClient.signAndSubmitTransaction(e.toString(), w, {
        networkName: p
      });
      return Ls({ txnHash: b });
    }
    const n = fi.serialize(this.dappInfo, t), r = await this.transport.sendRequest(n);
    return Oo.deserialize(r).args;
  }
  // endregion
}, uf = (t, e, n) => {
  if (!e.has(t))
    throw TypeError("Cannot " + n);
}, $n = (t, e, n) => (uf(t, e, "read from private field"), n ? n.call(t) : e.get(t)), Fc = (t, e, n) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, n);
}, Wc = (t, e, n, r) => (uf(t, e, "write to private field"), e.set(t, n), n), $s, yn, jw = class {
  constructor({ address: t, ansName: e, publicKey: n }) {
    this.chains = Yd, this.features = [], Fc(this, $s, void 0), Fc(this, yn, void 0), Wc(this, yn, n), Wc(this, $s, t), this.label = e;
  }
  get address() {
    return $n(this, $s).toString();
  }
  get publicKey() {
    return $n(this, yn).toUint8Array();
  }
  get signingScheme() {
    if ($n(this, yn) instanceof mn)
      return Ke.Ed25519;
    if ($n(this, yn) instanceof pr)
      return Ke.MultiEd25519;
    if ($n(this, yn) instanceof Fn)
      return Ke.SingleKey;
    if ($n(this, yn) instanceof as)
      return Ke.MultiKey;
    throw new Error("Unsupported public key type");
  }
  // endregion
};
$s = /* @__PURE__ */ new WeakMap();
yn = /* @__PURE__ */ new WeakMap();
function Qc({ address: t, name: e, publicKey: n }) {
  return new Kd({
    address: t,
    ansName: e,
    publicKey: n
  });
}
function Kc(t, e) {
  return t.status === "dismissed" ? { status: ot.REJECTED } : { args: e(t.args), status: ot.APPROVED };
}
function Pw(t) {
  switch (t) {
    case Ye.MAINNET:
      return ar.mainnet;
    case Ye.TESTNET:
      return ar.testnet;
    default:
      return ar.devnet;
  }
}
var lf = class xt {
  constructor({
    claimSecretKey: e,
    network: n = Ye.MAINNET,
    preferredWalletName: r,
    ...s
  }) {
    if (this.version = "1.0.0", this.chains = Yd, this.client = new Lw(s), !mo[n])
      throw new Error("Network not supported");
    const o = new cr({ network: n });
    this.aptosClient = new is(o), this.preferredWalletName = r, this.claimOptions = e ? { network: n, secretKey: new ii(e) } : void 0;
  }
  static get connectedAccount() {
    const e = localStorage.getItem(xt.connectedAccountStorageKey);
    if (e)
      try {
        const { address: n, publicKey: r } = JSON.parse(e);
        return new Kd({
          address: $e.from(n),
          publicKey: mh(r)
        });
      } catch {
        console.warn("Inconsistent state, resetting it"), this.connectedAccount = void 0;
        return;
      }
  }
  static set connectedAccount(e) {
    if (e !== void 0) {
      const n = {
        address: e.address.toString(),
        publicKey: X5(e.publicKey)
      };
      localStorage.setItem(xt.connectedAccountStorageKey, JSON.stringify(n));
    } else
      localStorage.removeItem(xt.connectedAccountStorageKey);
  }
  // eslint-disable-next-line class-methods-use-this
  get accounts() {
    const { connectedAccount: e } = xt;
    return e ? [new jw(e)] : [];
  }
  async connect() {
    const { connectedAccount: e } = xt;
    if (e !== void 0)
      return { args: e, status: ot.APPROVED };
    const n = await this.client.connect({
      claimOptions: this.claimOptions,
      preferredWalletName: this.preferredWalletName
    });
    if (n.status === "dismissed")
      return { status: ot.REJECTED };
    const r = Qc(n.args.account);
    return xt.connectedAccount = r, {
      args: r,
      status: ot.APPROVED
    };
  }
  async disconnect() {
    const { connectedAccount: e } = xt;
    e && (await this.client.disconnect(e.address), xt.connectedAccount = void 0);
  }
  // eslint-disable-next-line class-methods-use-this
  async getAccount() {
    const { connectedAccount: e } = xt;
    if (!e)
      throw new Os(es.Unauthorized);
    return Qc(e);
  }
  async getNetwork() {
    const { network: e } = this.aptosClient.config, n = await this.aptosClient.getChainId(), r = mo[e];
    return {
      chainId: n,
      name: e,
      url: r
    };
  }
  async signMessage(e) {
    const { connectedAccount: n } = xt;
    if (!n)
      throw new Os(es.Unauthorized);
    const r = Pw(this.aptosClient.config.network), { message: s, nonce: o } = e, c = new TextEncoder(), l = c.encode(s), f = c.encode(o), p = await this.client.signMessage({
      chainId: r,
      message: l,
      nonce: f,
      signerAddress: n.address
    });
    if (p.status === "dismissed")
      return { status: ot.REJECTED };
    const { fullMessage: y, signature: w } = p.args, b = {
      address: n.address.toString(),
      application: this.client.dappInfo.domain,
      chainId: r,
      message: s,
      nonce: o,
      prefix: "APTOS"
    };
    return {
      args: {
        fullMessage: y,
        signature: w,
        ...b
      },
      status: ot.APPROVED
    };
  }
  async signTransaction(e, n) {
    var c;
    const { connectedAccount: r } = xt;
    if (!r)
      throw new Os(es.Unauthorized);
    if ("bcsToBytes" in e) {
      const l = e, f = l.feePayerAddress ? { address: l.feePayerAddress } : void 0, p = (c = l.secondarySignerAddresses) == null ? void 0 : c.map((w) => ({ address: w })), y = await this.client.signTransaction({
        feePayer: f,
        secondarySigners: p,
        signerAddress: r.address,
        transaction: l.rawTransaction
      });
      return Kc(y, (w) => w.authenticator);
    }
    const s = e, o = await this.client.signTransaction({
      ...s,
      signerAddress: r.address
    });
    return Kc(o, (l) => {
      var b, x;
      const { authenticator: f, rawTransaction: p } = l;
      if (!p)
        throw new Error("Expected raw transaction in response args");
      const y = s.secondarySigners ?? [];
      let w;
      return y.length > 0 ? w = new Kf(
        p,
        y.map((I) => I.address),
        (b = s.feePayer) == null ? void 0 : b.address
      ) : w = new Su(p, (x = s.feePayer) == null ? void 0 : x.address), {
        authenticator: f,
        rawTransaction: w
      };
    });
  }
  async signAndSubmitTransaction(e) {
    const { gasUnitPrice: n, maxGasAmount: r, payload: s } = e, { connectedAccount: o } = xt;
    if (!o)
      throw new Os(es.Unauthorized);
    const c = await this.client.signAndSubmitTransaction({
      gasUnitPrice: n,
      maxGasAmount: r,
      network: this.aptosClient.config.network,
      payload: s,
      signerAddress: o.address
    });
    return c.status === "dismissed" ? { status: ot.REJECTED } : {
      args: { hash: c.args.txnHash },
      status: ot.APPROVED
    };
  }
  // eslint-disable-next-line class-methods-use-this
  async onAccountChange(e) {
  }
  // eslint-disable-next-line class-methods-use-this
  async onNetworkChange(e) {
  }
  // endregion
};
lf.connectedAccountStorageKey = "@aptos-connect/connectedAccount";
var df = lf, dr = {
  apple: {
    icon: (
      // eslint-disable-next-line max-len
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxzdHlsZT4KICAgICAgICBwYXRoIHsKICAgICAgICAgICAgZmlsbDogYmxhY2s7CiAgICAgICAgfQoKICAgICAgICBAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7CiAgICAgICAgICAgIHBhdGggewogICAgICAgICAgICAgICAgZmlsbDogd2hpdGU7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICA8L3N0eWxlPgogICAgPHBhdGgKICAgICAgICBkPSJNMjAuMzkzMiA4LjE4MjQyQzIwLjI1NzggOC4yOTA0MyAxNy44NjggOS42NzUzNyAxNy44NjggMTIuNzU0OUMxNy44NjggMTYuMzE2OCAyMC45MDkgMTcuNTc3IDIxIDE3LjYwODJDMjAuOTg2IDE3LjY4NSAyMC41MTY5IDE5LjMzMzkgMTkuMzk2NiAyMS4wMTQxQzE4LjM5NzcgMjIuNDkyNiAxNy4zNTQ1IDIzLjk2ODggMTUuNzY3NSAyMy45Njg4QzE0LjE4MDQgMjMuOTY4OCAxMy43NzIgMjMuMDIwNyAxMS45Mzk5IDIzLjAyMDdDMTAuMTU0NSAyMy4wMjA3IDkuNTE5NzIgMjQgOC4wNjgwNSAyNEM2LjYxNjM5IDI0IDUuNjAzNDkgMjIuNjMxOSA0LjQzODg5IDIwLjk1MTdDMy4wODk5MiAxOC45Nzg3IDIgMTUuOTEzNiAyIDEzLjAwNDVDMiA4LjMzODQzIDQuOTUwMDEgNS44NjM3OSA3Ljg1MzM0IDUuODYzNzlDOS4zOTYwMiA1Ljg2Mzc5IDEwLjY4MiA2LjkwNTQ5IDExLjY1MDUgNi45MDU0OUMxMi41NzI0IDYuOTA1NDkgMTQuMDEwMSA1LjgwMTM4IDE1Ljc2NTEgNS44MDEzOEMxNi40MzAzIDUuODAxMzggMTguODIwMiA1Ljg2Mzc5IDIwLjM5MzIgOC4xODI0MlpNMTQuOTMxOSAzLjgyNTk4QzE1LjY1NzggMi45NDAyOSAxNi4xNzEyIDEuNzExMzcgMTYuMTcxMiAwLjQ4MjQ0OEMxNi4xNzEyIDAuMzEyMDMxIDE2LjE1NzIgMC4xMzkyMTQgMTYuMTI2OSAwQzE0Ljk0NiAwLjA0NTYwNDYgMTMuNTQxIDAuODA4ODgxIDEyLjY5MzggMS44MTkzOEMxMi4wMjg2IDIuNTk3MDYgMTEuNDA3OCAzLjgyNTk4IDExLjQwNzggNS4wNzE3MUMxMS40MDc4IDUuMjU4OTMgMTEuNDM4MiA1LjQ0NjE0IDExLjQ1MjIgNS41MDYxNUMxMS41MjY4IDUuNTIwNTUgMTEuNjQ4MiA1LjUzNzM1IDExLjc2OTYgNS41MzczNUMxMi44MjkxIDUuNTM3MzUgMTQuMTYxOCA0LjgwNzY4IDE0LjkzMTkgMy44MjU5OFoiIC8+Cjwvc3ZnPg=="
    ),
    name: "Continue with Apple",
    url: "https://aptosconnect.app"
  },
  google: {
    icon: (
      // eslint-disable-next-line max-len
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBjbGFzcz0iaF8yMCB3XzIwIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIzLjU0IDEyLjc2MTNDMjMuNTQgMTEuOTQ1OSAyMy40NjY4IDExLjE2MTggMjMuMzMwOSAxMC40MDkxSDEyLjVWMTQuODU3NUgxOC42ODkxQzE4LjQyMjUgMTYuMjk1IDE3LjYxMjMgMTcuNTEyOSAxNi4zOTQzIDE4LjMyODRWMjEuMjEzOEgyMC4xMTA5QzIyLjI4NTUgMTkuMjExOCAyMy41NCAxNi4yNjM2IDIzLjU0IDEyLjc2MTNaIiBmaWxsPSIjNDI4NUY0Ij48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMi40OTk1IDIzLjk5OThDMTUuNjA0NSAyMy45OTk4IDE4LjIwNzcgMjIuOTcgMjAuMTEwNCAyMS4yMTM3TDE2LjM5MzggMTguMzI4MkMxNS4zNjQgMTkuMDE4MiAxNC4wNDY3IDE5LjQyNTkgMTIuNDk5NSAxOS40MjU5QzkuNTA0MjUgMTkuNDI1OSA2Ljk2OTAyIDE3LjQwMyA2LjA2NDcgMTQuNjg0OEgyLjIyMjY2VjE3LjY2NDRDNC4xMTQ5MyAyMS40MjI4IDguMDA0MDIgMjMuOTk5OCAxMi40OTk1IDIzLjk5OThaIiBmaWxsPSIjMzRBODUzIj48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA2NTIzIDE0LjY4NTFDNS44MzUyMyAxMy45OTUxIDUuNzA0NTUgMTMuMjU4MSA1LjcwNDU1IDEyLjUwMDFDNS43MDQ1NSAxMS43NDIyIDUuODM1MjMgMTEuMDA1MSA2LjA2NTIzIDEwLjMxNTFWNy4zMzU1N0gyLjIyMzE4QzEuNDQ0MzIgOC44ODgwNyAxIDEwLjY0NDQgMSAxMi41MDAxQzEgMTQuMzU1OCAxLjQ0NDMyIDE2LjExMjIgMi4yMjMxOCAxNy42NjQ3TDYuMDY1MjMgMTQuNjg1MVoiIGZpbGw9IiNGQkJDMDUiPjwvcGF0aD48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjQ5OTUgNS41NzM4NkMxNC4xODc5IDUuNTczODYgMTUuNzAzOCA2LjE1NDA5IDE2Ljg5NTYgNy4yOTM2NEwyMC4xOTQgMy45OTUyM0MxOC4yMDI0IDIuMTM5NTUgMTUuNTk5MiAxIDEyLjQ5OTUgMUM4LjAwNDAyIDEgNC4xMTQ5MyAzLjU3NzA1IDIuMjIyNjYgNy4zMzU0NUw2LjA2NDcgMTAuMzE1QzYuOTY5MDIgNy41OTY4MiA5LjUwNDI1IDUuNTczODYgMTIuNDk5NSA1LjU3Mzg2WiIgZmlsbD0iI0VBNDMzNSI+PC9wYXRoPjwvc3ZnPg=="
    ),
    name: "Continue with Google",
    url: "https://aptosconnect.app"
  }
}, _w = class extends df {
  constructor(t) {
    super({ ...t, provider: "google" }), this.name = dr.google.name, this.icon = dr.google.icon, this.url = dr.google.url;
  }
  // region AptosWallet
  get features() {
    return {
      [_d]: {
        connect: this.connect.bind(this),
        version: "1.0.0"
      },
      [Bd]: {
        disconnect: this.disconnect.bind(this),
        version: "1.0.0"
      },
      [Rd]: {
        account: this.getAccount.bind(this),
        version: "1.0.0"
      },
      [Fd]: {
        network: this.getNetwork.bind(this),
        version: "1.0.0"
      },
      [Wd]: {
        onAccountChange: this.onAccountChange.bind(this),
        version: "1.0.0"
      },
      [Qd]: {
        onNetworkChange: this.onNetworkChange.bind(this),
        version: "1.0.0"
      },
      [Ld]: {
        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),
        version: "1.1.0"
      },
      [jd]: {
        signMessage: this.signMessage.bind(this),
        version: "1.0.0"
      },
      [Pd]: {
        signTransaction: this.signTransaction.bind(this),
        version: "1.1"
      }
    };
  }
  // endregion
}, Bw = class extends df {
  constructor(t) {
    super({ ...t, provider: "apple" }), this.name = dr.apple.name, this.icon = dr.apple.icon, this.url = dr.apple.url;
  }
  // region AptosWallet
  get features() {
    return {
      [_d]: {
        connect: this.connect.bind(this),
        version: "1.0.0"
      },
      [Bd]: {
        disconnect: this.disconnect.bind(this),
        version: "1.0.0"
      },
      [Rd]: {
        account: this.getAccount.bind(this),
        version: "1.0.0"
      },
      [Fd]: {
        network: this.getNetwork.bind(this),
        version: "1.0.0"
      },
      [Wd]: {
        onAccountChange: this.onAccountChange.bind(this),
        version: "1.0.0"
      },
      [Qd]: {
        onNetworkChange: this.onNetworkChange.bind(this),
        version: "1.0.0"
      },
      [Ld]: {
        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),
        version: "1.1.0"
      },
      [jd]: {
        signMessage: this.signMessage.bind(this),
        version: "1.0.0"
      },
      [Pd]: {
        signTransaction: this.signTransaction.bind(this),
        version: "1.1"
      }
    };
  }
  // endregion
}, Rw = "aptos:devnet", Fw = "aptos:testnet", Ww = "aptos:localnet", Qw = "aptos:mainnet", Kw = [Rw, Fw, Ww, Qw], Hw = ((t) => (t[t.Unauthorized = 4100] = "Unauthorized", t[t.InternalError = -30001] = "InternalError", t))(Hw || {}), On = ((t) => (t.APPROVED = "Approved", t.REJECTED = "Rejected", t))(On || {});
class Qa {
  constructor(e = {}) {
    this.option = e, this.url = "https://www.twallet.ai", this.version = "1.0.0", this.name = "T wallet", this.icon = "data:image/png;base64,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", this.chains = Kw, this.accounts = [], this.provider = typeof window < "u" ? window.dekey : void 0, this.initializing = !1, this.account = async () => {
      var n;
      const r = await ((n = this.provider) == null ? void 0 : n.request({
        method: "aptos_account"
      }));
      return {
        address: r.address,
        publicKey: r.publicKey
      };
    }, this.connect = async () => {
      var n, r, s;
      if (!this.initializing) {
        this.initializing = !0, await import(
          // @ts-ignore
          "./index-DRmafxZ_-DRmafxZ_.mjs"
        );
        const c = Yw((n = this.option) == null ? void 0 : n.env);
        if (!c)
          throw this.initializing = !1, new Error(`walletDomain not found with env: ${(r = this.option) == null ? void 0 : r.env}`);
        if (!(window != null && window.initializeDekeyProvider))
          throw this.initializing = !1, new Error("initializeDekeyProvider not found");
        await window.initializeDekeyProvider(c), this.provider = window.dekey;
      }
      if (!await this.checkProvider())
        return {
          status: On.REJECTED
        };
      const o = await ((s = this.provider) == null ? void 0 : s.request({
        method: "aptos_requestAccounts"
      }));
      return o ? {
        status: On.APPROVED,
        args: {
          address: o.address,
          publicKey: o.publicKey
        }
      } : (await new Promise((c) => setTimeout(c, 2e3)), {
        status: On.REJECTED
      });
    }, this.checkProvider = async () => new Promise((n) => {
      setTimeout(() => {
        n(!1);
      }, 1e4);
      const r = setInterval(() => {
        this.provider && (n(!0), clearInterval(r));
      }, 100);
    }), this.network = async () => {
      const { chainId: n, name: r, url: s } = await this.provider.request({
        method: "aptos_network"
      });
      return {
        name: r,
        chainId: n,
        url: s
      };
    }, this.disconnect = async () => Promise.resolve(), this.signTransaction = async (n, r) => {
      try {
        const s = n.rawTransaction.bcsToBytes(), { concatedSig: o, uncompressedPubkey: c } = await this.provider.request({
          method: "aptos_signTransaction",
          params: [Array.from(s)]
        }), l = new Hf(c), f = new Yf(o), p = new Gf(
          new Fn(l),
          new Ai(f)
        );
        return Promise.resolve({
          status: On.APPROVED,
          args: p
        });
      } catch (s) {
        throw s.message;
      }
    }, this.signAndSubmitTransaction = async (n) => {
      const r = n.rawTransaction.bcsToBytes(), s = await this.provider.request({
        method: "aptos_signAndSubmitTransaction",
        params: [Array.from(r)]
      });
      return {
        status: On.APPROVED,
        args: s
      };
    }, this.signMessage = async (n) => {
      var r;
      try {
        const s = await ((r = this.provider) == null ? void 0 : r.request({
          method: "aptos_signMessage",
          params: [n.message]
        }));
        return {
          status: On.APPROVED,
          args: s
        };
      } catch (s) {
        throw s.message;
      }
    }, this.onAccountChange = async () => Promise.resolve(), this.onNetworkChange = async (n) => {
      const r = async () => {
        const s = await this.network(), { name: o, chainId: c, url: l } = s;
        n({
          name: o,
          chainId: c,
          url: l
        });
      };
      this.provider.on("chainChanged", () => {
        r();
      });
    }, !(e != null && e.env) && (e == null ? void 0 : e.registerWallet) === !0 && hf(this);
  }
  get features() {
    return {
      "aptos:connect": {
        version: "1.0.0",
        connect: this.connect
      },
      "aptos:network": {
        version: "1.0.0",
        network: this.network
      },
      "aptos:disconnect": {
        version: "1.0.0",
        disconnect: this.disconnect
      },
      "aptos:signTransaction": {
        version: "1.0.0",
        signTransaction: this.signTransaction
      },
      "aptos:signAndSubmitTransaction": {
        version: "1.0.0",
        signAndSubmitTransaction: this.signAndSubmitTransaction
      },
      "aptos:signMessage": {
        version: "1.0.0",
        signMessage: this.signMessage
      },
      "aptos:onAccountChange": {
        version: "1.0.0",
        onAccountChange: this.onAccountChange
      },
      "aptos:onNetworkChange": {
        version: "1.0.0",
        onNetworkChange: this.onNetworkChange
      },
      "aptos:account": {
        version: "1.0.0",
        account: this.account
      }
    };
  }
}
const Yw = (t) => t === "LOCAL" ? "http://localhost:5173" : t === "DEV" ? "https://dev.twallet.ai" : t === "QA" ? "https://qa.twallet.ai" : "https://www.twallet.ai", hf = (t) => {
  typeof window > "u" || Qp(t);
};
let Gw = class extends Qa {
  constructor(e = {}) {
    super({ ...e, env: "DEV" }), this.url = "https://dev.twallet.ai", this.name = "Dev T wallet", (e == null ? void 0 : e.registerWallet) === !0 && hf(this);
  }
};
class hr extends Error {
  constructor(n, r) {
    const s = `${hr.extractMessage(n)}: ${JSON.stringify({
      response: n,
      request: r
    })}`;
    super(s);
    Jn(this, "response");
    Jn(this, "request");
    Object.setPrototypeOf(this, hr.prototype), this.response = n, this.request = r, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, hr);
  }
  static extractMessage(n) {
    var r, s;
    return ((s = (r = n.errors) == null ? void 0 : r[0]) == null ? void 0 : s.message) ?? `GraphQL Error (Code: ${String(n.status)})`;
  }
}
const Hc = (t) => t.toUpperCase(), lo = (t) => typeof t == "function" ? t() : t, ff = (t, e) => t.map((n, r) => [n, e[r]]), er = (t) => {
  let e = {};
  return t instanceof Headers ? e = Vw(t) : Array.isArray(t) ? t.forEach(([n, r]) => {
    n && r !== void 0 && (e[n] = r);
  }) : t && (e = t), e;
}, Vw = (t) => {
  const e = {};
  return t.forEach((n, r) => {
    e[r] = n;
  }), e;
}, Zw = (t) => {
  try {
    const e = t();
    return qw(e) ? e.catch((n) => Yc(n)) : e;
  } catch (e) {
    return Yc(e);
  }
}, Yc = (t) => t instanceof Error ? t : new Error(String(t)), qw = (t) => typeof t == "object" && t !== null && "then" in t && typeof t.then == "function" && "catch" in t && typeof t.catch == "function" && "finally" in t && typeof t.finally == "function", Ka = (t) => {
  throw new Error(`Unhandled case: ${String(t)}`);
}, ei = (t) => typeof t == "object" && t !== null && !Array.isArray(t), Xw = (t, e) => t.documents ? t : {
  documents: t,
  requestHeaders: e,
  signal: void 0
}, Jw = (t, e, n) => t.query ? t : {
  query: t,
  variables: e,
  requestHeaders: n,
  signal: void 0
}, Gc = "Accept", Yo = "Content-Type", Go = "application/json", pf = "application/graphql-response+json", Vc = (t) => t.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim(), $w = (t) => {
  const e = t.toLowerCase();
  return e.includes(pf) || e.includes(Go);
}, Zc = (t) => {
  try {
    if (Array.isArray(t))
      return {
        _tag: "Batch",
        executionResults: t.map(qc)
      };
    if (ei(t))
      return {
        _tag: "Single",
        executionResult: qc(t)
      };
    throw new Error(`Invalid execution result: result is not object or array. 
Got:
${String(t)}`);
  } catch (e) {
    return e;
  }
}, qc = (t) => {
  if (typeof t != "object" || t === null)
    throw new Error("Invalid execution result: result is not object");
  let e, n, r;
  if ("errors" in t) {
    if (!ei(t.errors) && !Array.isArray(t.errors))
      throw new Error("Invalid execution result: errors is not plain object OR array");
    e = t.errors;
  }
  if ("data" in t) {
    if (!ei(t.data) && t.data !== null)
      throw new Error("Invalid execution result: data is not plain object");
    n = t.data;
  }
  if ("extensions" in t) {
    if (!ei(t.extensions))
      throw new Error("Invalid execution result: extensions is not plain object");
    r = t.extensions;
  }
  return {
    data: n,
    errors: e,
    extensions: r
  };
}, eA = (t) => t._tag === "Batch" ? t.executionResults.some(Xc) : Xc(t.executionResult), Xc = (t) => Array.isArray(t.errors) ? t.errors.length > 0 : !!t.errors, gf = (t) => typeof t == "object" && t !== null && "kind" in t && t.kind === be.OPERATION_DEFINITION, tA = (t) => {
  var r;
  let e;
  const n = t.definitions.filter(gf);
  return n.length === 1 && (e = (r = n[0].name) == null ? void 0 : r.value), e;
}, nA = (t) => {
  let e = !1;
  const n = t.definitions.filter(gf);
  return n.length === 1 && (e = n[0].operation === jn.MUTATION), e;
}, ho = (t, e) => {
  const n = typeof t == "string" ? t : _p(t);
  let r = !1, s;
  if (e)
    return { expression: n, isMutation: r, operationName: s };
  const o = Zw(() => typeof t == "string" ? Dp(t) : t);
  return o instanceof Error ? { expression: n, isMutation: r, operationName: s } : (s = tA(o), r = nA(o), { expression: n, operationName: s, isMutation: r });
}, Ha = JSON, fo = async (t) => {
  const e = {
    ...t,
    method: t.request._tag === "Single" ? t.request.document.isMutation ? "POST" : Hc(t.method ?? "post") : t.request.hasMutations ? "POST" : Hc(t.method ?? "post"),
    fetchOptions: {
      ...t.fetchOptions,
      errorPolicy: t.fetchOptions.errorPolicy ?? "none"
    }
  }, r = await sA(e.method)(e);
  if (!r.ok)
    return new hr({ status: r.status, headers: r.headers }, {
      query: t.request._tag === "Single" ? t.request.document.expression : t.request.query,
      variables: t.request.variables
    });
  const s = await rA(r, t.fetchOptions.jsonSerializer ?? Ha);
  if (s instanceof Error)
    throw s;
  const o = {
    status: r.status,
    headers: r.headers
  };
  if (eA(s) && e.fetchOptions.errorPolicy === "none") {
    const c = s._tag === "Batch" ? { ...s.executionResults, ...o } : {
      ...s.executionResult,
      ...o
    };
    return new hr(c, {
      query: t.request._tag === "Single" ? t.request.document.expression : t.request.query,
      variables: t.request.variables
    });
  }
  switch (s._tag) {
    case "Single":
      return {
        ...o,
        ...Jc(e)(s.executionResult)
      };
    case "Batch":
      return {
        ...o,
        data: s.executionResults.map(Jc(e))
      };
    default:
      Ka(s);
  }
}, Jc = (t) => (e) => ({
  extensions: e.extensions,
  data: e.data,
  errors: t.fetchOptions.errorPolicy === "all" ? e.errors : void 0
}), rA = async (t, e) => {
  const n = t.headers.get(Yo), r = await t.text();
  return n && $w(n) ? Zc(e.parse(r)) : Zc(r);
}, sA = (t) => async (e) => {
  const n = new Headers(e.headers);
  let r = null, s;
  n.has(Gc) || n.set(Gc, [pf, Go].join(", ")), t === "POST" ? (s = (e.fetchOptions.jsonSerializer ?? Ha).stringify(iA(e)), typeof s == "string" && !n.has(Yo) && n.set(Yo, Go)) : r = oA(e);
  const o = { method: t, headers: n, body: s, ...e.fetchOptions };
  let c = new URL(e.url), l = o;
  if (e.middleware) {
    const p = await Promise.resolve(e.middleware({
      ...o,
      url: e.url,
      operationName: e.request._tag === "Single" ? e.request.document.operationName : void 0,
      variables: e.request.variables
    })), { url: y, ...w } = p;
    c = new URL(y), l = w;
  }
  return r && r.forEach((p, y) => {
    c.searchParams.append(y, p);
  }), await (e.fetch ?? fetch)(c, l);
}, iA = (t) => {
  switch (t.request._tag) {
    case "Single":
      return {
        query: t.request.document.expression,
        variables: t.request.variables,
        operationName: t.request.document.operationName
      };
    case "Batch":
      return ff(t.request.query, t.request.variables ?? []).map(([e, n]) => ({
        query: e,
        variables: n
      }));
    default:
      throw Ka(t.request);
  }
}, oA = (t) => {
  var r;
  const e = t.fetchOptions.jsonSerializer ?? Ha, n = new URLSearchParams();
  switch (t.request._tag) {
    case "Single":
      return n.append("query", Vc(t.request.document.expression)), t.request.variables && n.append("variables", e.stringify(t.request.variables)), t.request.document.operationName && n.append("operationName", t.request.document.operationName), n;
    case "Batch": {
      const s = ((r = t.request.variables) == null ? void 0 : r.map((l) => e.stringify(l))) ?? [], o = t.request.query.map(Vc), c = ff(o, s).map(([l, f]) => ({
        query: l,
        variables: f
      }));
      return n.append("query", e.stringify(c)), n;
    }
    default:
      throw Ka(t.request);
  }
};
class aA {
  constructor(e, n = {}) {
    Jn(this, "url");
    Jn(this, "requestConfig");
    /**
     * Send a GraphQL query to the server.
     */
    Jn(this, "rawRequest", async (...e) => {
      const [n, r, s] = e, o = Jw(n, r, s), { headers: c, fetch: l = globalThis.fetch, method: f = "POST", requestMiddleware: p, responseMiddleware: y, excludeOperationName: w, ...b } = this.requestConfig, { url: x } = this;
      o.signal !== void 0 && (b.signal = o.signal);
      const I = ho(o.query, w), z = await fo({
        url: x,
        request: {
          _tag: "Single",
          document: I,
          variables: o.variables
        },
        headers: {
          ...er(lo(c)),
          ...er(o.requestHeaders)
        },
        fetch: l,
        method: f,
        fetchOptions: b,
        middleware: p
      });
      if (y && await y(z, {
        operationName: I.operationName,
        variables: r,
        url: this.url
      }), z instanceof Error)
        throw z;
      return z;
    });
    this.url = e, this.requestConfig = n;
  }
  async request(e, ...n) {
    const [r, s] = n, o = cA(e, r, s), { headers: c, fetch: l = globalThis.fetch, method: f = "POST", requestMiddleware: p, responseMiddleware: y, excludeOperationName: w, ...b } = this.requestConfig, { url: x } = this;
    o.signal !== void 0 && (b.signal = o.signal);
    const I = ho(o.document, w), z = await fo({
      url: x,
      request: {
        _tag: "Single",
        document: I,
        variables: o.variables
      },
      headers: {
        ...er(lo(c)),
        ...er(o.requestHeaders)
      },
      fetch: l,
      method: f,
      fetchOptions: b,
      middleware: p
    });
    if (y && await y(z, {
      operationName: I.operationName,
      variables: o.variables,
      url: this.url
    }), z instanceof Error)
      throw z;
    return z.data;
  }
  async batchRequests(e, n) {
    const r = Xw(e, n), { headers: s, excludeOperationName: o, ...c } = this.requestConfig;
    r.signal !== void 0 && (c.signal = r.signal);
    const l = r.documents.map(({ document: b }) => ho(b, o)), f = l.map(({ expression: b }) => b), p = l.some(({ isMutation: b }) => b), y = r.documents.map(({ variables: b }) => b), w = await fo({
      url: this.url,
      request: {
        _tag: "Batch",
        operationName: void 0,
        query: f,
        hasMutations: p,
        variables: y
      },
      headers: {
        ...er(lo(s)),
        ...er(r.requestHeaders)
      },
      fetch: this.requestConfig.fetch ?? globalThis.fetch,
      method: this.requestConfig.method || "POST",
      fetchOptions: c,
      middleware: this.requestConfig.requestMiddleware
    });
    if (this.requestConfig.responseMiddleware && await this.requestConfig.responseMiddleware(w, {
      operationName: void 0,
      variables: y,
      url: this.url
    }), w instanceof Error)
      throw w;
    return w.data;
  }
  setHeaders(e) {
    return this.requestConfig.headers = e, this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(e, n) {
    const { headers: r } = this.requestConfig;
    return r ? r[e] = n : this.requestConfig.headers = { [e]: n }, this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(e) {
    return this.url = e, this;
  }
}
async function vt(t, e, ...n) {
  const r = uA(t, e, ...n);
  return new aA(r.url).request({
    ...r
  });
}
const cA = (t, e, n) => t.document ? t : {
  document: t,
  variables: e,
  requestHeaders: n,
  signal: void 0
}, uA = (t, e, ...n) => {
  const [r, s] = n;
  return typeof t == "string" ? {
    url: t,
    document: e,
    variables: r,
    requestHeaders: s,
    signal: void 0
  } : t;
}, gt = (t, ...e) => t.reduce((n, r, s) => `${n}${r}${s in e ? String(e[s]) : ""}`, "");
var lA = Object.defineProperty, dA = (t, e, n) => e in t ? lA(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, tr = (t, e, n) => dA(t, typeof e != "symbol" ? e + "" : e, n), hA = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof Je.global < "u" ? Je.global : typeof self < "u" ? self : {};
function fA(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function pA(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var s = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, s.get ? s : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
var yf = { exports: {} };
(function(t) {
  (function(e, n) {
    t.exports ? t.exports = n() : (e.nacl || (e.nacl = {}), e.nacl.util = n());
  })(hA, function() {
    var e = {};
    function n(r) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(r))
        throw new TypeError("invalid encoding");
    }
    return e.decodeUTF8 = function(r) {
      if (typeof r != "string") throw new TypeError("expected string");
      var s, o = unescape(encodeURIComponent(r)), c = new Uint8Array(o.length);
      for (s = 0; s < o.length; s++) c[s] = o.charCodeAt(s);
      return c;
    }, e.encodeUTF8 = function(r) {
      var s, o = [];
      for (s = 0; s < r.length; s++) o.push(String.fromCharCode(r[s]));
      return decodeURIComponent(escape(o.join("")));
    }, typeof atob > "u" ? typeof Je.Buffer.from < "u" ? (e.encodeBase64 = function(r) {
      return Je.Buffer.from(r).toString("base64");
    }, e.decodeBase64 = function(r) {
      return n(r), new Uint8Array(Array.prototype.slice.call(Je.Buffer.from(r, "base64"), 0));
    }) : (e.encodeBase64 = function(r) {
      return new Je.Buffer(r).toString("base64");
    }, e.decodeBase64 = function(r) {
      return n(r), new Uint8Array(Array.prototype.slice.call(new Je.Buffer(r, "base64"), 0));
    }) : (e.encodeBase64 = function(r) {
      var s, o = [], c = r.length;
      for (s = 0; s < c; s++) o.push(String.fromCharCode(r[s]));
      return btoa(o.join(""));
    }, e.decodeBase64 = function(r) {
      n(r);
      var s, o = atob(r), c = new Uint8Array(o.length);
      for (s = 0; s < o.length; s++) c[s] = o.charCodeAt(s);
      return c;
    }), e;
  });
})(yf);
var gA = yf.exports;
const As = /* @__PURE__ */ fA(gA);
function yA(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var wA = { exports: {} };
const AA = {}, mA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: AA
}, Symbol.toStringTag, { value: "Module" })), vA = /* @__PURE__ */ pA(mA);
(function(t) {
  (function(e) {
    var n = function(a) {
      var d, u = new Float64Array(16);
      if (a) for (d = 0; d < a.length; d++) u[d] = a[d];
      return u;
    }, r = function() {
      throw new Error("no PRNG");
    }, s = new Uint8Array(16), o = new Uint8Array(32);
    o[0] = 9;
    var c = n(), l = n([1]), f = n([56129, 1]), p = n([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), y = n([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), w = n([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), b = n([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), x = n([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function I(a, d, u, i) {
      a[d] = u >> 24 & 255, a[d + 1] = u >> 16 & 255, a[d + 2] = u >> 8 & 255, a[d + 3] = u & 255, a[d + 4] = i >> 24 & 255, a[d + 5] = i >> 16 & 255, a[d + 6] = i >> 8 & 255, a[d + 7] = i & 255;
    }
    function z(a, d, u, i, h) {
      var A, m = 0;
      for (A = 0; A < h; A++) m |= a[d + A] ^ u[i + A];
      return (1 & m - 1 >>> 8) - 1;
    }
    function S(a, d, u, i) {
      return z(a, d, u, i, 16);
    }
    function Z(a, d, u, i) {
      return z(a, d, u, i, 32);
    }
    function le(a, d, u, i) {
      for (var h = i[0] & 255 | (i[1] & 255) << 8 | (i[2] & 255) << 16 | (i[3] & 255) << 24, A = u[0] & 255 | (u[1] & 255) << 8 | (u[2] & 255) << 16 | (u[3] & 255) << 24, m = u[4] & 255 | (u[5] & 255) << 8 | (u[6] & 255) << 16 | (u[7] & 255) << 24, M = u[8] & 255 | (u[9] & 255) << 8 | (u[10] & 255) << 16 | (u[11] & 255) << 24, C = u[12] & 255 | (u[13] & 255) << 8 | (u[14] & 255) << 16 | (u[15] & 255) << 24, W = i[4] & 255 | (i[5] & 255) << 8 | (i[6] & 255) << 16 | (i[7] & 255) << 24, O = d[0] & 255 | (d[1] & 255) << 8 | (d[2] & 255) << 16 | (d[3] & 255) << 24, fe = d[4] & 255 | (d[5] & 255) << 8 | (d[6] & 255) << 16 | (d[7] & 255) << 24, P = d[8] & 255 | (d[9] & 255) << 8 | (d[10] & 255) << 16 | (d[11] & 255) << 24, V = d[12] & 255 | (d[13] & 255) << 8 | (d[14] & 255) << 16 | (d[15] & 255) << 24, q = i[8] & 255 | (i[9] & 255) << 8 | (i[10] & 255) << 16 | (i[11] & 255) << 24, te = u[16] & 255 | (u[17] & 255) << 8 | (u[18] & 255) << 16 | (u[19] & 255) << 24, ee = u[20] & 255 | (u[21] & 255) << 8 | (u[22] & 255) << 16 | (u[23] & 255) << 24, X = u[24] & 255 | (u[25] & 255) << 8 | (u[26] & 255) << 16 | (u[27] & 255) << 24, $ = u[28] & 255 | (u[29] & 255) << 8 | (u[30] & 255) << 16 | (u[31] & 255) << 24, J = i[12] & 255 | (i[13] & 255) << 8 | (i[14] & 255) << 16 | (i[15] & 255) << 24, B = h, Q = A, j = m, R = M, F = C, k = W, v = O, E = fe, D = P, T = V, N = q, U = te, G = ee, ne = X, se = $, re = J, g, oe = 0; oe < 20; oe += 2)
        g = B + G | 0, F ^= g << 7 | g >>> 25, g = F + B | 0, D ^= g << 9 | g >>> 23, g = D + F | 0, G ^= g << 13 | g >>> 19, g = G + D | 0, B ^= g << 18 | g >>> 14, g = k + Q | 0, T ^= g << 7 | g >>> 25, g = T + k | 0, ne ^= g << 9 | g >>> 23, g = ne + T | 0, Q ^= g << 13 | g >>> 19, g = Q + ne | 0, k ^= g << 18 | g >>> 14, g = N + v | 0, se ^= g << 7 | g >>> 25, g = se + N | 0, j ^= g << 9 | g >>> 23, g = j + se | 0, v ^= g << 13 | g >>> 19, g = v + j | 0, N ^= g << 18 | g >>> 14, g = re + U | 0, R ^= g << 7 | g >>> 25, g = R + re | 0, E ^= g << 9 | g >>> 23, g = E + R | 0, U ^= g << 13 | g >>> 19, g = U + E | 0, re ^= g << 18 | g >>> 14, g = B + R | 0, Q ^= g << 7 | g >>> 25, g = Q + B | 0, j ^= g << 9 | g >>> 23, g = j + Q | 0, R ^= g << 13 | g >>> 19, g = R + j | 0, B ^= g << 18 | g >>> 14, g = k + F | 0, v ^= g << 7 | g >>> 25, g = v + k | 0, E ^= g << 9 | g >>> 23, g = E + v | 0, F ^= g << 13 | g >>> 19, g = F + E | 0, k ^= g << 18 | g >>> 14, g = N + T | 0, U ^= g << 7 | g >>> 25, g = U + N | 0, D ^= g << 9 | g >>> 23, g = D + U | 0, T ^= g << 13 | g >>> 19, g = T + D | 0, N ^= g << 18 | g >>> 14, g = re + se | 0, G ^= g << 7 | g >>> 25, g = G + re | 0, ne ^= g << 9 | g >>> 23, g = ne + G | 0, se ^= g << 13 | g >>> 19, g = se + ne | 0, re ^= g << 18 | g >>> 14;
      B = B + h | 0, Q = Q + A | 0, j = j + m | 0, R = R + M | 0, F = F + C | 0, k = k + W | 0, v = v + O | 0, E = E + fe | 0, D = D + P | 0, T = T + V | 0, N = N + q | 0, U = U + te | 0, G = G + ee | 0, ne = ne + X | 0, se = se + $ | 0, re = re + J | 0, a[0] = B >>> 0 & 255, a[1] = B >>> 8 & 255, a[2] = B >>> 16 & 255, a[3] = B >>> 24 & 255, a[4] = Q >>> 0 & 255, a[5] = Q >>> 8 & 255, a[6] = Q >>> 16 & 255, a[7] = Q >>> 24 & 255, a[8] = j >>> 0 & 255, a[9] = j >>> 8 & 255, a[10] = j >>> 16 & 255, a[11] = j >>> 24 & 255, a[12] = R >>> 0 & 255, a[13] = R >>> 8 & 255, a[14] = R >>> 16 & 255, a[15] = R >>> 24 & 255, a[16] = F >>> 0 & 255, a[17] = F >>> 8 & 255, a[18] = F >>> 16 & 255, a[19] = F >>> 24 & 255, a[20] = k >>> 0 & 255, a[21] = k >>> 8 & 255, a[22] = k >>> 16 & 255, a[23] = k >>> 24 & 255, a[24] = v >>> 0 & 255, a[25] = v >>> 8 & 255, a[26] = v >>> 16 & 255, a[27] = v >>> 24 & 255, a[28] = E >>> 0 & 255, a[29] = E >>> 8 & 255, a[30] = E >>> 16 & 255, a[31] = E >>> 24 & 255, a[32] = D >>> 0 & 255, a[33] = D >>> 8 & 255, a[34] = D >>> 16 & 255, a[35] = D >>> 24 & 255, a[36] = T >>> 0 & 255, a[37] = T >>> 8 & 255, a[38] = T >>> 16 & 255, a[39] = T >>> 24 & 255, a[40] = N >>> 0 & 255, a[41] = N >>> 8 & 255, a[42] = N >>> 16 & 255, a[43] = N >>> 24 & 255, a[44] = U >>> 0 & 255, a[45] = U >>> 8 & 255, a[46] = U >>> 16 & 255, a[47] = U >>> 24 & 255, a[48] = G >>> 0 & 255, a[49] = G >>> 8 & 255, a[50] = G >>> 16 & 255, a[51] = G >>> 24 & 255, a[52] = ne >>> 0 & 255, a[53] = ne >>> 8 & 255, a[54] = ne >>> 16 & 255, a[55] = ne >>> 24 & 255, a[56] = se >>> 0 & 255, a[57] = se >>> 8 & 255, a[58] = se >>> 16 & 255, a[59] = se >>> 24 & 255, a[60] = re >>> 0 & 255, a[61] = re >>> 8 & 255, a[62] = re >>> 16 & 255, a[63] = re >>> 24 & 255;
    }
    function L(a, d, u, i) {
      for (var h = i[0] & 255 | (i[1] & 255) << 8 | (i[2] & 255) << 16 | (i[3] & 255) << 24, A = u[0] & 255 | (u[1] & 255) << 8 | (u[2] & 255) << 16 | (u[3] & 255) << 24, m = u[4] & 255 | (u[5] & 255) << 8 | (u[6] & 255) << 16 | (u[7] & 255) << 24, M = u[8] & 255 | (u[9] & 255) << 8 | (u[10] & 255) << 16 | (u[11] & 255) << 24, C = u[12] & 255 | (u[13] & 255) << 8 | (u[14] & 255) << 16 | (u[15] & 255) << 24, W = i[4] & 255 | (i[5] & 255) << 8 | (i[6] & 255) << 16 | (i[7] & 255) << 24, O = d[0] & 255 | (d[1] & 255) << 8 | (d[2] & 255) << 16 | (d[3] & 255) << 24, fe = d[4] & 255 | (d[5] & 255) << 8 | (d[6] & 255) << 16 | (d[7] & 255) << 24, P = d[8] & 255 | (d[9] & 255) << 8 | (d[10] & 255) << 16 | (d[11] & 255) << 24, V = d[12] & 255 | (d[13] & 255) << 8 | (d[14] & 255) << 16 | (d[15] & 255) << 24, q = i[8] & 255 | (i[9] & 255) << 8 | (i[10] & 255) << 16 | (i[11] & 255) << 24, te = u[16] & 255 | (u[17] & 255) << 8 | (u[18] & 255) << 16 | (u[19] & 255) << 24, ee = u[20] & 255 | (u[21] & 255) << 8 | (u[22] & 255) << 16 | (u[23] & 255) << 24, X = u[24] & 255 | (u[25] & 255) << 8 | (u[26] & 255) << 16 | (u[27] & 255) << 24, $ = u[28] & 255 | (u[29] & 255) << 8 | (u[30] & 255) << 16 | (u[31] & 255) << 24, J = i[12] & 255 | (i[13] & 255) << 8 | (i[14] & 255) << 16 | (i[15] & 255) << 24, B = h, Q = A, j = m, R = M, F = C, k = W, v = O, E = fe, D = P, T = V, N = q, U = te, G = ee, ne = X, se = $, re = J, g, oe = 0; oe < 20; oe += 2)
        g = B + G | 0, F ^= g << 7 | g >>> 25, g = F + B | 0, D ^= g << 9 | g >>> 23, g = D + F | 0, G ^= g << 13 | g >>> 19, g = G + D | 0, B ^= g << 18 | g >>> 14, g = k + Q | 0, T ^= g << 7 | g >>> 25, g = T + k | 0, ne ^= g << 9 | g >>> 23, g = ne + T | 0, Q ^= g << 13 | g >>> 19, g = Q + ne | 0, k ^= g << 18 | g >>> 14, g = N + v | 0, se ^= g << 7 | g >>> 25, g = se + N | 0, j ^= g << 9 | g >>> 23, g = j + se | 0, v ^= g << 13 | g >>> 19, g = v + j | 0, N ^= g << 18 | g >>> 14, g = re + U | 0, R ^= g << 7 | g >>> 25, g = R + re | 0, E ^= g << 9 | g >>> 23, g = E + R | 0, U ^= g << 13 | g >>> 19, g = U + E | 0, re ^= g << 18 | g >>> 14, g = B + R | 0, Q ^= g << 7 | g >>> 25, g = Q + B | 0, j ^= g << 9 | g >>> 23, g = j + Q | 0, R ^= g << 13 | g >>> 19, g = R + j | 0, B ^= g << 18 | g >>> 14, g = k + F | 0, v ^= g << 7 | g >>> 25, g = v + k | 0, E ^= g << 9 | g >>> 23, g = E + v | 0, F ^= g << 13 | g >>> 19, g = F + E | 0, k ^= g << 18 | g >>> 14, g = N + T | 0, U ^= g << 7 | g >>> 25, g = U + N | 0, D ^= g << 9 | g >>> 23, g = D + U | 0, T ^= g << 13 | g >>> 19, g = T + D | 0, N ^= g << 18 | g >>> 14, g = re + se | 0, G ^= g << 7 | g >>> 25, g = G + re | 0, ne ^= g << 9 | g >>> 23, g = ne + G | 0, se ^= g << 13 | g >>> 19, g = se + ne | 0, re ^= g << 18 | g >>> 14;
      a[0] = B >>> 0 & 255, a[1] = B >>> 8 & 255, a[2] = B >>> 16 & 255, a[3] = B >>> 24 & 255, a[4] = k >>> 0 & 255, a[5] = k >>> 8 & 255, a[6] = k >>> 16 & 255, a[7] = k >>> 24 & 255, a[8] = N >>> 0 & 255, a[9] = N >>> 8 & 255, a[10] = N >>> 16 & 255, a[11] = N >>> 24 & 255, a[12] = re >>> 0 & 255, a[13] = re >>> 8 & 255, a[14] = re >>> 16 & 255, a[15] = re >>> 24 & 255, a[16] = v >>> 0 & 255, a[17] = v >>> 8 & 255, a[18] = v >>> 16 & 255, a[19] = v >>> 24 & 255, a[20] = E >>> 0 & 255, a[21] = E >>> 8 & 255, a[22] = E >>> 16 & 255, a[23] = E >>> 24 & 255, a[24] = D >>> 0 & 255, a[25] = D >>> 8 & 255, a[26] = D >>> 16 & 255, a[27] = D >>> 24 & 255, a[28] = T >>> 0 & 255, a[29] = T >>> 8 & 255, a[30] = T >>> 16 & 255, a[31] = T >>> 24 & 255;
    }
    function ve(a, d, u, i) {
      le(a, d, u, i);
    }
    function ye(a, d, u, i) {
      L(a, d, u, i);
    }
    var De = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function Re(a, d, u, i, h, A, m) {
      var M = new Uint8Array(16), C = new Uint8Array(64), W, O;
      for (O = 0; O < 16; O++) M[O] = 0;
      for (O = 0; O < 8; O++) M[O] = A[O];
      for (; h >= 64; ) {
        for (ve(C, M, m, De), O = 0; O < 64; O++) a[d + O] = u[i + O] ^ C[O];
        for (W = 1, O = 8; O < 16; O++)
          W = W + (M[O] & 255) | 0, M[O] = W & 255, W >>>= 8;
        h -= 64, d += 64, i += 64;
      }
      if (h > 0)
        for (ve(C, M, m, De), O = 0; O < h; O++) a[d + O] = u[i + O] ^ C[O];
      return 0;
    }
    function Le(a, d, u, i, h) {
      var A = new Uint8Array(16), m = new Uint8Array(64), M, C;
      for (C = 0; C < 16; C++) A[C] = 0;
      for (C = 0; C < 8; C++) A[C] = i[C];
      for (; u >= 64; ) {
        for (ve(m, A, h, De), C = 0; C < 64; C++) a[d + C] = m[C];
        for (M = 1, C = 8; C < 16; C++)
          M = M + (A[C] & 255) | 0, A[C] = M & 255, M >>>= 8;
        u -= 64, d += 64;
      }
      if (u > 0)
        for (ve(m, A, h, De), C = 0; C < u; C++) a[d + C] = m[C];
      return 0;
    }
    function tt(a, d, u, i, h) {
      var A = new Uint8Array(32);
      ye(A, i, h, De);
      for (var m = new Uint8Array(8), M = 0; M < 8; M++) m[M] = i[M + 16];
      return Le(a, d, u, m, A);
    }
    function ae(a, d, u, i, h, A, m) {
      var M = new Uint8Array(32);
      ye(M, A, m, De);
      for (var C = new Uint8Array(8), W = 0; W < 8; W++) C[W] = A[W + 16];
      return Re(a, d, u, i, h, C, M);
    }
    var ce = function(a) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var d, u, i, h, A, m, M, C;
      d = a[0] & 255 | (a[1] & 255) << 8, this.r[0] = d & 8191, u = a[2] & 255 | (a[3] & 255) << 8, this.r[1] = (d >>> 13 | u << 3) & 8191, i = a[4] & 255 | (a[5] & 255) << 8, this.r[2] = (u >>> 10 | i << 6) & 7939, h = a[6] & 255 | (a[7] & 255) << 8, this.r[3] = (i >>> 7 | h << 9) & 8191, A = a[8] & 255 | (a[9] & 255) << 8, this.r[4] = (h >>> 4 | A << 12) & 255, this.r[5] = A >>> 1 & 8190, m = a[10] & 255 | (a[11] & 255) << 8, this.r[6] = (A >>> 14 | m << 2) & 8191, M = a[12] & 255 | (a[13] & 255) << 8, this.r[7] = (m >>> 11 | M << 5) & 8065, C = a[14] & 255 | (a[15] & 255) << 8, this.r[8] = (M >>> 8 | C << 8) & 8191, this.r[9] = C >>> 5 & 127, this.pad[0] = a[16] & 255 | (a[17] & 255) << 8, this.pad[1] = a[18] & 255 | (a[19] & 255) << 8, this.pad[2] = a[20] & 255 | (a[21] & 255) << 8, this.pad[3] = a[22] & 255 | (a[23] & 255) << 8, this.pad[4] = a[24] & 255 | (a[25] & 255) << 8, this.pad[5] = a[26] & 255 | (a[27] & 255) << 8, this.pad[6] = a[28] & 255 | (a[29] & 255) << 8, this.pad[7] = a[30] & 255 | (a[31] & 255) << 8;
    };
    ce.prototype.blocks = function(a, d, u) {
      for (var i = this.fin ? 0 : 2048, h, A, m, M, C, W, O, fe, P, V, q, te, ee, X, $, J, B, Q, j, R = this.h[0], F = this.h[1], k = this.h[2], v = this.h[3], E = this.h[4], D = this.h[5], T = this.h[6], N = this.h[7], U = this.h[8], G = this.h[9], ne = this.r[0], se = this.r[1], re = this.r[2], g = this.r[3], oe = this.r[4], pe = this.r[5], ge = this.r[6], ie = this.r[7], de = this.r[8], he = this.r[9]; u >= 16; )
        h = a[d + 0] & 255 | (a[d + 1] & 255) << 8, R += h & 8191, A = a[d + 2] & 255 | (a[d + 3] & 255) << 8, F += (h >>> 13 | A << 3) & 8191, m = a[d + 4] & 255 | (a[d + 5] & 255) << 8, k += (A >>> 10 | m << 6) & 8191, M = a[d + 6] & 255 | (a[d + 7] & 255) << 8, v += (m >>> 7 | M << 9) & 8191, C = a[d + 8] & 255 | (a[d + 9] & 255) << 8, E += (M >>> 4 | C << 12) & 8191, D += C >>> 1 & 8191, W = a[d + 10] & 255 | (a[d + 11] & 255) << 8, T += (C >>> 14 | W << 2) & 8191, O = a[d + 12] & 255 | (a[d + 13] & 255) << 8, N += (W >>> 11 | O << 5) & 8191, fe = a[d + 14] & 255 | (a[d + 15] & 255) << 8, U += (O >>> 8 | fe << 8) & 8191, G += fe >>> 5 | i, P = 0, V = P, V += R * ne, V += F * (5 * he), V += k * (5 * de), V += v * (5 * ie), V += E * (5 * ge), P = V >>> 13, V &= 8191, V += D * (5 * pe), V += T * (5 * oe), V += N * (5 * g), V += U * (5 * re), V += G * (5 * se), P += V >>> 13, V &= 8191, q = P, q += R * se, q += F * ne, q += k * (5 * he), q += v * (5 * de), q += E * (5 * ie), P = q >>> 13, q &= 8191, q += D * (5 * ge), q += T * (5 * pe), q += N * (5 * oe), q += U * (5 * g), q += G * (5 * re), P += q >>> 13, q &= 8191, te = P, te += R * re, te += F * se, te += k * ne, te += v * (5 * he), te += E * (5 * de), P = te >>> 13, te &= 8191, te += D * (5 * ie), te += T * (5 * ge), te += N * (5 * pe), te += U * (5 * oe), te += G * (5 * g), P += te >>> 13, te &= 8191, ee = P, ee += R * g, ee += F * re, ee += k * se, ee += v * ne, ee += E * (5 * he), P = ee >>> 13, ee &= 8191, ee += D * (5 * de), ee += T * (5 * ie), ee += N * (5 * ge), ee += U * (5 * pe), ee += G * (5 * oe), P += ee >>> 13, ee &= 8191, X = P, X += R * oe, X += F * g, X += k * re, X += v * se, X += E * ne, P = X >>> 13, X &= 8191, X += D * (5 * he), X += T * (5 * de), X += N * (5 * ie), X += U * (5 * ge), X += G * (5 * pe), P += X >>> 13, X &= 8191, $ = P, $ += R * pe, $ += F * oe, $ += k * g, $ += v * re, $ += E * se, P = $ >>> 13, $ &= 8191, $ += D * ne, $ += T * (5 * he), $ += N * (5 * de), $ += U * (5 * ie), $ += G * (5 * ge), P += $ >>> 13, $ &= 8191, J = P, J += R * ge, J += F * pe, J += k * oe, J += v * g, J += E * re, P = J >>> 13, J &= 8191, J += D * se, J += T * ne, J += N * (5 * he), J += U * (5 * de), J += G * (5 * ie), P += J >>> 13, J &= 8191, B = P, B += R * ie, B += F * ge, B += k * pe, B += v * oe, B += E * g, P = B >>> 13, B &= 8191, B += D * re, B += T * se, B += N * ne, B += U * (5 * he), B += G * (5 * de), P += B >>> 13, B &= 8191, Q = P, Q += R * de, Q += F * ie, Q += k * ge, Q += v * pe, Q += E * oe, P = Q >>> 13, Q &= 8191, Q += D * g, Q += T * re, Q += N * se, Q += U * ne, Q += G * (5 * he), P += Q >>> 13, Q &= 8191, j = P, j += R * he, j += F * de, j += k * ie, j += v * ge, j += E * pe, P = j >>> 13, j &= 8191, j += D * oe, j += T * g, j += N * re, j += U * se, j += G * ne, P += j >>> 13, j &= 8191, P = (P << 2) + P | 0, P = P + V | 0, V = P & 8191, P = P >>> 13, q += P, R = V, F = q, k = te, v = ee, E = X, D = $, T = J, N = B, U = Q, G = j, d += 16, u -= 16;
      this.h[0] = R, this.h[1] = F, this.h[2] = k, this.h[3] = v, this.h[4] = E, this.h[5] = D, this.h[6] = T, this.h[7] = N, this.h[8] = U, this.h[9] = G;
    }, ce.prototype.finish = function(a, d) {
      var u = new Uint16Array(10), i, h, A, m;
      if (this.leftover) {
        for (m = this.leftover, this.buffer[m++] = 1; m < 16; m++) this.buffer[m] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (i = this.h[1] >>> 13, this.h[1] &= 8191, m = 2; m < 10; m++)
        this.h[m] += i, i = this.h[m] >>> 13, this.h[m] &= 8191;
      for (this.h[0] += i * 5, i = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += i, i = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += i, u[0] = this.h[0] + 5, i = u[0] >>> 13, u[0] &= 8191, m = 1; m < 10; m++)
        u[m] = this.h[m] + i, i = u[m] >>> 13, u[m] &= 8191;
      for (u[9] -= 8192, h = (i ^ 1) - 1, m = 0; m < 10; m++) u[m] &= h;
      for (h = ~h, m = 0; m < 10; m++) this.h[m] = this.h[m] & h | u[m];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, A = this.h[0] + this.pad[0], this.h[0] = A & 65535, m = 1; m < 8; m++)
        A = (this.h[m] + this.pad[m] | 0) + (A >>> 16) | 0, this.h[m] = A & 65535;
      a[d + 0] = this.h[0] >>> 0 & 255, a[d + 1] = this.h[0] >>> 8 & 255, a[d + 2] = this.h[1] >>> 0 & 255, a[d + 3] = this.h[1] >>> 8 & 255, a[d + 4] = this.h[2] >>> 0 & 255, a[d + 5] = this.h[2] >>> 8 & 255, a[d + 6] = this.h[3] >>> 0 & 255, a[d + 7] = this.h[3] >>> 8 & 255, a[d + 8] = this.h[4] >>> 0 & 255, a[d + 9] = this.h[4] >>> 8 & 255, a[d + 10] = this.h[5] >>> 0 & 255, a[d + 11] = this.h[5] >>> 8 & 255, a[d + 12] = this.h[6] >>> 0 & 255, a[d + 13] = this.h[6] >>> 8 & 255, a[d + 14] = this.h[7] >>> 0 & 255, a[d + 15] = this.h[7] >>> 8 & 255;
    }, ce.prototype.update = function(a, d, u) {
      var i, h;
      if (this.leftover) {
        for (h = 16 - this.leftover, h > u && (h = u), i = 0; i < h; i++)
          this.buffer[this.leftover + i] = a[d + i];
        if (u -= h, d += h, this.leftover += h, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (u >= 16 && (h = u - u % 16, this.blocks(a, d, h), d += h, u -= h), u) {
        for (i = 0; i < u; i++)
          this.buffer[this.leftover + i] = a[d + i];
        this.leftover += u;
      }
    };
    function Y(a, d, u, i, h, A) {
      var m = new ce(A);
      return m.update(u, i, h), m.finish(a, d), 0;
    }
    function K(a, d, u, i, h, A) {
      var m = new Uint8Array(16);
      return Y(m, 0, u, i, h, A), S(a, d, m, 0);
    }
    function ze(a, d, u, i, h) {
      var A;
      if (u < 32) return -1;
      for (ae(a, 0, d, 0, u, i, h), Y(a, 16, a, 32, u - 32, a), A = 0; A < 16; A++) a[A] = 0;
      return 0;
    }
    function Ee(a, d, u, i, h) {
      var A, m = new Uint8Array(32);
      if (u < 32 || (tt(m, 0, 32, i, h), K(d, 16, d, 32, u - 32, m) !== 0)) return -1;
      for (ae(a, 0, d, 0, u, i, h), A = 0; A < 32; A++) a[A] = 0;
      return 0;
    }
    function Ce(a, d) {
      var u;
      for (u = 0; u < 16; u++) a[u] = d[u] | 0;
    }
    function Wt(a) {
      var d, u, i = 1;
      for (d = 0; d < 16; d++)
        u = a[d] + i + 65535, i = Math.floor(u / 65536), a[d] = u - i * 65536;
      a[0] += i - 1 + 37 * (i - 1);
    }
    function dt(a, d, u) {
      for (var i, h = ~(u - 1), A = 0; A < 16; A++)
        i = h & (a[A] ^ d[A]), a[A] ^= i, d[A] ^= i;
    }
    function It(a, d) {
      var u, i, h, A = n(), m = n();
      for (u = 0; u < 16; u++) m[u] = d[u];
      for (Wt(m), Wt(m), Wt(m), i = 0; i < 2; i++) {
        for (A[0] = m[0] - 65517, u = 1; u < 15; u++)
          A[u] = m[u] - 65535 - (A[u - 1] >> 16 & 1), A[u - 1] &= 65535;
        A[15] = m[15] - 32767 - (A[14] >> 16 & 1), h = A[15] >> 16 & 1, A[14] &= 65535, dt(m, A, 1 - h);
      }
      for (u = 0; u < 16; u++)
        a[2 * u] = m[u] & 255, a[2 * u + 1] = m[u] >> 8;
    }
    function Ur(a, d) {
      var u = new Uint8Array(32), i = new Uint8Array(32);
      return It(u, a), It(i, d), Z(u, 0, i, 0);
    }
    function Cr(a) {
      var d = new Uint8Array(32);
      return It(d, a), d[0] & 1;
    }
    function En(a, d) {
      var u;
      for (u = 0; u < 16; u++) a[u] = d[2 * u] + (d[2 * u + 1] << 8);
      a[15] &= 32767;
    }
    function Ge(a, d, u) {
      for (var i = 0; i < 16; i++) a[i] = d[i] + u[i];
    }
    function Ve(a, d, u) {
      for (var i = 0; i < 16; i++) a[i] = d[i] - u[i];
    }
    function ue(a, d, u) {
      var i, h, A = 0, m = 0, M = 0, C = 0, W = 0, O = 0, fe = 0, P = 0, V = 0, q = 0, te = 0, ee = 0, X = 0, $ = 0, J = 0, B = 0, Q = 0, j = 0, R = 0, F = 0, k = 0, v = 0, E = 0, D = 0, T = 0, N = 0, U = 0, G = 0, ne = 0, se = 0, re = 0, g = u[0], oe = u[1], pe = u[2], ge = u[3], ie = u[4], de = u[5], he = u[6], Ne = u[7], Ae = u[8], Te = u[9], Ie = u[10], Me = u[11], Ue = u[12], Pe = u[13], _e = u[14], Be = u[15];
      i = d[0], A += i * g, m += i * oe, M += i * pe, C += i * ge, W += i * ie, O += i * de, fe += i * he, P += i * Ne, V += i * Ae, q += i * Te, te += i * Ie, ee += i * Me, X += i * Ue, $ += i * Pe, J += i * _e, B += i * Be, i = d[1], m += i * g, M += i * oe, C += i * pe, W += i * ge, O += i * ie, fe += i * de, P += i * he, V += i * Ne, q += i * Ae, te += i * Te, ee += i * Ie, X += i * Me, $ += i * Ue, J += i * Pe, B += i * _e, Q += i * Be, i = d[2], M += i * g, C += i * oe, W += i * pe, O += i * ge, fe += i * ie, P += i * de, V += i * he, q += i * Ne, te += i * Ae, ee += i * Te, X += i * Ie, $ += i * Me, J += i * Ue, B += i * Pe, Q += i * _e, j += i * Be, i = d[3], C += i * g, W += i * oe, O += i * pe, fe += i * ge, P += i * ie, V += i * de, q += i * he, te += i * Ne, ee += i * Ae, X += i * Te, $ += i * Ie, J += i * Me, B += i * Ue, Q += i * Pe, j += i * _e, R += i * Be, i = d[4], W += i * g, O += i * oe, fe += i * pe, P += i * ge, V += i * ie, q += i * de, te += i * he, ee += i * Ne, X += i * Ae, $ += i * Te, J += i * Ie, B += i * Me, Q += i * Ue, j += i * Pe, R += i * _e, F += i * Be, i = d[5], O += i * g, fe += i * oe, P += i * pe, V += i * ge, q += i * ie, te += i * de, ee += i * he, X += i * Ne, $ += i * Ae, J += i * Te, B += i * Ie, Q += i * Me, j += i * Ue, R += i * Pe, F += i * _e, k += i * Be, i = d[6], fe += i * g, P += i * oe, V += i * pe, q += i * ge, te += i * ie, ee += i * de, X += i * he, $ += i * Ne, J += i * Ae, B += i * Te, Q += i * Ie, j += i * Me, R += i * Ue, F += i * Pe, k += i * _e, v += i * Be, i = d[7], P += i * g, V += i * oe, q += i * pe, te += i * ge, ee += i * ie, X += i * de, $ += i * he, J += i * Ne, B += i * Ae, Q += i * Te, j += i * Ie, R += i * Me, F += i * Ue, k += i * Pe, v += i * _e, E += i * Be, i = d[8], V += i * g, q += i * oe, te += i * pe, ee += i * ge, X += i * ie, $ += i * de, J += i * he, B += i * Ne, Q += i * Ae, j += i * Te, R += i * Ie, F += i * Me, k += i * Ue, v += i * Pe, E += i * _e, D += i * Be, i = d[9], q += i * g, te += i * oe, ee += i * pe, X += i * ge, $ += i * ie, J += i * de, B += i * he, Q += i * Ne, j += i * Ae, R += i * Te, F += i * Ie, k += i * Me, v += i * Ue, E += i * Pe, D += i * _e, T += i * Be, i = d[10], te += i * g, ee += i * oe, X += i * pe, $ += i * ge, J += i * ie, B += i * de, Q += i * he, j += i * Ne, R += i * Ae, F += i * Te, k += i * Ie, v += i * Me, E += i * Ue, D += i * Pe, T += i * _e, N += i * Be, i = d[11], ee += i * g, X += i * oe, $ += i * pe, J += i * ge, B += i * ie, Q += i * de, j += i * he, R += i * Ne, F += i * Ae, k += i * Te, v += i * Ie, E += i * Me, D += i * Ue, T += i * Pe, N += i * _e, U += i * Be, i = d[12], X += i * g, $ += i * oe, J += i * pe, B += i * ge, Q += i * ie, j += i * de, R += i * he, F += i * Ne, k += i * Ae, v += i * Te, E += i * Ie, D += i * Me, T += i * Ue, N += i * Pe, U += i * _e, G += i * Be, i = d[13], $ += i * g, J += i * oe, B += i * pe, Q += i * ge, j += i * ie, R += i * de, F += i * he, k += i * Ne, v += i * Ae, E += i * Te, D += i * Ie, T += i * Me, N += i * Ue, U += i * Pe, G += i * _e, ne += i * Be, i = d[14], J += i * g, B += i * oe, Q += i * pe, j += i * ge, R += i * ie, F += i * de, k += i * he, v += i * Ne, E += i * Ae, D += i * Te, T += i * Ie, N += i * Me, U += i * Ue, G += i * Pe, ne += i * _e, se += i * Be, i = d[15], B += i * g, Q += i * oe, j += i * pe, R += i * ge, F += i * ie, k += i * de, v += i * he, E += i * Ne, D += i * Ae, T += i * Te, N += i * Ie, U += i * Me, G += i * Ue, ne += i * Pe, se += i * _e, re += i * Be, A += 38 * Q, m += 38 * j, M += 38 * R, C += 38 * F, W += 38 * k, O += 38 * v, fe += 38 * E, P += 38 * D, V += 38 * T, q += 38 * N, te += 38 * U, ee += 38 * G, X += 38 * ne, $ += 38 * se, J += 38 * re, h = 1, i = A + h + 65535, h = Math.floor(i / 65536), A = i - h * 65536, i = m + h + 65535, h = Math.floor(i / 65536), m = i - h * 65536, i = M + h + 65535, h = Math.floor(i / 65536), M = i - h * 65536, i = C + h + 65535, h = Math.floor(i / 65536), C = i - h * 65536, i = W + h + 65535, h = Math.floor(i / 65536), W = i - h * 65536, i = O + h + 65535, h = Math.floor(i / 65536), O = i - h * 65536, i = fe + h + 65535, h = Math.floor(i / 65536), fe = i - h * 65536, i = P + h + 65535, h = Math.floor(i / 65536), P = i - h * 65536, i = V + h + 65535, h = Math.floor(i / 65536), V = i - h * 65536, i = q + h + 65535, h = Math.floor(i / 65536), q = i - h * 65536, i = te + h + 65535, h = Math.floor(i / 65536), te = i - h * 65536, i = ee + h + 65535, h = Math.floor(i / 65536), ee = i - h * 65536, i = X + h + 65535, h = Math.floor(i / 65536), X = i - h * 65536, i = $ + h + 65535, h = Math.floor(i / 65536), $ = i - h * 65536, i = J + h + 65535, h = Math.floor(i / 65536), J = i - h * 65536, i = B + h + 65535, h = Math.floor(i / 65536), B = i - h * 65536, A += h - 1 + 37 * (h - 1), h = 1, i = A + h + 65535, h = Math.floor(i / 65536), A = i - h * 65536, i = m + h + 65535, h = Math.floor(i / 65536), m = i - h * 65536, i = M + h + 65535, h = Math.floor(i / 65536), M = i - h * 65536, i = C + h + 65535, h = Math.floor(i / 65536), C = i - h * 65536, i = W + h + 65535, h = Math.floor(i / 65536), W = i - h * 65536, i = O + h + 65535, h = Math.floor(i / 65536), O = i - h * 65536, i = fe + h + 65535, h = Math.floor(i / 65536), fe = i - h * 65536, i = P + h + 65535, h = Math.floor(i / 65536), P = i - h * 65536, i = V + h + 65535, h = Math.floor(i / 65536), V = i - h * 65536, i = q + h + 65535, h = Math.floor(i / 65536), q = i - h * 65536, i = te + h + 65535, h = Math.floor(i / 65536), te = i - h * 65536, i = ee + h + 65535, h = Math.floor(i / 65536), ee = i - h * 65536, i = X + h + 65535, h = Math.floor(i / 65536), X = i - h * 65536, i = $ + h + 65535, h = Math.floor(i / 65536), $ = i - h * 65536, i = J + h + 65535, h = Math.floor(i / 65536), J = i - h * 65536, i = B + h + 65535, h = Math.floor(i / 65536), B = i - h * 65536, A += h - 1 + 37 * (h - 1), a[0] = A, a[1] = m, a[2] = M, a[3] = C, a[4] = W, a[5] = O, a[6] = fe, a[7] = P, a[8] = V, a[9] = q, a[10] = te, a[11] = ee, a[12] = X, a[13] = $, a[14] = J, a[15] = B;
    }
    function He(a, d) {
      ue(a, d, d);
    }
    function zr(a, d) {
      var u = n(), i;
      for (i = 0; i < 16; i++) u[i] = d[i];
      for (i = 253; i >= 0; i--)
        He(u, u), i !== 2 && i !== 4 && ue(u, u, d);
      for (i = 0; i < 16; i++) a[i] = u[i];
    }
    function kr(a, d) {
      var u = n(), i;
      for (i = 0; i < 16; i++) u[i] = d[i];
      for (i = 250; i >= 0; i--)
        He(u, u), i !== 1 && ue(u, u, d);
      for (i = 0; i < 16; i++) a[i] = u[i];
    }
    function Gt(a, d, u) {
      var i = new Uint8Array(32), h = new Float64Array(80), A, m, M = n(), C = n(), W = n(), O = n(), fe = n(), P = n();
      for (m = 0; m < 31; m++) i[m] = d[m];
      for (i[31] = d[31] & 127 | 64, i[0] &= 248, En(h, u), m = 0; m < 16; m++)
        C[m] = h[m], O[m] = M[m] = W[m] = 0;
      for (M[0] = O[0] = 1, m = 254; m >= 0; --m)
        A = i[m >>> 3] >>> (m & 7) & 1, dt(M, C, A), dt(W, O, A), Ge(fe, M, W), Ve(M, M, W), Ge(W, C, O), Ve(C, C, O), He(O, fe), He(P, M), ue(M, W, M), ue(W, C, fe), Ge(fe, M, W), Ve(M, M, W), He(C, M), Ve(W, O, P), ue(M, W, f), Ge(M, M, O), ue(W, W, M), ue(M, O, P), ue(O, C, h), He(C, fe), dt(M, C, A), dt(W, O, A);
      for (m = 0; m < 16; m++)
        h[m + 16] = M[m], h[m + 32] = W[m], h[m + 48] = C[m], h[m + 64] = O[m];
      var V = h.subarray(32), q = h.subarray(16);
      return zr(V, V), ue(q, q, V), It(a, q), 0;
    }
    function Vt(a, d) {
      return Gt(a, d, o);
    }
    function Or(a, d) {
      return r(d, 32), Vt(a, d);
    }
    function Zt(a, d, u) {
      var i = new Uint8Array(32);
      return Gt(i, u, d), ye(a, s, i, De);
    }
    var Lr = ze, Wi = Ee;
    function Qi(a, d, u, i, h, A) {
      var m = new Uint8Array(32);
      return Zt(m, h, A), Lr(a, d, u, i, m);
    }
    function Ki(a, d, u, i, h, A) {
      var m = new Uint8Array(32);
      return Zt(m, h, A), Wi(a, d, u, i, m);
    }
    var jr = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function Pr(a, d, u, i) {
      for (var h = new Int32Array(16), A = new Int32Array(16), m, M, C, W, O, fe, P, V, q, te, ee, X, $, J, B, Q, j, R, F, k, v, E, D, T, N, U, G = a[0], ne = a[1], se = a[2], re = a[3], g = a[4], oe = a[5], pe = a[6], ge = a[7], ie = d[0], de = d[1], he = d[2], Ne = d[3], Ae = d[4], Te = d[5], Ie = d[6], Me = d[7], Ue = 0; i >= 128; ) {
        for (F = 0; F < 16; F++)
          k = 8 * F + Ue, h[F] = u[k + 0] << 24 | u[k + 1] << 16 | u[k + 2] << 8 | u[k + 3], A[F] = u[k + 4] << 24 | u[k + 5] << 16 | u[k + 6] << 8 | u[k + 7];
        for (F = 0; F < 80; F++)
          if (m = G, M = ne, C = se, W = re, O = g, fe = oe, P = pe, V = ge, q = ie, te = de, ee = he, X = Ne, $ = Ae, J = Te, B = Ie, Q = Me, v = ge, E = Me, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = (g >>> 14 | Ae << 18) ^ (g >>> 18 | Ae << 14) ^ (Ae >>> 9 | g << 23), E = (Ae >>> 14 | g << 18) ^ (Ae >>> 18 | g << 14) ^ (g >>> 9 | Ae << 23), D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, v = g & oe ^ ~g & pe, E = Ae & Te ^ ~Ae & Ie, D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, v = jr[F * 2], E = jr[F * 2 + 1], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, v = h[F % 16], E = A[F % 16], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, j = N & 65535 | U << 16, R = D & 65535 | T << 16, v = j, E = R, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = (G >>> 28 | ie << 4) ^ (ie >>> 2 | G << 30) ^ (ie >>> 7 | G << 25), E = (ie >>> 28 | G << 4) ^ (G >>> 2 | ie << 30) ^ (G >>> 7 | ie << 25), D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, v = G & ne ^ G & se ^ ne & se, E = ie & de ^ ie & he ^ de & he, D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, V = N & 65535 | U << 16, Q = D & 65535 | T << 16, v = W, E = X, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = j, E = R, D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, W = N & 65535 | U << 16, X = D & 65535 | T << 16, ne = m, se = M, re = C, g = W, oe = O, pe = fe, ge = P, G = V, de = q, he = te, Ne = ee, Ae = X, Te = $, Ie = J, Me = B, ie = Q, F % 16 === 15)
            for (k = 0; k < 16; k++)
              v = h[k], E = A[k], D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = h[(k + 9) % 16], E = A[(k + 9) % 16], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, j = h[(k + 1) % 16], R = A[(k + 1) % 16], v = (j >>> 1 | R << 31) ^ (j >>> 8 | R << 24) ^ j >>> 7, E = (R >>> 1 | j << 31) ^ (R >>> 8 | j << 24) ^ (R >>> 7 | j << 25), D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, j = h[(k + 14) % 16], R = A[(k + 14) % 16], v = (j >>> 19 | R << 13) ^ (R >>> 29 | j << 3) ^ j >>> 6, E = (R >>> 19 | j << 13) ^ (j >>> 29 | R << 3) ^ (R >>> 6 | j << 26), D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, h[k] = N & 65535 | U << 16, A[k] = D & 65535 | T << 16;
        v = G, E = ie, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[0], E = d[0], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[0] = G = N & 65535 | U << 16, d[0] = ie = D & 65535 | T << 16, v = ne, E = de, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[1], E = d[1], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[1] = ne = N & 65535 | U << 16, d[1] = de = D & 65535 | T << 16, v = se, E = he, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[2], E = d[2], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[2] = se = N & 65535 | U << 16, d[2] = he = D & 65535 | T << 16, v = re, E = Ne, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[3], E = d[3], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[3] = re = N & 65535 | U << 16, d[3] = Ne = D & 65535 | T << 16, v = g, E = Ae, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[4], E = d[4], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[4] = g = N & 65535 | U << 16, d[4] = Ae = D & 65535 | T << 16, v = oe, E = Te, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[5], E = d[5], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[5] = oe = N & 65535 | U << 16, d[5] = Te = D & 65535 | T << 16, v = pe, E = Ie, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[6], E = d[6], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[6] = pe = N & 65535 | U << 16, d[6] = Ie = D & 65535 | T << 16, v = ge, E = Me, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[7], E = d[7], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[7] = ge = N & 65535 | U << 16, d[7] = Me = D & 65535 | T << 16, Ue += 128, i -= 128;
      }
      return i;
    }
    function yt(a, d, u) {
      var i = new Int32Array(8), h = new Int32Array(8), A = new Uint8Array(256), m, M = u;
      for (i[0] = 1779033703, i[1] = 3144134277, i[2] = 1013904242, i[3] = 2773480762, i[4] = 1359893119, i[5] = 2600822924, i[6] = 528734635, i[7] = 1541459225, h[0] = 4089235720, h[1] = 2227873595, h[2] = 4271175723, h[3] = 1595750129, h[4] = 2917565137, h[5] = 725511199, h[6] = 4215389547, h[7] = 327033209, Pr(i, h, d, u), u %= 128, m = 0; m < u; m++) A[m] = d[M - u + m];
      for (A[u] = 128, u = 256 - 128 * (u < 112 ? 1 : 0), A[u - 9] = 0, I(A, u - 8, M / 536870912 | 0, M << 3), Pr(i, h, A, u), m = 0; m < 8; m++) I(a, 8 * m, i[m], h[m]);
      return 0;
    }
    function qt(a, d) {
      var u = n(), i = n(), h = n(), A = n(), m = n(), M = n(), C = n(), W = n(), O = n();
      Ve(u, a[1], a[0]), Ve(O, d[1], d[0]), ue(u, u, O), Ge(i, a[0], a[1]), Ge(O, d[0], d[1]), ue(i, i, O), ue(h, a[3], d[3]), ue(h, h, y), ue(A, a[2], d[2]), Ge(A, A, A), Ve(m, i, u), Ve(M, A, h), Ge(C, A, h), Ge(W, i, u), ue(a[0], m, M), ue(a[1], W, C), ue(a[2], C, M), ue(a[3], m, W);
    }
    function _r(a, d, u) {
      var i;
      for (i = 0; i < 4; i++)
        dt(a[i], d[i], u);
    }
    function bn(a, d) {
      var u = n(), i = n(), h = n();
      zr(h, d[2]), ue(u, d[0], h), ue(i, d[1], h), It(a, i), a[31] ^= Cr(u) << 7;
    }
    function Tn(a, d, u) {
      var i, h;
      for (Ce(a[0], c), Ce(a[1], l), Ce(a[2], l), Ce(a[3], c), h = 255; h >= 0; --h)
        i = u[h / 8 | 0] >> (h & 7) & 1, _r(a, d, i), qt(d, a), qt(a, a), _r(a, d, i);
    }
    function Xt(a, d) {
      var u = [n(), n(), n(), n()];
      Ce(u[0], w), Ce(u[1], b), Ce(u[2], l), ue(u[3], w, b), Tn(a, u, d);
    }
    function In(a, d, u) {
      var i = new Uint8Array(64), h = [n(), n(), n(), n()], A;
      for (u || r(d, 32), yt(i, d, 32), i[0] &= 248, i[31] &= 127, i[31] |= 64, Xt(h, i), bn(a, h), A = 0; A < 32; A++) d[A + 32] = a[A];
      return 0;
    }
    var Jt = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function Mn(a, d) {
      var u, i, h, A;
      for (i = 63; i >= 32; --i) {
        for (u = 0, h = i - 32, A = i - 12; h < A; ++h)
          d[h] += u - 16 * d[i] * Jt[h - (i - 32)], u = Math.floor((d[h] + 128) / 256), d[h] -= u * 256;
        d[h] += u, d[i] = 0;
      }
      for (u = 0, h = 0; h < 32; h++)
        d[h] += u - (d[31] >> 4) * Jt[h], u = d[h] >> 8, d[h] &= 255;
      for (h = 0; h < 32; h++) d[h] -= u * Jt[h];
      for (i = 0; i < 32; i++)
        d[i + 1] += d[i] >> 8, a[i] = d[i] & 255;
    }
    function Nn(a) {
      var d = new Float64Array(64), u;
      for (u = 0; u < 64; u++) d[u] = a[u];
      for (u = 0; u < 64; u++) a[u] = 0;
      Mn(a, d);
    }
    function Br(a, d, u, i) {
      var h = new Uint8Array(64), A = new Uint8Array(64), m = new Uint8Array(64), M, C, W = new Float64Array(64), O = [n(), n(), n(), n()];
      yt(h, i, 32), h[0] &= 248, h[31] &= 127, h[31] |= 64;
      var fe = u + 64;
      for (M = 0; M < u; M++) a[64 + M] = d[M];
      for (M = 0; M < 32; M++) a[32 + M] = h[32 + M];
      for (yt(m, a.subarray(32), u + 32), Nn(m), Xt(O, m), bn(a, O), M = 32; M < 64; M++) a[M] = i[M];
      for (yt(A, a, u + 64), Nn(A), M = 0; M < 64; M++) W[M] = 0;
      for (M = 0; M < 32; M++) W[M] = m[M];
      for (M = 0; M < 32; M++)
        for (C = 0; C < 32; C++)
          W[M + C] += A[M] * h[C];
      return Mn(a.subarray(32), W), fe;
    }
    function Hi(a, d) {
      var u = n(), i = n(), h = n(), A = n(), m = n(), M = n(), C = n();
      return Ce(a[2], l), En(a[1], d), He(h, a[1]), ue(A, h, p), Ve(h, h, a[2]), Ge(A, a[2], A), He(m, A), He(M, m), ue(C, M, m), ue(u, C, h), ue(u, u, A), kr(u, u), ue(u, u, h), ue(u, u, A), ue(u, u, A), ue(a[0], u, A), He(i, a[0]), ue(i, i, A), Ur(i, h) && ue(a[0], a[0], x), He(i, a[0]), ue(i, i, A), Ur(i, h) ? -1 : (Cr(a[0]) === d[31] >> 7 && Ve(a[0], c, a[0]), ue(a[3], a[0], a[1]), 0);
    }
    function xn(a, d, u, i) {
      var h, A = new Uint8Array(32), m = new Uint8Array(64), M = [n(), n(), n(), n()], C = [n(), n(), n(), n()];
      if (u < 64 || Hi(C, i)) return -1;
      for (h = 0; h < u; h++) a[h] = d[h];
      for (h = 0; h < 32; h++) a[h + 32] = i[h];
      if (yt(m, a, u), Nn(m), Tn(M, C, m), Xt(C, d.subarray(32)), qt(M, C), bn(A, M), u -= 64, Z(d, 0, A, 0)) {
        for (h = 0; h < u; h++) a[h] = 0;
        return -1;
      }
      for (h = 0; h < u; h++) a[h] = d[h + 64];
      return u;
    }
    var Sn = 32, $t = 24, Ut = 32, Mt = 16, Ct = 32, en = 32, zt = 32, kt = 32, Dn = 32, Rr = $t, Yi = Ut, Gi = Mt, st = 64, wt = 32, Nt = 64, Un = 32, Cn = 64;
    e.lowlevel = {
      crypto_core_hsalsa20: ye,
      crypto_stream_xor: ae,
      crypto_stream: tt,
      crypto_stream_salsa20_xor: Re,
      crypto_stream_salsa20: Le,
      crypto_onetimeauth: Y,
      crypto_onetimeauth_verify: K,
      crypto_verify_16: S,
      crypto_verify_32: Z,
      crypto_secretbox: ze,
      crypto_secretbox_open: Ee,
      crypto_scalarmult: Gt,
      crypto_scalarmult_base: Vt,
      crypto_box_beforenm: Zt,
      crypto_box_afternm: Lr,
      crypto_box: Qi,
      crypto_box_open: Ki,
      crypto_box_keypair: Or,
      crypto_hash: yt,
      crypto_sign: Br,
      crypto_sign_keypair: In,
      crypto_sign_open: xn,
      crypto_secretbox_KEYBYTES: Sn,
      crypto_secretbox_NONCEBYTES: $t,
      crypto_secretbox_ZEROBYTES: Ut,
      crypto_secretbox_BOXZEROBYTES: Mt,
      crypto_scalarmult_BYTES: Ct,
      crypto_scalarmult_SCALARBYTES: en,
      crypto_box_PUBLICKEYBYTES: zt,
      crypto_box_SECRETKEYBYTES: kt,
      crypto_box_BEFORENMBYTES: Dn,
      crypto_box_NONCEBYTES: Rr,
      crypto_box_ZEROBYTES: Yi,
      crypto_box_BOXZEROBYTES: Gi,
      crypto_sign_BYTES: st,
      crypto_sign_PUBLICKEYBYTES: wt,
      crypto_sign_SECRETKEYBYTES: Nt,
      crypto_sign_SEEDBYTES: Un,
      crypto_hash_BYTES: Cn,
      gf: n,
      D: p,
      L: Jt,
      pack25519: It,
      unpack25519: En,
      M: ue,
      A: Ge,
      S: He,
      Z: Ve,
      pow2523: kr,
      add: qt,
      set25519: Ce,
      modL: Mn,
      scalarmult: Tn,
      scalarbase: Xt
    };
    function Fr(a, d) {
      if (a.length !== Sn) throw new Error("bad key size");
      if (d.length !== $t) throw new Error("bad nonce size");
    }
    function Vi(a, d) {
      if (a.length !== zt) throw new Error("bad public key size");
      if (d.length !== kt) throw new Error("bad secret key size");
    }
    function Qe() {
      for (var a = 0; a < arguments.length; a++)
        if (!(arguments[a] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function Wr(a) {
      for (var d = 0; d < a.length; d++) a[d] = 0;
    }
    e.randomBytes = function(a) {
      var d = new Uint8Array(a);
      return r(d, a), d;
    }, e.secretbox = function(a, d, u) {
      Qe(a, d, u), Fr(u, d);
      for (var i = new Uint8Array(Ut + a.length), h = new Uint8Array(i.length), A = 0; A < a.length; A++) i[A + Ut] = a[A];
      return ze(h, i, i.length, d, u), h.subarray(Mt);
    }, e.secretbox.open = function(a, d, u) {
      Qe(a, d, u), Fr(u, d);
      for (var i = new Uint8Array(Mt + a.length), h = new Uint8Array(i.length), A = 0; A < a.length; A++) i[A + Mt] = a[A];
      return i.length < 32 || Ee(h, i, i.length, d, u) !== 0 ? null : h.subarray(Ut);
    }, e.secretbox.keyLength = Sn, e.secretbox.nonceLength = $t, e.secretbox.overheadLength = Mt, e.scalarMult = function(a, d) {
      if (Qe(a, d), a.length !== en) throw new Error("bad n size");
      if (d.length !== Ct) throw new Error("bad p size");
      var u = new Uint8Array(Ct);
      return Gt(u, a, d), u;
    }, e.scalarMult.base = function(a) {
      if (Qe(a), a.length !== en) throw new Error("bad n size");
      var d = new Uint8Array(Ct);
      return Vt(d, a), d;
    }, e.scalarMult.scalarLength = en, e.scalarMult.groupElementLength = Ct, e.box = function(a, d, u, i) {
      var h = e.box.before(u, i);
      return e.secretbox(a, d, h);
    }, e.box.before = function(a, d) {
      Qe(a, d), Vi(a, d);
      var u = new Uint8Array(Dn);
      return Zt(u, a, d), u;
    }, e.box.after = e.secretbox, e.box.open = function(a, d, u, i) {
      var h = e.box.before(u, i);
      return e.secretbox.open(a, d, h);
    }, e.box.open.after = e.secretbox.open, e.box.keyPair = function() {
      var a = new Uint8Array(zt), d = new Uint8Array(kt);
      return Or(a, d), { publicKey: a, secretKey: d };
    }, e.box.keyPair.fromSecretKey = function(a) {
      if (Qe(a), a.length !== kt)
        throw new Error("bad secret key size");
      var d = new Uint8Array(zt);
      return Vt(d, a), { publicKey: d, secretKey: new Uint8Array(a) };
    }, e.box.publicKeyLength = zt, e.box.secretKeyLength = kt, e.box.sharedKeyLength = Dn, e.box.nonceLength = Rr, e.box.overheadLength = e.secretbox.overheadLength, e.sign = function(a, d) {
      if (Qe(a, d), d.length !== Nt)
        throw new Error("bad secret key size");
      var u = new Uint8Array(st + a.length);
      return Br(u, a, a.length, d), u;
    }, e.sign.open = function(a, d) {
      if (Qe(a, d), d.length !== wt)
        throw new Error("bad public key size");
      var u = new Uint8Array(a.length), i = xn(u, a, a.length, d);
      if (i < 0) return null;
      for (var h = new Uint8Array(i), A = 0; A < h.length; A++) h[A] = u[A];
      return h;
    }, e.sign.detached = function(a, d) {
      for (var u = e.sign(a, d), i = new Uint8Array(st), h = 0; h < i.length; h++) i[h] = u[h];
      return i;
    }, e.sign.detached.verify = function(a, d, u) {
      if (Qe(a, d, u), d.length !== st)
        throw new Error("bad signature size");
      if (u.length !== wt)
        throw new Error("bad public key size");
      var i = new Uint8Array(st + a.length), h = new Uint8Array(st + a.length), A;
      for (A = 0; A < st; A++) i[A] = d[A];
      for (A = 0; A < a.length; A++) i[A + st] = a[A];
      return xn(h, i, i.length, u) >= 0;
    }, e.sign.keyPair = function() {
      var a = new Uint8Array(wt), d = new Uint8Array(Nt);
      return In(a, d), { publicKey: a, secretKey: d };
    }, e.sign.keyPair.fromSecretKey = function(a) {
      if (Qe(a), a.length !== Nt)
        throw new Error("bad secret key size");
      for (var d = new Uint8Array(wt), u = 0; u < d.length; u++) d[u] = a[32 + u];
      return { publicKey: d, secretKey: new Uint8Array(a) };
    }, e.sign.keyPair.fromSeed = function(a) {
      if (Qe(a), a.length !== Un)
        throw new Error("bad seed size");
      for (var d = new Uint8Array(wt), u = new Uint8Array(Nt), i = 0; i < 32; i++) u[i] = a[i];
      return In(d, u, !0), { publicKey: d, secretKey: u };
    }, e.sign.publicKeyLength = wt, e.sign.secretKeyLength = Nt, e.sign.seedLength = Un, e.sign.signatureLength = st, e.hash = function(a) {
      Qe(a);
      var d = new Uint8Array(Cn);
      return yt(d, a, a.length), d;
    }, e.hash.hashLength = Cn, e.verify = function(a, d) {
      return Qe(a, d), a.length === 0 || d.length === 0 || a.length !== d.length ? !1 : z(a, 0, d, 0, a.length) === 0;
    }, e.setPRNG = function(a) {
      r = a;
    }, function() {
      var a = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (a && a.getRandomValues) {
        var d = 65536;
        e.setPRNG(function(u, i) {
          var h, A = new Uint8Array(i);
          for (h = 0; h < i; h += d)
            a.getRandomValues(A.subarray(h, h + Math.min(i - h, d)));
          for (h = 0; h < i; h++) u[h] = A[h];
          Wr(A);
        });
      } else typeof yA < "u" && (a = vA, a && a.randomBytes && e.setPRNG(function(u, i) {
        var h, A = a.randomBytes(i);
        for (h = 0; h < i; h++) u[h] = A[h];
        Wr(A);
      }));
    }();
  })(t.exports ? t.exports : self.nacl = self.nacl || {});
})(wA);
function EA(t, e) {
  const n = As.encodeBase64(t);
  return e ? encodeURIComponent(n) : n;
}
function bA(t, e) {
  return e && (t = decodeURIComponent(t)), As.decodeBase64(t);
}
function TA(t, e = !1) {
  let n;
  return t instanceof Uint8Array ? n = t : (typeof t != "string" && (t = JSON.stringify(t)), n = As.decodeUTF8(t)), EA(n, e);
}
function IA(t, e = !1) {
  const n = bA(t, e);
  return {
    toString() {
      return As.encodeUTF8(n);
    },
    toObject() {
      try {
        return JSON.parse(As.encodeUTF8(n));
      } catch {
        return null;
      }
    },
    toUint8Array() {
      return n;
    }
  };
}
const Ps = {
  encode: TA,
  decode: IA
};
new AbortController();
const MA = (t) => {
  var e;
  if (!t) return new Error("JWT Token not found. ");
  const n = Vf(t);
  if ((n == null ? void 0 : n.exp) < Date.now() / 1e3)
    throw new Error("JWT Token expired. Please login again! ");
  if ((e = n == null ? void 0 : n["https://hasura.io/jwt/claims"]) != null && e["x-hasura-user-id"])
    return [n["https://hasura.io/jwt/claims"]["x-hasura-user-id"], t];
  throw new Error("User id not found in JWT Token");
}, NA = gt`
  mutation TGLoginMutation($appId: String = "", $initData: String = "") {
    tgLogin(appId: $appId, initData: $initData)
  }
`, xA = gt`
  mutation TGLoginMutation($appId: String = "", $initData: String = "", $shortId: String = "") {
    tgLogin(appId: $appId, initData: $initData, shortId: $shortId)
  }
`, SA = gt`
  mutation tgWidgetLoginMutation($appId: String = "", $authData: String = "") {
    tgWidgetLogin(appId: $appId, authData: $authData)
  }
`, DA = gt`
  mutation tgWidgetLoginMutation(
    $appId: String = ""
    $authData: String = ""
    $shortId: String = ""
  ) {
    tgWidgetLogin(appId: $appId, authData: $authData, shortId: $shortId)
  }
`, UA = gt`
  query CheckUserIsExistQueryByTgId {
    telegramUser {
      walletUserId
      tgId
    }
  }
`, $c = gt`
  query UserWalletAddressQuery($id: uuid = "") {
    walletUserByPk(id: $id) {
      sub_wallets {
        address
        publicKey
      }
      google_user {
        email
      }
      telegram_user {
        firstName
        lastName
        photoUrl
        userName
      }
      twitter_user {
        name
        userName
      }
    }
  }
`, CA = gt`
  mutation CreateOrderQuery($appId: String = "", $payload: String = "") {
    createOrder(appId: $appId, payload: $payload, encode: "base64")
  }
`, zA = gt`
  mutation createSignatureMutation($appId: String = "", $transactionHex: String = "") {
    createSignature(appId: $appId, transactionHex: $transactionHex)
  }
`, kA = gt`
  mutation createSignMessageMutation(
    $appId: String = ""
    $message: String = ""
    $nonce: String = ""
  ) {
    createSignMessage(appId: $appId, nonce: $nonce, message: $message) {
      fullMessage
      message
      nonce
      prefix
      signature
    }
  }
`, OA = gt`
  query simulateOrderQuery($payload: String = "") {
    simulateOrder(payload: $payload, encode: "base64")
  }
`, LA = gt`
  mutation confirmOrderQuery($orderId: String = "") {
    confirmOrder(orderId: $orderId)
  }
`, jA = gt`
  query fetchOrderQuery($id: uuid = "") {
    orderByPk(id: $id) {
      id
      createdAt
      payload
      decodedPayload
      status
      type
      updatedAt
      walletUserId
      applicationId
      hash
      type
      transactions {
        hash
        type
      }
    }
  }
`;
gt`
  query fetchOrderHashQuery($orderId: String = "") {
    getOrderHash(orderId: $orderId)
  }
`;
const PA = gt`
  query fetchOrderListQuery(
    $walletUserId: uuid = ""
    $limit: Int = 10
    $offset: Int = 0
    $status: [Int] = []
  ) {
    order(
      where: { walletUserId: { _eq: $walletUserId } }
      limit: $limit
      offset: $offset
      orderBy: { createdAt: DESC }
    ) {
      applicationId
      createdAt
      id
      payload
      decodedPayload
      status
      transactionSeqNo
      type
      updatedAt
      walletUserId
      hash
      gasFee
      transactions {
        hash
        gasFee
        createdAt
        status
        type
      }
    }
    orderAggregate(where: { walletUserId: { _eq: $walletUserId } }) {
      aggregate {
        count
      }
    }
  }
`, _A = gt`
  mutation bindGoogleQuery($address: String = "", $idToken: String = "") {
    googleBind(address: $address, idToken: $idToken)
  }
`, BA = gt`
  mutation createOrderWithCodeMutation(
    $appId: String = ""
    $authCode: String = ""
    $payload: String = ""
  ) {
    createOrderWithCode(appId: $appId, authCode: $authCode, payload: $payload, encode: "base64")
  }
`, po = (t) => ({
  function: t.function,
  functionArguments: t.functionArguments || t.arguments,
  typeArguments: t.typeArguments || t.type_arguments
});
var ts = /* @__PURE__ */ ((t) => (t[t.PENDING = 0] = "PENDING", t[t.CONFIRMED = 1] = "CONFIRMED", t[t.EXECUTED = 2] = "EXECUTED", t[t.SUCCESS = 3] = "SUCCESS", t[t.FAIL = 4] = "FAIL", t[t.CANCELED = 5] = "CANCELED", t))(ts || {});
const eu = {
  testnet: "https://hasura-wallet.mizu.one/v1/graphql",
  mainnet: "https://api.mz.xyz/v1/graphql/"
}, RA = "https://mizu.io/keyless_google";
class os {
  /**
   * Initialize MizuWallet SDK Core Client
   *
   * @param args.appId - Application ID
   * @param args.network - Network.MAINNET | Network.TESTNET
   */
  constructor(e) {
    if (tr(this, "appId"), tr(this, "network"), tr(this, "graphqlEndPoint", ""), tr(this, "userId", ""), tr(this, "jwtToken", ""), tr(this, "initialized", !1), !e.appId) throw new Error("appId is required");
    if (!e.network) throw new Error("network is required");
    this.appId = e.appId, this.network = e.network, this.graphqlEndPoint = eu[this.network], this.initialized = !0;
  }
  /**
   * Check if MizuWallet SDK Core Client is initialized
   */
  checkInitialized() {
    if (!this.initialized) throw new Error("MizuWallet SDK Core Client not initialized");
  }
  /**
   * Check if JWT Token is available
   */
  checkJWTToken() {
    if (!this.jwtToken) throw new Error("JWT Token not found. Please login first.");
  }
  /**
   * Decode JWT Token
   */
  static decodeJWTToken(e) {
    const [n, r] = MA(e);
    return [n, r];
  }
  /**
   * Clone MizuWallet SDK Core Client
   *
   * @param args.appId - Application ID
   * @param args.network - Network.MAINNET | Network.TESTNET
   * @param args.jwtToken - JWT Token
   */
  static clone(e) {
    if (!e.appId) throw new Error("appId is required");
    if (!e.network) throw new Error("network is required");
    if (!e.jwtToken) throw new Error("jwtToken is required");
    const n = new os({ appId: e.appId, network: e.network });
    return [n.userId, n.jwtToken] = os.decodeJWTToken(e.jwtToken), n;
  }
  /**
   * Update network
   * @param network - Network.MAINNET | Network.TESTNET
   */
  updateNetwork(e) {
    this.checkInitialized(), this.network = e, this.graphqlEndPoint = eu[this.network];
  }
  /**
   * Get network info
   */
  get networkInfo() {
    return {
      name: this.network,
      chainId: this.network === Ye.MAINNET ? 1 : 2,
      url: this.network === Ye.MAINNET ? "https://fullnode.mainnet.aptoslabs.com/v1" : "https://fullnode.testnet.aptoslabs.com/v1"
    };
  }
  /**
   *
   *
   */
  login() {
    this.checkInitialized();
  }
  /**
   * Login in TG
   *
   * @param data - initial data of TG, or stringified widget user object
   * @param opt.isWidget - is from login widget
   */
  async loginInTG(e, n) {
    this.checkInitialized();
    let r = "";
    n != null && n.isWidget ? r = (await vt({
      url: this.graphqlEndPoint,
      document: n != null && n.shortID ? DA : SA,
      variables: {
        appId: this.appId,
        authData: Ps.encode(e),
        ...n != null && n.shortID ? { shortId: n.shortID } : {}
      }
    })).tgWidgetLogin : r = (await vt({
      url: this.graphqlEndPoint,
      document: n != null && n.shortID ? xA : NA,
      variables: {
        appId: this.appId,
        initData: e,
        ...n != null && n.shortID ? { shortId: n.shortID } : {}
      }
    })).tgLogin;
    try {
      [this.userId, this.jwtToken] = os.decodeJWTToken(r);
    } catch {
      this.logout();
    }
  }
  /**
   * Check if user exist by TG ID
   *
   * @param tgId
   * @returns
   */
  async isUserExistByTgID(e) {
    var n;
    if (this.checkInitialized(), !e) throw new Error("tgId is required");
    const r = await vt({
      url: this.graphqlEndPoint,
      document: UA,
      variables: {},
      requestHeaders: {
        "x-hasura-tg-id": e
      }
    });
    return ((n = r == null ? void 0 : r.telegramUser) == null ? void 0 : n.length) > 0;
  }
  /**
   * fetch user wallet address
   *
   * @returns
   */
  async getUserWalletAddress() {
    return this.checkInitialized(), this.checkJWTToken(), (await vt({
      url: this.graphqlEndPoint,
      document: $c,
      variables: {
        id: this.userId
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    })).walletUserByPk.sub_wallets[0].address;
  }
  /**
   * fetch user wallet address
   *
   * @returns
   */
  async getUserInfo() {
    return this.checkInitialized(), this.checkJWTToken(), (await vt({
      url: this.graphqlEndPoint,
      document: $c,
      variables: {
        id: this.userId
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    })).walletUserByPk;
  }
  /**
   * Logout
   */
  logout() {
    this.userId = "", this.jwtToken = "";
  }
  /**
   *
   * @param args.redirect_uri
   */
  async startBindGoogle(e) {
    this.checkInitialized(), this.checkJWTToken();
    const n = new URLSearchParams({
      token: this.jwtToken,
      appId: this.appId,
      ...e
    });
    window.open(`${RA}?${n.toString()}`, "_blank");
  }
  /**
   *
   * @param args.address keyless address
   * @param args.idToken google jwt
   * @returns
   */
  async bindGoogleAccount(e) {
    return this.checkInitialized(), this.checkJWTToken(), await vt({
      url: this.graphqlEndPoint,
      document: _A,
      variables: {
        ...e
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
  }
  /**
   * Simulate Order
   *
   * @param args.payload TransactionPayload
   */
  async simulateOrder(e) {
    this.checkInitialized(), this.checkJWTToken();
    const n = await vt({
      url: this.graphqlEndPoint,
      document: OA,
      variables: {
        payload: Ps.encode(po(e.payload))
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return n == null ? void 0 : n.simulateOrder;
  }
  /**
   * Create Order
   *
   * @param args.payload TransactionPayload
   * @returns
   */
  async createOrder(e) {
    this.checkInitialized(), this.checkJWTToken();
    const n = await vt({
      url: this.graphqlEndPoint,
      document: CA,
      variables: {
        appId: this.appId,
        payload: Ps.encode(po(e.payload))
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return n == null ? void 0 : n.createOrder;
  }
  /**
   * Create Order with Code
   *
   * @param args.payload
   * @param args.code
   * @returns
   */
  async createOrderWithCode(e) {
    this.checkInitialized();
    const n = await vt({
      url: this.graphqlEndPoint,
      document: BA,
      variables: {
        appId: this.appId,
        authCode: e.code,
        payload: Ps.encode(po(e.payload))
      },
      requestHeaders: {}
    });
    return n == null ? void 0 : n.createOrderWithCode;
  }
  /**
   * Create Signature
   *
   * @param args.transactionHex AnyRawTransaction.bscToHex().toStringWithoutPrefix()
   * @returns
   */
  async createSignature(e) {
    this.checkInitialized(), this.checkJWTToken();
    const n = await vt({
      url: this.graphqlEndPoint,
      document: zA,
      variables: {
        appId: this.appId,
        transactionHex: e.transactionHex
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return n == null ? void 0 : n.createSignature;
  }
  /**
   * Sign Message
   *
   * @param args.message message to sign
   * @param args.nonce nonce
   * @returns
   */
  async signMessage(e) {
    this.checkInitialized(), this.checkJWTToken();
    const n = await vt({
      url: this.graphqlEndPoint,
      document: kA,
      variables: {
        appId: this.appId,
        ...e
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return n == null ? void 0 : n.createSignMessage;
  }
  /**
   * User interactive
   *
   * @param args.orderId Order ID
   * return bool
   */
  async confirmOrder(e) {
    this.checkInitialized(), this.checkJWTToken();
    const n = await vt({
      url: this.graphqlEndPoint,
      document: LA,
      variables: {
        orderId: e.orderId
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return n == null ? void 0 : n.confirmOrder;
  }
  /**
   * Fetch Order By ID
   *
   * @param args.id order.id
   * @returns
   */
  async fetchOrder(e) {
    this.checkInitialized(), this.checkJWTToken();
    const n = await vt({
      url: this.graphqlEndPoint,
      document: jA,
      variables: {
        id: e.id
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    if (!n.orderByPk) throw new Error("Order not found");
    return {
      ...n.orderByPk,
      payload: n.orderByPk.decodedPayload
    };
  }
  /**
   * Wait for order
   *
   * @param args.orderId order.id
   * @returns
   */
  async waitForOrder(e) {
    let n = await this.fetchOrder({
      id: e.orderId
    }), r = 20;
    for (; r-- > 0 && ![ts.SUCCESS, ts.FAIL, ts.CANCELED].includes(n.status); )
      await new Promise((s) => setTimeout(s, 5e3)), n = await this.fetchOrder({
        id: e.orderId
      });
    if (n.status === ts.FAIL)
      throw new Error("Order failed");
    return n;
  }
  /**
   * fetch order list
   *
   * @param args.walletUserId
   * @param args.limit
   * @param args.offset
   *
   * @returns
   */
  async fetchOrderList(e) {
    this.checkInitialized(), this.checkJWTToken();
    const { limit: n = 10, offset: r = 0 } = e || {}, s = await vt({
      url: this.graphqlEndPoint,
      document: PA,
      variables: {
        walletUserId: this.userId,
        limit: n,
        offset: r
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return {
      data: s == null ? void 0 : s.order.map((o) => {
        let c = {};
        try {
          c = o.decodedPayload;
        } catch (l) {
          console.error(l);
        }
        return {
          ...o,
          payload: c
        };
      }),
      pagination: {
        total: s == null ? void 0 : s.orderAggregate.aggregate.count,
        limit: n,
        offset: r
      }
    };
  }
}
var FA = Object.defineProperty, WA = (t, e, n) => e in t ? FA(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, je = (t, e, n) => WA(t, typeof e != "symbol" ? e + "" : e, n), QA = "aptos:devnet", KA = "aptos:testnet", HA = "aptos:localnet", YA = "aptos:mainnet", GA = [QA, KA, HA, YA], ti = ((t) => (t[t.Unauthorized = 4100] = "Unauthorized", t[t.InternalError = -30001] = "InternalError", t))(ti || {}), tu = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." } }), go = class wf extends Error {
  constructor(e, n) {
    var r, s;
    super(n ?? ((r = tu[e]) == null ? void 0 : r.message) ?? "Unknown error occurred"), this.code = e, this.status = ((s = tu[e]) == null ? void 0 : s.status) ?? "Unknown error", this.name = "AptosWalletError", Object.setPrototypeOf(this, wf.prototype);
  }
}, nn = ((t) => (t.APPROVED = "Approved", t.REJECTED = "Rejected", t))(nn || {});
const VA = "https://t.me/mizuwallet_bot/mizuwallet", ZA = "https://t.me/mizuwallet_bot/mizuwallet_testnet", qA = (t) => t === Ye.TESTNET ? ZA : VA, Ya = {
  CONNECT: "[Mizu Wallet Connection] ",
  TRANSACTION: "[Mizu Wallet Transaction] "
}, XA = "07418a1b-9574-4449-bd34-2146db60b05c", JA = "0c460c1a-5175-4383-b1c2-35b934f5aa71", $A = (t) => t === Ye.TESTNET ? JA : XA, e2 = "Mizu Wallet", t2 = "https://mizu.io", n2 = "data:image/png;base64,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";
var r2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof Je.global < "u" ? Je.global : typeof self < "u" ? self : {};
function Af(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function s2(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var s = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, s.get ? s : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
var mf = { exports: {} };
(function(t) {
  (function(e, n) {
    t.exports ? t.exports = n() : (e.nacl || (e.nacl = {}), e.nacl.util = n());
  })(r2, function() {
    var e = {};
    function n(r) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(r))
        throw new TypeError("invalid encoding");
    }
    return e.decodeUTF8 = function(r) {
      if (typeof r != "string") throw new TypeError("expected string");
      var s, o = unescape(encodeURIComponent(r)), c = new Uint8Array(o.length);
      for (s = 0; s < o.length; s++) c[s] = o.charCodeAt(s);
      return c;
    }, e.encodeUTF8 = function(r) {
      var s, o = [];
      for (s = 0; s < r.length; s++) o.push(String.fromCharCode(r[s]));
      return decodeURIComponent(escape(o.join("")));
    }, typeof atob > "u" ? typeof Je.Buffer.from < "u" ? (e.encodeBase64 = function(r) {
      return Je.Buffer.from(r).toString("base64");
    }, e.decodeBase64 = function(r) {
      return n(r), new Uint8Array(Array.prototype.slice.call(Je.Buffer.from(r, "base64"), 0));
    }) : (e.encodeBase64 = function(r) {
      return new Je.Buffer(r).toString("base64");
    }, e.decodeBase64 = function(r) {
      return n(r), new Uint8Array(Array.prototype.slice.call(new Je.Buffer(r, "base64"), 0));
    }) : (e.encodeBase64 = function(r) {
      var s, o = [], c = r.length;
      for (s = 0; s < c; s++) o.push(String.fromCharCode(r[s]));
      return btoa(o.join(""));
    }, e.decodeBase64 = function(r) {
      n(r);
      var s, o = atob(r), c = new Uint8Array(o.length);
      for (s = 0; s < o.length; s++) c[s] = o.charCodeAt(s);
      return c;
    }), e;
  });
})(mf);
var i2 = mf.exports;
const ms = /* @__PURE__ */ Af(i2);
function o2(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var vf = { exports: {} };
const a2 = {}, c2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: a2
}, Symbol.toStringTag, { value: "Module" })), u2 = /* @__PURE__ */ s2(c2);
(function(t) {
  (function(e) {
    var n = function(a) {
      var d, u = new Float64Array(16);
      if (a) for (d = 0; d < a.length; d++) u[d] = a[d];
      return u;
    }, r = function() {
      throw new Error("no PRNG");
    }, s = new Uint8Array(16), o = new Uint8Array(32);
    o[0] = 9;
    var c = n(), l = n([1]), f = n([56129, 1]), p = n([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), y = n([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), w = n([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), b = n([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), x = n([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function I(a, d, u, i) {
      a[d] = u >> 24 & 255, a[d + 1] = u >> 16 & 255, a[d + 2] = u >> 8 & 255, a[d + 3] = u & 255, a[d + 4] = i >> 24 & 255, a[d + 5] = i >> 16 & 255, a[d + 6] = i >> 8 & 255, a[d + 7] = i & 255;
    }
    function z(a, d, u, i, h) {
      var A, m = 0;
      for (A = 0; A < h; A++) m |= a[d + A] ^ u[i + A];
      return (1 & m - 1 >>> 8) - 1;
    }
    function S(a, d, u, i) {
      return z(a, d, u, i, 16);
    }
    function Z(a, d, u, i) {
      return z(a, d, u, i, 32);
    }
    function le(a, d, u, i) {
      for (var h = i[0] & 255 | (i[1] & 255) << 8 | (i[2] & 255) << 16 | (i[3] & 255) << 24, A = u[0] & 255 | (u[1] & 255) << 8 | (u[2] & 255) << 16 | (u[3] & 255) << 24, m = u[4] & 255 | (u[5] & 255) << 8 | (u[6] & 255) << 16 | (u[7] & 255) << 24, M = u[8] & 255 | (u[9] & 255) << 8 | (u[10] & 255) << 16 | (u[11] & 255) << 24, C = u[12] & 255 | (u[13] & 255) << 8 | (u[14] & 255) << 16 | (u[15] & 255) << 24, W = i[4] & 255 | (i[5] & 255) << 8 | (i[6] & 255) << 16 | (i[7] & 255) << 24, O = d[0] & 255 | (d[1] & 255) << 8 | (d[2] & 255) << 16 | (d[3] & 255) << 24, fe = d[4] & 255 | (d[5] & 255) << 8 | (d[6] & 255) << 16 | (d[7] & 255) << 24, P = d[8] & 255 | (d[9] & 255) << 8 | (d[10] & 255) << 16 | (d[11] & 255) << 24, V = d[12] & 255 | (d[13] & 255) << 8 | (d[14] & 255) << 16 | (d[15] & 255) << 24, q = i[8] & 255 | (i[9] & 255) << 8 | (i[10] & 255) << 16 | (i[11] & 255) << 24, te = u[16] & 255 | (u[17] & 255) << 8 | (u[18] & 255) << 16 | (u[19] & 255) << 24, ee = u[20] & 255 | (u[21] & 255) << 8 | (u[22] & 255) << 16 | (u[23] & 255) << 24, X = u[24] & 255 | (u[25] & 255) << 8 | (u[26] & 255) << 16 | (u[27] & 255) << 24, $ = u[28] & 255 | (u[29] & 255) << 8 | (u[30] & 255) << 16 | (u[31] & 255) << 24, J = i[12] & 255 | (i[13] & 255) << 8 | (i[14] & 255) << 16 | (i[15] & 255) << 24, B = h, Q = A, j = m, R = M, F = C, k = W, v = O, E = fe, D = P, T = V, N = q, U = te, G = ee, ne = X, se = $, re = J, g, oe = 0; oe < 20; oe += 2)
        g = B + G | 0, F ^= g << 7 | g >>> 25, g = F + B | 0, D ^= g << 9 | g >>> 23, g = D + F | 0, G ^= g << 13 | g >>> 19, g = G + D | 0, B ^= g << 18 | g >>> 14, g = k + Q | 0, T ^= g << 7 | g >>> 25, g = T + k | 0, ne ^= g << 9 | g >>> 23, g = ne + T | 0, Q ^= g << 13 | g >>> 19, g = Q + ne | 0, k ^= g << 18 | g >>> 14, g = N + v | 0, se ^= g << 7 | g >>> 25, g = se + N | 0, j ^= g << 9 | g >>> 23, g = j + se | 0, v ^= g << 13 | g >>> 19, g = v + j | 0, N ^= g << 18 | g >>> 14, g = re + U | 0, R ^= g << 7 | g >>> 25, g = R + re | 0, E ^= g << 9 | g >>> 23, g = E + R | 0, U ^= g << 13 | g >>> 19, g = U + E | 0, re ^= g << 18 | g >>> 14, g = B + R | 0, Q ^= g << 7 | g >>> 25, g = Q + B | 0, j ^= g << 9 | g >>> 23, g = j + Q | 0, R ^= g << 13 | g >>> 19, g = R + j | 0, B ^= g << 18 | g >>> 14, g = k + F | 0, v ^= g << 7 | g >>> 25, g = v + k | 0, E ^= g << 9 | g >>> 23, g = E + v | 0, F ^= g << 13 | g >>> 19, g = F + E | 0, k ^= g << 18 | g >>> 14, g = N + T | 0, U ^= g << 7 | g >>> 25, g = U + N | 0, D ^= g << 9 | g >>> 23, g = D + U | 0, T ^= g << 13 | g >>> 19, g = T + D | 0, N ^= g << 18 | g >>> 14, g = re + se | 0, G ^= g << 7 | g >>> 25, g = G + re | 0, ne ^= g << 9 | g >>> 23, g = ne + G | 0, se ^= g << 13 | g >>> 19, g = se + ne | 0, re ^= g << 18 | g >>> 14;
      B = B + h | 0, Q = Q + A | 0, j = j + m | 0, R = R + M | 0, F = F + C | 0, k = k + W | 0, v = v + O | 0, E = E + fe | 0, D = D + P | 0, T = T + V | 0, N = N + q | 0, U = U + te | 0, G = G + ee | 0, ne = ne + X | 0, se = se + $ | 0, re = re + J | 0, a[0] = B >>> 0 & 255, a[1] = B >>> 8 & 255, a[2] = B >>> 16 & 255, a[3] = B >>> 24 & 255, a[4] = Q >>> 0 & 255, a[5] = Q >>> 8 & 255, a[6] = Q >>> 16 & 255, a[7] = Q >>> 24 & 255, a[8] = j >>> 0 & 255, a[9] = j >>> 8 & 255, a[10] = j >>> 16 & 255, a[11] = j >>> 24 & 255, a[12] = R >>> 0 & 255, a[13] = R >>> 8 & 255, a[14] = R >>> 16 & 255, a[15] = R >>> 24 & 255, a[16] = F >>> 0 & 255, a[17] = F >>> 8 & 255, a[18] = F >>> 16 & 255, a[19] = F >>> 24 & 255, a[20] = k >>> 0 & 255, a[21] = k >>> 8 & 255, a[22] = k >>> 16 & 255, a[23] = k >>> 24 & 255, a[24] = v >>> 0 & 255, a[25] = v >>> 8 & 255, a[26] = v >>> 16 & 255, a[27] = v >>> 24 & 255, a[28] = E >>> 0 & 255, a[29] = E >>> 8 & 255, a[30] = E >>> 16 & 255, a[31] = E >>> 24 & 255, a[32] = D >>> 0 & 255, a[33] = D >>> 8 & 255, a[34] = D >>> 16 & 255, a[35] = D >>> 24 & 255, a[36] = T >>> 0 & 255, a[37] = T >>> 8 & 255, a[38] = T >>> 16 & 255, a[39] = T >>> 24 & 255, a[40] = N >>> 0 & 255, a[41] = N >>> 8 & 255, a[42] = N >>> 16 & 255, a[43] = N >>> 24 & 255, a[44] = U >>> 0 & 255, a[45] = U >>> 8 & 255, a[46] = U >>> 16 & 255, a[47] = U >>> 24 & 255, a[48] = G >>> 0 & 255, a[49] = G >>> 8 & 255, a[50] = G >>> 16 & 255, a[51] = G >>> 24 & 255, a[52] = ne >>> 0 & 255, a[53] = ne >>> 8 & 255, a[54] = ne >>> 16 & 255, a[55] = ne >>> 24 & 255, a[56] = se >>> 0 & 255, a[57] = se >>> 8 & 255, a[58] = se >>> 16 & 255, a[59] = se >>> 24 & 255, a[60] = re >>> 0 & 255, a[61] = re >>> 8 & 255, a[62] = re >>> 16 & 255, a[63] = re >>> 24 & 255;
    }
    function L(a, d, u, i) {
      for (var h = i[0] & 255 | (i[1] & 255) << 8 | (i[2] & 255) << 16 | (i[3] & 255) << 24, A = u[0] & 255 | (u[1] & 255) << 8 | (u[2] & 255) << 16 | (u[3] & 255) << 24, m = u[4] & 255 | (u[5] & 255) << 8 | (u[6] & 255) << 16 | (u[7] & 255) << 24, M = u[8] & 255 | (u[9] & 255) << 8 | (u[10] & 255) << 16 | (u[11] & 255) << 24, C = u[12] & 255 | (u[13] & 255) << 8 | (u[14] & 255) << 16 | (u[15] & 255) << 24, W = i[4] & 255 | (i[5] & 255) << 8 | (i[6] & 255) << 16 | (i[7] & 255) << 24, O = d[0] & 255 | (d[1] & 255) << 8 | (d[2] & 255) << 16 | (d[3] & 255) << 24, fe = d[4] & 255 | (d[5] & 255) << 8 | (d[6] & 255) << 16 | (d[7] & 255) << 24, P = d[8] & 255 | (d[9] & 255) << 8 | (d[10] & 255) << 16 | (d[11] & 255) << 24, V = d[12] & 255 | (d[13] & 255) << 8 | (d[14] & 255) << 16 | (d[15] & 255) << 24, q = i[8] & 255 | (i[9] & 255) << 8 | (i[10] & 255) << 16 | (i[11] & 255) << 24, te = u[16] & 255 | (u[17] & 255) << 8 | (u[18] & 255) << 16 | (u[19] & 255) << 24, ee = u[20] & 255 | (u[21] & 255) << 8 | (u[22] & 255) << 16 | (u[23] & 255) << 24, X = u[24] & 255 | (u[25] & 255) << 8 | (u[26] & 255) << 16 | (u[27] & 255) << 24, $ = u[28] & 255 | (u[29] & 255) << 8 | (u[30] & 255) << 16 | (u[31] & 255) << 24, J = i[12] & 255 | (i[13] & 255) << 8 | (i[14] & 255) << 16 | (i[15] & 255) << 24, B = h, Q = A, j = m, R = M, F = C, k = W, v = O, E = fe, D = P, T = V, N = q, U = te, G = ee, ne = X, se = $, re = J, g, oe = 0; oe < 20; oe += 2)
        g = B + G | 0, F ^= g << 7 | g >>> 25, g = F + B | 0, D ^= g << 9 | g >>> 23, g = D + F | 0, G ^= g << 13 | g >>> 19, g = G + D | 0, B ^= g << 18 | g >>> 14, g = k + Q | 0, T ^= g << 7 | g >>> 25, g = T + k | 0, ne ^= g << 9 | g >>> 23, g = ne + T | 0, Q ^= g << 13 | g >>> 19, g = Q + ne | 0, k ^= g << 18 | g >>> 14, g = N + v | 0, se ^= g << 7 | g >>> 25, g = se + N | 0, j ^= g << 9 | g >>> 23, g = j + se | 0, v ^= g << 13 | g >>> 19, g = v + j | 0, N ^= g << 18 | g >>> 14, g = re + U | 0, R ^= g << 7 | g >>> 25, g = R + re | 0, E ^= g << 9 | g >>> 23, g = E + R | 0, U ^= g << 13 | g >>> 19, g = U + E | 0, re ^= g << 18 | g >>> 14, g = B + R | 0, Q ^= g << 7 | g >>> 25, g = Q + B | 0, j ^= g << 9 | g >>> 23, g = j + Q | 0, R ^= g << 13 | g >>> 19, g = R + j | 0, B ^= g << 18 | g >>> 14, g = k + F | 0, v ^= g << 7 | g >>> 25, g = v + k | 0, E ^= g << 9 | g >>> 23, g = E + v | 0, F ^= g << 13 | g >>> 19, g = F + E | 0, k ^= g << 18 | g >>> 14, g = N + T | 0, U ^= g << 7 | g >>> 25, g = U + N | 0, D ^= g << 9 | g >>> 23, g = D + U | 0, T ^= g << 13 | g >>> 19, g = T + D | 0, N ^= g << 18 | g >>> 14, g = re + se | 0, G ^= g << 7 | g >>> 25, g = G + re | 0, ne ^= g << 9 | g >>> 23, g = ne + G | 0, se ^= g << 13 | g >>> 19, g = se + ne | 0, re ^= g << 18 | g >>> 14;
      a[0] = B >>> 0 & 255, a[1] = B >>> 8 & 255, a[2] = B >>> 16 & 255, a[3] = B >>> 24 & 255, a[4] = k >>> 0 & 255, a[5] = k >>> 8 & 255, a[6] = k >>> 16 & 255, a[7] = k >>> 24 & 255, a[8] = N >>> 0 & 255, a[9] = N >>> 8 & 255, a[10] = N >>> 16 & 255, a[11] = N >>> 24 & 255, a[12] = re >>> 0 & 255, a[13] = re >>> 8 & 255, a[14] = re >>> 16 & 255, a[15] = re >>> 24 & 255, a[16] = v >>> 0 & 255, a[17] = v >>> 8 & 255, a[18] = v >>> 16 & 255, a[19] = v >>> 24 & 255, a[20] = E >>> 0 & 255, a[21] = E >>> 8 & 255, a[22] = E >>> 16 & 255, a[23] = E >>> 24 & 255, a[24] = D >>> 0 & 255, a[25] = D >>> 8 & 255, a[26] = D >>> 16 & 255, a[27] = D >>> 24 & 255, a[28] = T >>> 0 & 255, a[29] = T >>> 8 & 255, a[30] = T >>> 16 & 255, a[31] = T >>> 24 & 255;
    }
    function ve(a, d, u, i) {
      le(a, d, u, i);
    }
    function ye(a, d, u, i) {
      L(a, d, u, i);
    }
    var De = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function Re(a, d, u, i, h, A, m) {
      var M = new Uint8Array(16), C = new Uint8Array(64), W, O;
      for (O = 0; O < 16; O++) M[O] = 0;
      for (O = 0; O < 8; O++) M[O] = A[O];
      for (; h >= 64; ) {
        for (ve(C, M, m, De), O = 0; O < 64; O++) a[d + O] = u[i + O] ^ C[O];
        for (W = 1, O = 8; O < 16; O++)
          W = W + (M[O] & 255) | 0, M[O] = W & 255, W >>>= 8;
        h -= 64, d += 64, i += 64;
      }
      if (h > 0)
        for (ve(C, M, m, De), O = 0; O < h; O++) a[d + O] = u[i + O] ^ C[O];
      return 0;
    }
    function Le(a, d, u, i, h) {
      var A = new Uint8Array(16), m = new Uint8Array(64), M, C;
      for (C = 0; C < 16; C++) A[C] = 0;
      for (C = 0; C < 8; C++) A[C] = i[C];
      for (; u >= 64; ) {
        for (ve(m, A, h, De), C = 0; C < 64; C++) a[d + C] = m[C];
        for (M = 1, C = 8; C < 16; C++)
          M = M + (A[C] & 255) | 0, A[C] = M & 255, M >>>= 8;
        u -= 64, d += 64;
      }
      if (u > 0)
        for (ve(m, A, h, De), C = 0; C < u; C++) a[d + C] = m[C];
      return 0;
    }
    function tt(a, d, u, i, h) {
      var A = new Uint8Array(32);
      ye(A, i, h, De);
      for (var m = new Uint8Array(8), M = 0; M < 8; M++) m[M] = i[M + 16];
      return Le(a, d, u, m, A);
    }
    function ae(a, d, u, i, h, A, m) {
      var M = new Uint8Array(32);
      ye(M, A, m, De);
      for (var C = new Uint8Array(8), W = 0; W < 8; W++) C[W] = A[W + 16];
      return Re(a, d, u, i, h, C, M);
    }
    var ce = function(a) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var d, u, i, h, A, m, M, C;
      d = a[0] & 255 | (a[1] & 255) << 8, this.r[0] = d & 8191, u = a[2] & 255 | (a[3] & 255) << 8, this.r[1] = (d >>> 13 | u << 3) & 8191, i = a[4] & 255 | (a[5] & 255) << 8, this.r[2] = (u >>> 10 | i << 6) & 7939, h = a[6] & 255 | (a[7] & 255) << 8, this.r[3] = (i >>> 7 | h << 9) & 8191, A = a[8] & 255 | (a[9] & 255) << 8, this.r[4] = (h >>> 4 | A << 12) & 255, this.r[5] = A >>> 1 & 8190, m = a[10] & 255 | (a[11] & 255) << 8, this.r[6] = (A >>> 14 | m << 2) & 8191, M = a[12] & 255 | (a[13] & 255) << 8, this.r[7] = (m >>> 11 | M << 5) & 8065, C = a[14] & 255 | (a[15] & 255) << 8, this.r[8] = (M >>> 8 | C << 8) & 8191, this.r[9] = C >>> 5 & 127, this.pad[0] = a[16] & 255 | (a[17] & 255) << 8, this.pad[1] = a[18] & 255 | (a[19] & 255) << 8, this.pad[2] = a[20] & 255 | (a[21] & 255) << 8, this.pad[3] = a[22] & 255 | (a[23] & 255) << 8, this.pad[4] = a[24] & 255 | (a[25] & 255) << 8, this.pad[5] = a[26] & 255 | (a[27] & 255) << 8, this.pad[6] = a[28] & 255 | (a[29] & 255) << 8, this.pad[7] = a[30] & 255 | (a[31] & 255) << 8;
    };
    ce.prototype.blocks = function(a, d, u) {
      for (var i = this.fin ? 0 : 2048, h, A, m, M, C, W, O, fe, P, V, q, te, ee, X, $, J, B, Q, j, R = this.h[0], F = this.h[1], k = this.h[2], v = this.h[3], E = this.h[4], D = this.h[5], T = this.h[6], N = this.h[7], U = this.h[8], G = this.h[9], ne = this.r[0], se = this.r[1], re = this.r[2], g = this.r[3], oe = this.r[4], pe = this.r[5], ge = this.r[6], ie = this.r[7], de = this.r[8], he = this.r[9]; u >= 16; )
        h = a[d + 0] & 255 | (a[d + 1] & 255) << 8, R += h & 8191, A = a[d + 2] & 255 | (a[d + 3] & 255) << 8, F += (h >>> 13 | A << 3) & 8191, m = a[d + 4] & 255 | (a[d + 5] & 255) << 8, k += (A >>> 10 | m << 6) & 8191, M = a[d + 6] & 255 | (a[d + 7] & 255) << 8, v += (m >>> 7 | M << 9) & 8191, C = a[d + 8] & 255 | (a[d + 9] & 255) << 8, E += (M >>> 4 | C << 12) & 8191, D += C >>> 1 & 8191, W = a[d + 10] & 255 | (a[d + 11] & 255) << 8, T += (C >>> 14 | W << 2) & 8191, O = a[d + 12] & 255 | (a[d + 13] & 255) << 8, N += (W >>> 11 | O << 5) & 8191, fe = a[d + 14] & 255 | (a[d + 15] & 255) << 8, U += (O >>> 8 | fe << 8) & 8191, G += fe >>> 5 | i, P = 0, V = P, V += R * ne, V += F * (5 * he), V += k * (5 * de), V += v * (5 * ie), V += E * (5 * ge), P = V >>> 13, V &= 8191, V += D * (5 * pe), V += T * (5 * oe), V += N * (5 * g), V += U * (5 * re), V += G * (5 * se), P += V >>> 13, V &= 8191, q = P, q += R * se, q += F * ne, q += k * (5 * he), q += v * (5 * de), q += E * (5 * ie), P = q >>> 13, q &= 8191, q += D * (5 * ge), q += T * (5 * pe), q += N * (5 * oe), q += U * (5 * g), q += G * (5 * re), P += q >>> 13, q &= 8191, te = P, te += R * re, te += F * se, te += k * ne, te += v * (5 * he), te += E * (5 * de), P = te >>> 13, te &= 8191, te += D * (5 * ie), te += T * (5 * ge), te += N * (5 * pe), te += U * (5 * oe), te += G * (5 * g), P += te >>> 13, te &= 8191, ee = P, ee += R * g, ee += F * re, ee += k * se, ee += v * ne, ee += E * (5 * he), P = ee >>> 13, ee &= 8191, ee += D * (5 * de), ee += T * (5 * ie), ee += N * (5 * ge), ee += U * (5 * pe), ee += G * (5 * oe), P += ee >>> 13, ee &= 8191, X = P, X += R * oe, X += F * g, X += k * re, X += v * se, X += E * ne, P = X >>> 13, X &= 8191, X += D * (5 * he), X += T * (5 * de), X += N * (5 * ie), X += U * (5 * ge), X += G * (5 * pe), P += X >>> 13, X &= 8191, $ = P, $ += R * pe, $ += F * oe, $ += k * g, $ += v * re, $ += E * se, P = $ >>> 13, $ &= 8191, $ += D * ne, $ += T * (5 * he), $ += N * (5 * de), $ += U * (5 * ie), $ += G * (5 * ge), P += $ >>> 13, $ &= 8191, J = P, J += R * ge, J += F * pe, J += k * oe, J += v * g, J += E * re, P = J >>> 13, J &= 8191, J += D * se, J += T * ne, J += N * (5 * he), J += U * (5 * de), J += G * (5 * ie), P += J >>> 13, J &= 8191, B = P, B += R * ie, B += F * ge, B += k * pe, B += v * oe, B += E * g, P = B >>> 13, B &= 8191, B += D * re, B += T * se, B += N * ne, B += U * (5 * he), B += G * (5 * de), P += B >>> 13, B &= 8191, Q = P, Q += R * de, Q += F * ie, Q += k * ge, Q += v * pe, Q += E * oe, P = Q >>> 13, Q &= 8191, Q += D * g, Q += T * re, Q += N * se, Q += U * ne, Q += G * (5 * he), P += Q >>> 13, Q &= 8191, j = P, j += R * he, j += F * de, j += k * ie, j += v * ge, j += E * pe, P = j >>> 13, j &= 8191, j += D * oe, j += T * g, j += N * re, j += U * se, j += G * ne, P += j >>> 13, j &= 8191, P = (P << 2) + P | 0, P = P + V | 0, V = P & 8191, P = P >>> 13, q += P, R = V, F = q, k = te, v = ee, E = X, D = $, T = J, N = B, U = Q, G = j, d += 16, u -= 16;
      this.h[0] = R, this.h[1] = F, this.h[2] = k, this.h[3] = v, this.h[4] = E, this.h[5] = D, this.h[6] = T, this.h[7] = N, this.h[8] = U, this.h[9] = G;
    }, ce.prototype.finish = function(a, d) {
      var u = new Uint16Array(10), i, h, A, m;
      if (this.leftover) {
        for (m = this.leftover, this.buffer[m++] = 1; m < 16; m++) this.buffer[m] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (i = this.h[1] >>> 13, this.h[1] &= 8191, m = 2; m < 10; m++)
        this.h[m] += i, i = this.h[m] >>> 13, this.h[m] &= 8191;
      for (this.h[0] += i * 5, i = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += i, i = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += i, u[0] = this.h[0] + 5, i = u[0] >>> 13, u[0] &= 8191, m = 1; m < 10; m++)
        u[m] = this.h[m] + i, i = u[m] >>> 13, u[m] &= 8191;
      for (u[9] -= 8192, h = (i ^ 1) - 1, m = 0; m < 10; m++) u[m] &= h;
      for (h = ~h, m = 0; m < 10; m++) this.h[m] = this.h[m] & h | u[m];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, A = this.h[0] + this.pad[0], this.h[0] = A & 65535, m = 1; m < 8; m++)
        A = (this.h[m] + this.pad[m] | 0) + (A >>> 16) | 0, this.h[m] = A & 65535;
      a[d + 0] = this.h[0] >>> 0 & 255, a[d + 1] = this.h[0] >>> 8 & 255, a[d + 2] = this.h[1] >>> 0 & 255, a[d + 3] = this.h[1] >>> 8 & 255, a[d + 4] = this.h[2] >>> 0 & 255, a[d + 5] = this.h[2] >>> 8 & 255, a[d + 6] = this.h[3] >>> 0 & 255, a[d + 7] = this.h[3] >>> 8 & 255, a[d + 8] = this.h[4] >>> 0 & 255, a[d + 9] = this.h[4] >>> 8 & 255, a[d + 10] = this.h[5] >>> 0 & 255, a[d + 11] = this.h[5] >>> 8 & 255, a[d + 12] = this.h[6] >>> 0 & 255, a[d + 13] = this.h[6] >>> 8 & 255, a[d + 14] = this.h[7] >>> 0 & 255, a[d + 15] = this.h[7] >>> 8 & 255;
    }, ce.prototype.update = function(a, d, u) {
      var i, h;
      if (this.leftover) {
        for (h = 16 - this.leftover, h > u && (h = u), i = 0; i < h; i++)
          this.buffer[this.leftover + i] = a[d + i];
        if (u -= h, d += h, this.leftover += h, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (u >= 16 && (h = u - u % 16, this.blocks(a, d, h), d += h, u -= h), u) {
        for (i = 0; i < u; i++)
          this.buffer[this.leftover + i] = a[d + i];
        this.leftover += u;
      }
    };
    function Y(a, d, u, i, h, A) {
      var m = new ce(A);
      return m.update(u, i, h), m.finish(a, d), 0;
    }
    function K(a, d, u, i, h, A) {
      var m = new Uint8Array(16);
      return Y(m, 0, u, i, h, A), S(a, d, m, 0);
    }
    function ze(a, d, u, i, h) {
      var A;
      if (u < 32) return -1;
      for (ae(a, 0, d, 0, u, i, h), Y(a, 16, a, 32, u - 32, a), A = 0; A < 16; A++) a[A] = 0;
      return 0;
    }
    function Ee(a, d, u, i, h) {
      var A, m = new Uint8Array(32);
      if (u < 32 || (tt(m, 0, 32, i, h), K(d, 16, d, 32, u - 32, m) !== 0)) return -1;
      for (ae(a, 0, d, 0, u, i, h), A = 0; A < 32; A++) a[A] = 0;
      return 0;
    }
    function Ce(a, d) {
      var u;
      for (u = 0; u < 16; u++) a[u] = d[u] | 0;
    }
    function Wt(a) {
      var d, u, i = 1;
      for (d = 0; d < 16; d++)
        u = a[d] + i + 65535, i = Math.floor(u / 65536), a[d] = u - i * 65536;
      a[0] += i - 1 + 37 * (i - 1);
    }
    function dt(a, d, u) {
      for (var i, h = ~(u - 1), A = 0; A < 16; A++)
        i = h & (a[A] ^ d[A]), a[A] ^= i, d[A] ^= i;
    }
    function It(a, d) {
      var u, i, h, A = n(), m = n();
      for (u = 0; u < 16; u++) m[u] = d[u];
      for (Wt(m), Wt(m), Wt(m), i = 0; i < 2; i++) {
        for (A[0] = m[0] - 65517, u = 1; u < 15; u++)
          A[u] = m[u] - 65535 - (A[u - 1] >> 16 & 1), A[u - 1] &= 65535;
        A[15] = m[15] - 32767 - (A[14] >> 16 & 1), h = A[15] >> 16 & 1, A[14] &= 65535, dt(m, A, 1 - h);
      }
      for (u = 0; u < 16; u++)
        a[2 * u] = m[u] & 255, a[2 * u + 1] = m[u] >> 8;
    }
    function Ur(a, d) {
      var u = new Uint8Array(32), i = new Uint8Array(32);
      return It(u, a), It(i, d), Z(u, 0, i, 0);
    }
    function Cr(a) {
      var d = new Uint8Array(32);
      return It(d, a), d[0] & 1;
    }
    function En(a, d) {
      var u;
      for (u = 0; u < 16; u++) a[u] = d[2 * u] + (d[2 * u + 1] << 8);
      a[15] &= 32767;
    }
    function Ge(a, d, u) {
      for (var i = 0; i < 16; i++) a[i] = d[i] + u[i];
    }
    function Ve(a, d, u) {
      for (var i = 0; i < 16; i++) a[i] = d[i] - u[i];
    }
    function ue(a, d, u) {
      var i, h, A = 0, m = 0, M = 0, C = 0, W = 0, O = 0, fe = 0, P = 0, V = 0, q = 0, te = 0, ee = 0, X = 0, $ = 0, J = 0, B = 0, Q = 0, j = 0, R = 0, F = 0, k = 0, v = 0, E = 0, D = 0, T = 0, N = 0, U = 0, G = 0, ne = 0, se = 0, re = 0, g = u[0], oe = u[1], pe = u[2], ge = u[3], ie = u[4], de = u[5], he = u[6], Ne = u[7], Ae = u[8], Te = u[9], Ie = u[10], Me = u[11], Ue = u[12], Pe = u[13], _e = u[14], Be = u[15];
      i = d[0], A += i * g, m += i * oe, M += i * pe, C += i * ge, W += i * ie, O += i * de, fe += i * he, P += i * Ne, V += i * Ae, q += i * Te, te += i * Ie, ee += i * Me, X += i * Ue, $ += i * Pe, J += i * _e, B += i * Be, i = d[1], m += i * g, M += i * oe, C += i * pe, W += i * ge, O += i * ie, fe += i * de, P += i * he, V += i * Ne, q += i * Ae, te += i * Te, ee += i * Ie, X += i * Me, $ += i * Ue, J += i * Pe, B += i * _e, Q += i * Be, i = d[2], M += i * g, C += i * oe, W += i * pe, O += i * ge, fe += i * ie, P += i * de, V += i * he, q += i * Ne, te += i * Ae, ee += i * Te, X += i * Ie, $ += i * Me, J += i * Ue, B += i * Pe, Q += i * _e, j += i * Be, i = d[3], C += i * g, W += i * oe, O += i * pe, fe += i * ge, P += i * ie, V += i * de, q += i * he, te += i * Ne, ee += i * Ae, X += i * Te, $ += i * Ie, J += i * Me, B += i * Ue, Q += i * Pe, j += i * _e, R += i * Be, i = d[4], W += i * g, O += i * oe, fe += i * pe, P += i * ge, V += i * ie, q += i * de, te += i * he, ee += i * Ne, X += i * Ae, $ += i * Te, J += i * Ie, B += i * Me, Q += i * Ue, j += i * Pe, R += i * _e, F += i * Be, i = d[5], O += i * g, fe += i * oe, P += i * pe, V += i * ge, q += i * ie, te += i * de, ee += i * he, X += i * Ne, $ += i * Ae, J += i * Te, B += i * Ie, Q += i * Me, j += i * Ue, R += i * Pe, F += i * _e, k += i * Be, i = d[6], fe += i * g, P += i * oe, V += i * pe, q += i * ge, te += i * ie, ee += i * de, X += i * he, $ += i * Ne, J += i * Ae, B += i * Te, Q += i * Ie, j += i * Me, R += i * Ue, F += i * Pe, k += i * _e, v += i * Be, i = d[7], P += i * g, V += i * oe, q += i * pe, te += i * ge, ee += i * ie, X += i * de, $ += i * he, J += i * Ne, B += i * Ae, Q += i * Te, j += i * Ie, R += i * Me, F += i * Ue, k += i * Pe, v += i * _e, E += i * Be, i = d[8], V += i * g, q += i * oe, te += i * pe, ee += i * ge, X += i * ie, $ += i * de, J += i * he, B += i * Ne, Q += i * Ae, j += i * Te, R += i * Ie, F += i * Me, k += i * Ue, v += i * Pe, E += i * _e, D += i * Be, i = d[9], q += i * g, te += i * oe, ee += i * pe, X += i * ge, $ += i * ie, J += i * de, B += i * he, Q += i * Ne, j += i * Ae, R += i * Te, F += i * Ie, k += i * Me, v += i * Ue, E += i * Pe, D += i * _e, T += i * Be, i = d[10], te += i * g, ee += i * oe, X += i * pe, $ += i * ge, J += i * ie, B += i * de, Q += i * he, j += i * Ne, R += i * Ae, F += i * Te, k += i * Ie, v += i * Me, E += i * Ue, D += i * Pe, T += i * _e, N += i * Be, i = d[11], ee += i * g, X += i * oe, $ += i * pe, J += i * ge, B += i * ie, Q += i * de, j += i * he, R += i * Ne, F += i * Ae, k += i * Te, v += i * Ie, E += i * Me, D += i * Ue, T += i * Pe, N += i * _e, U += i * Be, i = d[12], X += i * g, $ += i * oe, J += i * pe, B += i * ge, Q += i * ie, j += i * de, R += i * he, F += i * Ne, k += i * Ae, v += i * Te, E += i * Ie, D += i * Me, T += i * Ue, N += i * Pe, U += i * _e, G += i * Be, i = d[13], $ += i * g, J += i * oe, B += i * pe, Q += i * ge, j += i * ie, R += i * de, F += i * he, k += i * Ne, v += i * Ae, E += i * Te, D += i * Ie, T += i * Me, N += i * Ue, U += i * Pe, G += i * _e, ne += i * Be, i = d[14], J += i * g, B += i * oe, Q += i * pe, j += i * ge, R += i * ie, F += i * de, k += i * he, v += i * Ne, E += i * Ae, D += i * Te, T += i * Ie, N += i * Me, U += i * Ue, G += i * Pe, ne += i * _e, se += i * Be, i = d[15], B += i * g, Q += i * oe, j += i * pe, R += i * ge, F += i * ie, k += i * de, v += i * he, E += i * Ne, D += i * Ae, T += i * Te, N += i * Ie, U += i * Me, G += i * Ue, ne += i * Pe, se += i * _e, re += i * Be, A += 38 * Q, m += 38 * j, M += 38 * R, C += 38 * F, W += 38 * k, O += 38 * v, fe += 38 * E, P += 38 * D, V += 38 * T, q += 38 * N, te += 38 * U, ee += 38 * G, X += 38 * ne, $ += 38 * se, J += 38 * re, h = 1, i = A + h + 65535, h = Math.floor(i / 65536), A = i - h * 65536, i = m + h + 65535, h = Math.floor(i / 65536), m = i - h * 65536, i = M + h + 65535, h = Math.floor(i / 65536), M = i - h * 65536, i = C + h + 65535, h = Math.floor(i / 65536), C = i - h * 65536, i = W + h + 65535, h = Math.floor(i / 65536), W = i - h * 65536, i = O + h + 65535, h = Math.floor(i / 65536), O = i - h * 65536, i = fe + h + 65535, h = Math.floor(i / 65536), fe = i - h * 65536, i = P + h + 65535, h = Math.floor(i / 65536), P = i - h * 65536, i = V + h + 65535, h = Math.floor(i / 65536), V = i - h * 65536, i = q + h + 65535, h = Math.floor(i / 65536), q = i - h * 65536, i = te + h + 65535, h = Math.floor(i / 65536), te = i - h * 65536, i = ee + h + 65535, h = Math.floor(i / 65536), ee = i - h * 65536, i = X + h + 65535, h = Math.floor(i / 65536), X = i - h * 65536, i = $ + h + 65535, h = Math.floor(i / 65536), $ = i - h * 65536, i = J + h + 65535, h = Math.floor(i / 65536), J = i - h * 65536, i = B + h + 65535, h = Math.floor(i / 65536), B = i - h * 65536, A += h - 1 + 37 * (h - 1), h = 1, i = A + h + 65535, h = Math.floor(i / 65536), A = i - h * 65536, i = m + h + 65535, h = Math.floor(i / 65536), m = i - h * 65536, i = M + h + 65535, h = Math.floor(i / 65536), M = i - h * 65536, i = C + h + 65535, h = Math.floor(i / 65536), C = i - h * 65536, i = W + h + 65535, h = Math.floor(i / 65536), W = i - h * 65536, i = O + h + 65535, h = Math.floor(i / 65536), O = i - h * 65536, i = fe + h + 65535, h = Math.floor(i / 65536), fe = i - h * 65536, i = P + h + 65535, h = Math.floor(i / 65536), P = i - h * 65536, i = V + h + 65535, h = Math.floor(i / 65536), V = i - h * 65536, i = q + h + 65535, h = Math.floor(i / 65536), q = i - h * 65536, i = te + h + 65535, h = Math.floor(i / 65536), te = i - h * 65536, i = ee + h + 65535, h = Math.floor(i / 65536), ee = i - h * 65536, i = X + h + 65535, h = Math.floor(i / 65536), X = i - h * 65536, i = $ + h + 65535, h = Math.floor(i / 65536), $ = i - h * 65536, i = J + h + 65535, h = Math.floor(i / 65536), J = i - h * 65536, i = B + h + 65535, h = Math.floor(i / 65536), B = i - h * 65536, A += h - 1 + 37 * (h - 1), a[0] = A, a[1] = m, a[2] = M, a[3] = C, a[4] = W, a[5] = O, a[6] = fe, a[7] = P, a[8] = V, a[9] = q, a[10] = te, a[11] = ee, a[12] = X, a[13] = $, a[14] = J, a[15] = B;
    }
    function He(a, d) {
      ue(a, d, d);
    }
    function zr(a, d) {
      var u = n(), i;
      for (i = 0; i < 16; i++) u[i] = d[i];
      for (i = 253; i >= 0; i--)
        He(u, u), i !== 2 && i !== 4 && ue(u, u, d);
      for (i = 0; i < 16; i++) a[i] = u[i];
    }
    function kr(a, d) {
      var u = n(), i;
      for (i = 0; i < 16; i++) u[i] = d[i];
      for (i = 250; i >= 0; i--)
        He(u, u), i !== 1 && ue(u, u, d);
      for (i = 0; i < 16; i++) a[i] = u[i];
    }
    function Gt(a, d, u) {
      var i = new Uint8Array(32), h = new Float64Array(80), A, m, M = n(), C = n(), W = n(), O = n(), fe = n(), P = n();
      for (m = 0; m < 31; m++) i[m] = d[m];
      for (i[31] = d[31] & 127 | 64, i[0] &= 248, En(h, u), m = 0; m < 16; m++)
        C[m] = h[m], O[m] = M[m] = W[m] = 0;
      for (M[0] = O[0] = 1, m = 254; m >= 0; --m)
        A = i[m >>> 3] >>> (m & 7) & 1, dt(M, C, A), dt(W, O, A), Ge(fe, M, W), Ve(M, M, W), Ge(W, C, O), Ve(C, C, O), He(O, fe), He(P, M), ue(M, W, M), ue(W, C, fe), Ge(fe, M, W), Ve(M, M, W), He(C, M), Ve(W, O, P), ue(M, W, f), Ge(M, M, O), ue(W, W, M), ue(M, O, P), ue(O, C, h), He(C, fe), dt(M, C, A), dt(W, O, A);
      for (m = 0; m < 16; m++)
        h[m + 16] = M[m], h[m + 32] = W[m], h[m + 48] = C[m], h[m + 64] = O[m];
      var V = h.subarray(32), q = h.subarray(16);
      return zr(V, V), ue(q, q, V), It(a, q), 0;
    }
    function Vt(a, d) {
      return Gt(a, d, o);
    }
    function Or(a, d) {
      return r(d, 32), Vt(a, d);
    }
    function Zt(a, d, u) {
      var i = new Uint8Array(32);
      return Gt(i, u, d), ye(a, s, i, De);
    }
    var Lr = ze, Wi = Ee;
    function Qi(a, d, u, i, h, A) {
      var m = new Uint8Array(32);
      return Zt(m, h, A), Lr(a, d, u, i, m);
    }
    function Ki(a, d, u, i, h, A) {
      var m = new Uint8Array(32);
      return Zt(m, h, A), Wi(a, d, u, i, m);
    }
    var jr = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function Pr(a, d, u, i) {
      for (var h = new Int32Array(16), A = new Int32Array(16), m, M, C, W, O, fe, P, V, q, te, ee, X, $, J, B, Q, j, R, F, k, v, E, D, T, N, U, G = a[0], ne = a[1], se = a[2], re = a[3], g = a[4], oe = a[5], pe = a[6], ge = a[7], ie = d[0], de = d[1], he = d[2], Ne = d[3], Ae = d[4], Te = d[5], Ie = d[6], Me = d[7], Ue = 0; i >= 128; ) {
        for (F = 0; F < 16; F++)
          k = 8 * F + Ue, h[F] = u[k + 0] << 24 | u[k + 1] << 16 | u[k + 2] << 8 | u[k + 3], A[F] = u[k + 4] << 24 | u[k + 5] << 16 | u[k + 6] << 8 | u[k + 7];
        for (F = 0; F < 80; F++)
          if (m = G, M = ne, C = se, W = re, O = g, fe = oe, P = pe, V = ge, q = ie, te = de, ee = he, X = Ne, $ = Ae, J = Te, B = Ie, Q = Me, v = ge, E = Me, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = (g >>> 14 | Ae << 18) ^ (g >>> 18 | Ae << 14) ^ (Ae >>> 9 | g << 23), E = (Ae >>> 14 | g << 18) ^ (Ae >>> 18 | g << 14) ^ (g >>> 9 | Ae << 23), D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, v = g & oe ^ ~g & pe, E = Ae & Te ^ ~Ae & Ie, D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, v = jr[F * 2], E = jr[F * 2 + 1], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, v = h[F % 16], E = A[F % 16], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, j = N & 65535 | U << 16, R = D & 65535 | T << 16, v = j, E = R, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = (G >>> 28 | ie << 4) ^ (ie >>> 2 | G << 30) ^ (ie >>> 7 | G << 25), E = (ie >>> 28 | G << 4) ^ (G >>> 2 | ie << 30) ^ (G >>> 7 | ie << 25), D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, v = G & ne ^ G & se ^ ne & se, E = ie & de ^ ie & he ^ de & he, D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, V = N & 65535 | U << 16, Q = D & 65535 | T << 16, v = W, E = X, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = j, E = R, D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, W = N & 65535 | U << 16, X = D & 65535 | T << 16, ne = m, se = M, re = C, g = W, oe = O, pe = fe, ge = P, G = V, de = q, he = te, Ne = ee, Ae = X, Te = $, Ie = J, Me = B, ie = Q, F % 16 === 15)
            for (k = 0; k < 16; k++)
              v = h[k], E = A[k], D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = h[(k + 9) % 16], E = A[(k + 9) % 16], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, j = h[(k + 1) % 16], R = A[(k + 1) % 16], v = (j >>> 1 | R << 31) ^ (j >>> 8 | R << 24) ^ j >>> 7, E = (R >>> 1 | j << 31) ^ (R >>> 8 | j << 24) ^ (R >>> 7 | j << 25), D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, j = h[(k + 14) % 16], R = A[(k + 14) % 16], v = (j >>> 19 | R << 13) ^ (R >>> 29 | j << 3) ^ j >>> 6, E = (R >>> 19 | j << 13) ^ (j >>> 29 | R << 3) ^ (R >>> 6 | j << 26), D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, h[k] = N & 65535 | U << 16, A[k] = D & 65535 | T << 16;
        v = G, E = ie, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[0], E = d[0], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[0] = G = N & 65535 | U << 16, d[0] = ie = D & 65535 | T << 16, v = ne, E = de, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[1], E = d[1], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[1] = ne = N & 65535 | U << 16, d[1] = de = D & 65535 | T << 16, v = se, E = he, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[2], E = d[2], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[2] = se = N & 65535 | U << 16, d[2] = he = D & 65535 | T << 16, v = re, E = Ne, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[3], E = d[3], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[3] = re = N & 65535 | U << 16, d[3] = Ne = D & 65535 | T << 16, v = g, E = Ae, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[4], E = d[4], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[4] = g = N & 65535 | U << 16, d[4] = Ae = D & 65535 | T << 16, v = oe, E = Te, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[5], E = d[5], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[5] = oe = N & 65535 | U << 16, d[5] = Te = D & 65535 | T << 16, v = pe, E = Ie, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[6], E = d[6], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[6] = pe = N & 65535 | U << 16, d[6] = Ie = D & 65535 | T << 16, v = ge, E = Me, D = E & 65535, T = E >>> 16, N = v & 65535, U = v >>> 16, v = a[7], E = d[7], D += E & 65535, T += E >>> 16, N += v & 65535, U += v >>> 16, T += D >>> 16, N += T >>> 16, U += N >>> 16, a[7] = ge = N & 65535 | U << 16, d[7] = Me = D & 65535 | T << 16, Ue += 128, i -= 128;
      }
      return i;
    }
    function yt(a, d, u) {
      var i = new Int32Array(8), h = new Int32Array(8), A = new Uint8Array(256), m, M = u;
      for (i[0] = 1779033703, i[1] = 3144134277, i[2] = 1013904242, i[3] = 2773480762, i[4] = 1359893119, i[5] = 2600822924, i[6] = 528734635, i[7] = 1541459225, h[0] = 4089235720, h[1] = 2227873595, h[2] = 4271175723, h[3] = 1595750129, h[4] = 2917565137, h[5] = 725511199, h[6] = 4215389547, h[7] = 327033209, Pr(i, h, d, u), u %= 128, m = 0; m < u; m++) A[m] = d[M - u + m];
      for (A[u] = 128, u = 256 - 128 * (u < 112 ? 1 : 0), A[u - 9] = 0, I(A, u - 8, M / 536870912 | 0, M << 3), Pr(i, h, A, u), m = 0; m < 8; m++) I(a, 8 * m, i[m], h[m]);
      return 0;
    }
    function qt(a, d) {
      var u = n(), i = n(), h = n(), A = n(), m = n(), M = n(), C = n(), W = n(), O = n();
      Ve(u, a[1], a[0]), Ve(O, d[1], d[0]), ue(u, u, O), Ge(i, a[0], a[1]), Ge(O, d[0], d[1]), ue(i, i, O), ue(h, a[3], d[3]), ue(h, h, y), ue(A, a[2], d[2]), Ge(A, A, A), Ve(m, i, u), Ve(M, A, h), Ge(C, A, h), Ge(W, i, u), ue(a[0], m, M), ue(a[1], W, C), ue(a[2], C, M), ue(a[3], m, W);
    }
    function _r(a, d, u) {
      var i;
      for (i = 0; i < 4; i++)
        dt(a[i], d[i], u);
    }
    function bn(a, d) {
      var u = n(), i = n(), h = n();
      zr(h, d[2]), ue(u, d[0], h), ue(i, d[1], h), It(a, i), a[31] ^= Cr(u) << 7;
    }
    function Tn(a, d, u) {
      var i, h;
      for (Ce(a[0], c), Ce(a[1], l), Ce(a[2], l), Ce(a[3], c), h = 255; h >= 0; --h)
        i = u[h / 8 | 0] >> (h & 7) & 1, _r(a, d, i), qt(d, a), qt(a, a), _r(a, d, i);
    }
    function Xt(a, d) {
      var u = [n(), n(), n(), n()];
      Ce(u[0], w), Ce(u[1], b), Ce(u[2], l), ue(u[3], w, b), Tn(a, u, d);
    }
    function In(a, d, u) {
      var i = new Uint8Array(64), h = [n(), n(), n(), n()], A;
      for (u || r(d, 32), yt(i, d, 32), i[0] &= 248, i[31] &= 127, i[31] |= 64, Xt(h, i), bn(a, h), A = 0; A < 32; A++) d[A + 32] = a[A];
      return 0;
    }
    var Jt = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function Mn(a, d) {
      var u, i, h, A;
      for (i = 63; i >= 32; --i) {
        for (u = 0, h = i - 32, A = i - 12; h < A; ++h)
          d[h] += u - 16 * d[i] * Jt[h - (i - 32)], u = Math.floor((d[h] + 128) / 256), d[h] -= u * 256;
        d[h] += u, d[i] = 0;
      }
      for (u = 0, h = 0; h < 32; h++)
        d[h] += u - (d[31] >> 4) * Jt[h], u = d[h] >> 8, d[h] &= 255;
      for (h = 0; h < 32; h++) d[h] -= u * Jt[h];
      for (i = 0; i < 32; i++)
        d[i + 1] += d[i] >> 8, a[i] = d[i] & 255;
    }
    function Nn(a) {
      var d = new Float64Array(64), u;
      for (u = 0; u < 64; u++) d[u] = a[u];
      for (u = 0; u < 64; u++) a[u] = 0;
      Mn(a, d);
    }
    function Br(a, d, u, i) {
      var h = new Uint8Array(64), A = new Uint8Array(64), m = new Uint8Array(64), M, C, W = new Float64Array(64), O = [n(), n(), n(), n()];
      yt(h, i, 32), h[0] &= 248, h[31] &= 127, h[31] |= 64;
      var fe = u + 64;
      for (M = 0; M < u; M++) a[64 + M] = d[M];
      for (M = 0; M < 32; M++) a[32 + M] = h[32 + M];
      for (yt(m, a.subarray(32), u + 32), Nn(m), Xt(O, m), bn(a, O), M = 32; M < 64; M++) a[M] = i[M];
      for (yt(A, a, u + 64), Nn(A), M = 0; M < 64; M++) W[M] = 0;
      for (M = 0; M < 32; M++) W[M] = m[M];
      for (M = 0; M < 32; M++)
        for (C = 0; C < 32; C++)
          W[M + C] += A[M] * h[C];
      return Mn(a.subarray(32), W), fe;
    }
    function Hi(a, d) {
      var u = n(), i = n(), h = n(), A = n(), m = n(), M = n(), C = n();
      return Ce(a[2], l), En(a[1], d), He(h, a[1]), ue(A, h, p), Ve(h, h, a[2]), Ge(A, a[2], A), He(m, A), He(M, m), ue(C, M, m), ue(u, C, h), ue(u, u, A), kr(u, u), ue(u, u, h), ue(u, u, A), ue(u, u, A), ue(a[0], u, A), He(i, a[0]), ue(i, i, A), Ur(i, h) && ue(a[0], a[0], x), He(i, a[0]), ue(i, i, A), Ur(i, h) ? -1 : (Cr(a[0]) === d[31] >> 7 && Ve(a[0], c, a[0]), ue(a[3], a[0], a[1]), 0);
    }
    function xn(a, d, u, i) {
      var h, A = new Uint8Array(32), m = new Uint8Array(64), M = [n(), n(), n(), n()], C = [n(), n(), n(), n()];
      if (u < 64 || Hi(C, i)) return -1;
      for (h = 0; h < u; h++) a[h] = d[h];
      for (h = 0; h < 32; h++) a[h + 32] = i[h];
      if (yt(m, a, u), Nn(m), Tn(M, C, m), Xt(C, d.subarray(32)), qt(M, C), bn(A, M), u -= 64, Z(d, 0, A, 0)) {
        for (h = 0; h < u; h++) a[h] = 0;
        return -1;
      }
      for (h = 0; h < u; h++) a[h] = d[h + 64];
      return u;
    }
    var Sn = 32, $t = 24, Ut = 32, Mt = 16, Ct = 32, en = 32, zt = 32, kt = 32, Dn = 32, Rr = $t, Yi = Ut, Gi = Mt, st = 64, wt = 32, Nt = 64, Un = 32, Cn = 64;
    e.lowlevel = {
      crypto_core_hsalsa20: ye,
      crypto_stream_xor: ae,
      crypto_stream: tt,
      crypto_stream_salsa20_xor: Re,
      crypto_stream_salsa20: Le,
      crypto_onetimeauth: Y,
      crypto_onetimeauth_verify: K,
      crypto_verify_16: S,
      crypto_verify_32: Z,
      crypto_secretbox: ze,
      crypto_secretbox_open: Ee,
      crypto_scalarmult: Gt,
      crypto_scalarmult_base: Vt,
      crypto_box_beforenm: Zt,
      crypto_box_afternm: Lr,
      crypto_box: Qi,
      crypto_box_open: Ki,
      crypto_box_keypair: Or,
      crypto_hash: yt,
      crypto_sign: Br,
      crypto_sign_keypair: In,
      crypto_sign_open: xn,
      crypto_secretbox_KEYBYTES: Sn,
      crypto_secretbox_NONCEBYTES: $t,
      crypto_secretbox_ZEROBYTES: Ut,
      crypto_secretbox_BOXZEROBYTES: Mt,
      crypto_scalarmult_BYTES: Ct,
      crypto_scalarmult_SCALARBYTES: en,
      crypto_box_PUBLICKEYBYTES: zt,
      crypto_box_SECRETKEYBYTES: kt,
      crypto_box_BEFORENMBYTES: Dn,
      crypto_box_NONCEBYTES: Rr,
      crypto_box_ZEROBYTES: Yi,
      crypto_box_BOXZEROBYTES: Gi,
      crypto_sign_BYTES: st,
      crypto_sign_PUBLICKEYBYTES: wt,
      crypto_sign_SECRETKEYBYTES: Nt,
      crypto_sign_SEEDBYTES: Un,
      crypto_hash_BYTES: Cn,
      gf: n,
      D: p,
      L: Jt,
      pack25519: It,
      unpack25519: En,
      M: ue,
      A: Ge,
      S: He,
      Z: Ve,
      pow2523: kr,
      add: qt,
      set25519: Ce,
      modL: Mn,
      scalarmult: Tn,
      scalarbase: Xt
    };
    function Fr(a, d) {
      if (a.length !== Sn) throw new Error("bad key size");
      if (d.length !== $t) throw new Error("bad nonce size");
    }
    function Vi(a, d) {
      if (a.length !== zt) throw new Error("bad public key size");
      if (d.length !== kt) throw new Error("bad secret key size");
    }
    function Qe() {
      for (var a = 0; a < arguments.length; a++)
        if (!(arguments[a] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function Wr(a) {
      for (var d = 0; d < a.length; d++) a[d] = 0;
    }
    e.randomBytes = function(a) {
      var d = new Uint8Array(a);
      return r(d, a), d;
    }, e.secretbox = function(a, d, u) {
      Qe(a, d, u), Fr(u, d);
      for (var i = new Uint8Array(Ut + a.length), h = new Uint8Array(i.length), A = 0; A < a.length; A++) i[A + Ut] = a[A];
      return ze(h, i, i.length, d, u), h.subarray(Mt);
    }, e.secretbox.open = function(a, d, u) {
      Qe(a, d, u), Fr(u, d);
      for (var i = new Uint8Array(Mt + a.length), h = new Uint8Array(i.length), A = 0; A < a.length; A++) i[A + Mt] = a[A];
      return i.length < 32 || Ee(h, i, i.length, d, u) !== 0 ? null : h.subarray(Ut);
    }, e.secretbox.keyLength = Sn, e.secretbox.nonceLength = $t, e.secretbox.overheadLength = Mt, e.scalarMult = function(a, d) {
      if (Qe(a, d), a.length !== en) throw new Error("bad n size");
      if (d.length !== Ct) throw new Error("bad p size");
      var u = new Uint8Array(Ct);
      return Gt(u, a, d), u;
    }, e.scalarMult.base = function(a) {
      if (Qe(a), a.length !== en) throw new Error("bad n size");
      var d = new Uint8Array(Ct);
      return Vt(d, a), d;
    }, e.scalarMult.scalarLength = en, e.scalarMult.groupElementLength = Ct, e.box = function(a, d, u, i) {
      var h = e.box.before(u, i);
      return e.secretbox(a, d, h);
    }, e.box.before = function(a, d) {
      Qe(a, d), Vi(a, d);
      var u = new Uint8Array(Dn);
      return Zt(u, a, d), u;
    }, e.box.after = e.secretbox, e.box.open = function(a, d, u, i) {
      var h = e.box.before(u, i);
      return e.secretbox.open(a, d, h);
    }, e.box.open.after = e.secretbox.open, e.box.keyPair = function() {
      var a = new Uint8Array(zt), d = new Uint8Array(kt);
      return Or(a, d), { publicKey: a, secretKey: d };
    }, e.box.keyPair.fromSecretKey = function(a) {
      if (Qe(a), a.length !== kt)
        throw new Error("bad secret key size");
      var d = new Uint8Array(zt);
      return Vt(d, a), { publicKey: d, secretKey: new Uint8Array(a) };
    }, e.box.publicKeyLength = zt, e.box.secretKeyLength = kt, e.box.sharedKeyLength = Dn, e.box.nonceLength = Rr, e.box.overheadLength = e.secretbox.overheadLength, e.sign = function(a, d) {
      if (Qe(a, d), d.length !== Nt)
        throw new Error("bad secret key size");
      var u = new Uint8Array(st + a.length);
      return Br(u, a, a.length, d), u;
    }, e.sign.open = function(a, d) {
      if (Qe(a, d), d.length !== wt)
        throw new Error("bad public key size");
      var u = new Uint8Array(a.length), i = xn(u, a, a.length, d);
      if (i < 0) return null;
      for (var h = new Uint8Array(i), A = 0; A < h.length; A++) h[A] = u[A];
      return h;
    }, e.sign.detached = function(a, d) {
      for (var u = e.sign(a, d), i = new Uint8Array(st), h = 0; h < i.length; h++) i[h] = u[h];
      return i;
    }, e.sign.detached.verify = function(a, d, u) {
      if (Qe(a, d, u), d.length !== st)
        throw new Error("bad signature size");
      if (u.length !== wt)
        throw new Error("bad public key size");
      var i = new Uint8Array(st + a.length), h = new Uint8Array(st + a.length), A;
      for (A = 0; A < st; A++) i[A] = d[A];
      for (A = 0; A < a.length; A++) i[A + st] = a[A];
      return xn(h, i, i.length, u) >= 0;
    }, e.sign.keyPair = function() {
      var a = new Uint8Array(wt), d = new Uint8Array(Nt);
      return In(a, d), { publicKey: a, secretKey: d };
    }, e.sign.keyPair.fromSecretKey = function(a) {
      if (Qe(a), a.length !== Nt)
        throw new Error("bad secret key size");
      for (var d = new Uint8Array(wt), u = 0; u < d.length; u++) d[u] = a[32 + u];
      return { publicKey: d, secretKey: new Uint8Array(a) };
    }, e.sign.keyPair.fromSeed = function(a) {
      if (Qe(a), a.length !== Un)
        throw new Error("bad seed size");
      for (var d = new Uint8Array(wt), u = new Uint8Array(Nt), i = 0; i < 32; i++) u[i] = a[i];
      return In(d, u, !0), { publicKey: d, secretKey: u };
    }, e.sign.publicKeyLength = wt, e.sign.secretKeyLength = Nt, e.sign.seedLength = Un, e.sign.signatureLength = st, e.hash = function(a) {
      Qe(a);
      var d = new Uint8Array(Cn);
      return yt(d, a, a.length), d;
    }, e.hash.hashLength = Cn, e.verify = function(a, d) {
      return Qe(a, d), a.length === 0 || d.length === 0 || a.length !== d.length ? !1 : z(a, 0, d, 0, a.length) === 0;
    }, e.setPRNG = function(a) {
      r = a;
    }, function() {
      var a = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (a && a.getRandomValues) {
        var d = 65536;
        e.setPRNG(function(u, i) {
          var h, A = new Uint8Array(i);
          for (h = 0; h < i; h += d)
            a.getRandomValues(A.subarray(h, h + Math.min(i - h, d)));
          for (h = 0; h < i; h++) u[h] = A[h];
          Wr(A);
        });
      } else typeof o2 < "u" && (a = u2, a && a.randomBytes && e.setPRNG(function(u, i) {
        var h, A = a.randomBytes(i);
        for (h = 0; h < i; h++) u[h] = A[h];
        Wr(A);
      }));
    }();
  })(t.exports ? t.exports : self.nacl = self.nacl || {});
})(vf);
var l2 = vf.exports;
const Hr = /* @__PURE__ */ Af(l2);
var d2 = Object.defineProperty, h2 = (t, e, n) => e in t ? d2(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, _n = (t, e, n) => h2(t, typeof e != "symbol" ? e + "" : e, n);
async function f2(t, e) {
  const n = t.getReader();
  let r;
  for (; !(r = await n.read()).done; )
    e(r.value);
}
function p2(t) {
  let e, n, r, s = !1;
  return function(o) {
    e === void 0 ? (e = o, n = 0, r = -1) : e = y2(e, o);
    const c = e.length;
    let l = 0;
    for (; n < c; ) {
      s && (e[n] === 10 && (l = ++n), s = !1);
      let f = -1;
      for (; n < c && f === -1; ++n)
        switch (e[n]) {
          case 58:
            r === -1 && (r = n - l);
            break;
          case 13:
            s = !0;
          case 10:
            f = n;
            break;
        }
      if (f === -1)
        break;
      t(e.subarray(l, f), r), l = n, r = -1;
    }
    l === c ? e = void 0 : l !== 0 && (e = e.subarray(l), n -= l);
  };
}
function g2(t, e, n) {
  let r = nu();
  const s = new TextDecoder();
  return function(o, c) {
    if (o.length === 0)
      n == null || n(r), r = nu();
    else if (c > 0) {
      const l = s.decode(o.subarray(0, c)), f = c + (o[c + 1] === 32 ? 2 : 1), p = s.decode(o.subarray(f));
      switch (l) {
        case "data":
          r.data = r.data ? r.data + `
` + p : p;
          break;
        case "event":
          r.event = p;
          break;
        case "id":
          t(r.id = p);
          break;
        case "retry":
          const y = parseInt(p, 10);
          isNaN(y) || e(r.retry = y);
          break;
      }
    }
  };
}
function y2(t, e) {
  const n = new Uint8Array(t.length + e.length);
  return n.set(t), n.set(e, t.length), n;
}
function nu() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  };
}
var w2 = function(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, r = Object.getOwnPropertySymbols(t); s < r.length; s++)
      e.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[s]) && (n[r[s]] = t[r[s]]);
  return n;
};
const Vo = "text/event-stream", A2 = 1e3, ru = "last-event-id";
function Ef(t, e) {
  var { signal: n, headers: r, onopen: s, onmessage: o, onclose: c, onerror: l, openWhenHidden: f, fetch: p } = e, y = w2(e, ["signal", "headers", "onopen", "onmessage", "onclose", "onerror", "openWhenHidden", "fetch"]);
  return new Promise((w, b) => {
    const x = Object.assign({}, r);
    x.accept || (x.accept = Vo);
    let I;
    function z() {
      I.abort(), document.hidden || ye();
    }
    f || document.addEventListener("visibilitychange", z);
    let S = A2, Z = 0;
    function le() {
      document.removeEventListener("visibilitychange", z), window.clearTimeout(Z), I.abort();
    }
    n == null || n.addEventListener("abort", () => {
      le(), w();
    });
    const L = p ?? window.fetch, ve = s ?? m2;
    async function ye() {
      var De;
      I = new AbortController();
      try {
        const Re = await L(t, Object.assign(Object.assign({}, y), { headers: x, signal: I.signal }));
        await ve(Re), await f2(Re.body, p2(g2((Le) => {
          Le ? x[ru] = Le : delete x[ru];
        }, (Le) => {
          S = Le;
        }, o))), c == null || c(), le(), w();
      } catch (Re) {
        if (!I.signal.aborted)
          try {
            const Le = (De = l == null ? void 0 : l(Re)) !== null && De !== void 0 ? De : S;
            window.clearTimeout(Z), Z = window.setTimeout(ye, Le);
          } catch (Le) {
            le(), b(Le);
          }
      }
    }
    ye();
  });
}
function m2(t) {
  const e = t.headers.get("content-type");
  if (!(e != null && e.startsWith(Vo)))
    throw new Error(`Expected content-type to be ${Vo}, Actual: ${e}`);
}
function v2(t, e) {
  const n = ms.encodeBase64(t);
  return e ? encodeURIComponent(n) : n;
}
function E2(t, e) {
  return e && (t = decodeURIComponent(t)), ms.decodeBase64(t);
}
function b2(t, e = !1) {
  let n;
  return t instanceof Uint8Array ? n = t : (typeof t != "string" && (t = JSON.stringify(t)), n = ms.decodeUTF8(t)), v2(n, e);
}
function T2(t, e = !1) {
  const n = E2(t, e);
  return {
    toString() {
      return ms.encodeUTF8(n);
    },
    toObject() {
      try {
        return JSON.parse(ms.encodeUTF8(n));
      } catch {
        return null;
      }
    },
    toUint8Array() {
      return n;
    }
  };
}
const su = {
  encode: b2,
  decode: T2
};
function I2(t, e) {
  const n = new Uint8Array(t.length + e.length);
  return n.set(t), n.set(e, t.length), n;
}
function M2(t, e) {
  if (e >= t.length)
    throw new Error("Index is out of buffer");
  const n = t.slice(0, e), r = t.slice(e);
  return [n, r];
}
function ir(t) {
  let e = "";
  return t.forEach((n) => {
    e += ("0" + (n & 255).toString(16)).slice(-2);
  }), e;
}
function vs(t) {
  if (t.length % 2 !== 0)
    throw new Error(`Cannot convert ${t} to bytesArray`);
  const e = new Uint8Array(t.length / 2);
  for (let n = 0; n < t.length; n += 2)
    e[n / 2] = parseInt(t.slice(n, n + 2), 16);
  return e;
}
class or {
  constructor(e) {
    _n(this, "nonceLength", 24), _n(this, "keyPair"), _n(this, "sessionId"), this.keyPair = e ? this.createKeypairFromString(e) : this.createKeypair(), this.sessionId = ir(this.keyPair.publicKey);
  }
  createKeypair() {
    return Hr.box.keyPair();
  }
  createKeypairFromString(e) {
    return {
      publicKey: vs(e.publicKey),
      secretKey: vs(e.secretKey)
    };
  }
  createNonce() {
    return Hr.randomBytes(this.nonceLength);
  }
  encrypt(e, n) {
    const r = new TextEncoder().encode(e), s = this.createNonce(), o = Hr.box(r, s, n, this.keyPair.secretKey);
    return I2(s, o);
  }
  decrypt(e, n) {
    const [r, s] = M2(e, this.nonceLength), o = Hr.box.open(
      s,
      r,
      n,
      this.keyPair.secretKey
    );
    if (!o)
      throw new Error(
        `Decryption error: 
 message: ${e.toString()} 
 sender pubkey: ${n.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`
      );
    return new TextDecoder().decode(o);
  }
  stringifyKeypair() {
    return {
      publicKey: ir(this.keyPair.publicKey),
      secretKey: ir(this.keyPair.secretKey)
    };
  }
  static async generateKeyPairByString(e) {
    const n = new TextEncoder().encode(e), r = await crypto.subtle.digest("SHA-256", n), s = new Uint8Array(r), o = Hr.box.keyPair.fromSecretKey(s.slice(0, 32));
    return {
      publicKey: ir(o.publicKey),
      secretKey: ir(o.secretKey)
    };
  }
  static isSameKeypair(e, n) {
    return !e || !n ? !1 : e.publicKey === n.publicKey && e.secretKey === n.secretKey;
  }
}
const bf = "https://bridge.mz.xyz", iu = {
  CONNECT: "[MizuWallet SSE Connect]"
};
var Zo = /* @__PURE__ */ ((t) => (t[t.SUCCESS = 0] = "SUCCESS", t[t.ERROR = 1] = "ERROR", t))(Zo || {}), ns = /* @__PURE__ */ ((t) => (t[t.MIZU = 0] = "MIZU", t[t.MIZU_PC = 1] = "MIZU_PC", t[t.THIRD_PARTY = 2] = "THIRD_PARTY", t))(ns || {}), wn = /* @__PURE__ */ ((t) => (t[t.START = 0] = "START", t[t.DATA = 1] = "DATA", t[t.FULFILLED = 2] = "FULFILLED", t[t.REJECT = 3] = "REJECT", t[t.CANCEL = 4] = "CANCEL", t[t.CLOSE = 5] = "CLOSE", t))(wn || {});
const ou = async (t) => {
  const e = new URLSearchParams(), n = new or(t.keypair), r = new AbortController();
  e.append("client_id", n.sessionId.toString()), e.append("to", t.to.toString()), e.append("ttl", t.ttl.toString());
  const s = JSON.stringify(t.content), o = vs(t.to.toString()), c = n.encrypt(s, o), l = ir(c);
  return await Ef(`${bf}/bridge/message?${e.toString()}`, {
    method: "POST",
    openWhenHidden: !1,
    headers: {
      Accept: "text/event-stream"
    },
    onopen(f) {
      var p, y, w, b;
      return f.ok && f.status === 200 ? ((p = console.group) == null || p.call(console, "[SessionPost]"), console.log(`The connection from ${n.sessionId} to ${t.to}`), (y = console.groupEnd) == null || y.call(console), Promise.resolve()) : ((w = console.group) == null || w.call(console, "[SessionPost]"), console.log(`The connection from ${n.sessionId} to ${t.to}`), console.log("Client side error ", f), (b = console.groupEnd) == null || b.call(console), Promise.reject());
    },
    onmessage() {
    },
    onclose() {
      var f, p;
      (f = console.group) == null || f.call(console, "[SessionPost]"), console.log(`The connection from ${n.sessionId} to ${t.to} is closed by the server`), (p = console.groupEnd) == null || p.call(console), console.log("abort"), r == null || r.abort();
    },
    onerror(f) {
      var p, y;
      (p = console.group) == null || p.call(console, "[SessionPost]"), console.log(`The connection from ${n.sessionId} to ${t.to}`), console.log("There was an error from server", f.message || f), (y = console.groupEnd) == null || y.call(console), r == null || r.abort();
    },
    body: l,
    signal: r.signal
  }), {
    ctrl: r
  };
}, au = async (t) => {
  const e = new URLSearchParams(), n = t.keypair.publicKey.toString();
  e.append("client_id", n);
  const r = new AbortController();
  return Ef(`${bf}/bridge/events?${e.toString()}`, {
    openWhenHidden: !1,
    onopen(s) {
      return s.status === 200 ? (console.info(`${iu.CONNECT} Opened`), Promise.resolve()) : (console.error(`${iu.CONNECT} Failed to open`), Promise.reject());
    },
    onmessage(s) {
      var o, c;
      try {
        if (s.data && s.data.startsWith("{")) {
          const l = JSON.parse(s.data);
          if (l.message) {
            const f = new or({
              ...t.keypair
            }), p = l.message, y = vs(p), w = f.decrypt(
              y,
              vs(l.from.toString())
            ), b = JSON.parse(w);
            (t.nonce && b.nonce == t.nonce || !t.nonce) && ((o = t.callback) == null || o.call(t, {
              status: 0,
              message: b
            }));
          }
        }
      } catch (l) {
        console.error(l), (c = t.callback) == null || c.call(t, {
          status: 1,
          error: l
        });
      }
    },
    onclose() {
      var s, o;
      (s = console.group) == null || s.call(console, "[SessionListenerLong]"), console.log(`Listening channel: ${n}`), console.log("Close abort"), (o = console.groupEnd) == null || o.call(console), r == null || r.abort();
    },
    onerror(s) {
      var o, c;
      (o = console.group) == null || o.call(console, "[SessionListenerLong]"), console.log(`Listening channel: ${n}`), console.log("There was an error from server", s.message || s), console.log("Error abort"), (c = console.groupEnd) == null || c.call(console), r == null || r.abort();
    },
    signal: r.signal
  }), {
    ctrl: r
  };
};
class cu {
  constructor(e) {
    _n(this, "from", ""), _n(this, "nonce", ""), _n(this, "body"), _n(this, "type", ""), Object.assign(this, e), this.body = e.body;
  }
}
const Yr = typeof window < "u" && !!(window != null && window.TelegramWebviewProxy);
var uu, lu;
typeof window < "u" && (lu = (uu = window == null ? void 0 : window.Telegram) == null ? void 0 : uu.WebApp) != null && lu.openTelegramLink;
const N2 = typeof window < "u" && (window == null ? void 0 : window.parent) != null && window != (window == null ? void 0 : window.parent);
function x2(t, e, n) {
  if (e || (e = function() {
  }), n === void 0 && (n = ""), console.log("[Telegram.WebView] > postEvent", t, n), (window == null ? void 0 : window.TelegramWebviewProxy) !== void 0)
    window == null || window.TelegramWebviewProxy.postEvent(t, JSON.stringify(n)), e();
  else if (N2)
    try {
      var r = "https://web.telegram.org";
      r = "*", window == null || window.parent.postMessage(
        JSON.stringify({ eventType: t, eventData: n }),
        r
      ), e();
    } catch (s) {
      e(s);
    }
  else
    e({ notAvailable: !0 });
}
const S2 = function(t) {
  var e, n, r, s;
  if (typeof window < "u" && (n = (e = window == null ? void 0 : window.Telegram) == null ? void 0 : e.WebApp) != null && n.openTelegramLink) {
    (s = (r = window == null ? void 0 : window.Telegram) == null ? void 0 : r.WebApp) == null || s.openTelegramLink(t);
    return;
  }
  let o = document.createElement("A");
  if (o.href = t, o.protocol != "http:" && o.protocol != "https:")
    throw console.error("[Telegram.WebApp] Url protocol is not supported", t), Error("WebAppTgUrlInvalid");
  if (o.hostname != "t.me")
    throw console.error("[Telegram.WebApp] Url host is not supported", t), Error("WebAppTgUrlInvalid");
  var c = o.pathname + o.search;
  x2("web_app_open_tg_link", !1, { path_full: c });
}, yo = (t) => {
  var e, n, r;
  return ((r = (n = (e = t == null ? void 0 : t.response) == null ? void 0 : e.errors) == null ? void 0 : n[0]) == null ? void 0 : r.message) || t.message || t;
};
class Ga {
  static buildAction(e) {
    return `${e.prefix}${e.action}_${e.params.map((n) => Ga.actionParamsEncode(n)).join("_")}`;
  }
  static actionParamsEncode(e) {
    return encodeURIComponent(e).replace(/\./g, "%2E").replace(/%/g, "--");
  }
  static actionParamsDecode(e) {
    return decodeURIComponent(e.replace(/--/g, "%"));
  }
}
const wo = "mizuwallet-address";
class Tf {
  constructor() {
    je(this, "manifestURL", ""), je(this, "miniAppURL", ""), je(this, "origin", ""), je(this, "mizuClient", null), je(this, "network", "");
  }
  async startWebChannel(e) {
    var n;
    const r = new or(), s = Date.now().toString(), o = await or.generateKeyPairByString(
      `${e.address || ""}+${s}`
    ), c = su.encode(o, !0), l = new URLSearchParams();
    l.append("network", this.network), l.append("sessionId", r.sessionId), l.append("nonce", s.toString()), l.append("k", c), e.redirectURL && l.append("redirect_url", e.redirectURL), document.querySelector(".mizu-wallet-frame") && ((n = document.querySelector(".mizu-wallet-frame")) == null || n.remove());
    const f = document.createElement("iframe");
    f.setAttribute("class", "mizu-wallet-frame"), f.setAttribute("src", `${this.origin}/walletv2/${e.url}?${l.toString()}`), document.body.appendChild(f);
    const { ctrl: p } = await ou({
      to: o.publicKey,
      ttl: 300,
      content: new cu({
        from: ns.THIRD_PARTY,
        type: wn.DATA,
        // put all data here
        body: {
          manifestURL: this.manifestURL,
          address: window == null ? void 0 : window.localStorage.getItem(wo),
          ...e.metadata
        },
        nonce: s
      })
    });
    return new Promise(async (y, w) => {
      const { ctrl: b } = await au({
        keypair: r.stringifyKeypair(),
        callback: (x) => {
          var I, z, S, Z, le;
          const { message: L, status: ve } = x;
          if ((L == null ? void 0 : L.from) === ns.MIZU_PC) {
            if (ve === Zo.ERROR) {
              (I = f.parentNode) == null || I.removeChild(f), p.abort(), b.abort(), w(x.error);
              return;
            }
            if ((L == null ? void 0 : L.type) == wn.CLOSE) {
              (z = f.parentNode) == null || z.removeChild(f), p.abort(), b.abort(), y({});
              return;
            }
            if ((L == null ? void 0 : L.type) == wn.CANCEL) {
              (S = f.parentNode) == null || S.removeChild(f), p.abort(), b.abort(), w("User Canceled");
              return;
            }
            if (L.type === wn.FULFILLED) {
              (Z = f.parentNode) == null || Z.removeChild(f), p.abort(), b.abort(), e.returnKey ? y({
                [e.returnKey]: (le = L.body) == null ? void 0 : le[e.returnKey]
              }) : y({});
              return;
            }
          }
        }
      });
    });
  }
  async startChannel(e) {
    const n = window == null ? void 0 : window.localStorage.getItem(wo);
    if (n && e.isAddressRequired || !e.isAddressRequired) {
      const r = new or(), s = Date.now().toString(), o = await or.generateKeyPairByString(
        `${n || ""}+${s}`
      ), c = su.encode(o, !0), l = Ga.buildAction({
        prefix: "R_",
        action: e.buildAction.actions,
        params: [r.sessionId, s, c]
      });
      S2(`${this.miniAppURL}?startapp=${l}`);
      const { ctrl: f } = await ou({
        to: o.publicKey,
        ttl: 300,
        content: new cu({
          from: ns.THIRD_PARTY,
          type: wn.DATA,
          // put all data here
          body: {
            manifestURL: this.manifestURL,
            address: window == null ? void 0 : window.localStorage.getItem(wo),
            ...e.metadata
          },
          nonce: s
        })
      });
      return new Promise(async (p, y) => {
        const { ctrl: w } = await au({
          keypair: r.stringifyKeypair(),
          callback: (b) => {
            var x;
            const { message: I, status: z } = b;
            if ((I == null ? void 0 : I.from) === ns.MIZU) {
              if (z === Zo.ERROR) {
                f.abort(), w.abort(), y(b.error);
                return;
              }
              if ((I == null ? void 0 : I.type) == wn.CANCEL) {
                f.abort(), w.abort(), y("User Canceled");
                return;
              }
              if (I.type === wn.FULFILLED) {
                f.abort(), w.abort(), e.returnKey ? p({
                  [e.returnKey]: (x = I.body) == null ? void 0 : x[e.returnKey]
                }) : p({});
                return;
              }
            }
          }
        });
      });
    } else
      throw new Error(`${Ya.TRANSACTION} No address found`);
  }
}
const Gr = "mizuwallet-address", Vr = "mizuwallet-publickey";
class D2 extends Tf {
  /**
   *
   * @param args.manifestURL Manifest URL
   */
  constructor(e) {
    if (super(), je(this, "manifestURL"), je(this, "miniAppURL"), !e.manifestURL) throw new Error("manifestURL is required");
    this.manifestURL = e.manifestURL, this.miniAppURL = qA(e.network);
  }
  /**
   * Connect
   *
   * Open MizuWallet MiniApp to connect
   * Try to get Address info back
   *
   *
   * @returns
   */
  async connect() {
    var e, n, r, s;
    if (window != null && window.localStorage && (e = window.localStorage) != null && e.getItem(Gr) && (n = window.localStorage) != null && n.getItem(Vr))
      return {
        address: ((r = window.localStorage.getItem(Gr)) == null ? void 0 : r.toString()) || "",
        publicKey: ((s = window.localStorage.getItem(Vr)) == null ? void 0 : s.toString()) || ""
      };
    const { account: o } = await this.startChannel({
      buildAction: {
        actions: "miniapp-connectv2"
      },
      metadata: {},
      returnKey: "account"
    });
    if (window != null && window.localStorage && o != null && o.address && $e.isValid({
      input: o == null ? void 0 : o.address,
      strict: !0
    }))
      return window.localStorage.setItem(Gr, o == null ? void 0 : o.address), window.localStorage.setItem(Vr, o == null ? void 0 : o.publicKey), {
        address: o == null ? void 0 : o.address,
        publicKey: o == null ? void 0 : o.publicKey
      };
    throw new Error(`${Ya.CONNECT} Error`);
  }
  disconnect() {
    window != null && window.localStorage.getItem(Gr) && (window == null || window.localStorage.removeItem(Gr)), window != null && window.localStorage.getItem(Vr) && (window == null || window.localStorage.removeItem(Vr));
  }
  async signAndSubmitTransaction(e) {
    return await this.startChannel({
      buildAction: {
        actions: "miniapp-transactionv2"
      },
      metadata: {
        transaction: e
      },
      returnKey: "hash",
      isAddressRequired: !0
    });
  }
  async signTransaction(e) {
    return await this.startChannel({
      buildAction: {
        actions: "miniapp-signtransactionv2"
      },
      metadata: {
        transaction: e.bcsToHex().toStringWithoutPrefix()
      },
      returnKey: "signature",
      isAddressRequired: !0
    });
  }
  async signMessage(e) {
    return await this.startChannel({
      buildAction: {
        actions: "miniapp-signmessagev2"
      },
      metadata: {
        args: e
      },
      returnKey: "data",
      isAddressRequired: !0
    });
  }
}
const U2 = "https://mizu.io", C2 = () => {
  const t = document.createElement("style");
  t.innerHTML = `
	  .mizu-wallet-frame {
		position: fixed;
		top: 0;
		left: 0;
		width: 100vw;
		height: 100vh;
		border: none;
		z-index: 999999999;
		inset: 0px;
    color-scheme: light;
    pointer-events: auto;
	  }
	`, document.head.appendChild(t);
};
class z2 extends Tf {
  /**
   *
   * @param args.manifestURL Manifest URL
   */
  constructor(e) {
    if (super(), je(this, "authCode"), je(this, "address"), je(this, "manifestURL"), je(this, "network"), je(this, "mizuClient"), je(this, "provider"), je(this, "origin"), !e.manifestURL) throw new Error("manifestURL is required");
    this.authCode = "", this.manifestURL = e.manifestURL, this.network = e.network, this.mizuClient = e.mizuClient, this.origin = U2, this.address = "", C2();
  }
  async connect() {
    var e, n, r, s;
    const o = await this.startWebChannel({
      url: "checkLogin",
      metadata: {
        manifestURL: this.manifestURL,
        network: this.network,
        appId: this.mizuClient.appId
      },
      returnKey: "account"
    });
    return o.account ? (this.authCode = (e = o.account) == null ? void 0 : e.code, this.address = (n = o.account) == null ? void 0 : n.address, Promise.resolve({
      address: (r = o.account) == null ? void 0 : r.address,
      publicKey: ((s = o.account) == null ? void 0 : s.publicKey) || ""
    })) : Promise.reject("User Canceled");
  }
  async disconnect() {
    var e;
    await this.startWebChannel({
      url: "checkLogin",
      redirectURL: "/walletv2/logout",
      metadata: {
        manifestURL: this.manifestURL,
        network: this.network,
        appId: this.mizuClient.appId
      },
      returnKey: ""
    }), await ((e = this.mizuClient) == null ? void 0 : e.logout());
  }
  async signAndSubmitTransaction(e) {
    var n;
    try {
      const r = await ((n = this.mizuClient) == null ? void 0 : n.createOrderWithCode({
        code: this.authCode,
        payload: e
      }));
      if (!r) throw new Error("Transaction creation failed");
      return await this.startWebChannel({
        url: "checkLogin",
        redirectURL: "/walletv2/transaction",
        metadata: {
          manifestURL: this.manifestURL,
          network: this.network,
          appId: this.mizuClient.appId,
          orderId: r,
          transaction: e
        },
        returnKey: "hash"
      });
    } catch (r) {
      throw console.error(r), new Error(yo(r));
    }
  }
  async signTransaction(e) {
    try {
      return {
        signature: (await this.startWebChannel({
          url: "checkLogin",
          redirectURL: "/walletv2/sign_transaction",
          metadata: {
            manifestURL: this.manifestURL,
            network: this.network,
            appId: this.mizuClient.appId,
            transaction: e.bcsToHex().toStringWithoutPrefix()
          },
          returnKey: "signature"
        })).signature
      };
    } catch (n) {
      throw console.error(n), new Error(yo(n));
    }
  }
  async signMessage(e) {
    try {
      return {
        data: {
          ...(await this.startWebChannel({
            url: "checkLogin",
            redirectURL: "/walletv2/sign_message",
            metadata: {
              manifestURL: this.manifestURL,
              network: this.network,
              appId: this.mizuClient.appId,
              messageInfo: {
                ...e
              }
            },
            returnKey: "message"
          })).message
        }
      };
    } catch (n) {
      throw console.error(n), new Error(yo(n));
    }
  }
}
class k2 {
  constructor(e) {
    if (je(this, "url", t2), je(this, "version", "1.0.0"), je(this, "name", e2), je(this, "icon", n2), je(this, "chains", GA), je(this, "accounts", []), je(this, "provider"), je(this, "mizuClient"), je(this, "telegramMiniAppHelper"), je(this, "websiteHelper"), je(this, "accountInfo"), je(this, "account", async () => this.accountInfo || {
      address: "",
      publicKey: ""
    }), je(this, "connect", async () => {
      var n;
      try {
        if (Yr)
          if (this.telegramMiniAppHelper)
            this.accountInfo = await this.telegramMiniAppHelper.connect();
          else
            throw new Error(`${Ya.CONNECT} Please pass a valid manifestURL`);
        else
          this.accountInfo = await ((n = this.websiteHelper) == null ? void 0 : n.connect());
        return {
          args: {
            ...this.accountInfo
          },
          status: nn.APPROVED
        };
      } catch (r) {
        return console.error(r), {
          status: nn.REJECTED
        };
      }
    }), je(this, "network", async () => ({
      name: this.provider.network,
      chainId: this.provider.network === "mainnet" ? 1 : 2
    })), je(this, "disconnect", async () => {
      var n, r;
      try {
        Yr ? await ((n = this.telegramMiniAppHelper) == null ? void 0 : n.disconnect()) : await ((r = this.websiteHelper) == null ? void 0 : r.disconnect());
      } catch (s) {
        throw s;
      }
    }), je(this, "signTransaction", async (n, r) => {
      var s, o;
      try {
        console.log(r);
        let c = {};
        if (Yr ? c = await ((s = this.telegramMiniAppHelper) == null ? void 0 : s.signTransaction(n)) : c = await ((o = this.websiteHelper) == null ? void 0 : o.signTransaction(n)), c.signature) {
          const l = new un(kn.Buffer.from(c.signature, "hex"));
          return {
            args: Es.deserialize(l),
            status: nn.APPROVED
          };
        } else
          return {
            status: nn.REJECTED
          };
      } catch (c) {
        throw c.message || c ? new Error(c.message || c) : new go(ti.InternalError);
      }
    }), je(this, "signAndSubmitTransaction", async (n) => {
      var r, s;
      try {
        let o = {};
        return Yr ? o = await ((r = this.telegramMiniAppHelper) == null ? void 0 : r.signAndSubmitTransaction(n.payload)) : o = await ((s = this.websiteHelper) == null ? void 0 : s.signAndSubmitTransaction(n.payload)), o != null && o.hash ? {
          args: o,
          status: nn.APPROVED
        } : {
          status: nn.REJECTED
        };
      } catch (o) {
        throw o.message || o ? new Error(o.message || o) : new go(ti.InternalError);
      }
    }), je(this, "signMessage", async (n) => {
      var r, s;
      try {
        const { message: o, nonce: c, ...l } = n;
        let f = {};
        return Yr ? f = await ((r = this.telegramMiniAppHelper) == null ? void 0 : r.signMessage({
          message: o,
          nonce: c
        })) : f = await ((s = this.websiteHelper) == null ? void 0 : s.signMessage({
          message: o,
          nonce: c
        })), f != null && f.data ? {
          args: {
            ...f == null ? void 0 : f.data,
            ...l
          },
          status: nn.APPROVED
        } : {
          status: nn.REJECTED
        };
      } catch (o) {
        throw o.message || o ? new Error(o.message || o) : new go(ti.InternalError);
      }
    }), je(this, "onAccountChange", async () => Promise.resolve()), je(this, "onNetworkChange", async () => Promise.resolve()), !e.network) throw new Error("MizuWallet: network is required");
    if (this.mizuClient = new os({
      appId: e.appId || $A(e.network),
      network: e.network
    }), this.provider = {
      network: e.network,
      address: ""
    }, e.manifestURL.indexOf("_") > -1)
      throw new Error('manifestURL can not contain underscore: "_"');
    e != null && e.manifestURL && (this.telegramMiniAppHelper = new D2({
      manifestURL: e == null ? void 0 : e.manifestURL,
      network: e.network
    })), this.websiteHelper = new z2({
      manifestURL: e.manifestURL,
      network: e.network,
      mizuClient: this.mizuClient
    });
  }
  get features() {
    return {
      "aptos:connect": {
        version: "1.0.0",
        connect: this.connect
      },
      "aptos:network": {
        version: "1.0.0",
        network: this.network
      },
      "aptos:disconnect": {
        version: "1.0.0",
        disconnect: this.disconnect
      },
      "aptos:signTransaction": {
        version: "1.0.0",
        signTransaction: this.signTransaction
      },
      "aptos:signAndSubmitTransaction": {
        version: "1.1.0",
        signAndSubmitTransaction: this.signAndSubmitTransaction
      },
      "aptos:signMessage": {
        version: "1.0.0",
        signMessage: this.signMessage
      },
      "aptos:onAccountChange": {
        version: "1.0.0",
        onAccountChange: this.onAccountChange
      },
      "aptos:onNetworkChange": {
        version: "1.0.0",
        onNetworkChange: this.onNetworkChange
      },
      "aptos:account": {
        version: "1.0.0",
        account: this.account
      }
    };
  }
}
var If = "4.24.0";
function O2(t) {
  const e = [];
  return typeof window < "u" && (e.push(
    new _w({
      network: t == null ? void 0 : t.network,
      dappId: t == null ? void 0 : t.aptosConnectDappId,
      ...t == null ? void 0 : t.aptosConnect
    }),
    new Bw({
      network: t == null ? void 0 : t.network,
      dappId: t == null ? void 0 : t.aptosConnectDappId,
      ...t == null ? void 0 : t.aptosConnect
    })
  ), t != null && t.mizuwallet && (t != null && t.network) && [Ye.MAINNET, Ye.TESTNET].includes(t.network) && e.push(
    new k2({
      network: t.network,
      manifestURL: t.mizuwallet.manifestURL,
      appId: t.mizuwallet.appId
    })
  )), (t == null ? void 0 : t.network) === Ye.MAINNET ? e.push(new Qa()) : e.push(new Gw()), e;
}
var ni = /* @__PURE__ */ ((t) => (t.Installed = "Installed", t.NotDetected = "NotDetected", t.Loadable = "Loadable", t.Unsupported = "Unsupported", t))(ni || {}), L2 = {
  1: "mainnet",
  2: "testnet"
}, mt = class extends Error {
  constructor(t, e) {
    super(t), this.error = e;
  }
}, j2 = class extends mt {
  constructor() {
    super(...arguments), this.name = "WalletNotSelectedError";
  }
}, du = class extends mt {
  constructor() {
    super(...arguments), this.name = "WalletNotReadyError";
  }
}, Yt = class extends mt {
  constructor() {
    super(...arguments), this.name = "WalletConnectionError";
  }
}, P2 = class extends mt {
  constructor() {
    super(...arguments), this.name = "WalletDisconnectionError";
  }
}, hu = class extends mt {
  constructor() {
    super(...arguments), this.name = "WalletAccountError";
  }
}, _2 = class extends mt {
  constructor() {
    super(...arguments), this.name = "WalletGetNetworkError";
  }
}, B2 = class extends mt {
  constructor() {
    super(...arguments), this.name = "WalletAccountChangeError";
  }
}, R2 = class extends mt {
  constructor() {
    super(...arguments), this.name = "WalletNetworkChangeError";
  }
}, fu = class extends mt {
  constructor() {
    super(...arguments), this.name = "WalletNotConnectedError";
  }
}, Mf = class extends mt {
  constructor() {
    super(...arguments), this.name = "WalletSignMessageError";
  }
}, fr = class extends mt {
  constructor() {
    super(...arguments), this.name = "WalletSignMessageAndVerifyError";
  }
}, vr = class extends mt {
  constructor() {
    super(...arguments), this.name = "WalletSignAndSubmitMessageError";
  }
}, qo = class extends mt {
  constructor() {
    super(...arguments), this.name = "WalletSignTransactionError";
  }
}, Nf = class extends mt {
  constructor() {
    super(...arguments), this.name = "WalletNotSupportedMethod";
  }
}, pu = class extends mt {
  constructor() {
    super(...arguments), this.name = "WalletChangeNetworkError";
  }
};
function F2(t) {
  switch (t == null ? void 0 : t.name) {
    case "mainnet":
      return Ye.MAINNET;
    case "testnet":
      return Ye.TESTNET;
    case "devnet":
      return Ye.DEVNET;
    case "local":
      return Ye.LOCAL;
    default:
      throw new Error("Invalid Aptos network name");
  }
}
function W2(t) {
  const e = new Vn.Deserializer(t.bcsToBytes());
  return Oe.TransactionPayload.deserialize(e);
}
function Q2(t) {
  var e, n;
  if ("bytecode" in t)
    throw new Error("script payload not supported");
  if ("multisigAddress" in t) {
    const r = (e = t.typeArguments) == null ? void 0 : e.map(
      (o) => o instanceof oi ? o.toString() : o
    );
    return {
      type: "multisig_payload",
      multisig_address: t.multisigAddress.toString(),
      function: t.function,
      type_arguments: r || [],
      arguments: t.functionArguments
    };
  } else {
    const r = (n = t.typeArguments) == null ? void 0 : n.map(
      (o) => o instanceof oi ? o.toString() : o
    );
    return {
      type: "entry_function_payload",
      function: t.function,
      type_arguments: r || [],
      arguments: t.functionArguments
    };
  }
}
function xf(t) {
  if ("function" in t)
    return {
      function: t.function,
      functionArguments: t.arguments,
      typeArguments: t.type_arguments
    };
  throw new Error("Payload type not supported");
}
async function K2(t, e) {
  if ("function" in e) {
    const n = xf(e);
    return cs({ ...n, aptosConfig: t });
  }
  throw new Error("Payload type not supported");
}
function H2() {
  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(
    navigator.userAgent
  );
}
function Y2() {
  const t = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
    navigator.userAgent
  ), e = /(Android).*Version\/[\d.]+.*Chrome\/[^\s]+ Mobile/i.test(
    navigator.userAgent
  );
  return t || e;
}
function G2() {
  return typeof navigator > "u" || !navigator ? !1 : H2() && !Y2();
}
function bt(t) {
  return typeof t == "object" && "message" in t ? t.message : t;
}
var V2 = (t) => t.length === 0 ? !1 : t.every(
  (e) => e instanceof Xo
), rs = (t, e) => {
  if (!t)
    throw new Error("Undefined network");
  if (Sf(t)) {
    const n = F2(t);
    if (Z2(n)) {
      const r = e == null ? void 0 : e.aptosApiKeys;
      return new cr({
        network: n,
        clientConfig: { API_KEY: r ? r[n] : void 0 }
      });
    }
    return new cr({
      network: n
    });
  }
  return new cr({
    network: Ye.CUSTOM,
    fullnode: t.url
  });
}, Sf = (t) => {
  if (!t)
    throw new Error("Undefined network");
  return mo[t.name] !== void 0;
}, Z2 = (t) => t === "devnet" || t === "testnet" || t === "mainnet", q2 = async () => await new is().getChainId(), X2 = (t) => {
  let e = t.data.functionArguments[0];
  typeof e == "string" && (e = on.fromHexInput(e).toUint8Array());
  let n = t.data.functionArguments[1];
  if (Array.isArray(n))
    n = n.map((r) => typeof r == "string" ? on.fromHexInput(r).toUint8Array() : r);
  else
    throw new vr(
      "The bytecode argument must be an array."
    ).message;
  return { metadataBytes: e, byteCode: n };
}, Df = "AptosWalletName";
function J2(t) {
  localStorage.setItem(Df, t);
}
function $2() {
  localStorage.removeItem(Df);
}
function em(t) {
  if (typeof window > "u" || typeof document > "u")
    return;
  const e = [];
  function n() {
    if (t())
      for (const o of e)
        o();
  }
  const r = setInterval(n, 1e3);
  e.push(() => clearInterval(r)), document.readyState === "loading" && (document.addEventListener("DOMContentLoaded", n, {
    once: !0
  }), e.push(
    () => document.removeEventListener("DOMContentLoaded", n)
  )), document.readyState !== "complete" && (window.addEventListener("load", n, { once: !0 }), e.push(() => window.removeEventListener("load", n))), n();
}
var tm = class extends Od {
  async connect(t) {
    return await t.connect();
  }
  async resolveSignAndSubmitTransaction(t, e, n, r, s) {
    var o, c, l, f, p, y, w, b;
    if (V2(t.functionArguments)) {
      const I = rs(e, s), z = await cs({
        ...t,
        aptosConfig: I
      }), S = W2(z);
      return await this.signAndSubmitBCSTransaction(
        S,
        n,
        {
          max_gas_amount: (o = r.options) != null && o.maxGasAmount ? BigInt((c = r.options) == null ? void 0 : c.maxGasAmount) : void 0,
          gas_unit_price: (l = r.options) != null && l.gasUnitPrice ? BigInt((f = r.options) == null ? void 0 : f.gasUnitPrice) : void 0
        }
      );
    }
    const x = Q2(t);
    return await this.signAndSubmitTransaction(x, n, {
      max_gas_amount: (p = r.options) != null && p.maxGasAmount ? BigInt((y = r.options) == null ? void 0 : y.maxGasAmount) : void 0,
      gas_unit_price: (w = r.options) != null && w.gasUnitPrice ? BigInt((b = r.options) == null ? void 0 : b.gasUnitPrice) : void 0
    });
  }
  async signAndSubmitTransaction(t, e, n) {
    try {
      return await e.signAndSubmitTransaction(
        t,
        n
      );
    } catch (r) {
      const s = typeof r == "object" && "message" in r ? r.message : r;
      throw new vr(s).message;
    }
  }
  async signAndSubmitBCSTransaction(t, e, n) {
    if (!("signAndSubmitBCSTransaction" in e))
      throw new Nf(
        `Submit a BCS Transaction is not supported by ${e.name}`
      ).message;
    try {
      return await e.signAndSubmitBCSTransaction(
        t,
        n
      );
    } catch (r) {
      const s = typeof r == "object" && "message" in r ? r.message : r;
      throw new vr(s).message;
    }
  }
  async signTransaction(t, e, n) {
    try {
      return await e.signTransaction(
        t,
        n
      );
    } catch (r) {
      const s = typeof r == "object" && "message" in r ? r.message : r;
      throw new qo(s).message;
    }
  }
  async signMessageAndVerify(t, e, n) {
    try {
      const r = await e.signMessage(t);
      if (!r)
        throw new fr("Failed to sign a message").message;
      console.log("signMessageAndVerify signMessage response", r);
      let s = !1;
      if (Array.isArray(r.signature)) {
        const { fullMessage: o, signature: c, bitmap: l } = r;
        if (l) {
          const f = n.minKeysRequired;
          if (c.length < f)
            s = !1;
          else {
            const p = Array.from(l).flatMap(
              (x) => Array.from({ length: 8 }).map((I, z) => x >> z & 1)
            ), y = p.map((x, I) => I).filter((x) => p[x]), b = n.publicKey.filter(
              (x, I) => y.includes(I)
            );
            s = !0;
            for (let x = 0; x < c.length; x++)
              if (!St.sign.detached.verify(
                kn.Buffer.from(o),
                kn.Buffer.from(c[x], "hex"),
                kn.Buffer.from(b[x], "hex")
              )) {
                s = !1;
                break;
              }
          }
        } else
          throw new fr("Failed to get a bitmap").message;
      } else {
        const o = new me(
          n.publicKey
        ), c = new me(
          r.signature
        );
        s = St.sign.detached.verify(
          kn.Buffer.from(r.fullMessage),
          kn.Buffer.from(c.noPrefix(), "hex"),
          kn.Buffer.from(o.noPrefix(), "hex")
        );
      }
      return s;
    } catch (r) {
      const s = bt(r);
      throw new fr(s).message;
    }
  }
}, nm = class {
  async connect(t) {
    const e = await t.connect();
    if (e.status === ot.REJECTED)
      throw new Yt("User has rejected the request").message;
    return e.args;
  }
  async signAndSubmitTransaction(t, e, n, r, s) {
    var o, c, l;
    try {
      const f = s.find(
        (w) => r.name === w.name
      );
      if (((o = f == null ? void 0 : f.features["aptos:signAndSubmitTransaction"]) == null ? void 0 : o.version) !== "1.1.0") {
        const w = await e.transaction.build.simple({
          sender: n.address.toString(),
          data: t.data,
          options: t.options
        }), b = await r.signAndSubmitTransaction(
          w
        );
        if (b.status === ot.REJECTED)
          throw new Yt("User has rejected the request").message;
        return b.args;
      }
      const p = {
        gasUnitPrice: (c = t.options) == null ? void 0 : c.gasUnitPrice,
        maxGasAmount: (l = t.options) == null ? void 0 : l.maxGasAmount,
        payload: t.data
      }, y = await r.signAndSubmitTransaction(
        p
      );
      if (y.status === ot.REJECTED)
        throw new Yt("User has rejected the request").message;
      return y.args;
    } catch (f) {
      const p = bt(f);
      throw new vr(p).message;
    }
  }
  async signTransaction(t, e, n) {
    const r = await e.signTransaction(
      t,
      n
    );
    if (r.status === ot.REJECTED)
      throw new Yt("User has rejected the request").message;
    return r.args;
  }
  async signMessage(t, e) {
    try {
      const n = await e.signMessage(
        t
      );
      if (n.status === ot.REJECTED)
        throw new Yt("User has rejected the request").message;
      return n.args;
    } catch (n) {
      const r = bt(n);
      throw new Mf(r).message;
    }
  }
  async signMessageAndVerify(t, e) {
    try {
      const n = await e.signMessage(
        t
      ), r = await e.account();
      if (n.status === ot.REJECTED)
        throw new Yt("Failed to sign a message").message;
      if (r.publicKey instanceof Fn && r.publicKey.variant === qf.Keyless)
        return !0;
      let s = !1;
      if (n.args.signature instanceof Jo) {
        if (!(r.publicKey instanceof pr))
          throw new fr(
            "Public key and Signature type mismatch"
          ).message;
        const { fullMessage: o, signature: c } = n.args;
        if (c.bitmap) {
          const f = r.publicKey.threshold;
          c.signatures.length < f ? s = !1 : s = r.publicKey.verifySignature({
            message: new TextEncoder().encode(o),
            signature: c
          });
        }
      } else
        s = r.publicKey.verifySignature({
          message: new TextEncoder().encode(n.args.fullMessage),
          signature: n.args.signature
        });
      return s;
    } catch (n) {
      const r = bt(n);
      throw new fr(r).message;
    }
  }
}, rm = class {
  constructor() {
    this.aptosGAID = "G-GNVVWBL3J9", this.injectGA(this.aptosGAID);
  }
  gtag(t, e, n) {
    (window.dataLayer || []).push(arguments);
  }
  injectGA(t) {
    if (typeof window > "u" || !t)
      return;
    const e = document.getElementsByTagName("head")[0];
    var n = document.createElement("script");
    n.setAttribute(
      "src",
      `https://www.googletagmanager.com/gtag/js?id=${t}`
    );
    const r = this;
    n.onload = function() {
      r.gtag("js", /* @__PURE__ */ new Date()), r.gtag("config", `${t}`, {
        send_page_view: !1
      });
    }, e.insertBefore(n, e.children[1]);
  }
}, sm = [
  {
    name: "Nightly",
    url: "https://chromewebstore.google.com/detail/nightly/fiikommddbeccaoicoejoniammnalkfa?hl=en",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
    readyState: "NotDetected",
    isAIP62Standard: !0
  },
  {
    name: "Petra",
    url: "https://chromewebstore.google.com/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci?hl=en",
    icon: "data:image/png;base64,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",
    readyState: "NotDetected",
    isAIP62Standard: !0,
    deeplinkProvider: "https://petra.app/explore?link="
  },
  {
    name: "Pontem Wallet",
    url: "https://pontem.network/pontem-wallet",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzYiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCAzNiAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE4IDBDOC4wNzMwNCAwIDAgOC4wNzEzOSAwIDE3Ljk5NjNDMCAyNS4xMjk4IDQuMTczMTYgMzEuMzEwOCAxMC4yMDc2IDM0LjIyMDNWMzQuMjM1MUgxMC4yMzcyQzEyLjU4NiAzNS4zNjQ5IDE1LjIyMjggMzYgMTggMzZDMjcuOTI3IDM2IDM2IDI3LjkyODYgMzYgMTguMDAzN0MzNiA4LjA3MTM4IDI3LjkyNyAwIDE4IDBaTTE4IDEuNDc2OTJDMjcuMTA3MSAxLjQ3NjkyIDM0LjUyMjggOC44OTEwOCAzNC41MjI4IDE3Ljk5NjNDMzQuNTIyOCAyMC42MTA1IDMzLjkwOTcgMjMuMDkxNyAzMi44MjQgMjUuMjkyM0MzMC40NDU2IDI0LjE0MDMgMjguMDMwNCAyMy4yODM3IDI1LjU5MjkgMjIuNzAwM1Y4LjkyMDYyQzI1LjU5MjkgOC40NDA2MiAyNS4yMTYyIDguMDU2NjIgMjQuNzQzNSA4LjA1NjYySDIxLjcxNTJIMTQuMDg1NEgxMS4wNTdDMTAuNTkxNyA4LjA1NjYyIDEwLjIwNzYgOC40NDA2MiAxMC4yMDc2IDguOTIwNjJWMjIuNzY2OEM3Ljg0NDA3IDIzLjM1MDIgNS40OTUyOCAyNC4xOTIgMy4xODM0MiAyNS4yOTk3QzIuMDkwMjcgMjMuMDkxNyAxLjQ3NzIzIDIwLjYxNzggMS40NzcyMyAxNy45OTYzQzEuNDc3MjMgOC44OTEwOCA4Ljg5MjkgMS40NzY5MiAxOCAxLjQ3NjkyWk00LjEzNjIzIDI2Ljk2MTJDNi4wOTM1NiAyNS45OTM4IDguMTI0NzQgMjUuMjQ4IDEwLjIxNSAyNC43MzExVjMyLjU1ODhDNy43NDA2NiAzMS4yMzY5IDUuNjUwMzkgMjkuMzAyMiA0LjEzNjIzIDI2Ljk2MTJaTTE0LjA4NTQgMzQuMDQzMVYxNS42MDM3QzE0LjA4NTQgMTMuNDY5NSAxNS44MzU5IDExLjcwNDYgMTcuOTI2MSAxMS43MDQ2QzIwLjAxNjQgMTEuNzA0NiAyMS43MTUyIDEzLjQzMjYgMjEuNzE1MiAxNS41NTk0QzIxLjcxNTIgMTUuNTc0MiAyMS43MDc4IDE1LjU4ODkgMjEuNzA3OCAxNS42MDM3SDIxLjcxNTJWMjIuMDIwOUMxOS45MzUyIDIxLjgxNDIgMTguMTQ3NyAyMS43NDc3IDE2LjM2MDMgMjEuODQzN0wxNC44OTA0IDIzLjk3NzhDMTcuMTgwMSAyMy43ODU4IDE5LjQxMDcgMjMuODAwNiAyMS42MTE4IDI0LjA1MTdDMjEuNjM0IDI0LjA1MTcgMjEuNjQ4NyAyNC4wNTE3IDIxLjY3MDkgMjQuMDU5MUMyMS42ODU3IDI0LjA1OTEgMjEuNzAwNSAyNC4wNTkxIDIxLjcyMjYgMjQuMDY2NUMyMi4xMDY3IDI0LjExMDggMjMuNTAyNyAyNC4yODggMjQuNzgwNSAyNC42MDU1TDIxLjcyMjYgMjUuNjQ2OFYzNC4xMDIyQzIwLjUyNjEgMzQuMzc1NCAxOS4yODUyIDM0LjUzMDUgMTguMDE0OCAzNC41MzA1QzE2LjY0ODMgMzQuNTE1NyAxNS4zNDEgMzQuMzQ1OCAxNC4wODU0IDM0LjA0MzFaTTI1LjU4NTYgMzIuNjYyMlYyNC43NjhDMjcuNjY4NCAyNS4yOTIzIDI5LjcyOTIgMjYuMDYwMyAzMS43OTczIDI3LjA2NDZDMzAuMjQ2MiAyOS40MjAzIDI4LjEwNDIgMzEuMzU1MSAyNS41ODU2IDMyLjY2MjJaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMjIyXzE2NzApIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIyXzE2NzAiIHgxPSIxNy45OTk3IiB5MT0iMzYuNzc4OSIgeDI9IjE3Ljk5OTciIHkyPSItNS41MTk3OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuMDg1OCIgc3RvcC1jb2xvcj0iIzhEMjlDMSIvPgo8c3RvcCBvZmZzZXQ9IjAuMjM4MyIgc3RvcC1jb2xvcj0iIzk0MkJCQiIvPgo8c3RvcCBvZmZzZXQ9IjAuNDY2NyIgc3RvcC1jb2xvcj0iI0E5MkZBQyIvPgo8c3RvcCBvZmZzZXQ9IjAuNzQxMyIgc3RvcC1jb2xvcj0iI0NBMzc5MyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGMDNGNzciLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K",
    readyState: "NotDetected",
    isAIP62Standard: !0
  }
], im = class extends Od {
  constructor(t, e, n, r) {
    super(), this._wallets = [], this._optInWallets = [], this._standard_wallets = [], this._all_wallets = [], this._wallet = null, this._account = null, this._network = null, this.walletCoreV1 = new tm(), this.walletStandardCore = new nm(), this._connecting = !1, this._connected = !1, this.ga4 = null, this._disableTelemetry = !1, this.standardizeStandardWalletToPluginWalletType = (s) => {
      var o, c, l, f;
      let p = {
        name: s.name,
        url: s.url,
        icon: s.icon,
        provider: s,
        connect: s.features["aptos:connect"].connect,
        disconnect: s.features["aptos:disconnect"].disconnect,
        network: s.features["aptos:network"].network,
        account: s.features["aptos:account"].account,
        signAndSubmitTransaction: (o = s.features["aptos:signAndSubmitTransaction"]) == null ? void 0 : o.signAndSubmitTransaction,
        signMessage: s.features["aptos:signMessage"].signMessage,
        onAccountChange: s.features["aptos:onAccountChange"].onAccountChange,
        onNetworkChange: s.features["aptos:onNetworkChange"].onNetworkChange,
        signTransaction: s.features["aptos:signTransaction"].signTransaction,
        openInMobileApp: (c = s.features["aptos:openInMobileApp"]) == null ? void 0 : c.openInMobileApp,
        changeNetwork: (l = s.features["aptos:changeNetwork"]) == null ? void 0 : l.changeNetwork,
        readyState: "Installed",
        isAIP62Standard: !0,
        isSignTransactionV1_1: ((f = s.features["aptos:signTransaction"]) == null ? void 0 : f.version) === "1.1"
      };
      this._all_wallets = this._all_wallets.filter(
        (y) => y.name !== p.name
      ), this._all_wallets.push(p), this.emit("standardWalletsAdded", p);
    }, this._wallets = t, this._optInWallets = e, this._dappConfig = n, this._disableTelemetry = r, this._sdkWallets = O2(this._dappConfig), this._disableTelemetry || (this.ga4 = new rm()), this.fetchExtensionAIP62AptosWallets(), this.fetchSDKAIP62AptosWallets(), this.scopePollingDetectionStrategy(), this.appendNotDetectedStandardSupportedWallets();
  }
  scopePollingDetectionStrategy() {
    var t;
    (t = this._wallets) == null || t.forEach((e) => {
      const n = this._standard_wallets.find(
        (s) => s.name == "Pontem Wallet"
      );
      e.name === "Pontem" && n || this._standard_wallets.findIndex(
        (s) => s.name == e.name
      ) !== -1 || (this._all_wallets.push(e), e.readyState || (e.readyState = typeof window > "u" || typeof document > "u" ? "Unsupported" : "NotDetected"), typeof window < "u" && em(() => {
        const s = e.providerName || e.name.toLowerCase();
        return Object.keys(window).includes(s) ? (e.readyState = "Installed", e.provider = window[s], this.emit("readyStateChange", e), !0) : !1;
      }));
    });
  }
  fetchExtensionAIP62AptosWallets() {
    let { aptosWallets: t, on: e } = Xi();
    if (this.setExtensionAIP62Wallets(t), typeof window > "u")
      return;
    const n = this;
    e("register", function() {
      let { aptosWallets: r } = Xi();
      n.setExtensionAIP62Wallets(r);
    }), e("unregister", function() {
      let { aptosWallets: r } = Xi();
      n.setExtensionAIP62Wallets(r);
    });
  }
  appendNotDetectedStandardSupportedWallets() {
    sm.map((t) => {
      if (this.wallets.findIndex(
        (s) => s.name === t.name
      ) !== -1)
        return;
      const n = this.wallets.find(
        (s) => s.name == "Pontem"
      );
      if (t.name === "Pontem Wallet" && n)
        return;
      const r = this._standard_wallets.find(
        (s) => s.name == t.name
      );
      r && this.excludeWallet(r) || r || (this._all_wallets.push(t), this.emit("standardWalletsAdded", t));
    });
  }
  fetchSDKAIP62AptosWallets() {
    this._sdkWallets.map((t) => {
      this.standardizeAIP62WalletType(t);
    });
  }
  setExtensionAIP62Wallets(t) {
    t.filter(
      (n) => n.name !== "Dev T wallet" && n.name !== "T wallet"
    ).map((n) => {
      this.standardizeAIP62WalletType(n), this._standard_wallets.push(n);
    });
  }
  excludeWallet(t) {
    return this._optInWallets.length > 0 && !this._optInWallets.includes(t.name);
  }
  standardizeAIP62WalletType(t) {
    if (this.excludeWallet(t))
      return;
    Gd(t) && (t.readyState = "Installed", this.standardizeStandardWalletToPluginWalletType(t), this._standard_wallets.push(t));
  }
  recordEvent(t, e) {
    var n, r, s, o;
    (o = this.ga4) == null || o.gtag("event", `wallet_adapter_${t}`, {
      wallet: (n = this._wallet) == null ? void 0 : n.name,
      network: (r = this._network) == null ? void 0 : r.name,
      network_url: (s = this._network) == null ? void 0 : s.url,
      adapter_core_version: If,
      send_to: "G-GNVVWBL3J9",
      ...e
    });
  }
  ensureWalletExists(t) {
    if (!t)
      throw new fu().name;
    if (!(t.readyState === "Loadable" || t.readyState === "Installed"))
      throw new du("Wallet is not set").name;
  }
  ensureAccountExists(t) {
    if (!t)
      throw new hu("Account is not set").name;
  }
  doesWalletExist() {
    if (!this._connected || this._connecting || !this._wallet)
      throw new fu().name;
    if (!(this._wallet.readyState === "Loadable" || this._wallet.readyState === "Installed"))
      throw new du().name;
    return !0;
  }
  clearData() {
    this._connected = !1, this.setWallet(null), this.setAccount(null), this.setNetwork(null), $2();
  }
  async setAnsName() {
    var t;
    if ((t = this._network) != null && t.chainId && this._account) {
      if (!L2[this._network.chainId] || !Sf(this._network)) {
        this._account.ansName = void 0;
        return;
      }
      const e = rs(this._network, this._dappConfig), r = await new is(e).ans.getPrimaryName({
        address: this._account.address.toString()
      });
      this._account.ansName = r;
    }
  }
  setWallet(t) {
    this._wallet = t;
  }
  setAccount(t) {
    var e;
    if (t === null) {
      this._account = null;
      return;
    }
    if ((e = this._wallet) != null && e.isAIP62Standard)
      if ("status" in t) {
        const n = t;
        if (n.status === ot.REJECTED)
          throw this._connecting = !1, new Yt("User has rejected the request").message;
        this._account = {
          address: n.args.address.toString(),
          publicKey: n.args.publicKey.toString(),
          ansName: n.args.ansName
        };
        return;
      } else {
        const n = t;
        this._account = {
          address: n.address.toString(),
          publicKey: n.publicKey.toString(),
          ansName: n.ansName
        };
        return;
      }
    this._account = { ...t };
  }
  setNetwork(t) {
    var e, n, r;
    if (t === null) {
      this._network = null;
      return;
    }
    if ((e = this._wallet) != null && e.isAIP62Standard) {
      const s = t;
      this.recordEvent("network_change", {
        from: (n = this._network) == null ? void 0 : n.name,
        to: s.name
      }), this._network = {
        name: s.name.toLowerCase(),
        chainId: s.chainId.toString(),
        url: s.url
      };
      return;
    }
    this.recordEvent("network_change", {
      from: (r = this._network) == null ? void 0 : r.name,
      to: t.name
    }), this._network = {
      ...t,
      name: t.name.toLowerCase()
    };
  }
  isConnected() {
    return this._connected;
  }
  get wallets() {
    return this._all_wallets;
  }
  get pluginWallets() {
    return this._wallets;
  }
  get standardWallets() {
    return this._standard_wallets;
  }
  get wallet() {
    try {
      return this._wallet ? {
        name: this._wallet.name,
        icon: this._wallet.icon,
        url: this._wallet.url
      } : null;
    } catch (t) {
      throw new j2(t).message;
    }
  }
  get account() {
    try {
      return this._account;
    } catch (t) {
      throw new hu(t).message;
    }
  }
  get network() {
    try {
      return this._network;
    } catch (t) {
      throw new _2(t).message;
    }
  }
  async connect(t) {
    var e;
    const r = this._all_wallets.find(
      (s) => s.name === t
    );
    if (r) {
      if (this._connected && ((e = this._wallet) == null ? void 0 : e.name) === t)
        throw new Yt(
          `${t} wallet is already connected`
        ).message;
      if (G2() && r.readyState !== "Installed") {
        if (r.isAIP62Standard) {
          if (r.openInMobileApp) {
            r.openInMobileApp();
            return;
          }
          const s = r;
          if (s.deeplinkProvider) {
            const o = encodeURIComponent(window.location.href), c = s.deeplinkProvider.concat(o);
            window.location.href = c;
            return;
          }
        }
        if (r.deeplinkProvider) {
          const s = encodeURIComponent(window.location.href), o = r.deeplinkProvider({ url: s });
          window.location.href = o;
        }
        return;
      }
      r.readyState !== "Installed" && r.readyState !== "Loadable" || await this.connectWallet(r);
    }
  }
  async connectWallet(t) {
    try {
      this._connecting = !0, this.setWallet(t);
      let e;
      t.isAIP62Standard ? e = await this.walletStandardCore.connect(t) : e = await this.walletCoreV1.connect(t), this.setAccount(e);
      const n = await t.network();
      this.setNetwork(n), await this.setAnsName(), J2(t.name), this._connected = !0, this.recordEvent("wallet_connect"), this.emit("connect", e);
    } catch (e) {
      this.clearData();
      const n = bt(e);
      throw new Yt(n).message;
    } finally {
      this._connecting = !1;
    }
  }
  async disconnect() {
    try {
      this.ensureWalletExists(this._wallet), await this._wallet.disconnect(), this.clearData(), this.recordEvent("wallet_disconnect"), this.emit("disconnect");
    } catch (t) {
      const e = bt(t);
      throw new P2(e).message;
    }
  }
  async signAndSubmitTransaction(t) {
    try {
      if ("function" in t.data) {
        if (t.data.function === "0x1::account::rotate_authentication_key_call")
          throw new vr("SCAM SITE DETECTED").message;
        t.data.function === "0x1::code::publish_package_txn" && ({
          metadataBytes: t.data.functionArguments[0],
          byteCode: t.data.functionArguments[1]
        } = X2(t));
      }
      this.ensureWalletExists(this._wallet), this.ensureAccountExists(this._account), this.recordEvent("sign_and_submit_transaction");
      const e = t.data, n = rs(this._network, this._dappConfig), r = new is(n);
      if (this._wallet.signAndSubmitTransaction)
        if (this._wallet.isAIP62Standard) {
          const { hash: l, ...f } = await this.walletStandardCore.signAndSubmitTransaction(
            t,
            r,
            this._account,
            this._wallet,
            this._standard_wallets
          );
          return { hash: l, output: f };
        } else {
          const { hash: l, ...f } = await this.walletCoreV1.resolveSignAndSubmitTransaction(
            e,
            this._network,
            this._wallet,
            t,
            this._dappConfig
          );
          return { hash: l, output: f };
        }
      const s = await r.transaction.build.simple({
        sender: this._account.address,
        data: t.data,
        options: t.options
      }), o = await this.signTransaction(s);
      return await this.submitTransaction({
        transaction: s,
        senderAuthenticator: o
      });
    } catch (e) {
      const n = bt(e);
      throw new vr(n).message;
    }
  }
  async signTransaction(t, e, n) {
    var r, s, o, c, l, f, p;
    try {
      if (this.ensureWalletExists(this._wallet), this.recordEvent("sign_transaction"), this._wallet.signTransaction) {
        if (this._wallet.isAIP62Standard) {
          if ("rawTransaction" in t)
            return await this.walletStandardCore.signTransaction(
              t,
              this._wallet,
              e
            );
          if (this._wallet.isSignTransactionV1_1) {
            const y = xf(t), w = n, { authenticator: b } = await this.walletStandardCore.signTransaction(
              {
                payload: y,
                expirationTimestamp: (r = w == null ? void 0 : w.expireTimestamp) != null ? r : w == null ? void 0 : w.expirationTimestamp,
                expirationSecondsFromNow: w == null ? void 0 : w.expirationSecondsFromNow,
                gasUnitPrice: (s = w == null ? void 0 : w.gasUnitPrice) != null ? s : w == null ? void 0 : w.gas_unit_price,
                maxGasAmount: (o = w == null ? void 0 : w.maxGasAmount) != null ? o : w == null ? void 0 : w.max_gas_amount,
                sequenceNumber: w == null ? void 0 : w.sequenceNumber,
                sender: w != null && w.sender ? { address: $e.from(w.sender) } : void 0
              },
              this._wallet
            );
            return b;
          } else {
            const y = rs(this._network, this._dappConfig);
            this.ensureAccountExists(this._account);
            const w = this._account.address, b = await K2(
              y,
              t
            ), x = n, I = {
              accountSequenceNumber: x == null ? void 0 : x.sequenceNumber,
              expireTimestamp: (c = x == null ? void 0 : x.expireTimestamp) != null ? c : x == null ? void 0 : x.expirationTimestamp,
              gasUnitPrice: (l = x == null ? void 0 : x.gasUnitPrice) != null ? l : x == null ? void 0 : x.gas_unit_price,
              maxGasAmount: (f = x == null ? void 0 : x.maxGasAmount) != null ? f : x == null ? void 0 : x.max_gas_amount
            }, z = await xu({
              aptosConfig: y,
              payload: b,
              sender: w,
              options: I
            });
            return await this.walletStandardCore.signTransaction(
              new Su(z),
              this._wallet,
              !1
            );
          }
        }
        if ("rawTransaction" in t)
          return await this._wallet.signTransaction(
            t,
            e
          );
        {
          const y = await this.walletCoreV1.signTransaction(
            t,
            this._wallet,
            {
              max_gas_amount: n != null && n.maxGasAmount ? BigInt(n == null ? void 0 : n.maxGasAmount) : void 0,
              gas_unit_price: n != null && n.gasUnitPrice ? BigInt(n == null ? void 0 : n.gasUnitPrice) : void 0
            }
          );
          if (!y)
            throw new Error("error");
          const w = new Vn.Deserializer(y), x = Oe.SignedTransaction.deserialize(w).authenticator, I = x.public_key.value, z = x.signature.value;
          return new Zf(
            new mn(I),
            new gr(z)
          );
        }
      }
      throw new Nf(
        `Sign Transaction is not supported by ${(p = this.wallet) == null ? void 0 : p.name}`
      ).message;
    } catch (y) {
      const w = bt(y);
      throw new qo(w).message;
    }
  }
  async signMessage(t) {
    try {
      return this.ensureWalletExists(this._wallet), this.recordEvent("sign_message"), this._wallet.isAIP62Standard ? await this.walletStandardCore.signMessage(t, this._wallet) : await this._wallet.signMessage(t);
    } catch (e) {
      const n = bt(e);
      throw new Mf(n).message;
    }
  }
  async submitTransaction(t) {
    try {
      this.ensureWalletExists(this._wallet);
      const { additionalSignersAuthenticators: e } = t, n = e !== void 0 ? "multi-agent" : "simple";
      if (this.recordEvent("submit_transaction", {
        transaction_type: n
      }), this._wallet.submitTransaction)
        return await this._wallet.submitTransaction(t);
      const r = rs(this._network, this._dappConfig), s = new is(r);
      if (e !== void 0) {
        const o = {
          ...t,
          additionalSignersAuthenticators: e
        };
        return s.transaction.submit.multiAgent(o);
      } else
        return s.transaction.submit.simple(t);
    } catch (e) {
      const n = bt(e);
      throw new qo(n).message;
    }
  }
  async onAccountChange() {
    try {
      this.ensureWalletExists(this._wallet), await this._wallet.onAccountChange(
        async (t) => {
          this.setAccount(t), await this.setAnsName(), this.recordEvent("account_change"), this.emit("accountChange", this._account);
        }
      );
    } catch (t) {
      const e = bt(t);
      throw new B2(e).message;
    }
  }
  async onNetworkChange() {
    try {
      this.ensureWalletExists(this._wallet), await this._wallet.onNetworkChange(
        async (t) => {
          this.setNetwork(t), await this.setAnsName(), this.emit("networkChange", this._network);
        }
      );
    } catch (t) {
      const e = bt(t);
      throw new R2(e).message;
    }
  }
  async changeNetwork(t) {
    var e;
    try {
      this.ensureWalletExists(this._wallet), this.recordEvent("change_network_request", {
        from: (e = this._network) == null ? void 0 : e.name,
        to: t
      });
      const n = t === Ye.DEVNET ? await q2() : ar[t];
      if (this._wallet.changeNetwork) {
        const r = {
          name: t,
          chainId: n
        }, s = await this._wallet.changeNetwork(r);
        if (s.status === ot.REJECTED)
          throw new Yt("User has rejected the request").message;
        return s.args;
      }
      throw new pu(
        `${this._wallet.name} does not support changing network request`
      ).message;
    } catch (n) {
      const r = bt(n);
      throw new pu(r).message;
    }
  }
  async signMessageAndVerify(t) {
    try {
      return this.ensureWalletExists(this._wallet), this.ensureAccountExists(this._account), this.recordEvent("sign_message_and_verify"), this._wallet.isAIP62Standard ? this.walletStandardCore.signMessageAndVerify(
        t,
        this._wallet
      ) : await this.walletCoreV1.signMessageAndVerify(
        t,
        this._wallet,
        this._account
      );
    } catch (e) {
      const n = bt(e);
      throw new fr(n).message;
    }
  }
};
typeof window < "u" && (window.WALLET_ADAPTER_CORE_VERSION = If);
var om = Object.defineProperty, gu = Object.getOwnPropertySymbols, am = Object.prototype.hasOwnProperty, cm = Object.prototype.propertyIsEnumerable, yu = (t, e, n) => e in t ? om(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, wu = (t, e) => {
  for (var n in e || (e = {}))
    am.call(e, n) && yu(t, n, e[n]);
  if (gu)
    for (var n of gu(e))
      cm.call(e, n) && yu(t, n, e[n]);
  return t;
}, Lt = (t, e, n) => new Promise((r, s) => {
  var o = (f) => {
    try {
      l(n.next(f));
    } catch (p) {
      s(p);
    }
  }, c = (f) => {
    try {
      l(n.throw(f));
    } catch (p) {
      s(p);
    }
  }, l = (f) => f.done ? r(f.value) : Promise.resolve(f.value).then(o, c);
  l((n = n.apply(t, e)).next());
}), Zr = "Bitget Wallet", um = class {
  constructor() {
    this.name = Zr, this.url = "https://web3.bitget.com/", this.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFQAAABUCAYAAAAcaxDBAAAACXBIWXMAACE4AAAhOAFFljFgAAAFw2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNy4xLWMwMDAgNzkuZWRhMmIzZmFjLCAyMDIxLzExLzE3LTE3OjIzOjE5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjMuMSAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjQtMDEtMThUMjE6MDI6NTcrMDg6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDI0LTAxLTE4VDIxOjA1OjAzKzA4OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0LTAxLTE4VDIxOjA1OjAzKzA4OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4NDlhZjYwMS0xZmYxLTQwMTMtYjc2Ny01ZTVlNTU1MDUwYWUiIHhtcE1NOkRvY3VtZW50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", this.provider = typeof window < "u" ? window == null ? void 0 : window.bitkeep : void 0, this.readyState = typeof window < "u" ? window != null && window.bitkeep ? ni.Installed : ni.NotDetected : ni.Unsupported;
  }
  deeplinkProvider(t) {
    const n = (t == null ? void 0 : t.url) || "https://web3.bitget.com/zh-CN/wallet-download?type=2";
    let r = "https://bkcode.vip?action=dapp&url=";
    return r += encodeURIComponent(n), r;
  }
  connect() {
    return Lt(this, null, function* () {
      var t, e;
      try {
        const n = yield (e = (t = this.provider) == null ? void 0 : t.aptos) == null ? void 0 : e.connect();
        if (!n)
          throw `${Zr} Address Info Error`;
        return n;
      } catch (n) {
        throw n;
      }
    });
  }
  account() {
    return Lt(this, null, function* () {
      var t, e;
      const n = yield (e = (t = this.provider) == null ? void 0 : t.aptos) == null ? void 0 : e.account();
      if (!n)
        throw `${Zr} Account Error`;
      return n;
    });
  }
  disconnect() {
    return Lt(this, null, function* () {
      var t, e;
      try {
        yield (e = (t = this.provider) == null ? void 0 : t.aptos) == null ? void 0 : e.disconnect();
      } catch (n) {
        throw n;
      }
    });
  }
  signAndSubmitTransaction(t, e) {
    return Lt(this, null, function* () {
      var n, r;
      try {
        const s = yield (r = (n = this.provider) == null ? void 0 : n.aptos) == null ? void 0 : r.signAndSubmitTransaction(
          t,
          e
        );
        if (!s)
          throw new Error("No response");
        return s;
      } catch (s) {
        throw new Error(`${JSON.stringify(s)}`);
      }
    });
  }
  signTransaction(t, e) {
    return Lt(this, null, function* () {
      var n, r;
      try {
        const s = yield (r = (n = this.provider) == null ? void 0 : n.aptos) == null ? void 0 : r.signTransaction(
          t,
          e
        );
        if (!s)
          throw new Error("Failed to sign transaction");
        return s;
      } catch (s) {
        throw s;
      }
    });
  }
  signMessage(t) {
    return Lt(this, null, function* () {
      var e, n;
      try {
        (typeof t != "object" || !t.nonce) && `${Zr}`;
        const r = yield (n = (e = this.provider) == null ? void 0 : e.aptos) == null ? void 0 : n.signMessage(t);
        if (r)
          return r;
        throw `${Zr} Sign Message failed`;
      } catch (r) {
        throw r.message;
      }
    });
  }
  onNetworkChange(t) {
    return Lt(this, null, function* () {
      var e, n;
      try {
        const r = (s) => Lt(this, null, function* () {
          t({
            name: s == null ? void 0 : s.name,
            chainId: s == null ? void 0 : s.chainId,
            api: void 0
          });
        });
        yield (n = (e = this.provider) == null ? void 0 : e.aptos) == null ? void 0 : n.onNetworkChange(r);
      } catch (r) {
        throw r.message;
      }
    });
  }
  onAccountChange(t) {
    return Lt(this, null, function* () {
      var e, n;
      try {
        const r = (s) => Lt(this, null, function* () {
          if (s != null && s.publicKey)
            t(wu({}, s));
          else {
            const o = yield this.connect();
            t(wu({}, o));
          }
        });
        yield (n = (e = this.provider) == null ? void 0 : e.aptos) == null ? void 0 : n.onAccountChange(r);
      } catch (r) {
        throw console.log(r), r.message;
      }
    });
  }
  network() {
    return Lt(this, null, function* () {
      return {
        name: ul.MAINNET,
        chainId: "1"
      };
    });
  }
}, nr = "Martian", lm = class {
  constructor() {
    this.networkToChainId = {
      mainnet: 1,
      testnet: 2,
      devnet: 43
    }, this.name = nr, this.url = "https://chrome.google.com/webstore/detail/martian-wallet/efbglgofoippbgcjepnhiblaibcnclgk", this.icon = "data:image/png;base64,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", this.provider = typeof window < "u" ? window.martian : void 0;
  }
  async connect() {
    var t;
    try {
      const e = await ((t = this.provider) == null ? void 0 : t.connect());
      if (!e)
        throw `${nr} Address Info Error`;
      return e;
    } catch (e) {
      throw e;
    }
  }
  async account() {
    var e;
    const t = await ((e = this.provider) == null ? void 0 : e.account());
    if (!t)
      throw `${nr} Account Error`;
    return t;
  }
  async disconnect() {
    var t;
    try {
      await ((t = this.provider) == null ? void 0 : t.disconnect());
    } catch (e) {
      throw e;
    }
  }
  async signAndSubmitTransaction(t, e) {
    var n, r, s;
    try {
      const o = await this.account(), c = await ((r = this.provider) == null ? void 0 : r.generateTransaction(
        o.address,
        t,
        { ...e, max_gas_amount: (n = e == null ? void 0 : e.max_gas_amount) == null ? void 0 : n.toString() }
      ));
      if (!c)
        throw new Error(
          "Cannot generate transaction"
        );
      const l = await ((s = this.provider) == null ? void 0 : s.signAndSubmitTransaction(c));
      if (!l)
        throw new Error("No response");
      return { hash: l };
    } catch (o) {
      throw o;
    }
  }
  async signAndSubmitBCSTransaction(t, e) {
    var n;
    try {
      const r = new Vn.Serializer();
      t.serialize(r);
      const s = await ((n = this.provider) == null ? void 0 : n.signAndSubmitBCSTransaction(
        r.getBytes().toString(),
        e
      ));
      if (s.code)
        throw new Error(s.message);
      return { hash: s };
    } catch (r) {
      throw r.message;
    }
  }
  async signTransaction(t, e) {
    var n, r;
    try {
      const s = await this.account(), o = await ((n = this.provider) == null ? void 0 : n.generateTransaction(
        s.address,
        t,
        e
      ));
      if (!o)
        throw new Error(
          "Cannot generate transaction"
        );
      const c = await ((r = this.provider) == null ? void 0 : r.signTransaction(o));
      if (!c)
        throw new Error("No response");
      return c;
    } catch (s) {
      throw s;
    }
  }
  async signMessage(t) {
    var e;
    try {
      (typeof t != "object" || !t.nonce) && `${nr}`;
      const n = await ((e = this.provider) == null ? void 0 : e.signMessage(t));
      if (n)
        return n;
      throw `${nr} Sign Message failed`;
    } catch (n) {
      throw n.message;
    }
  }
  async onNetworkChange(t) {
    var e;
    try {
      const n = async (r) => {
        t({
          name: r,
          chainId: void 0,
          api: void 0
        });
      };
      await ((e = this.provider) == null ? void 0 : e.onNetworkChange(n));
    } catch (n) {
      throw n.message;
    }
  }
  async onAccountChange(t) {
    var e;
    try {
      const n = async (r) => {
        if (r != null && r.publicKey)
          t({
            ...r
          });
        else {
          const s = await this.connect();
          t({
            ...s
          });
        }
      };
      await ((e = this.provider) == null ? void 0 : e.onAccountChange(n));
    } catch (n) {
      throw console.log(n), n.message;
    }
  }
  async network() {
    var t;
    try {
      const e = await ((t = this.provider) == null ? void 0 : t.network());
      if (!e)
        throw `${nr} Network Error`;
      return {
        name: e,
        chainId: this.networkToChainId[e.toLowerCase()]
      };
    } catch (e) {
      throw e;
    }
  }
}, dm = { exports: {} };
(function(t) {
  var e = Object.prototype.hasOwnProperty, n = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));
  function s(f, p, y) {
    this.fn = f, this.context = p, this.once = y || !1;
  }
  function o(f, p, y, w, b) {
    if (typeof y != "function")
      throw new TypeError("The listener must be a function");
    var x = new s(y, w || f, b), I = n ? n + p : p;
    return f._events[I] ? f._events[I].fn ? f._events[I] = [f._events[I], x] : f._events[I].push(x) : (f._events[I] = x, f._eventsCount++), f;
  }
  function c(f, p) {
    --f._eventsCount === 0 ? f._events = new r() : delete f._events[p];
  }
  function l() {
    this._events = new r(), this._eventsCount = 0;
  }
  l.prototype.eventNames = function() {
    var p = [], y, w;
    if (this._eventsCount === 0) return p;
    for (w in y = this._events)
      e.call(y, w) && p.push(n ? w.slice(1) : w);
    return Object.getOwnPropertySymbols ? p.concat(Object.getOwnPropertySymbols(y)) : p;
  }, l.prototype.listeners = function(p) {
    var y = n ? n + p : p, w = this._events[y];
    if (!w) return [];
    if (w.fn) return [w.fn];
    for (var b = 0, x = w.length, I = new Array(x); b < x; b++)
      I[b] = w[b].fn;
    return I;
  }, l.prototype.listenerCount = function(p) {
    var y = n ? n + p : p, w = this._events[y];
    return w ? w.fn ? 1 : w.length : 0;
  }, l.prototype.emit = function(p, y, w, b, x, I) {
    var z = n ? n + p : p;
    if (!this._events[z]) return !1;
    var S = this._events[z], Z = arguments.length, le, L;
    if (S.fn) {
      switch (S.once && this.removeListener(p, S.fn, void 0, !0), Z) {
        case 1:
          return S.fn.call(S.context), !0;
        case 2:
          return S.fn.call(S.context, y), !0;
        case 3:
          return S.fn.call(S.context, y, w), !0;
        case 4:
          return S.fn.call(S.context, y, w, b), !0;
        case 5:
          return S.fn.call(S.context, y, w, b, x), !0;
        case 6:
          return S.fn.call(S.context, y, w, b, x, I), !0;
      }
      for (L = 1, le = new Array(Z - 1); L < Z; L++)
        le[L - 1] = arguments[L];
      S.fn.apply(S.context, le);
    } else {
      var ve = S.length, ye;
      for (L = 0; L < ve; L++)
        switch (S[L].once && this.removeListener(p, S[L].fn, void 0, !0), Z) {
          case 1:
            S[L].fn.call(S[L].context);
            break;
          case 2:
            S[L].fn.call(S[L].context, y);
            break;
          case 3:
            S[L].fn.call(S[L].context, y, w);
            break;
          case 4:
            S[L].fn.call(S[L].context, y, w, b);
            break;
          default:
            if (!le) for (ye = 1, le = new Array(Z - 1); ye < Z; ye++)
              le[ye - 1] = arguments[ye];
            S[L].fn.apply(S[L].context, le);
        }
    }
    return !0;
  }, l.prototype.on = function(p, y, w) {
    return o(this, p, y, w, !1);
  }, l.prototype.once = function(p, y, w) {
    return o(this, p, y, w, !0);
  }, l.prototype.removeListener = function(p, y, w, b) {
    var x = n ? n + p : p;
    if (!this._events[x]) return this;
    if (!y)
      return c(this, x), this;
    var I = this._events[x];
    if (I.fn)
      I.fn === y && (!b || I.once) && (!w || I.context === w) && c(this, x);
    else {
      for (var z = 0, S = [], Z = I.length; z < Z; z++)
        (I[z].fn !== y || b && !I[z].once || w && I[z].context !== w) && S.push(I[z]);
      S.length ? this._events[x] = S.length === 1 ? S[0] : S : c(this, x);
    }
    return this;
  }, l.prototype.removeAllListeners = function(p) {
    var y;
    return p ? (y = n ? n + p : p, this._events[y] && c(this, y)) : (this._events = new r(), this._eventsCount = 0), this;
  }, l.prototype.off = l.prototype.removeListener, l.prototype.addListener = l.prototype.on, l.prefixed = n, l.EventEmitter = l, t.exports = l;
})(dm);
var ri = /* @__PURE__ */ ((t) => (t.Mainnet = "mainnet", t.Testnet = "testnet", t.Devnet = "devnet", t))(ri || {}), Au = {
  "Aptos mainnet": ri.Mainnet,
  "Aptos testnet": ri.Testnet,
  "Aptos devnet": ri.Devnet
}, zn = "Pontem", hm = class {
  constructor() {
    this.name = zn, this.url = "https://onelink.to/t3sae5", this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzYiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCAzNiAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE4IDBDOC4wNzMwNCAwIDAgOC4wNzEzOSAwIDE3Ljk5NjNDMCAyNS4xMjk4IDQuMTczMTYgMzEuMzEwOCAxMC4yMDc2IDM0LjIyMDNWMzQuMjM1MUgxMC4yMzcyQzEyLjU4NiAzNS4zNjQ5IDE1LjIyMjggMzYgMTggMzZDMjcuOTI3IDM2IDM2IDI3LjkyODYgMzYgMTguMDAzN0MzNiA4LjA3MTM4IDI3LjkyNyAwIDE4IDBaTTE4IDEuNDc2OTJDMjcuMTA3MSAxLjQ3NjkyIDM0LjUyMjggOC44OTEwOCAzNC41MjI4IDE3Ljk5NjNDMzQuNTIyOCAyMC42MTA1IDMzLjkwOTcgMjMuMDkxNyAzMi44MjQgMjUuMjkyM0MzMC40NDU2IDI0LjE0MDMgMjguMDMwNCAyMy4yODM3IDI1LjU5MjkgMjIuNzAwM1Y4LjkyMDYyQzI1LjU5MjkgOC40NDA2MiAyNS4yMTYyIDguMDU2NjIgMjQuNzQzNSA4LjA1NjYySDIxLjcxNTJIMTQuMDg1NEgxMS4wNTdDMTAuNTkxNyA4LjA1NjYyIDEwLjIwNzYgOC40NDA2MiAxMC4yMDc2IDguOTIwNjJWMjIuNzY2OEM3Ljg0NDA3IDIzLjM1MDIgNS40OTUyOCAyNC4xOTIgMy4xODM0MiAyNS4yOTk3QzIuMDkwMjcgMjMuMDkxNyAxLjQ3NzIzIDIwLjYxNzggMS40NzcyMyAxNy45OTYzQzEuNDc3MjMgOC44OTEwOCA4Ljg5MjkgMS40NzY5MiAxOCAxLjQ3NjkyWk00LjEzNjIzIDI2Ljk2MTJDNi4wOTM1NiAyNS45OTM4IDguMTI0NzQgMjUuMjQ4IDEwLjIxNSAyNC43MzExVjMyLjU1ODhDNy43NDA2NiAzMS4yMzY5IDUuNjUwMzkgMjkuMzAyMiA0LjEzNjIzIDI2Ljk2MTJaTTE0LjA4NTQgMzQuMDQzMVYxNS42MDM3QzE0LjA4NTQgMTMuNDY5NSAxNS44MzU5IDExLjcwNDYgMTcuOTI2MSAxMS43MDQ2QzIwLjAxNjQgMTEuNzA0NiAyMS43MTUyIDEzLjQzMjYgMjEuNzE1MiAxNS41NTk0QzIxLjcxNTIgMTUuNTc0MiAyMS43MDc4IDE1LjU4ODkgMjEuNzA3OCAxNS42MDM3SDIxLjcxNTJWMjIuMDIwOUMxOS45MzUyIDIxLjgxNDIgMTguMTQ3NyAyMS43NDc3IDE2LjM2MDMgMjEuODQzN0wxNC44OTA0IDIzLjk3NzhDMTcuMTgwMSAyMy43ODU4IDE5LjQxMDcgMjMuODAwNiAyMS42MTE4IDI0LjA1MTdDMjEuNjM0IDI0LjA1MTcgMjEuNjQ4NyAyNC4wNTE3IDIxLjY3MDkgMjQuMDU5MUMyMS42ODU3IDI0LjA1OTEgMjEuNzAwNSAyNC4wNTkxIDIxLjcyMjYgMjQuMDY2NUMyMi4xMDY3IDI0LjExMDggMjMuNTAyNyAyNC4yODggMjQuNzgwNSAyNC42MDU1TDIxLjcyMjYgMjUuNjQ2OFYzNC4xMDIyQzIwLjUyNjEgMzQuMzc1NCAxOS4yODUyIDM0LjUzMDUgMTguMDE0OCAzNC41MzA1QzE2LjY0ODMgMzQuNTE1NyAxNS4zNDEgMzQuMzQ1OCAxNC4wODU0IDM0LjA0MzFaTTI1LjU4NTYgMzIuNjYyMlYyNC43NjhDMjcuNjY4NCAyNS4yOTIzIDI5LjcyOTIgMjYuMDYwMyAzMS43OTczIDI3LjA2NDZDMzAuMjQ2MiAyOS40MjAzIDI4LjEwNDIgMzEuMzU1MSAyNS41ODU2IDMyLjY2MjJaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMjIyXzE2NzApIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIyXzE2NzAiIHgxPSIxNy45OTk3IiB5MT0iMzYuNzc4OSIgeDI9IjE3Ljk5OTciIHkyPSItNS41MTk3OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuMDg1OCIgc3RvcC1jb2xvcj0iIzhEMjlDMSIvPgo8c3RvcCBvZmZzZXQ9IjAuMjM4MyIgc3RvcC1jb2xvcj0iIzk0MkJCQiIvPgo8c3RvcCBvZmZzZXQ9IjAuNDY2NyIgc3RvcC1jb2xvcj0iI0E5MkZBQyIvPgo8c3RvcCBvZmZzZXQ9IjAuNzQxMyIgc3RvcC1jb2xvcj0iI0NBMzc5MyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGMDNGNzciLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K", this.provider = typeof window < "u" ? window.pontem : void 0;
  }
  deeplinkProvider(t) {
    return `pontem-wallet://link?url=${t.url}`;
  }
  async connect() {
    var t;
    try {
      const e = await ((t = this.provider) == null ? void 0 : t.connect());
      if (!e)
        throw `${zn} Address Info Error`;
      return e;
    } catch (e) {
      throw e;
    }
  }
  async account() {
    var t, e, n;
    const r = await ((t = this.provider) == null ? void 0 : t.account());
    if (!r)
      throw `${zn} Account Error`;
    let s = "";
    return (e = this.provider) != null && e.publicKey && (s = await ((n = this.provider) == null ? void 0 : n.publicKey())), { ...r, publicKey: s };
  }
  async disconnect() {
    var t;
    try {
      await ((t = this.provider) == null ? void 0 : t.disconnect());
    } catch (e) {
      throw e;
    }
  }
  async signAndSubmitTransaction(t, e) {
    var n, r, s;
    try {
      if (!((n = this.provider) != null && n.signAndSubmit))
        throw `${zn} Sign and Submit failed`;
      const o = await ((s = this.provider) == null ? void 0 : s.signAndSubmit(
        t,
        { ...e, max_gas_amount: (r = e == null ? void 0 : e.max_gas_amount) == null ? void 0 : r.toString() }
      ));
      if (!o || !o.success)
        throw new Error("No response");
      if (o != null && o.code)
        throw new Error(o == null ? void 0 : o.message);
      return { hash: o.result.hash };
    } catch (o) {
      throw o.message;
    }
  }
  async signMessage(t) {
    var e;
    try {
      (typeof t != "object" || !t.nonce) && `${zn}`;
      const n = await ((e = this.provider) == null ? void 0 : e.signMessage(t));
      if (n)
        return n;
      throw `${zn} Sign Message failed`;
    } catch (n) {
      throw n.message;
    }
  }
  async network() {
    var t;
    try {
      const e = await ((t = this.provider) == null ? void 0 : t.network());
      if (!e)
        throw `${zn} Network Error`;
      return typeof e == "object" && (e != null && e.name) ? {
        name: Au[e.name],
        chainId: (e == null ? void 0 : e.chainId) ?? void 0,
        api: (e == null ? void 0 : e.api) ?? void 0
      } : e;
    } catch (e) {
      throw e;
    }
  }
  async onNetworkChange(t) {
    var e;
    try {
      const n = async (r) => {
        r != null && r.name && t({
          name: Au[r.name],
          chainId: (r == null ? void 0 : r.chainId) ?? void 0,
          api: (r == null ? void 0 : r.api) ?? void 0
        }), r != null && r.networkName && t({
          name: r.networkName,
          chainId: void 0,
          api: void 0
        });
      };
      await ((e = this.provider) == null ? void 0 : e.onNetworkChange(n));
    } catch (n) {
      throw n.message;
    }
  }
  async onAccountChange(t) {
    var e;
    try {
      const n = async (r) => {
        if (r != null && r.publicKey)
          t({
            publicKey: r.publicKey,
            address: r.address
          });
        else {
          const s = await this.connect();
          t({
            address: s == null ? void 0 : s.address,
            publicKey: s == null ? void 0 : s.publicKey
          });
        }
      };
      await ((e = this.provider) == null ? void 0 : e.onAccountChange(n));
    } catch (n) {
      throw n.message;
    }
  }
}, qr = (t) => {
  let e = "";
  switch (t) {
    case 200:
      break;
    case 401:
      e = "User rejected the request";
      break;
    case 403:
      e = "Please connect wallet";
      break;
    case 500:
      e = "Unknown error";
      break;
    default:
      e = "Unknown error";
  }
  if (e)
    throw new Error(e);
}, jt = "Fewcha", fm = class {
  constructor() {
    this.name = jt, this.url = "https://chrome.google.com/webstore/detail/fewcha-move-wallet/ebfidpplhabeedpnhjnobghokpiioolj", this.icon = "data:image/png;base64,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", this.provider = typeof window < "u" ? window.fewcha : void 0;
  }
  async connect() {
    var t;
    try {
      const e = await ((t = this.provider) == null ? void 0 : t.connect());
      if (!e)
        throw `${jt} Address Info Error`;
      return qr(e.status), e.data;
    } catch (e) {
      throw e;
    }
  }
  async account() {
    var t;
    try {
      const e = await ((t = this.provider) == null ? void 0 : t.account());
      if (!e)
        throw `${jt} Account Error`;
      return qr(e.status), e.data;
    } catch (e) {
      throw e;
    }
  }
  async disconnect() {
    var t;
    try {
      const e = await ((t = this.provider) == null ? void 0 : t.disconnect());
      if (!e)
        throw `${jt} Disconnect Error`;
      qr(e.status);
    } catch (e) {
      throw e;
    }
  }
  async signAndSubmitTransaction(t, e) {
    var n, r;
    try {
      const s = await ((n = this.provider) == null ? void 0 : n.aptos.generateTransaction(
        t,
        e
      ));
      if (!s)
        throw `${jt} Generate Transaction Error`;
      if (s.status === 500)
        throw new Error(s.data);
      const o = await ((r = this.provider) == null ? void 0 : r.aptos.signAndSubmitTransaction(
        s.data
      ));
      if (!o)
        throw `${jt} Sign And Submit Transaction Error`;
      if (s.status === 500)
        throw new Error(o.data);
      return { hash: o == null ? void 0 : o.data };
    } catch (s) {
      throw s;
    }
  }
  async signTransaction(t, e) {
    var n, r;
    try {
      const s = await ((n = this.provider) == null ? void 0 : n.aptos.generateTransaction(
        t,
        e
      ));
      if (!s)
        throw `${jt} Generate Transaction Error`;
      if (s.status === 500)
        throw new Error(s.data);
      const o = await ((r = this.provider) == null ? void 0 : r.aptos.signTransaction(
        s.data
      ));
      if (!o)
        throw `${jt} Sign And Submit Transaction Error`;
      if (s.status === 500)
        throw new Error(o.data);
      return o.data;
    } catch (s) {
      throw s;
    }
  }
  async signAndSubmitBCSTransaction(t, e) {
    throw "not supported yet";
  }
  async signMessage(t) {
    var e;
    try {
      (typeof t != "object" || !t.nonce) && `${jt}`;
      const n = await ((e = this.provider) == null ? void 0 : e.aptos.signMessage(t));
      if (!n)
        throw `${jt} Sign Message Error`;
      return qr(n.status), n.data;
    } catch (n) {
      throw n.message;
    }
  }
  async network() {
    var t;
    try {
      const e = await ((t = this.provider) == null ? void 0 : t.getNetwork());
      if (!e)
        throw `${jt} Network Error`;
      return qr(e.status), {
        name: e.data
      };
    } catch (e) {
      throw e;
    }
  }
  async onNetworkChange(t) {
    var e;
    try {
      const n = async () => {
        const r = await this.network();
        t({
          name: r.name,
          chainId: void 0,
          api: void 0
        });
      };
      await ((e = this.provider) == null ? void 0 : e.onChangeNetwork(n));
    } catch (n) {
      throw n;
    }
  }
  async onAccountChange(t) {
    var e;
    try {
      const n = async () => {
        const r = await this.connect();
        t({
          address: r == null ? void 0 : r.address,
          publicKey: r == null ? void 0 : r.publicKey
        });
      };
      await ((e = this.provider) == null ? void 0 : e.onChangeAccount(n));
    } catch (n) {
      throw n;
    }
  }
}, pm = { exports: {} };
(function(t) {
  var e = Object.prototype.hasOwnProperty, n = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));
  function s(f, p, y) {
    this.fn = f, this.context = p, this.once = y || !1;
  }
  function o(f, p, y, w, b) {
    if (typeof y != "function")
      throw new TypeError("The listener must be a function");
    var x = new s(y, w || f, b), I = n ? n + p : p;
    return f._events[I] ? f._events[I].fn ? f._events[I] = [f._events[I], x] : f._events[I].push(x) : (f._events[I] = x, f._eventsCount++), f;
  }
  function c(f, p) {
    --f._eventsCount === 0 ? f._events = new r() : delete f._events[p];
  }
  function l() {
    this._events = new r(), this._eventsCount = 0;
  }
  l.prototype.eventNames = function() {
    var p = [], y, w;
    if (this._eventsCount === 0) return p;
    for (w in y = this._events)
      e.call(y, w) && p.push(n ? w.slice(1) : w);
    return Object.getOwnPropertySymbols ? p.concat(Object.getOwnPropertySymbols(y)) : p;
  }, l.prototype.listeners = function(p) {
    var y = n ? n + p : p, w = this._events[y];
    if (!w) return [];
    if (w.fn) return [w.fn];
    for (var b = 0, x = w.length, I = new Array(x); b < x; b++)
      I[b] = w[b].fn;
    return I;
  }, l.prototype.listenerCount = function(p) {
    var y = n ? n + p : p, w = this._events[y];
    return w ? w.fn ? 1 : w.length : 0;
  }, l.prototype.emit = function(p, y, w, b, x, I) {
    var z = n ? n + p : p;
    if (!this._events[z]) return !1;
    var S = this._events[z], Z = arguments.length, le, L;
    if (S.fn) {
      switch (S.once && this.removeListener(p, S.fn, void 0, !0), Z) {
        case 1:
          return S.fn.call(S.context), !0;
        case 2:
          return S.fn.call(S.context, y), !0;
        case 3:
          return S.fn.call(S.context, y, w), !0;
        case 4:
          return S.fn.call(S.context, y, w, b), !0;
        case 5:
          return S.fn.call(S.context, y, w, b, x), !0;
        case 6:
          return S.fn.call(S.context, y, w, b, x, I), !0;
      }
      for (L = 1, le = new Array(Z - 1); L < Z; L++)
        le[L - 1] = arguments[L];
      S.fn.apply(S.context, le);
    } else {
      var ve = S.length, ye;
      for (L = 0; L < ve; L++)
        switch (S[L].once && this.removeListener(p, S[L].fn, void 0, !0), Z) {
          case 1:
            S[L].fn.call(S[L].context);
            break;
          case 2:
            S[L].fn.call(S[L].context, y);
            break;
          case 3:
            S[L].fn.call(S[L].context, y, w);
            break;
          case 4:
            S[L].fn.call(S[L].context, y, w, b);
            break;
          default:
            if (!le) for (ye = 1, le = new Array(Z - 1); ye < Z; ye++)
              le[ye - 1] = arguments[ye];
            S[L].fn.apply(S[L].context, le);
        }
    }
    return !0;
  }, l.prototype.on = function(p, y, w) {
    return o(this, p, y, w, !1);
  }, l.prototype.once = function(p, y, w) {
    return o(this, p, y, w, !0);
  }, l.prototype.removeListener = function(p, y, w, b) {
    var x = n ? n + p : p;
    if (!this._events[x]) return this;
    if (!y)
      return c(this, x), this;
    var I = this._events[x];
    if (I.fn)
      I.fn === y && (!b || I.once) && (!w || I.context === w) && c(this, x);
    else {
      for (var z = 0, S = [], Z = I.length; z < Z; z++)
        (I[z].fn !== y || b && !I[z].once || w && I[z].context !== w) && S.push(I[z]);
      S.length ? this._events[x] = S.length === 1 ? S[0] : S : c(this, x);
    }
    return this;
  }, l.prototype.removeAllListeners = function(p) {
    var y;
    return p ? (y = n ? n + p : p, this._events[y] && c(this, y)) : (this._events = new r(), this._eventsCount = 0), this;
  }, l.prototype.off = l.prototype.removeListener, l.prototype.addListener = l.prototype.on, l.prefixed = n, l.EventEmitter = l, t.exports = l;
})(pm);
var gm = ((t) => (t[t.Unauthorized = 4100] = "Unauthorized", t[t.InternalError = -30001] = "InternalError", t))(gm || {}), ym = ((t) => (t.APPROVED = "Approved", t.REJECTED = "Rejected", t))(ym || {}), wm = "3.16.0", Am = [];
Am.push(new Qa());
var mm = (t) => t.length === 0 ? !1 : t.every(
  (e) => e instanceof Xo
);
typeof window < "u" && (window.WALLET_ADAPTER_CORE_VERSION = wm);
function vm(t, e) {
  const n = Vn.bcsToBytes(t), r = new un(n);
  return e.deserialize(r);
}
function si(t, e) {
  const n = t.bcsToBytes(), r = new Vn.Deserializer(n);
  return e.deserialize(r);
}
function Em(t) {
  switch (t == null ? void 0 : t.name.toLowerCase()) {
    case "mainnet":
      return Ye.MAINNET;
    case "testnet":
      return Ye.TESTNET;
    case "devnet":
      return Ye.DEVNET;
    default:
      throw new Error("Invalid network name");
  }
}
function bm(t) {
  var e;
  if ("bytecode" in t)
    throw new Error("script payload not supported");
  const n = (e = t.typeArguments) == null ? void 0 : e.map(
    (r) => r instanceof oi ? r.toString() : r
  );
  return {
    type: "entry_function_payload",
    function: t.function,
    type_arguments: n || [],
    arguments: t.functionArguments
  };
}
async function Tm(t, e) {
  const n = new cr({
    network: Em(e)
  }), r = await cs({
    ...t,
    aptosConfig: n
  });
  return si(r, Oe.TransactionPayload);
}
var Ln = class extends Error {
  constructor(t, e, n) {
    super(n), this.code = t, this.status = e, this.status = e, this.code = t, Object.setPrototypeOf(this, Ln.prototype);
  }
}, mu = Object.freeze({
  INTERNAL_ERROR: new Ln(-30001, "Internal Error", "Internal Error"),
  NO_ACCOUNTS: new Ln(4e3, "No Accounts", "No accounts found"),
  TIME_OUT: new Ln(
    4002,
    "Time Out",
    "The prompt timed out without a response. This could be because the user did not respond or because a new request was opened."
  ),
  UNAUTHORIZED: new Ln(
    4100,
    "Unauthorized",
    "The requested method and/or account has not been authorized by the user."
  ),
  UNSUPPORTED: new Ln(
    4200,
    "Unsupported",
    "The provider does not support the requested method."
  ),
  USER_REJECTION: new Ln(
    4001,
    "Rejected",
    "The user rejected the request"
  )
});
function Im(t) {
  return Object.values(mu).find((e) => e.code === t) ?? mu.INTERNAL_ERROR;
}
function vu(t) {
  return t instanceof Error && t.message === "Cannot read properties of undefined (reading 'map')";
}
function Mm(t) {
  return t === void 0 || Object.keys(t).length === 0 || Object.values(t).every((e) => e === void 0);
}
function Ht(t) {
  throw "code" in t ? Im(t.code) : t;
}
function Ao(t) {
  return {
    maxGasAmount: t != null && t.max_gas_amount ? Number(t == null ? void 0 : t.max_gas_amount) : void 0,
    gasUnitPrice: t != null && t.gas_unit_price ? Number(t == null ? void 0 : t.gas_unit_price) : void 0,
    ...t
  };
}
var _s = "Petra", Nm = class {
  constructor() {
    this.name = _s, this.version = "v2", this.url = "https://chrome.google.com/webstore/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci", this.icon = "data:image/png;base64,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", this.provider = typeof window < "u" ? window.petra : void 0;
  }
  deeplinkProvider(t) {
    return `https://petra.app/explore?link=${t.url}`;
  }
  async connect() {
    const t = await this.provider.connect().catch(Ht);
    if (!t)
      throw `${_s} Address Info Error`;
    return t;
  }
  async account() {
    const t = await this.provider.account().catch(Ht);
    if (!t)
      throw `${_s} Account Error`;
    return t;
  }
  async disconnect() {
    return this.provider.disconnect().catch(Ht);
  }
  async signAndSubmitTransaction(t, e) {
    var n;
    if ("data" in t) {
      const o = t, c = {
        expirationTimestamp: (n = o.options) == null ? void 0 : n.expireTimestamp,
        sender: o.sender ? $e.from(o.sender).toString() : void 0,
        ...o.options
      };
      if (mm(o.data.functionArguments)) {
        const f = await this.network(), p = await Tm(o.data, f);
        return await this.signAndSubmitBCSTransaction(p, c);
      }
      const l = await bm(o.data);
      return await this.signAndSubmitTransaction(l, c);
    }
    const r = t;
    return await this.provider.signAndSubmitTransaction(
      r,
      e ? Ao(e) : void 0
    ).catch(Ht);
  }
  async signAndSubmitBCSTransaction(t, e) {
    if (!Mm(e))
      try {
        return await this.provider.signAndSubmitTransaction(
          {
            payload: t,
            options: Ao(e)
          }
        ).catch(Ht);
      } catch (r) {
        if (!vu(r))
          throw r;
        console.warn(`Options are not supported by your current version of Petra and they will be ignored. Please update to Petra >= 1.2.27.
Ignored options: `, e);
      }
    return await this.provider.signAndSubmitTransaction(
      t
    ).catch(Ht);
  }
  async signMessage(t) {
    if (typeof t != "object" || !t.nonce)
      throw `${_s} Invalid signMessage Payload`;
    return this.provider.signMessage(t).catch(Ht);
  }
  async signTransaction(t, e) {
    var n;
    if ("rawTransaction" in t) {
      const o = t, c = e ?? !1, l = si(o.rawTransaction, Oe.RawTransaction), f = (n = o.secondarySignerAddresses) == null ? void 0 : n.map(
        (y) => si(y, Oe.AccountAddress)
      );
      let p;
      if (c) {
        const y = await this.account(), w = Oe.AccountAddress.fromHex(y.address);
        p = new Oe.FeePayerRawTransaction(
          l,
          f ?? [],
          w
        );
      } else if (o.feePayerAddress) {
        const y = si(o.feePayerAddress, Oe.AccountAddress);
        p = new Oe.FeePayerRawTransaction(
          l,
          f ?? [],
          y
        );
      } else f ? p = new Oe.MultiAgentRawTransaction(
        l,
        f
      ) : p = l;
      try {
        const { accountAuthenticator: y } = await this.provider.signTransaction(
          { rawTxn: p }
        ).catch(Ht);
        return vm(y, Es);
      } catch (y) {
        throw vu(y) ? new Error("Signing an arbitrary raw transaction is not supported by your current version of Petra. Please update to Petra >= 1.2.27.") : y;
      }
    }
    const r = t, s = e;
    return await this.provider.signTransaction(
      r,
      s ? Ao(s) : void 0
    ).catch(Ht);
  }
  async onNetworkChange(t) {
    var e;
    (e = this.provider) == null || e.onNetworkChange(t);
  }
  async onAccountChange(t) {
    var e;
    (e = this.provider) == null || e.onAccountChange(t);
  }
  async network() {
    const t = await window.petra.getNetwork().catch(Ht);
    return {
      name: t.name,
      chainId: t.chainId,
      url: t.url
    };
  }
};
const xm = {
  icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAxIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDIwMSAyMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0wLjM5MDYyNSAxMDBDMC4zOTA2MjUgNDQuNzcxNSA0NS4xNjIyIDAgMTAwLjM5MSAwQzE1NS42MTkgMCAyMDAuMzkxIDQ0Ljc3MTUgMjAwLjM5MSAxMDBDMjAwLjM5MSAxNTUuMjI4IDE1NS42MTkgMjAwIDEwMC4zOTEgMjAwQzQ1LjE2MjIgMjAwIDAuMzkwNjI1IDE1NS4yMjggMC4zOTA2MjUgMTAwWiIgZmlsbD0iIzYwNjdGOSIvPgo8cGF0aCBkPSJNMTQ2LjgzOCA0MEMxMzguMDU0IDUyLjI2MDcgMTI3LjA2MSA2MC43NjM0IDExNC4wNzIgNjYuNDQ3NEMxMDkuNTYzIDY1LjIwMjYgMTA0LjkzNiA2NC41Njg0IDEwMC4zNzkgNjQuNjE1NEM5NS44MjIzIDY0LjU2ODQgOTEuMTk1MSA2NS4yMjYxIDg2LjY4NTUgNjYuNDQ3NEM3My42OTY2IDYwLjczOTkgNjIuNzA0MiA1Mi4yODQyIDUzLjkxOTggNDBDNTEuMjY1NiA0Ni42NzA2IDQxLjA0ODMgNjkuNjg4OCA1My4zMDkxIDEwMS44NjdDNTMuMzA5MSAxMDEuODY3IDQ5LjM4NjYgMTE4LjY2MSA1Ni41OTc0IDEzMy4wODNDNTYuNTk3NCAxMzMuMDgzIDY3LjAyNiAxMjguMzYyIDc1LjMxNzMgMTM1LjAwOUM4My45ODQzIDE0Mi4wMzIgODEuMjEyOCAxNDguNzk2IDg3LjMxOTYgMTU0LjYyMUM5Mi41ODA5IDE2MCAxMDAuNDAyIDE2MCAxMDAuNDAyIDE2MEMxMDAuNDAyIDE2MCAxMDguMjI0IDE2MCAxMTMuNDg1IDE1NC42NDVDMTE5LjU5MiAxNDguODQzIDExNi44NDQgMTQyLjA3OSAxMjUuNDg4IDEzNS4wMzJDMTMzLjc1NSAxMjguMzg1IDE0NC4yMDcgMTMzLjEwNiAxNDQuMjA3IDEzMy4xMDZDMTUxLjM5NSAxMTguNjg1IDE0Ny40OTYgMTAxLjg5MSAxNDcuNDk2IDEwMS44OTFDMTU5LjcxIDY5LjY4ODggMTQ5LjUxNiA0Ni42NzA2IDE0Ni44MzggNDBaTTU5LjgzODcgOTcuNDI4MUM1My4xNjgxIDgzLjczNDYgNTEuMzM2MSA2NC45NDQyIDU1LjU0MDQgNTAuMDk5OEM2MS4xMDcxIDY0LjE5MjYgNjguNjcwMiA3MC41MTA5IDc3LjY2NjEgNzcuMTgxNEM3My44NjEgODUuMDk2OSA2Ni42OTcyIDkyLjU2NjEgNTkuODM4NyA5Ny40MjgxWk03OS4wMjg0IDEyMS41NUM3My43NjcxIDExOS4yMjUgNzIuNjYzMSAxMTQuNjQ1IDcyLjY2MzEgMTE0LjY0NUM3OS44MjcgMTEwLjEzNSA5MC4zNzMxIDExMy41ODggOTAuNzAxOSAxMjQuMjUxQzg1LjE1ODcgMTIwLjg5MyA4My4zMDMyIDEyMy40MDYgNzkuMDI4NCAxMjEuNTVaTTEwMC4zNzkgMTU5LjQxM0M5Ni42MjA5IDE1OS40MTMgOTMuNTY3NCAxNTYuNzEyIDkzLjU2NzQgMTUzLjRDOTMuNTY3NCAxNTAuMDg4IDk2LjYyMDkgMTQ3LjM4NyAxMDAuMzc5IDE0Ny4zODdDMTA0LjEzNyAxNDcuMzg3IDEwNy4xOSAxNTAuMDg4IDEwNy4xOSAxNTMuNEMxMDcuMTkgMTU2LjczNSAxMDQuMTM3IDE1OS40MTMgMTAwLjM3OSAxNTkuNDEzWk0xMjEuNzUzIDEyMS41NUMxMTcuNDc4IDEyMy40MjkgMTE1LjY0NiAxMjAuODkzIDExMC4wNzkgMTI0LjI1MUMxMTAuNDMyIDExMy41ODggMTIwLjkzMSAxMTAuMTM1IDEyOC4xMTggMTE0LjY0NUMxMjguMTE4IDExNC42MjEgMTI2Ljk5MSAxMTkuMjI1IDEyMS43NTMgMTIxLjU1Wk0xNDAuOTE5IDk3LjQyODFDMTM0LjA4NCA5Mi41NjYxIDEyNi44OTcgODUuMTIwNCAxMjMuMDY4IDc3LjE4MTRDMTMyLjA2NCA3MC41MTA5IDEzOS42NTEgNjQuMTY5MSAxNDUuMTk0IDUwLjA5OThDMTQ5LjQ0NSA2NC45NDQyIDE0Ny42MTMgODMuNzU4MSAxNDAuOTE5IDk3LjQyODFaIiBmaWxsPSIjRjdGN0Y3Ii8+Cjwvc3ZnPgo="
}, Sm = {
  icon: "data:image/png;base64,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"
}, Eu = {
  icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgdmlld0JveD0iMCAwIDI1NiAyNTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8yMDM1XzExMDYpIj4KPHJlY3Qgd2lkdGg9IjI1NiIgaGVpZ2h0PSIyNTYiIGZpbGw9IiM1NEZGRjUiLz4KPGcgZmlsdGVyPSJ1cmwoI2ZpbHRlcjBfZl8yMDM1XzExMDYpIj4KPHBhdGggZD0iTTEzLjQ4MDYgMTk4LjYwNUMtMjkuMzI3NiAzMTkuMDQzIDE5OS42NjEgMjg1LjAyNyAzMTkuNTA3IDI1Mi45NjRDNDQyLjE2NSAyMTIuMjU5IDM1Ny4zODYgMzIuODI2OSAyNjkuNDE1IDI4Ljg1NThDMTgxLjQ0MyAyNC44ODQ3IDI4MC4zMjIgMTExLjgyNCAyMDUuNTk1IDEzNi42NTZDMTMwLjg2OCAxNjEuNDg3IDY2Ljk5MDcgNDguMDU4MyAxMy40ODA2IDE5OC42MDVaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIxX2ZfMjAzNV8xMTA2KSI+CjxwYXRoIGQ9Ik04NS41MTE4IC00NS44MjI1QzYzLjA1NjIgLTEwNy4xNzYgLTE2LjkxODkgLTIzLjk5NTMgLTU0LjA5OTUgMjUuMjY0M0MtODkuNTY1MiA3OC44NDc5IDMuMDA5MzcgMTI1LjE1MiAzOS4zMjA4IDEwMC4wMzdDNzUuNjMyMyA3NC45MjI3IDcuNzc0NDggNzAuMDM2MyAyOS4zNzA4IDM3LjM3ODVDNTAuOTY3MSA0LjcyMDc2IDExMy41ODEgMzAuODY5NSA4NS41MTE4IC00NS44MjI1WiIgZmlsbD0iIzAwRkZGMCIgZmlsbC1vcGFjaXR5PSIwLjY3Ii8+CjwvZz4KPGcgZmlsdGVyPSJ1cmwoI2ZpbHRlcjJfZl8yMDM1XzExMDYpIj4KPHBhdGggZD0iTTk2LjQ3OTYgMjI1LjQyNEM2NS44NTAyIDEyMi4zNjMgLTY2LjA4MTggMTc2LjYzNyAtMTI4LjIxOSAyMTYuNjU3Qy0xODcuOTkgMjY0LjA0MiAtNDYuMDcxMSA0MDAuMzQ4IDEyLjg3MjUgMzkzLjM3NkM3MS44MTYxIDM4Ni40MDMgLTM0LjQxMTggMzI3LjA2NSAxLjk4NzAyIDI5OC4xN0MzOC4zODU4IDI2OS4yNzYgMTM0Ljc2NiAzNTQuMjQ5IDk2LjQ3OTYgMjI1LjQyNFoiIGZpbGw9IiM5RDgxRkYiLz4KPC9nPgo8ZyBmaWx0ZXI9InVybCgjZmlsdGVyM19mXzIwMzVfMTEwNikiPgo8cGF0aCBkPSJNMjgyLjEyIC0xMDcuMzUzQzIxNi4wNDcgLTE4Ni4wMzEgMTIxLjQ2MyAtMTIwLjk3IDgyLjQyOTYgLTc4LjYwNDdDNDguMjczOSAtMzAuNjQ0NiAyMjQuMjc1IDU3LjIzMTIgMjczLjEyMSA0Mi4xNzE0QzMyMS45NjggMjcuMTExNSAyMDYuNTEyIC00LjA1MDM4IDIyNy4yOTcgLTMzLjI4NzlDMjQ4LjA4MiAtNjIuNTI1NSAzNjQuNzEyIC05LjAwNTY2IDI4Mi4xMiAtMTA3LjM1M1oiIGZpbGw9IiM0RDk0RkYiLz4KPC9nPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTkzLjE4OSAxNTIuODM2SDEzNi42NzRMODcuMjA4NiAxMDMuMDUxTDEzNy4zMSA1My4yNjYzTDE1MC45NTUgNDBIMTA1LjgxOUw0OC4zMzU5IDk3Ljc3NzNDNDUuNDM0OSAxMDAuNjg5IDQ1LjQ0OTggMTA1LjQwMiA0OC4zNjU2IDEwOC4yOTlMOTMuMTg5IDE1Mi44MzZaTTExOS4zMyAxMDMuMTY4SDExOC45OTVMMTE5LjMyNiAxMDMuMTY0TDExOS4zMyAxMDMuMTY4Wk0xMTkuMzMgMTAzLjE2OEwxNjguNzkxIDE1Mi45NDlMMTE4LjY5IDIwMi43MzRMMTA1LjA0NSAyMTZIMTUwLjE4TDIwNy42NjQgMTU4LjIyNkMyMTAuNTY1IDE1NS4zMTQgMjEwLjU1IDE1MC42MDIgMjA3LjYzNCAxNDcuNzA1TDE2Mi44MTEgMTAzLjE2OEgxMTkuMzNaIiBmaWxsPSJibGFjayIvPgo8L2c+CjxkZWZzPgo8ZmlsdGVyIGlkPSJmaWx0ZXIwX2ZfMjAzNV8xMTA2IiB4PSItOTAuMjQxMSIgeT0iLTY5LjczNjkiIHdpZHRoPSI1NjkuNTU4IiBoZWlnaHQ9IjQ1MS40MzEiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KPGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz4KPGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0ic2hhcGUiLz4KPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iNDkuMjMwOCIgcmVzdWx0PSJlZmZlY3QxX2ZvcmVncm91bmRCbHVyXzIwMzVfMTEwNiIvPgo8L2ZpbHRlcj4KPGZpbHRlciBpZD0iZmlsdGVyMV9mXzIwMzVfMTEwNiIgeD0iLTE2MC41MTEiIHk9Ii0xNjUuOTg3IiB3aWR0aD0iMzUxLjU5NiIgaGVpZ2h0PSIzNzEuNTA3IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBoaWMiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9InNoYXBlIi8+CjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjQ5LjIzMDgiIHJlc3VsdD0iZWZmZWN0MV9mb3JlZ3JvdW5kQmx1cl8yMDM1XzExMDYiLz4KPC9maWx0ZXI+CjxmaWx0ZXIgaWQ9ImZpbHRlcjJfZl8yMDM1XzExMDYiIHg9Ii0yNDEuMDc4IiB5PSI2Ny42NDIiIHdpZHRoPSI0NDQuODUxIiBoZWlnaHQ9IjQyNC40NTIiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KPGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz4KPGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0ic2hhcGUiLz4KPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iNDkuMjMwOCIgcmVzdWx0PSJlZmZlY3QxX2ZvcmVncm91bmRCbHVyXzIwMzVfMTEwNiIvPgo8L2ZpbHRlcj4KPGZpbHRlciBpZD0iZmlsdGVyM19mXzIwMzVfMTEwNiIgeD0iLTIwLjM5NjgiIHk9Ii0yNDIuNzU4IiB3aWR0aD0iNDMwLjE5MSIgaGVpZ2h0PSIzODUuMTA1IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBoaWMiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9InNoYXBlIi8+CjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjQ5LjIzMDgiIHJlc3VsdD0iZWZmZWN0MV9mb3JlZ3JvdW5kQmx1cl8yMDM1XzExMDYiLz4KPC9maWx0ZXI+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMjAzNV8xMTA2Ij4KPHJlY3Qgd2lkdGg9IjI1NiIgaGVpZ2h0PSIyNTYiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==",
  name: "Bitget Wallet"
}, Dm = {
  nightly: xm,
  snap: Sm,
  bitkeep: Eu,
  bitget: Eu
}, Um = (t) => Dm[t.name.toLocaleLowerCase()] || t, Cm = (t, e, n) => e[t] || n[t], bu = (t, e) => Cm(t, Um(e), e);
class Tu extends Lf {
  /**
   * @param selectedAptosWallet The Aptos wallet adapter which will serve as the underlying connection to the wallet
   * @param walletCore WalletCore class obtained via walletCoreFactory static function
   */
  constructor(e, n) {
    super(), this.selectedAptosWallet = e, this.walletCore = n;
  }
  /**
   * @param config WalletCore configuration
   * @param withNonStandard Add nonstandard wallets to the wallet core, these includes the following wallets:
   * - BitgetWallet
   * - MartianWallet
   * - MSafeWalletAdapter
   * - OKXWallet
   * - PontemWallet
   * - TrustWallet
   * - FewchaWallet
   * - PetraWallet
   * @param newWalletsToAdd Add new wallets to the wallet core
   * @returns {WalletCore} WalletCore instance
   */
  static walletCoreFactory(e = { network: "mainnet" }, n = !0, r = []) {
    const s = [
      // We are forcing PetraWallet to avoid the NotDetected issue
      new Nm(),
      // ---------------------------------------------------------
      new um(),
      new lm(),
      new hm(),
      // FIXME: These wallets are not working!!
      new fm()
      // new OKXWallet(),
      // new MSafeWalletAdapter(),
      // new TrustWallet() as IAptosWallet,
    ];
    return new im(
      n ? [...s, ...r] : r,
      // FIXME: T Wallet is not working and is removed from available wallets.
      [
        "Nightly",
        "Continue with Google",
        "Continue with Apple",
        "Mizu Wallet",
        "Pontem Wallet"
      ],
      e,
      !0
    );
  }
  getName() {
    return bu("name", this.selectedAptosWallet);
  }
  getUrl() {
    return this.selectedAptosWallet.url;
  }
  async connect() {
    var e;
    return await this.walletCore.connect(this.selectedAptosWallet.name), this.address = (e = this.walletCore.account) == null ? void 0 : e.address, this.walletCore.on("accountChange", async (n) => {
      this.address = n == null ? void 0 : n.address;
    }), this.network = this.walletCore.network || void 0, this.walletCore.on("networkChange", async (n) => {
      this.network = n || void 0;
    }), this.getAddresses();
  }
  getNetworkInfo() {
    return this.network;
  }
  isConnected() {
    return this.walletCore.isConnected();
  }
  disconnect() {
    return this.walletCore.off("accountChange"), this.walletCore.off("networkChange"), this.walletCore.disconnect();
  }
  getChainId() {
    return Va;
  }
  getAddress() {
    return this.address;
  }
  getAddresses() {
    const e = this.getAddress();
    return e ? [e] : [];
  }
  setMainAddress() {
    throw new Za();
  }
  getBalance() {
    throw new Za();
  }
  async signTransaction(e) {
    return this.walletCore.signTransaction(e);
  }
  async sendTransaction(e) {
    const n = await this.walletCore.submitTransaction({
      transaction: e.transaction,
      senderAuthenticator: e.senderAuthenticator
    });
    return {
      id: n.hash,
      data: { hash: n.hash }
    };
  }
  async signAndSendTransaction(e) {
    const n = await this.walletCore.signAndSubmitTransaction(e);
    return {
      id: n.hash,
      data: n
    };
  }
  async signMessage(e) {
    return this.walletCore.signMessage(e);
  }
  getIcon() {
    return bu("icon", this.selectedAptosWallet);
  }
  getWalletState() {
    const e = this.selectedAptosWallet.readyState;
    return qa[e || qa.NotDetected];
  }
  getFeatures() {
    return Object.values(jf);
  }
  supportsChain(e) {
    return e === Va;
  }
}
function tv() {
  const t = {
    network: _f.isMainnet ? "mainnet" : "testnet"
  }, e = {}, n = Tu.walletCoreFactory(t, !0, []);
  return n.wallets.forEach((r) => {
    e[r.name] = new Tu(r, n);
  }), e;
}
async function nv(t, e) {
  const n = t.transaction;
  n.functionArguments = n.functionArguments.map((l) => l instanceof Uint8Array ? Array.from(l) : typeof l == "bigint" ? l.toString() : l);
  const o = await (await Pf()).getPlatform("Aptos").getRpc("Aptos"), c = await e.signAndSendTransaction({
    data: n,
    options: {
      // this is set to 5 minutes in case the user takes a while to sign the transaction
      expireTimestamp: Math.floor(Date.now() / 1e3) + 60 * 5
    }
  });
  return await o.waitForTransaction({ transactionHash: c.id }), c;
}
export {
  tv as fetchOptions,
  nv as signAndSendTransaction
};
