"use strict";var l=Object.defineProperty;var y=(i,e,t)=>e in i?l(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var o=(i,e,t)=>y(i,typeof e!="symbol"?e+"":e,t);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const s=require("./index-Cq7ztix4.js"),g=require("./unsignedTransaction-C1YeEl4G.js"),f=require("./aptos-CaZs_9d3.js"),w=[{name:"tokenBridgeAddress",...s.universalAddressItem},{name:"chain",...s.chainItem()},{name:"domainSeparator",binary:"bytes",custom:s.bytes.encode(s.APTOS_SEPARATOR),omit:!0},{name:"tokenId",...s.universalAddressItem},{name:"domainSeparator",binary:"bytes",custom:new Uint8Array([255]),omit:!0}],T=i=>s.serialize$1(w,i);class d{constructor(e,t,n,r){o(this,"network");o(this,"chain");o(this,"connection");o(this,"contracts");o(this,"chainId");o(this,"tokenBridgeAddress");this.network=e,this.chain=t,this.connection=n,this.contracts=r,this.chainId=s.toChainId(t);const a=r.tokenBridge;if(!a)throw new Error(`TokenBridge contract Address for chain ${t} not found`);this.tokenBridgeAddress=a}static async fromRpc(e,t){const[n,r]=await f.AptosPlatform.chainFromRpc(e),a=t[r];if(a.network!==n)throw new Error("Network mismatch "+a.network+" !== "+n);return new d(n,r,e,a.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{return!1}}async getOriginalAsset(e){const t=e.toString().split(s.APTOS_SEPARATOR),n=await this.connection.getAccountResource({accountAddress:t[0],resourceType:`${this.tokenBridgeAddress}::state::OriginInfo`});if(!n)throw s.ErrNotWrapped(e.toString());const r=s.toChain(parseInt(n.token_chain.number)),a=new s.UniversalAddress(n.token_address.external_address);return{chain:r,address:a}}async getTokenUniversalAddress(e){return new s.UniversalAddress(s.hex.encode(s.sha3_256(e.toString()),!0))}async getTokenNativeAddress(e,t){const n=e===this.chain?await this.getTypeFromExternalAddress(t.toString()):await this.getAssetFullyQualifiedType({chain:e,address:t});if(!n)throw new Error("Invalid asset address.");return new s.AptosAddress(n)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedAsset(e){if(s.isNative(e.address))throw new Error("native asset cannot be a wrapped asset");const t=await this.getAssetFullyQualifiedType(e);if(!t)throw new Error("Invalid asset address.");return await this.connection.getAccountResource({accountAddress:s.coalesceModuleAddress(t),resourceType:`${this.tokenBridgeAddress}::state::OriginInfo`}),s.toNative(this.chain,t)}async isTransferCompleted(e){const n=(await this.connection.getAccountResource({accountAddress:this.tokenBridgeAddress,resourceType:`${this.tokenBridgeAddress}::state::State`})).consumed_vaas.elems.handle;try{return await this.connection.getTableItem({handle:n,data:{key_type:"vector<u8>",value_type:"u8",key:`0x${s.dist.Buffer.from(s.keccak_256(e.hash)).toString("hex")}`}}),!0}catch{return!1}}async getWrappedNative(){return s.toNative(this.chain,s.APTOS_COIN)}async*createAttestation(e,t){const n={chain:this.chain,address:new s.AptosAddress(e)},r=await this.getAssetFullyQualifiedType(n);if(!r)throw new Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::attest_token::attest_token_entry`,typeArguments:[r],functionArguments:[]},"Aptos.AttestToken")}async*submitAttestation(e,t){yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin_type`,typeArguments:[],functionArguments:[s.serialize(e)]},"Aptos.CreateWrappedCoinType");const n=await this.getAssetFullyQualifiedType(e.payload.token);if(!n)throw new Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin`,typeArguments:[n],functionArguments:[s.serialize(e)]},"Aptos.CreateWrappedCoin")}async*transfer(e,t,n,r,a){const p=0n,c=0n,h=s.isNative(n)?s.APTOS_COIN:n.toString(),u=t.address.toUniversalAddress().toUint8Array(),A=s.toChainId(t.chain);a?yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_with_payload_entry`,typeArguments:[h],functionArguments:[r,A,u,c,a]},"Aptos.TransferTokensWithPayload"):yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_entry`,typeArguments:[h],functionArguments:[r,A,u,p,c]},"Aptos.TransferTokens")}async*redeem(e,t,n=!0){const r=t.payload.token.chain===this.chain?await this.getTypeFromExternalAddress(t.payload.token.address.toString()):await this.getAssetFullyQualifiedType(t.payload.token);if(!r)throw new Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::complete_transfer::submit_vaa_and_register_entry`,typeArguments:[r],functionArguments:[s.serialize(t)]},"Aptos.CompleteTransfer")}async getAssetFullyQualifiedType(e){return e.chain===this.chain?s.isValidAptosType(e.address.toString())?e.address.toString():null:`${d.getForeignAssetAddress(this.chain,this.tokenBridgeAddress,e)}::coin::T`}async getTypeFromExternalAddress(e){try{const t=await this.connection.getAccountResource({accountAddress:this.tokenBridgeAddress,resourceType:`${this.tokenBridgeAddress}::state::State`}),{handle:n}=t.native_infos,r=await this.connection.getTableItem({handle:n,data:{key_type:`${this.tokenBridgeAddress}::token_hash::TokenHash`,value_type:"0x1::type_info::TypeInfo",key:{hash:e}}});return r?[r.account_address,String.fromCharCode(...s.hex.decode(r.module_name)),String.fromCharCode(...s.hex.decode(r.struct_name))].join(s.APTOS_SEPARATOR):null}catch{return null}}static getForeignAssetAddress(e,t,n){if(s.isNative(n.address))throw new Error("Invalid token address");const r=T({chain:n.chain,tokenBridgeAddress:new s.AptosAddress(t).toUniversalAddress(),tokenId:n.address.toUniversalAddress()});return s.hex.encode(s.sha3_256(r),!0)}createUnsignedTx(e,t,n=!1){return new g.AptosUnsignedTransaction(e,this.network,this.chain,t,n)}}s.registerProtocol("Aptos","TokenBridge",d);exports.AptosTokenBridge=d;
