var d = Object.defineProperty;
var h = (a, e, t) => e in a ? d(a, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : a[e] = t;
var o = (a, e, t) => h(a, typeof e != "symbol" ? e + "" : e, t);
import { b2 as m, bx as w, cg as g, r as p, bf as u } from "./index-CGIqRhuR.mjs";
import { A as l } from "./aptos-D3MPi63x.mjs";
class i {
  constructor(e, t, r, s) {
    o(this, "network");
    o(this, "chain");
    o(this, "connection");
    o(this, "contracts");
    o(this, "chainId");
    o(this, "coreBridge");
    this.network = e, this.chain = t, this.connection = r, this.contracts = s, this.chainId = m(t);
    const n = s.coreBridge;
    if (!n)
      throw new Error(`CoreBridge contract Address for chain ${t} not found`);
    this.coreBridge = n;
  }
  getGuardianSet(e) {
    throw new Error("Method not implemented.");
  }
  getGuardianSetIndex() {
    throw new Error("Method not implemented.");
  }
  getMessageFee() {
    throw new Error("Method not implemented.");
  }
  static async fromRpc(e, t) {
    const [r, s] = await l.chainFromRpc(e), n = t[s];
    if (n.network !== r)
      throw new Error(`Network mismatch: ${n.network} !== ${r}`);
    return new i(r, s, e, n.contracts);
  }
  async *publishMessage(e, t) {
    throw new Error("Method not implemented.");
  }
  async *verifyMessage(e, t) {
    throw new Error("Not implemented.");
  }
  async parseTransaction(e) {
    return (await this.parseMessages(e)).map((r) => ({
      chain: r.emitterChain,
      emitter: r.emitterAddress,
      sequence: r.sequence
    }));
  }
  async parseMessages(e) {
    const t = await this.connection.getTransactionByHash({ transactionHash: e });
    if (t.type !== "user_transaction")
      throw new Error(`${e} is not a user_transaction`);
    const r = t.events.filter((s) => s.type.endsWith("WormholeMessage"));
    if (!r || r.length === 0)
      throw new Error(`WormholeMessage not found for ${e}`);
    return r.map((s) => {
      const n = s.data, c = new w(BigInt(n.sender).toString(16).padStart(64, "0"));
      return g("Uint8Array", {
        guardianSet: 0,
        // TODO: need to implement guardian set idx
        emitterChain: this.chain,
        emitterAddress: c,
        sequence: BigInt(n.sequence),
        timestamp: Number(n.timestamp),
        consistencyLevel: n.consistency_level,
        nonce: Number(n.nonce),
        signatures: [],
        payload: p.decode(n.payload)
      });
    });
  }
}
u("Aptos", "WormholeCore", i);
export {
  i as AptosWormholeCore
};
