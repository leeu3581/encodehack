var w = Object.defineProperty;
var _ = (i, t, n) => t in i ? w(i, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : i[t] = n;
var h = (i, t, n) => _(i, typeof t != "symbol" ? t + "" : t, n);
import { C as y, h as b, i as p, n as C, j as S, k as u, l as T, m as d, o as v, p as f, q as A, r as N, c as I } from "./index-CGIqRhuR.mjs";
import { e as g, s as B, t as k, o as x, z as E } from "./chunk-IMTC3J2M-ldki5kWL.mjs";
class m extends y {
}
const c = class c extends b {
  constructor(t, n) {
    super(t, n ?? C(t, c._platform));
  }
  getRpc(t) {
    if (t in this.config) {
      const n = this.network === "Mainnet" ? g.MAINNET : g.TESTNET, a = new B({ fullnode: this.config[t].rpc, network: n });
      return new k(a);
    }
    throw new Error("No configuration available for chain: " + t);
  }
  getChain(t, n) {
    if (t in this.config)
      return new m(t, this);
    throw new Error("No configuration available for chain: " + t);
  }
  static nativeTokenId(t, n) {
    if (!this.isSupportedChain(n))
      throw new Error(`invalid chain: ${n}`);
    return S.tokenId(n, u);
  }
  static isNativeTokenId(t, n, a) {
    return !this.isSupportedChain(n) || a.chain !== n ? !1 : this.nativeTokenId(t, n) == a;
  }
  static isSupportedChain(t) {
    return T(t) === c._platform;
  }
  static async getDecimals(t, n, a) {
    if (d(a) || a === u)
      return v(c._platform);
    const s = a.toString();
    return (await n.getFungibleAssetMetadataByAssetType({ assetType: s })).decimals;
  }
  static async getBalance(t, n, a, s) {
    var e;
    const o = d(s) ? u : s.toString();
    try {
      return ((e = (await n.getCurrentFungibleAssetBalances({
        options: {
          where: {
            owner_address: { _eq: a },
            asset_type: { _eq: o }
          }
        }
      }))[0]) == null ? void 0 : e.amount) ?? null;
    } catch (r) {
      if (r.status === 404)
        return null;
      throw r;
    }
  }
  static async getBalances(t, n, a, s) {
    return (await Promise.all(s.map(async (e) => {
      const r = await this.getBalance(t, n, a, e);
      return { [d(e) ? "native" : new f(e).toString()]: r };
    }))).reduce((e, r) => Object.assign(e, r), {});
  }
  static async sendWait(t, n, a) {
    const s = [];
    for (const o of a) {
      const e = await n.transaction.submit.simple(o.transaction), r = await n.waitForTransaction({
        transactionHash: e.hash
      });
      s.push(r.hash);
    }
    return s;
  }
  static async getLatestBlock(t) {
    const n = await t.getLedgerInfo();
    return Number(n.block_height);
  }
  static async getLatestFinalizedBlock(t) {
    const n = await t.getLedgerInfo();
    return Number(n.block_height);
  }
  static chainFromChainId(t) {
    const n = A(c._platform, BigInt(t));
    if (!n)
      throw new Error(`No matching chainId to determine network and chain: ${t}`);
    const [a, s] = n;
    return [a, s];
  }
  static async chainFromRpc(t) {
    const n = await t.getLedgerInfo();
    return this.chainFromChainId(n.chain_id.toString());
  }
};
h(c, "_platform", p);
let l = c;
async function F(i, t) {
  const [n, a] = await l.chainFromRpc(i), s = x.fromPrivateKey({
    // TODO: support secp256k1
    privateKey: new E(N.decode(t))
  });
  return new O(a, s, i);
}
class O {
  constructor(t, n, a, s) {
    h(this, "_chain");
    h(this, "_account");
    h(this, "_rpc");
    h(this, "_debug");
    this._chain = t, this._account = n, this._rpc = a, this._debug = s;
  }
  chain() {
    return this._chain;
  }
  address() {
    return this._account.accountAddress.toString();
  }
  async signAndSend(t) {
    const n = [];
    for (const a of t) {
      const { description: s, transaction: o } = a;
      this._debug && console.log(`Signing: ${s} for ${this.address()}`);
      const e = await this._rpc.transaction.build.simple({
        sender: this._account.accountAddress,
        data: o
      }), { hash: r } = await this._simSignSend(e);
      n.push(r);
    }
    return n;
  }
  async _simSignSend(t) {
    return await this._rpc.transaction.simulate.simple({
      signerPublicKey: this._account.publicKey,
      transaction: t
    }).then((n) => n.forEach((a) => {
      if (!a.success)
        throw new Error(`Transaction failed: ${a.vm_status}
${JSON.stringify(a, null, 2)}`);
    })), this._rpc.signAndSubmitTransaction({ signer: this._account, transaction: t }).then((n) => this._rpc.waitForTransaction({ transactionHash: n.hash }));
  }
}
const P = {
  Address: f,
  Platform: l,
  getSigner: F,
  protocols: {
    WormholeCore: () => import("./index-118WjLIm.mjs"),
    TokenBridge: () => import("./index-7VXOHrwH.mjs"),
    CircleBridge: () => import("./index-BOGFzmkL.mjs")
  },
  getChain: (i, t, n) => new m(t, new l(i, I(i, p, {
    [t]: n
  })))
}, M = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: P
}, Symbol.toStringTag, { value: "Module" }));
export {
  l as A,
  M as a
};
