"use strict";var G=Object.defineProperty;var V=(n,i,t)=>i in n?G(n,i,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[i]=t;var c=(n,i,t)=>V(n,typeof i!="symbol"?i+"":i,t);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const e=require("./index-Cq7ztix4.js"),d=require("./index-F8bueU3E.js"),U={version:"0.1.0",name:"wormhole_gateway",instructions:[{name:"initialize",accounts:[{name:"authority",isMut:!0,isSigner:!0},{name:"custodian",isMut:!0,isSigner:!1},{name:"tbtcMint",isMut:!1,isSigner:!1,docs:["TBTC Program's mint PDA address bump is saved in this program's config. Ordinarily, we would","not have to deserialize this account. But we do in this case to make sure the TBTC program","has been initialized before this program."]},{name:"wrappedTbtcMint",isMut:!1,isSigner:!1},{name:"wrappedTbtcToken",isMut:!0,isSigner:!1},{name:"tokenBridgeSender",isMut:!1,isSigner:!1,docs:["sign for transferring via Token Bridge program with a message."]},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"mintingLimit",type:"u64"}]},{name:"changeAuthority",accounts:[{name:"custodian",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0},{name:"newAuthority",isMut:!1,isSigner:!1}],args:[]},{name:"cancelAuthorityChange",accounts:[{name:"custodian",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[]},{name:"takeAuthority",accounts:[{name:"custodian",isMut:!0,isSigner:!1},{name:"pendingAuthority",isMut:!1,isSigner:!0}],args:[]},{name:"updateGatewayAddress",accounts:[{name:"custodian",isMut:!1,isSigner:!1},{name:"gatewayInfo",isMut:!0,isSigner:!1},{name:"authority",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"args",type:{defined:"UpdateGatewayAddressArgs"}}]},{name:"updateMintingLimit",accounts:[{name:"custodian",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"newLimit",type:"u64"}]},{name:"receiveTbtc",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"custodian",isMut:!0,isSigner:!1},{name:"postedVaa",isMut:!1,isSigner:!1},{name:"tokenBridgeClaim",isMut:!0,isSigner:!1,docs:["transfer. By checking whether this account exists is a short-circuit way of bailing out","early if this transfer has already been redeemed (as opposed to letting the Token Bridge","instruction fail)."]},{name:"wrappedTbtcToken",isMut:!0,isSigner:!1,docs:["Custody account."]},{name:"wrappedTbtcMint",isMut:!0,isSigner:!1,docs:["This mint is owned by the Wormhole Token Bridge program. This PDA address is stored in the","custodian account."]},{name:"tbtcMint",isMut:!0,isSigner:!1},{name:"recipientToken",isMut:!0,isSigner:!1,docs:["Token account for minted tBTC.","","NOTE: Because the recipient is encoded in the transfer message payload, we can check the","authority from the deserialized VAA. But we should still check whether the authority is the","zero address in access control."]},{name:"recipient",isMut:!1,isSigner:!1,docs:["be created for him."]},{name:"recipientWrappedToken",isMut:!0,isSigner:!1,docs:["The gateway will create an associated token account for the recipient if it doesn't exist.","","NOTE: When the minting limit increases, the recipient can use this token account to mint","tBTC using the deposit_wormhole_tbtc instruction."]},{name:"tbtcConfig",isMut:!1,isSigner:!1},{name:"tbtcMinterInfo",isMut:!1,isSigner:!1},{name:"tokenBridgeConfig",isMut:!1,isSigner:!1},{name:"tokenBridgeRegisteredEmitter",isMut:!1,isSigner:!1},{name:"tokenBridgeWrappedAsset",isMut:!1,isSigner:!1},{name:"tokenBridgeMintAuthority",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"tbtcProgram",isMut:!1,isSigner:!1},{name:"tokenBridgeProgram",isMut:!1,isSigner:!1},{name:"coreBridgeProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"messageHash",type:{array:["u8",32]}}]},{name:"sendTbtcGateway",accounts:[{name:"custodian",isMut:!0,isSigner:!1},{name:"gatewayInfo",isMut:!1,isSigner:!1},{name:"wrappedTbtcToken",isMut:!0,isSigner:!1,docs:["Custody account."]},{name:"wrappedTbtcMint",isMut:!0,isSigner:!1},{name:"tbtcMint",isMut:!0,isSigner:!1},{name:"senderToken",isMut:!0,isSigner:!1},{name:"sender",isMut:!0,isSigner:!0},{name:"tokenBridgeConfig",isMut:!1,isSigner:!1},{name:"tokenBridgeWrappedAsset",isMut:!1,isSigner:!1},{name:"tokenBridgeTransferAuthority",isMut:!1,isSigner:!1},{name:"coreBridgeData",isMut:!0,isSigner:!1},{name:"coreMessage",isMut:!0,isSigner:!1},{name:"tokenBridgeCoreEmitter",isMut:!1,isSigner:!1},{name:"coreEmitterSequence",isMut:!0,isSigner:!1},{name:"coreFeeCollector",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"tokenBridgeSender",isMut:!1,isSigner:!1,docs:["sign for transferring via Token Bridge program with a message."]},{name:"rent",isMut:!1,isSigner:!1},{name:"tokenBridgeProgram",isMut:!1,isSigner:!1},{name:"coreBridgeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"args",type:{defined:"SendTbtcGatewayArgs"}}]},{name:"sendTbtcWrapped",accounts:[{name:"custodian",isMut:!0,isSigner:!1},{name:"wrappedTbtcToken",isMut:!0,isSigner:!1,docs:["Custody account."]},{name:"wrappedTbtcMint",isMut:!0,isSigner:!1},{name:"tbtcMint",isMut:!0,isSigner:!1},{name:"senderToken",isMut:!0,isSigner:!1},{name:"sender",isMut:!0,isSigner:!0},{name:"tokenBridgeConfig",isMut:!1,isSigner:!1},{name:"tokenBridgeWrappedAsset",isMut:!1,isSigner:!1},{name:"tokenBridgeTransferAuthority",isMut:!1,isSigner:!1},{name:"coreBridgeData",isMut:!0,isSigner:!1},{name:"coreMessage",isMut:!0,isSigner:!1},{name:"tokenBridgeCoreEmitter",isMut:!1,isSigner:!1},{name:"coreEmitterSequence",isMut:!0,isSigner:!1},{name:"coreFeeCollector",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"tokenBridgeProgram",isMut:!1,isSigner:!1},{name:"coreBridgeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"args",type:{defined:"SendTbtcWrappedArgs"}}]},{name:"depositWormholeTbtc",accounts:[{name:"custodian",isMut:!0,isSigner:!1,docs:["NOTE: This account also acts as a minter for the TBTC program."]},{name:"wrappedTbtcToken",isMut:!0,isSigner:!1,docs:["This token account is owned by this program, whose mint is the wrapped TBTC mint. This PDA","address is stored in the custodian account."]},{name:"wrappedTbtcMint",isMut:!1,isSigner:!1,docs:["This mint is owned by the Wormhole Token Bridge program. This PDA address is stored in the","custodian account."]},{name:"tbtcMint",isMut:!0,isSigner:!1,docs:["This mint is owned by the TBTC program. This PDA address is stored in the custodian account."]},{name:"recipientWrappedToken",isMut:!0,isSigner:!1},{name:"recipientToken",isMut:!0,isSigner:!1},{name:"recipient",isMut:!1,isSigner:!0,docs:["This program requires that the owner of the TBTC token account sign for TBTC being minted","into his account."]},{name:"tbtcConfig",isMut:!1,isSigner:!1},{name:"tbtcMinterInfo",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"tbtcProgram",isMut:!1,isSigner:!1}],args:[{name:"amount",type:"u64"}]}],accounts:[{name:"custodian",type:{kind:"struct",fields:[{name:"bump",type:"u8"},{name:"authority",type:"publicKey"},{name:"pendingAuthority",type:{option:"publicKey"}},{name:"tbtcMint",type:"publicKey"},{name:"wrappedTbtcMint",type:"publicKey"},{name:"wrappedTbtcToken",type:"publicKey"},{name:"tokenBridgeSender",type:"publicKey"},{name:"tokenBridgeSenderBump",type:"u8"},{name:"mintingLimit",type:"u64"},{name:"mintedAmount",type:"u64"}]}},{name:"GatewayInfo",type:{kind:"struct",fields:[{name:"bump",type:"u8"},{name:"address",type:{array:["u8",32]}}]}}],types:[{name:"UpdateGatewayAddressArgs",type:{kind:"struct",fields:[{name:"chain",type:"u16"},{name:"address",type:{array:["u8",32]}}]}},{name:"SendTbtcGatewayArgs",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"recipientChain",type:"u16"},{name:"recipient",type:{array:["u8",32]}},{name:"nonce",type:"u32"}]}},{name:"SendTbtcWrappedArgs",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"recipientChain",type:"u16"},{name:"recipient",type:{array:["u8",32]}},{name:"arbiterFee",type:"u64"},{name:"nonce",type:"u32"}]}}],events:[{name:"WormholeTbtcReceived",fields:[{name:"receiver",type:"publicKey",index:!1},{name:"amount",type:"u64",index:!1}]},{name:"WormholeTbtcSent",fields:[{name:"amount",type:"u64",index:!1},{name:"recipientChain",type:"u16",index:!1},{name:"gateway",type:{array:["u8",32]},index:!1},{name:"recipient",type:{array:["u8",32]},index:!1},{name:"arbiterFee",type:"u64",index:!1},{name:"nonce",type:"u32",index:!1}]},{name:"WormholeTbtcDeposited",fields:[{name:"depositor",type:"publicKey",index:!1},{name:"amount",type:"u64",index:!1}]},{name:"GatewayAddressUpdated",fields:[{name:"chain",type:"u16",index:!1},{name:"gateway",type:{array:["u8",32]},index:!1}]},{name:"MintingLimitUpdated",fields:[{name:"mintingLimit",type:"u64",index:!1}]}],errors:[{code:6016,name:"MintingLimitExceeded",msg:"Cannot mint more than the minting limit"},{code:6032,name:"IsNotAuthority",msg:"Only custodian authority is permitted for this action"},{code:6034,name:"IsNotPendingAuthority",msg:"Not valid pending authority to take authority"},{code:6036,name:"NoPendingAuthorityChange",msg:"No pending authority"},{code:6048,name:"ZeroRecipient",msg:"0x0 recipient not allowed"},{code:6064,name:"NotEnoughWrappedTbtc",msg:"Not enough wormhole tBTC in the gateway to bridge"},{code:6080,name:"ZeroAmount",msg:"Amount must not be 0"},{code:6112,name:"TransferAlreadyRedeemed",msg:"Token Bridge transfer already redeemed"},{code:6128,name:"InvalidEthereumTbtc",msg:"Token chain and address do not match Ethereum's tBTC"},{code:6144,name:"NoTbtcTransferred",msg:"No tBTC transferred"},{code:6160,name:"RecipientZeroAddress",msg:"0x0 receiver not allowed"},{code:6176,name:"MintedAmountUnderflow",msg:"Not enough minted by the gateway to satisfy sending tBTC"},{code:6178,name:"MintedAmountOverflow",msg:"Minted amount after deposit exceeds u64"}]};function I(n){return e.PublicKey.findProgramAddressSync([e.dist.Buffer.from("redeemer")],new e.PublicKey(n))[0]}function q(n,i){const t=e.dist.Buffer.alloc(8);return t.writeBigUInt64LE(i),e.PublicKey.findProgramAddressSync([e.dist.Buffer.from("msg"),t],new e.PublicKey(n))[0]}function L(n,i){const t=e.dist.Buffer.alloc(2);return t.writeUInt16LE(e.toChainId(i)),e.PublicKey.findProgramAddressSync([e.dist.Buffer.from("gateway-info"),t],new e.PublicKey(n))[0]}const T=new e.PublicKey("Gj93RRt6QB7FjmyokAD5rcMAku7pq3Fk2Aa8y6nNbwsV");function D(){return e.PublicKey.findProgramAddressSync([e.dist.Buffer.from("config")],T)[0]}function _(n){return e.PublicKey.findProgramAddressSync([e.dist.Buffer.from("minter-info"),n.toBuffer()],T)[0]}const B=new e.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");new e.PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");const b=new e.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new e.PublicKey("So11111111111111111111111111111111111111112");new e.PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");class F extends Error{constructor(i){super(i)}}class z extends F{constructor(){super(...arguments),this.name="TokenOwnerOffCurveError"}}const Y=e.struct([e.u32("mintAuthorityOption"),e.publicKey("mintAuthority"),e.u64("supply"),e.u8("decimals"),e.bool("isInitialized"),e.u32("freezeAuthorityOption"),e.publicKey("freezeAuthority")]);Y.span;async function M(n,i,t=!1,a=B,s=b){if(!t&&!e.PublicKey.isOnCurve(i.toBuffer()))throw new z;const[r]=await e.PublicKey.findProgramAddress([i.toBuffer(),a.toBuffer(),n.toBuffer()],s);return r}function H(n,i,t,a,s=B,r=b){return Z(n,i,t,a,e.dist.Buffer.alloc(0),s,r)}function Z(n,i,t,a,s,r=B,o=b){const u=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:e.SystemProgram.programId,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1}];return new e.TransactionInstruction({keys:u,programId:o,data:s})}class h{constructor(i,t,a,s){c(this,"network");c(this,"chain");c(this,"connection");c(this,"contracts");c(this,"gateway");c(this,"tokenBridgeId");c(this,"coreBridgeId");if(this.network=i,this.chain=t,this.connection=a,this.contracts=s,this.network!=="Mainnet")throw new Error("TBTC is only supported on Mainnet");if(!this.contracts.tbtc)throw new Error("TBTC contract address is required");if(!this.contracts.tokenBridge)throw new Error("TokenBridge contract address is required");if(!this.contracts.coreBridge)throw new Error("CoreBridge contract address is required");this.gateway=new e.Program(U,this.contracts.tbtc,{connection:a}),this.tokenBridgeId=new e.PublicKey(this.contracts.tokenBridge),this.coreBridgeId=new e.PublicKey(this.contracts.coreBridge)}static async fromRpc(i,t){const[a,s]=await e.SolanaPlatform.chainFromRpc(i),r=t[s];if(r.network!==a)throw new Error(`Network mismatch: ${r.network} != ${a}`);return new h(a,s,i,r.contracts)}async*transfer(i,t,a){const s=new e.SolanaAddress(i).unwrap(),r=I(this.gateway.programId),{tbtcMint:o,wrappedTbtcToken:u,wrappedTbtcMint:g}=await this.gateway.account.custodian.fetch(r),p=d.deriveWrappedMetaKey(this.tokenBridgeId,g),m=d.deriveTokenBridgeConfigKey(this.tokenBridgeId),l=d.deriveAuthoritySignerKey(this.tokenBridgeId),A=e.deriveFeeCollectorKey(this.coreBridgeId),{sequence:y}=await e.getProgramSequenceTracker(this.connection,this.tokenBridgeId,this.coreBridgeId),S=q(this.gateway.programId,y),w=e.deriveWormholeBridgeDataKey(this.coreBridgeId),f=e.deriveWormholeEmitterKey(this.tokenBridgeId),k=e.deriveEmitterSequenceKey(f,this.coreBridgeId),K=L(this.gateway.programId,t.chain),E=d.deriveSenderAccountKey(this.gateway.programId),P={amount:new e.BN(a.toString()),recipientChain:e.toChainId(t.chain),recipient:[...t.address.toUniversalAddress().toUint8Array()],nonce:0},W=await M(o,s),v=e.tbtc.get(this.network,t.chain),C={custodian:r,wrappedTbtcToken:u,wrappedTbtcMint:g,tbtcMint:o,senderToken:W,sender:s,tokenBridgeConfig:m,tokenBridgeWrappedAsset:p,tokenBridgeTransferAuthority:l,coreBridgeData:w,coreMessage:S,tokenBridgeCoreEmitter:f,coreEmitterSequence:k,coreFeeCollector:A,clock:e.SYSVAR_CLOCK_PUBKEY,rent:e.SYSVAR_RENT_PUBKEY,tokenBridgeProgram:this.tokenBridgeId,coreBridgeProgram:this.coreBridgeId},x=v?await this.gateway.methods.sendTbtcGateway({...P}).accounts({...C,gatewayInfo:K,tokenBridgeSender:E}).instruction():await this.gateway.methods.sendTbtcWrapped({...P,arbiterFee:new e.BN(0)}).accounts(C).instruction(),{blockhash:N}=await this.connection.getLatestBlockhash(),O=e.MessageV0.compile({instructions:[x],payerKey:s,recentBlockhash:N}),R=new e.VersionedTransaction(O);yield this.createUnsignedTransaction({transaction:R},"TBTCBridge.Send")}async*redeem(i,t){if(t.payloadName!=="GatewayTransfer")throw new Error("Invalid VAA payload");yield*new e.SolanaWormholeCore(this.network,this.chain,this.connection,this.contracts).postVaa(i,t);const s=[],r=new e.SolanaAddress(i).unwrap(),o=t.payload.payload.recipient.toNative(this.chain).unwrap(),u=I(this.gateway.programId),{tbtcMint:g,wrappedTbtcToken:p,wrappedTbtcMint:m}=await this.gateway.account.custodian.fetch(u),l=await M(g,o);await this.connection.getAccountInfo(l)||s.push(H(r,l,o,g));const y=d.deriveWrappedMetaKey(this.tokenBridgeId,m),S=await M(m,o);s.push(await this.gateway.methods.receiveTbtc([...t.hash]).accounts({payer:r,custodian:u,postedVaa:e.derivePostedVaaKey(this.coreBridgeId,e.dist.Buffer.from(t.hash)),tokenBridgeClaim:e.deriveClaimKey(this.tokenBridgeId,t.emitterAddress.toUint8Array(),e.toChainId(t.emitterChain),t.sequence),wrappedTbtcToken:p,wrappedTbtcMint:m,tbtcMint:g,recipientToken:l,recipient:o,recipientWrappedToken:S,tbtcConfig:D(),tbtcMinterInfo:_(u),tokenBridgeConfig:d.deriveTokenBridgeConfigKey(this.tokenBridgeId),tokenBridgeRegisteredEmitter:d.deriveEndpointKey(this.tokenBridgeId,e.toChainId(t.emitterChain),t.emitterAddress.toUint8Array()),tokenBridgeWrappedAsset:y,tokenBridgeMintAuthority:d.deriveMintAuthorityKey(this.tokenBridgeId),rent:e.SYSVAR_RENT_PUBKEY,tbtcProgram:T,tokenBridgeProgram:this.tokenBridgeId,coreBridgeProgram:this.coreBridgeId}).instruction());const{blockhash:w}=await this.connection.getLatestBlockhash(),f=e.MessageV0.compile({instructions:s,payerKey:r,recentBlockhash:w}),k=new e.VersionedTransaction(f);yield this.createUnsignedTransaction({transaction:k},"TBTCBridge.Send")}createUnsignedTransaction(i,t){return new e.SolanaUnsignedTransaction(i,this.network,this.chain,t,!1)}}e.registerProtocol(e._platform$1,"TBTCBridge",h);exports.SolanaTBTCBridge=h;
