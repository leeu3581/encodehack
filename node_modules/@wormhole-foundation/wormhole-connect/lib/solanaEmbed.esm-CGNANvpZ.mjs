import { cT as Pn, az as _r, cY as ks, O as le, cZ as Zb, as as Ye, c_ as Bn, c$ as Ls, Q as Oi, d0 as Xi, cS as q1, a5 as Gg, d1 as V1, d2 as G1, d3 as z1, d4 as K1, d5 as J1, d6 as Y1, a9 as zg } from "./index-CGIqRhuR.mjs";
function Ps(e) {
  "@babel/helpers - typeof";
  return Ps = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ps(e);
}
function X1(e, t) {
  if (Ps(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var o = r.call(e, t);
    if (Ps(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Z1(e) {
  var t = X1(e, "string");
  return Ps(t) == "symbol" ? t : t + "";
}
var vc = { exports: {} }, Qb = Pn.EventEmitter, Pl, Kg;
function Q1() {
  if (Kg) return Pl;
  Kg = 1;
  function e(x, v) {
    var C = Object.keys(x);
    if (Object.getOwnPropertySymbols) {
      var B = Object.getOwnPropertySymbols(x);
      v && (B = B.filter(function(P) {
        return Object.getOwnPropertyDescriptor(x, P).enumerable;
      })), C.push.apply(C, B);
    }
    return C;
  }
  function t(x) {
    for (var v = 1; v < arguments.length; v++) {
      var C = arguments[v] != null ? arguments[v] : {};
      v % 2 ? e(Object(C), !0).forEach(function(B) {
        r(x, B, C[B]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(x, Object.getOwnPropertyDescriptors(C)) : e(Object(C)).forEach(function(B) {
        Object.defineProperty(x, B, Object.getOwnPropertyDescriptor(C, B));
      });
    }
    return x;
  }
  function r(x, v, C) {
    return v = f(v), v in x ? Object.defineProperty(x, v, { value: C, enumerable: !0, configurable: !0, writable: !0 }) : x[v] = C, x;
  }
  function o(x, v) {
    if (!(x instanceof v))
      throw new TypeError("Cannot call a class as a function");
  }
  function s(x, v) {
    for (var C = 0; C < v.length; C++) {
      var B = v[C];
      B.enumerable = B.enumerable || !1, B.configurable = !0, "value" in B && (B.writable = !0), Object.defineProperty(x, f(B.key), B);
    }
  }
  function u(x, v, C) {
    return v && s(x.prototype, v), Object.defineProperty(x, "prototype", { writable: !1 }), x;
  }
  function f(x) {
    var v = h(x, "string");
    return typeof v == "symbol" ? v : String(v);
  }
  function h(x, v) {
    if (typeof x != "object" || x === null) return x;
    var C = x[Symbol.toPrimitive];
    if (C !== void 0) {
      var B = C.call(x, v);
      if (typeof B != "object") return B;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(x);
  }
  var l = _r, p = l.Buffer, b = ks, w = b.inspect, I = w && w.custom || "inspect";
  function A(x, v, C) {
    p.prototype.copy.call(x, v, C);
  }
  return Pl = /* @__PURE__ */ function() {
    function x() {
      o(this, x), this.head = null, this.tail = null, this.length = 0;
    }
    return u(x, [{
      key: "push",
      value: function(C) {
        var B = {
          data: C,
          next: null
        };
        this.length > 0 ? this.tail.next = B : this.head = B, this.tail = B, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(C) {
        var B = {
          data: C,
          next: this.head
        };
        this.length === 0 && (this.tail = B), this.head = B, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var C = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, C;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(C) {
        if (this.length === 0) return "";
        for (var B = this.head, P = "" + B.data; B = B.next; ) P += C + B.data;
        return P;
      }
    }, {
      key: "concat",
      value: function(C) {
        if (this.length === 0) return p.alloc(0);
        for (var B = p.allocUnsafe(C >>> 0), P = this.head, S = 0; P; )
          A(P.data, B, S), S += P.data.length, P = P.next;
        return B;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(C, B) {
        var P;
        return C < this.head.data.length ? (P = this.head.data.slice(0, C), this.head.data = this.head.data.slice(C)) : C === this.head.data.length ? P = this.shift() : P = B ? this._getString(C) : this._getBuffer(C), P;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(C) {
        var B = this.head, P = 1, S = B.data;
        for (C -= S.length; B = B.next; ) {
          var m = B.data, j = C > m.length ? m.length : C;
          if (j === m.length ? S += m : S += m.slice(0, C), C -= j, C === 0) {
            j === m.length ? (++P, B.next ? this.head = B.next : this.head = this.tail = null) : (this.head = B, B.data = m.slice(j));
            break;
          }
          ++P;
        }
        return this.length -= P, S;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(C) {
        var B = p.allocUnsafe(C), P = this.head, S = 1;
        for (P.data.copy(B), C -= P.data.length; P = P.next; ) {
          var m = P.data, j = C > m.length ? m.length : C;
          if (m.copy(B, B.length - C, 0, j), C -= j, C === 0) {
            j === m.length ? (++S, P.next ? this.head = P.next : this.head = this.tail = null) : (this.head = P, P.data = m.slice(j));
            break;
          }
          ++S;
        }
        return this.length -= S, B;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: I,
      value: function(C, B) {
        return w(this, t(t({}, B), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), x;
  }(), Pl;
}
function eA(e, t) {
  var r = this, o = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
  return o || s ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, le.process.nextTick(Sc, this, e)) : le.process.nextTick(Sc, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(u) {
    !t && u ? r._writableState ? r._writableState.errorEmitted ? le.process.nextTick(hu, r) : (r._writableState.errorEmitted = !0, le.process.nextTick(Jg, r, u)) : le.process.nextTick(Jg, r, u) : t ? (le.process.nextTick(hu, r), t(u)) : le.process.nextTick(hu, r);
  }), this);
}
function Jg(e, t) {
  Sc(e, t), hu(e);
}
function hu(e) {
  e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
}
function tA() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function Sc(e, t) {
  e.emit("error", t);
}
function rA(e, t) {
  var r = e._readableState, o = e._writableState;
  r && r.autoDestroy || o && o.autoDestroy ? e.destroy(t) : e.emit("error", t);
}
var e_ = {
  destroy: eA,
  undestroy: tA,
  errorOrDestroy: rA
}, Zi = {};
function nA(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
var t_ = {};
function Vr(e, t, r) {
  r || (r = Error);
  function o(u, f, h) {
    return typeof t == "string" ? t : t(u, f, h);
  }
  var s = /* @__PURE__ */ function(u) {
    nA(f, u);
    function f(h, l, p) {
      return u.call(this, o(h, l, p)) || this;
    }
    return f;
  }(r);
  s.prototype.name = r.name, s.prototype.code = e, t_[e] = s;
}
function Yg(e, t) {
  if (Array.isArray(e)) {
    var r = e.length;
    return e = e.map(function(o) {
      return String(o);
    }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
  } else
    return "of ".concat(t, " ").concat(String(e));
}
function iA(e, t, r) {
  return e.substr(0, t.length) === t;
}
function oA(e, t, r) {
  return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
}
function sA(e, t, r) {
  return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
}
Vr("ERR_INVALID_OPT_VALUE", function(e, t) {
  return 'The value "' + t + '" is invalid for option "' + e + '"';
}, TypeError);
Vr("ERR_INVALID_ARG_TYPE", function(e, t, r) {
  var o;
  typeof t == "string" && iA(t, "not ") ? (o = "must not be", t = t.replace(/^not /, "")) : o = "must be";
  var s;
  if (oA(e, " argument"))
    s = "The ".concat(e, " ").concat(o, " ").concat(Yg(t, "type"));
  else {
    var u = sA(e, ".") ? "property" : "argument";
    s = 'The "'.concat(e, '" ').concat(u, " ").concat(o, " ").concat(Yg(t, "type"));
  }
  return s += ". Received type ".concat(typeof r), s;
}, TypeError);
Vr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
Vr("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
  return "The " + e + " method is not implemented";
});
Vr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
Vr("ERR_STREAM_DESTROYED", function(e) {
  return "Cannot call " + e + " after a stream was destroyed";
});
Vr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
Vr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
Vr("ERR_STREAM_WRITE_AFTER_END", "write after end");
Vr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Vr("ERR_UNKNOWN_ENCODING", function(e) {
  return "Unknown encoding: " + e;
}, TypeError);
Vr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
Zi.codes = t_;
var aA = Zi.codes.ERR_INVALID_OPT_VALUE;
function uA(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function fA(e, t, r, o) {
  var s = uA(t, o, r);
  if (s != null) {
    if (!(isFinite(s) && Math.floor(s) === s) || s < 0) {
      var u = o ? r : "highWaterMark";
      throw new aA(u, s);
    }
    return Math.floor(s);
  }
  return e.objectMode ? 16 : 16 * 1024;
}
var r_ = {
  getHighWaterMark: fA
}, Bl, Xg;
function n_() {
  if (Xg) return Bl;
  Xg = 1, Bl = ae;
  function e(R) {
    var O = this;
    this.next = null, this.entry = null, this.finish = function() {
      be(O, R);
    };
  }
  var t;
  ae.WritableState = Z;
  var r = {
    deprecate: Zb()
  }, o = Qb, s = _r.Buffer, u = (typeof Ye < "u" ? Ye : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function f(R) {
    return s.from(R);
  }
  function h(R) {
    return s.isBuffer(R) || R instanceof u;
  }
  var l = e_, p = r_, b = p.getHighWaterMark, w = Zi.codes, I = w.ERR_INVALID_ARG_TYPE, A = w.ERR_METHOD_NOT_IMPLEMENTED, x = w.ERR_MULTIPLE_CALLBACK, v = w.ERR_STREAM_CANNOT_PIPE, C = w.ERR_STREAM_DESTROYED, B = w.ERR_STREAM_NULL_VALUES, P = w.ERR_STREAM_WRITE_AFTER_END, S = w.ERR_UNKNOWN_ENCODING, m = l.errorOrDestroy;
  Bn(ae, o);
  function j() {
  }
  function Z(R, O, W) {
    t = t || No(), R = R || {}, typeof W != "boolean" && (W = O instanceof t), this.objectMode = !!R.objectMode, W && (this.objectMode = this.objectMode || !!R.writableObjectMode), this.highWaterMark = b(this, R, "writableHighWaterMark", W), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ie = R.decodeStrings === !1;
    this.decodeStrings = !ie, this.defaultEncoding = R.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ye) {
      J(O, ye);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = R.emitClose !== !1, this.autoDestroy = !!R.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  Z.prototype.getBuffer = function() {
    for (var O = this.bufferedRequest, W = []; O; )
      W.push(O), O = O.next;
    return W;
  }, function() {
    try {
      Object.defineProperty(Z.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ce;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ce = Function.prototype[Symbol.hasInstance], Object.defineProperty(ae, Symbol.hasInstance, {
    value: function(O) {
      return ce.call(this, O) ? !0 : this !== ae ? !1 : O && O._writableState instanceof Z;
    }
  })) : ce = function(O) {
    return O instanceof this;
  };
  function ae(R) {
    t = t || No();
    var O = this instanceof t;
    if (!O && !ce.call(ae, this)) return new ae(R);
    this._writableState = new Z(R, this, O), this.writable = !0, R && (typeof R.write == "function" && (this._write = R.write), typeof R.writev == "function" && (this._writev = R.writev), typeof R.destroy == "function" && (this._destroy = R.destroy), typeof R.final == "function" && (this._final = R.final)), o.call(this);
  }
  ae.prototype.pipe = function() {
    m(this, new v());
  };
  function ee(R, O) {
    var W = new P();
    m(R, W), le.process.nextTick(O, W);
  }
  function Se(R, O, W, ie) {
    var ye;
    return W === null ? ye = new B() : typeof W != "string" && !O.objectMode && (ye = new I("chunk", ["string", "Buffer"], W)), ye ? (m(R, ye), le.process.nextTick(ie, ye), !1) : !0;
  }
  ae.prototype.write = function(R, O, W) {
    var ie = this._writableState, ye = !1, d = !ie.objectMode && h(R);
    return d && !s.isBuffer(R) && (R = f(R)), typeof O == "function" && (W = O, O = null), d ? O = "buffer" : O || (O = ie.defaultEncoding), typeof W != "function" && (W = j), ie.ending ? ee(this, W) : (d || Se(this, ie, R, W)) && (ie.pendingcb++, ye = F(this, ie, d, R, O, W)), ye;
  }, ae.prototype.cork = function() {
    this._writableState.corked++;
  }, ae.prototype.uncork = function() {
    var R = this._writableState;
    R.corked && (R.corked--, !R.writing && !R.corked && !R.bufferProcessing && R.bufferedRequest && H(this, R));
  }, ae.prototype.setDefaultEncoding = function(O) {
    if (typeof O == "string" && (O = O.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((O + "").toLowerCase()) > -1)) throw new S(O);
    return this._writableState.defaultEncoding = O, this;
  }, Object.defineProperty(ae.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function me(R, O, W) {
    return !R.objectMode && R.decodeStrings !== !1 && typeof O == "string" && (O = s.from(O, W)), O;
  }
  Object.defineProperty(ae.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function F(R, O, W, ie, ye, d) {
    if (!W) {
      var g = me(O, ie, ye);
      ie !== g && (W = !0, ye = "buffer", ie = g);
    }
    var _ = O.objectMode ? 1 : ie.length;
    O.length += _;
    var E = O.length < O.highWaterMark;
    if (E || (O.needDrain = !0), O.writing || O.corked) {
      var K = O.lastBufferedRequest;
      O.lastBufferedRequest = {
        chunk: ie,
        encoding: ye,
        isBuf: W,
        callback: d,
        next: null
      }, K ? K.next = O.lastBufferedRequest : O.bufferedRequest = O.lastBufferedRequest, O.bufferedRequestCount += 1;
    } else
      U(R, O, !1, _, ie, ye, d);
    return E;
  }
  function U(R, O, W, ie, ye, d, g) {
    O.writelen = ie, O.writecb = g, O.writing = !0, O.sync = !0, O.destroyed ? O.onwrite(new C("write")) : W ? R._writev(ye, O.onwrite) : R._write(ye, d, O.onwrite), O.sync = !1;
  }
  function $(R, O, W, ie, ye) {
    --O.pendingcb, W ? (le.process.nextTick(ye, ie), le.process.nextTick(te, R, O), R._writableState.errorEmitted = !0, m(R, ie)) : (ye(ie), R._writableState.errorEmitted = !0, m(R, ie), te(R, O));
  }
  function q(R) {
    R.writing = !1, R.writecb = null, R.length -= R.writelen, R.writelen = 0;
  }
  function J(R, O) {
    var W = R._writableState, ie = W.sync, ye = W.writecb;
    if (typeof ye != "function") throw new x();
    if (q(W), O) $(R, W, ie, O, ye);
    else {
      var d = z(W) || R.destroyed;
      !d && !W.corked && !W.bufferProcessing && W.bufferedRequest && H(R, W), ie ? le.process.nextTick(V, R, W, d, ye) : V(R, W, d, ye);
    }
  }
  function V(R, O, W, ie) {
    W || re(R, O), O.pendingcb--, ie(), te(R, O);
  }
  function re(R, O) {
    O.length === 0 && O.needDrain && (O.needDrain = !1, R.emit("drain"));
  }
  function H(R, O) {
    O.bufferProcessing = !0;
    var W = O.bufferedRequest;
    if (R._writev && W && W.next) {
      var ie = O.bufferedRequestCount, ye = new Array(ie), d = O.corkedRequestsFree;
      d.entry = W;
      for (var g = 0, _ = !0; W; )
        ye[g] = W, W.isBuf || (_ = !1), W = W.next, g += 1;
      ye.allBuffers = _, U(R, O, !0, O.length, ye, "", d.finish), O.pendingcb++, O.lastBufferedRequest = null, d.next ? (O.corkedRequestsFree = d.next, d.next = null) : O.corkedRequestsFree = new e(O), O.bufferedRequestCount = 0;
    } else {
      for (; W; ) {
        var E = W.chunk, K = W.encoding, ne = W.callback, oe = O.objectMode ? 1 : E.length;
        if (U(R, O, !1, oe, E, K, ne), W = W.next, O.bufferedRequestCount--, O.writing)
          break;
      }
      W === null && (O.lastBufferedRequest = null);
    }
    O.bufferedRequest = W, O.bufferProcessing = !1;
  }
  ae.prototype._write = function(R, O, W) {
    W(new A("_write()"));
  }, ae.prototype._writev = null, ae.prototype.end = function(R, O, W) {
    var ie = this._writableState;
    return typeof R == "function" ? (W = R, R = null, O = null) : typeof O == "function" && (W = O, O = null), R != null && this.write(R, O), ie.corked && (ie.corked = 1, this.uncork()), ie.ending || _e(this, ie, W), this;
  }, Object.defineProperty(ae.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function z(R) {
    return R.ending && R.length === 0 && R.bufferedRequest === null && !R.finished && !R.writing;
  }
  function se(R, O) {
    R._final(function(W) {
      O.pendingcb--, W && m(R, W), O.prefinished = !0, R.emit("prefinish"), te(R, O);
    });
  }
  function de(R, O) {
    !O.prefinished && !O.finalCalled && (typeof R._final == "function" && !O.destroyed ? (O.pendingcb++, O.finalCalled = !0, le.process.nextTick(se, R, O)) : (O.prefinished = !0, R.emit("prefinish")));
  }
  function te(R, O) {
    var W = z(O);
    if (W && (de(R, O), O.pendingcb === 0 && (O.finished = !0, R.emit("finish"), O.autoDestroy))) {
      var ie = R._readableState;
      (!ie || ie.autoDestroy && ie.endEmitted) && R.destroy();
    }
    return W;
  }
  function _e(R, O, W) {
    O.ending = !0, te(R, O), W && (O.finished ? le.process.nextTick(W) : R.once("finish", W)), O.ended = !0, R.writable = !1;
  }
  function be(R, O, W) {
    var ie = R.entry;
    for (R.entry = null; ie; ) {
      var ye = ie.callback;
      O.pendingcb--, ye(W), ie = ie.next;
    }
    O.corkedRequestsFree.next = R;
  }
  return Object.defineProperty(ae.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(O) {
      this._writableState && (this._writableState.destroyed = O);
    }
  }), ae.prototype.destroy = l.destroy, ae.prototype._undestroy = l.undestroy, ae.prototype._destroy = function(R, O) {
    O(R);
  }, Bl;
}
var Nl, Zg;
function No() {
  if (Zg) return Nl;
  Zg = 1;
  var e = Object.keys || function(p) {
    var b = [];
    for (var w in p) b.push(w);
    return b;
  };
  Nl = f;
  var t = o_(), r = n_();
  Bn(f, t);
  for (var o = e(r.prototype), s = 0; s < o.length; s++) {
    var u = o[s];
    f.prototype[u] || (f.prototype[u] = r.prototype[u]);
  }
  function f(p) {
    if (!(this instanceof f)) return new f(p);
    t.call(this, p), r.call(this, p), this.allowHalfOpen = !0, p && (p.readable === !1 && (this.readable = !1), p.writable === !1 && (this.writable = !1), p.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", h)));
  }
  Object.defineProperty(f.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(f.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(f.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function h() {
    this._writableState.ended || le.process.nextTick(l, this);
  }
  function l(p) {
    p.end();
  }
  return Object.defineProperty(f.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(b) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = b, this._writableState.destroyed = b);
    }
  }), Nl;
}
var Qg = Zi.codes.ERR_STREAM_PREMATURE_CLOSE;
function lA(e) {
  var t = !1;
  return function() {
    if (!t) {
      t = !0;
      for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++)
        o[s] = arguments[s];
      e.apply(this, o);
    }
  };
}
function cA() {
}
function dA(e) {
  return e.setHeader && typeof e.abort == "function";
}
function i_(e, t, r) {
  if (typeof t == "function") return i_(e, null, t);
  t || (t = {}), r = lA(r || cA);
  var o = t.readable || t.readable !== !1 && e.readable, s = t.writable || t.writable !== !1 && e.writable, u = function() {
    e.writable || h();
  }, f = e._writableState && e._writableState.finished, h = function() {
    s = !1, f = !0, o || r.call(e);
  }, l = e._readableState && e._readableState.endEmitted, p = function() {
    o = !1, l = !0, s || r.call(e);
  }, b = function(x) {
    r.call(e, x);
  }, w = function() {
    var x;
    if (o && !l)
      return (!e._readableState || !e._readableState.ended) && (x = new Qg()), r.call(e, x);
    if (s && !f)
      return (!e._writableState || !e._writableState.ended) && (x = new Qg()), r.call(e, x);
  }, I = function() {
    e.req.on("finish", h);
  };
  return dA(e) ? (e.on("complete", h), e.on("abort", w), e.req ? I() : e.on("request", I)) : s && !e._writableState && (e.on("end", u), e.on("close", u)), e.on("end", p), e.on("finish", h), t.error !== !1 && e.on("error", b), e.on("close", w), function() {
    e.removeListener("complete", h), e.removeListener("abort", w), e.removeListener("request", I), e.req && e.req.removeListener("finish", h), e.removeListener("end", u), e.removeListener("close", u), e.removeListener("finish", h), e.removeListener("end", p), e.removeListener("error", b), e.removeListener("close", w);
  };
}
var Xc = i_, $l, ep;
function hA() {
  if (ep) return $l;
  ep = 1;
  var e;
  function t(S, m, j) {
    return m = r(m), m in S ? Object.defineProperty(S, m, { value: j, enumerable: !0, configurable: !0, writable: !0 }) : S[m] = j, S;
  }
  function r(S) {
    var m = o(S, "string");
    return typeof m == "symbol" ? m : String(m);
  }
  function o(S, m) {
    if (typeof S != "object" || S === null) return S;
    var j = S[Symbol.toPrimitive];
    if (j !== void 0) {
      var Z = j.call(S, m);
      if (typeof Z != "object") return Z;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (m === "string" ? String : Number)(S);
  }
  var s = Xc, u = Symbol("lastResolve"), f = Symbol("lastReject"), h = Symbol("error"), l = Symbol("ended"), p = Symbol("lastPromise"), b = Symbol("handlePromise"), w = Symbol("stream");
  function I(S, m) {
    return {
      value: S,
      done: m
    };
  }
  function A(S) {
    var m = S[u];
    if (m !== null) {
      var j = S[w].read();
      j !== null && (S[p] = null, S[u] = null, S[f] = null, m(I(j, !1)));
    }
  }
  function x(S) {
    le.process.nextTick(A, S);
  }
  function v(S, m) {
    return function(j, Z) {
      S.then(function() {
        if (m[l]) {
          j(I(void 0, !0));
          return;
        }
        m[b](j, Z);
      }, Z);
    };
  }
  var C = Object.getPrototypeOf(function() {
  }), B = Object.setPrototypeOf((e = {
    get stream() {
      return this[w];
    },
    next: function() {
      var m = this, j = this[h];
      if (j !== null)
        return Promise.reject(j);
      if (this[l])
        return Promise.resolve(I(void 0, !0));
      if (this[w].destroyed)
        return new Promise(function(ee, Se) {
          le.process.nextTick(function() {
            m[h] ? Se(m[h]) : ee(I(void 0, !0));
          });
        });
      var Z = this[p], ce;
      if (Z)
        ce = new Promise(v(Z, this));
      else {
        var ae = this[w].read();
        if (ae !== null)
          return Promise.resolve(I(ae, !1));
        ce = new Promise(this[b]);
      }
      return this[p] = ce, ce;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var m = this;
    return new Promise(function(j, Z) {
      m[w].destroy(null, function(ce) {
        if (ce) {
          Z(ce);
          return;
        }
        j(I(void 0, !0));
      });
    });
  }), e), C), P = function(m) {
    var j, Z = Object.create(B, (j = {}, t(j, w, {
      value: m,
      writable: !0
    }), t(j, u, {
      value: null,
      writable: !0
    }), t(j, f, {
      value: null,
      writable: !0
    }), t(j, h, {
      value: null,
      writable: !0
    }), t(j, l, {
      value: m._readableState.endEmitted,
      writable: !0
    }), t(j, b, {
      value: function(ae, ee) {
        var Se = Z[w].read();
        Se ? (Z[p] = null, Z[u] = null, Z[f] = null, ae(I(Se, !1))) : (Z[u] = ae, Z[f] = ee);
      },
      writable: !0
    }), j));
    return Z[p] = null, s(m, function(ce) {
      if (ce && ce.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var ae = Z[f];
        ae !== null && (Z[p] = null, Z[u] = null, Z[f] = null, ae(ce)), Z[h] = ce;
        return;
      }
      var ee = Z[u];
      ee !== null && (Z[p] = null, Z[u] = null, Z[f] = null, ee(I(void 0, !0))), Z[l] = !0;
    }), m.on("readable", x.bind(null, Z)), Z;
  };
  return $l = P, $l;
}
var Ml, tp;
function gA() {
  return tp || (tp = 1, Ml = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Ml;
}
var xl, rp;
function o_() {
  if (rp) return xl;
  rp = 1, xl = ee;
  var e;
  ee.ReadableState = ae, Pn.EventEmitter;
  var t = function(g, _) {
    return g.listeners(_).length;
  }, r = Qb, o = _r.Buffer, s = (typeof Ye < "u" ? Ye : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function u(d) {
    return o.from(d);
  }
  function f(d) {
    return o.isBuffer(d) || d instanceof s;
  }
  var h = ks, l;
  h && h.debuglog ? l = h.debuglog("stream") : l = function() {
  };
  var p = Q1(), b = e_, w = r_, I = w.getHighWaterMark, A = Zi.codes, x = A.ERR_INVALID_ARG_TYPE, v = A.ERR_STREAM_PUSH_AFTER_EOF, C = A.ERR_METHOD_NOT_IMPLEMENTED, B = A.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, P, S, m;
  Bn(ee, r);
  var j = b.errorOrDestroy, Z = ["error", "close", "destroy", "pause", "resume"];
  function ce(d, g, _) {
    if (typeof d.prependListener == "function") return d.prependListener(g, _);
    !d._events || !d._events[g] ? d.on(g, _) : Array.isArray(d._events[g]) ? d._events[g].unshift(_) : d._events[g] = [_, d._events[g]];
  }
  function ae(d, g, _) {
    e = e || No(), d = d || {}, typeof _ != "boolean" && (_ = g instanceof e), this.objectMode = !!d.objectMode, _ && (this.objectMode = this.objectMode || !!d.readableObjectMode), this.highWaterMark = I(this, d, "readableHighWaterMark", _), this.buffer = new p(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = d.emitClose !== !1, this.autoDestroy = !!d.autoDestroy, this.destroyed = !1, this.defaultEncoding = d.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, d.encoding && (P || (P = Ls().StringDecoder), this.decoder = new P(d.encoding), this.encoding = d.encoding);
  }
  function ee(d) {
    if (e = e || No(), !(this instanceof ee)) return new ee(d);
    var g = this instanceof e;
    this._readableState = new ae(d, this, g), this.readable = !0, d && (typeof d.read == "function" && (this._read = d.read), typeof d.destroy == "function" && (this._destroy = d.destroy)), r.call(this);
  }
  Object.defineProperty(ee.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(g) {
      this._readableState && (this._readableState.destroyed = g);
    }
  }), ee.prototype.destroy = b.destroy, ee.prototype._undestroy = b.undestroy, ee.prototype._destroy = function(d, g) {
    g(d);
  }, ee.prototype.push = function(d, g) {
    var _ = this._readableState, E;
    return _.objectMode ? E = !0 : typeof d == "string" && (g = g || _.defaultEncoding, g !== _.encoding && (d = o.from(d, g), g = ""), E = !0), Se(this, d, g, !1, E);
  }, ee.prototype.unshift = function(d) {
    return Se(this, d, null, !0, !1);
  };
  function Se(d, g, _, E, K) {
    l("readableAddChunk", g);
    var ne = d._readableState;
    if (g === null)
      ne.reading = !1, J(d, ne);
    else {
      var oe;
      if (K || (oe = F(ne, g)), oe)
        j(d, oe);
      else if (ne.objectMode || g && g.length > 0)
        if (typeof g != "string" && !ne.objectMode && Object.getPrototypeOf(g) !== o.prototype && (g = u(g)), E)
          ne.endEmitted ? j(d, new B()) : me(d, ne, g, !0);
        else if (ne.ended)
          j(d, new v());
        else {
          if (ne.destroyed)
            return !1;
          ne.reading = !1, ne.decoder && !_ ? (g = ne.decoder.write(g), ne.objectMode || g.length !== 0 ? me(d, ne, g, !1) : H(d, ne)) : me(d, ne, g, !1);
        }
      else E || (ne.reading = !1, H(d, ne));
    }
    return !ne.ended && (ne.length < ne.highWaterMark || ne.length === 0);
  }
  function me(d, g, _, E) {
    g.flowing && g.length === 0 && !g.sync ? (g.awaitDrain = 0, d.emit("data", _)) : (g.length += g.objectMode ? 1 : _.length, E ? g.buffer.unshift(_) : g.buffer.push(_), g.needReadable && V(d)), H(d, g);
  }
  function F(d, g) {
    var _;
    return !f(g) && typeof g != "string" && g !== void 0 && !d.objectMode && (_ = new x("chunk", ["string", "Buffer", "Uint8Array"], g)), _;
  }
  ee.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ee.prototype.setEncoding = function(d) {
    P || (P = Ls().StringDecoder);
    var g = new P(d);
    this._readableState.decoder = g, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var _ = this._readableState.buffer.head, E = ""; _ !== null; )
      E += g.write(_.data), _ = _.next;
    return this._readableState.buffer.clear(), E !== "" && this._readableState.buffer.push(E), this._readableState.length = E.length, this;
  };
  var U = 1073741824;
  function $(d) {
    return d >= U ? d = U : (d--, d |= d >>> 1, d |= d >>> 2, d |= d >>> 4, d |= d >>> 8, d |= d >>> 16, d++), d;
  }
  function q(d, g) {
    return d <= 0 || g.length === 0 && g.ended ? 0 : g.objectMode ? 1 : d !== d ? g.flowing && g.length ? g.buffer.head.data.length : g.length : (d > g.highWaterMark && (g.highWaterMark = $(d)), d <= g.length ? d : g.ended ? g.length : (g.needReadable = !0, 0));
  }
  ee.prototype.read = function(d) {
    l("read", d), d = parseInt(d, 10);
    var g = this._readableState, _ = d;
    if (d !== 0 && (g.emittedReadable = !1), d === 0 && g.needReadable && ((g.highWaterMark !== 0 ? g.length >= g.highWaterMark : g.length > 0) || g.ended))
      return l("read: emitReadable", g.length, g.ended), g.length === 0 && g.ended ? W(this) : V(this), null;
    if (d = q(d, g), d === 0 && g.ended)
      return g.length === 0 && W(this), null;
    var E = g.needReadable;
    l("need readable", E), (g.length === 0 || g.length - d < g.highWaterMark) && (E = !0, l("length less than watermark", E)), g.ended || g.reading ? (E = !1, l("reading or ended", E)) : E && (l("do read"), g.reading = !0, g.sync = !0, g.length === 0 && (g.needReadable = !0), this._read(g.highWaterMark), g.sync = !1, g.reading || (d = q(_, g)));
    var K;
    return d > 0 ? K = O(d, g) : K = null, K === null ? (g.needReadable = g.length <= g.highWaterMark, d = 0) : (g.length -= d, g.awaitDrain = 0), g.length === 0 && (g.ended || (g.needReadable = !0), _ !== d && g.ended && W(this)), K !== null && this.emit("data", K), K;
  };
  function J(d, g) {
    if (l("onEofChunk"), !g.ended) {
      if (g.decoder) {
        var _ = g.decoder.end();
        _ && _.length && (g.buffer.push(_), g.length += g.objectMode ? 1 : _.length);
      }
      g.ended = !0, g.sync ? V(d) : (g.needReadable = !1, g.emittedReadable || (g.emittedReadable = !0, re(d)));
    }
  }
  function V(d) {
    var g = d._readableState;
    l("emitReadable", g.needReadable, g.emittedReadable), g.needReadable = !1, g.emittedReadable || (l("emitReadable", g.flowing), g.emittedReadable = !0, le.process.nextTick(re, d));
  }
  function re(d) {
    var g = d._readableState;
    l("emitReadable_", g.destroyed, g.length, g.ended), !g.destroyed && (g.length || g.ended) && (d.emit("readable"), g.emittedReadable = !1), g.needReadable = !g.flowing && !g.ended && g.length <= g.highWaterMark, R(d);
  }
  function H(d, g) {
    g.readingMore || (g.readingMore = !0, le.process.nextTick(z, d, g));
  }
  function z(d, g) {
    for (; !g.reading && !g.ended && (g.length < g.highWaterMark || g.flowing && g.length === 0); ) {
      var _ = g.length;
      if (l("maybeReadMore read 0"), d.read(0), _ === g.length)
        break;
    }
    g.readingMore = !1;
  }
  ee.prototype._read = function(d) {
    j(this, new C("_read()"));
  }, ee.prototype.pipe = function(d, g) {
    var _ = this, E = this._readableState;
    switch (E.pipesCount) {
      case 0:
        E.pipes = d;
        break;
      case 1:
        E.pipes = [E.pipes, d];
        break;
      default:
        E.pipes.push(d);
        break;
    }
    E.pipesCount += 1, l("pipe count=%d opts=%j", E.pipesCount, g);
    var K = (!g || g.end !== !1) && d !== le.process.stdout && d !== le.process.stderr, ne = K ? Ie : yt;
    E.endEmitted ? le.process.nextTick(ne) : _.once("end", ne), d.on("unpipe", oe);
    function oe(Xe, Ge) {
      l("onunpipe"), Xe === _ && Ge && Ge.hasUnpiped === !1 && (Ge.hasUnpiped = !0, Ue());
    }
    function Ie() {
      l("onend"), d.end();
    }
    var Be = se(_);
    d.on("drain", Be);
    var Ce = !1;
    function Ue() {
      l("cleanup"), d.removeListener("close", _t), d.removeListener("finish", tt), d.removeListener("drain", Be), d.removeListener("error", He), d.removeListener("unpipe", oe), _.removeListener("end", Ie), _.removeListener("end", yt), _.removeListener("data", Re), Ce = !0, E.awaitDrain && (!d._writableState || d._writableState.needDrain) && Be();
    }
    _.on("data", Re);
    function Re(Xe) {
      l("ondata");
      var Ge = d.write(Xe);
      l("dest.write", Ge), Ge === !1 && ((E.pipesCount === 1 && E.pipes === d || E.pipesCount > 1 && ye(E.pipes, d) !== -1) && !Ce && (l("false write response, pause", E.awaitDrain), E.awaitDrain++), _.pause());
    }
    function He(Xe) {
      l("onerror", Xe), yt(), d.removeListener("error", He), t(d, "error") === 0 && j(d, Xe);
    }
    ce(d, "error", He);
    function _t() {
      d.removeListener("finish", tt), yt();
    }
    d.once("close", _t);
    function tt() {
      l("onfinish"), d.removeListener("close", _t), yt();
    }
    d.once("finish", tt);
    function yt() {
      l("unpipe"), _.unpipe(d);
    }
    return d.emit("pipe", _), E.flowing || (l("pipe resume"), _.resume()), d;
  };
  function se(d) {
    return function() {
      var _ = d._readableState;
      l("pipeOnDrain", _.awaitDrain), _.awaitDrain && _.awaitDrain--, _.awaitDrain === 0 && t(d, "data") && (_.flowing = !0, R(d));
    };
  }
  ee.prototype.unpipe = function(d) {
    var g = this._readableState, _ = {
      hasUnpiped: !1
    };
    if (g.pipesCount === 0) return this;
    if (g.pipesCount === 1)
      return d && d !== g.pipes ? this : (d || (d = g.pipes), g.pipes = null, g.pipesCount = 0, g.flowing = !1, d && d.emit("unpipe", this, _), this);
    if (!d) {
      var E = g.pipes, K = g.pipesCount;
      g.pipes = null, g.pipesCount = 0, g.flowing = !1;
      for (var ne = 0; ne < K; ne++) E[ne].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var oe = ye(g.pipes, d);
    return oe === -1 ? this : (g.pipes.splice(oe, 1), g.pipesCount -= 1, g.pipesCount === 1 && (g.pipes = g.pipes[0]), d.emit("unpipe", this, _), this);
  }, ee.prototype.on = function(d, g) {
    var _ = r.prototype.on.call(this, d, g), E = this._readableState;
    return d === "data" ? (E.readableListening = this.listenerCount("readable") > 0, E.flowing !== !1 && this.resume()) : d === "readable" && !E.endEmitted && !E.readableListening && (E.readableListening = E.needReadable = !0, E.flowing = !1, E.emittedReadable = !1, l("on readable", E.length, E.reading), E.length ? V(this) : E.reading || le.process.nextTick(te, this)), _;
  }, ee.prototype.addListener = ee.prototype.on, ee.prototype.removeListener = function(d, g) {
    var _ = r.prototype.removeListener.call(this, d, g);
    return d === "readable" && le.process.nextTick(de, this), _;
  }, ee.prototype.removeAllListeners = function(d) {
    var g = r.prototype.removeAllListeners.apply(this, arguments);
    return (d === "readable" || d === void 0) && le.process.nextTick(de, this), g;
  };
  function de(d) {
    var g = d._readableState;
    g.readableListening = d.listenerCount("readable") > 0, g.resumeScheduled && !g.paused ? g.flowing = !0 : d.listenerCount("data") > 0 && d.resume();
  }
  function te(d) {
    l("readable nexttick read 0"), d.read(0);
  }
  ee.prototype.resume = function() {
    var d = this._readableState;
    return d.flowing || (l("resume"), d.flowing = !d.readableListening, _e(this, d)), d.paused = !1, this;
  };
  function _e(d, g) {
    g.resumeScheduled || (g.resumeScheduled = !0, le.process.nextTick(be, d, g));
  }
  function be(d, g) {
    l("resume", g.reading), g.reading || d.read(0), g.resumeScheduled = !1, d.emit("resume"), R(d), g.flowing && !g.reading && d.read(0);
  }
  ee.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function R(d) {
    var g = d._readableState;
    for (l("flow", g.flowing); g.flowing && d.read() !== null; ) ;
  }
  ee.prototype.wrap = function(d) {
    var g = this, _ = this._readableState, E = !1;
    d.on("end", function() {
      if (l("wrapped end"), _.decoder && !_.ended) {
        var oe = _.decoder.end();
        oe && oe.length && g.push(oe);
      }
      g.push(null);
    }), d.on("data", function(oe) {
      if (l("wrapped data"), _.decoder && (oe = _.decoder.write(oe)), !(_.objectMode && oe == null) && !(!_.objectMode && (!oe || !oe.length))) {
        var Ie = g.push(oe);
        Ie || (E = !0, d.pause());
      }
    });
    for (var K in d)
      this[K] === void 0 && typeof d[K] == "function" && (this[K] = /* @__PURE__ */ function(Ie) {
        return function() {
          return d[Ie].apply(d, arguments);
        };
      }(K));
    for (var ne = 0; ne < Z.length; ne++)
      d.on(Z[ne], this.emit.bind(this, Z[ne]));
    return this._read = function(oe) {
      l("wrapped _read", oe), E && (E = !1, d.resume());
    }, this;
  }, typeof Symbol == "function" && (ee.prototype[Symbol.asyncIterator] = function() {
    return S === void 0 && (S = hA()), S(this);
  }), Object.defineProperty(ee.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(ee.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(ee.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(g) {
      this._readableState && (this._readableState.flowing = g);
    }
  }), ee._fromList = O, Object.defineProperty(ee.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function O(d, g) {
    if (g.length === 0) return null;
    var _;
    return g.objectMode ? _ = g.buffer.shift() : !d || d >= g.length ? (g.decoder ? _ = g.buffer.join("") : g.buffer.length === 1 ? _ = g.buffer.first() : _ = g.buffer.concat(g.length), g.buffer.clear()) : _ = g.buffer.consume(d, g.decoder), _;
  }
  function W(d) {
    var g = d._readableState;
    l("endReadable", g.endEmitted), g.endEmitted || (g.ended = !0, le.process.nextTick(ie, g, d));
  }
  function ie(d, g) {
    if (l("endReadableNT", d.endEmitted, d.length), !d.endEmitted && d.length === 0 && (d.endEmitted = !0, g.readable = !1, g.emit("end"), d.autoDestroy)) {
      var _ = g._writableState;
      (!_ || _.autoDestroy && _.finished) && g.destroy();
    }
  }
  typeof Symbol == "function" && (ee.from = function(d, g) {
    return m === void 0 && (m = gA()), m(ee, d, g);
  });
  function ye(d, g) {
    for (var _ = 0, E = d.length; _ < E; _++)
      if (d[_] === g) return _;
    return -1;
  }
  return xl;
}
var s_ = Qn, Lu = Zi.codes, pA = Lu.ERR_METHOD_NOT_IMPLEMENTED, bA = Lu.ERR_MULTIPLE_CALLBACK, _A = Lu.ERR_TRANSFORM_ALREADY_TRANSFORMING, yA = Lu.ERR_TRANSFORM_WITH_LENGTH_0, Pu = No();
Bn(Qn, Pu);
function wA(e, t) {
  var r = this._transformState;
  r.transforming = !1;
  var o = r.writecb;
  if (o === null)
    return this.emit("error", new bA());
  r.writechunk = null, r.writecb = null, t != null && this.push(t), o(e);
  var s = this._readableState;
  s.reading = !1, (s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
}
function Qn(e) {
  if (!(this instanceof Qn)) return new Qn(e);
  Pu.call(this, e), this._transformState = {
    afterTransform: wA.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", mA);
}
function mA() {
  var e = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
    np(e, t, r);
  }) : np(this, null, null);
}
Qn.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, Pu.prototype.push.call(this, e, t);
};
Qn.prototype._transform = function(e, t, r) {
  r(new pA("_transform()"));
};
Qn.prototype._write = function(e, t, r) {
  var o = this._transformState;
  if (o.writecb = r, o.writechunk = e, o.writeencoding = t, !o.transforming) {
    var s = this._readableState;
    (o.needTransform || s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
  }
};
Qn.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
Qn.prototype._destroy = function(e, t) {
  Pu.prototype._destroy.call(this, e, function(r) {
    t(r);
  });
};
function np(e, t, r) {
  if (t) return e.emit("error", t);
  if (r != null && e.push(r), e._writableState.length) throw new yA();
  if (e._transformState.transforming) throw new _A();
  return e.push(null);
}
var EA = Bs, a_ = s_;
Bn(Bs, a_);
function Bs(e) {
  if (!(this instanceof Bs)) return new Bs(e);
  a_.call(this, e);
}
Bs.prototype._transform = function(e, t, r) {
  r(null, e);
};
var Dl;
function vA(e) {
  var t = !1;
  return function() {
    t || (t = !0, e.apply(void 0, arguments));
  };
}
var u_ = Zi.codes, SA = u_.ERR_MISSING_ARGS, RA = u_.ERR_STREAM_DESTROYED;
function ip(e) {
  if (e) throw e;
}
function AA(e) {
  return e.setHeader && typeof e.abort == "function";
}
function TA(e, t, r, o) {
  o = vA(o);
  var s = !1;
  e.on("close", function() {
    s = !0;
  }), Dl === void 0 && (Dl = Xc), Dl(e, {
    readable: t,
    writable: r
  }, function(f) {
    if (f) return o(f);
    s = !0, o();
  });
  var u = !1;
  return function(f) {
    if (!s && !u) {
      if (u = !0, AA(e)) return e.abort();
      if (typeof e.destroy == "function") return e.destroy();
      o(f || new RA("pipe"));
    }
  };
}
function op(e) {
  e();
}
function IA(e, t) {
  return e.pipe(t);
}
function OA(e) {
  return !e.length || typeof e[e.length - 1] != "function" ? ip : e.pop();
}
function CA() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var o = OA(t);
  if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
    throw new SA("streams");
  var s, u = t.map(function(f, h) {
    var l = h < t.length - 1, p = h > 0;
    return TA(f, l, p, function(b) {
      s || (s = b), b && u.forEach(op), !l && (u.forEach(op), o(s));
    });
  });
  return t.reduce(IA);
}
var LA = CA;
(function(e, t) {
  t = e.exports = o_(), t.Stream = t, t.Readable = t, t.Writable = n_(), t.Duplex = No(), t.Transform = s_, t.PassThrough = EA, t.finished = Xc, t.pipeline = LA;
})(vc, vc.exports);
var f_ = vc.exports;
const { Transform: UN } = f_, { Transform: kN } = f_;
var l_ = {};
const sp = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
l_.p1600 = function(e) {
  for (let t = 0; t < 24; ++t) {
    const r = e[0] ^ e[10] ^ e[20] ^ e[30] ^ e[40], o = e[1] ^ e[11] ^ e[21] ^ e[31] ^ e[41], s = e[2] ^ e[12] ^ e[22] ^ e[32] ^ e[42], u = e[3] ^ e[13] ^ e[23] ^ e[33] ^ e[43], f = e[4] ^ e[14] ^ e[24] ^ e[34] ^ e[44], h = e[5] ^ e[15] ^ e[25] ^ e[35] ^ e[45], l = e[6] ^ e[16] ^ e[26] ^ e[36] ^ e[46], p = e[7] ^ e[17] ^ e[27] ^ e[37] ^ e[47], b = e[8] ^ e[18] ^ e[28] ^ e[38] ^ e[48], w = e[9] ^ e[19] ^ e[29] ^ e[39] ^ e[49];
    let I = b ^ (s << 1 | u >>> 31), A = w ^ (u << 1 | s >>> 31);
    const x = e[0] ^ I, v = e[1] ^ A, C = e[10] ^ I, B = e[11] ^ A, P = e[20] ^ I, S = e[21] ^ A, m = e[30] ^ I, j = e[31] ^ A, Z = e[40] ^ I, ce = e[41] ^ A;
    I = r ^ (f << 1 | h >>> 31), A = o ^ (h << 1 | f >>> 31);
    const ae = e[2] ^ I, ee = e[3] ^ A, Se = e[12] ^ I, me = e[13] ^ A, F = e[22] ^ I, U = e[23] ^ A, $ = e[32] ^ I, q = e[33] ^ A, J = e[42] ^ I, V = e[43] ^ A;
    I = s ^ (l << 1 | p >>> 31), A = u ^ (p << 1 | l >>> 31);
    const re = e[4] ^ I, H = e[5] ^ A, z = e[14] ^ I, se = e[15] ^ A, de = e[24] ^ I, te = e[25] ^ A, _e = e[34] ^ I, be = e[35] ^ A, R = e[44] ^ I, O = e[45] ^ A;
    I = f ^ (b << 1 | w >>> 31), A = h ^ (w << 1 | b >>> 31);
    const W = e[6] ^ I, ie = e[7] ^ A, ye = e[16] ^ I, d = e[17] ^ A, g = e[26] ^ I, _ = e[27] ^ A, E = e[36] ^ I, K = e[37] ^ A, ne = e[46] ^ I, oe = e[47] ^ A;
    I = l ^ (r << 1 | o >>> 31), A = p ^ (o << 1 | r >>> 31);
    const Ie = e[8] ^ I, Be = e[9] ^ A, Ce = e[18] ^ I, Ue = e[19] ^ A, Re = e[28] ^ I, He = e[29] ^ A, _t = e[38] ^ I, tt = e[39] ^ A, yt = e[48] ^ I, Xe = e[49] ^ A, Ge = x, jt = v, Pt = B << 4 | C >>> 28, ut = C << 4 | B >>> 28, Nt = P << 3 | S >>> 29, lr = S << 3 | P >>> 29, tr = j << 9 | m >>> 23, Ft = m << 9 | j >>> 23, cr = Z << 18 | ce >>> 14, Jr = ce << 18 | Z >>> 14, Yr = ae << 1 | ee >>> 31, un = ee << 1 | ae >>> 31, fn = me << 12 | Se >>> 20, rr = Se << 12 | me >>> 20, Lr = F << 10 | U >>> 22, nr = U << 10 | F >>> 22, $n = q << 13 | $ >>> 19, Xr = $ << 13 | q >>> 19, ln = J << 2 | V >>> 30, N = V << 2 | J >>> 30, D = H << 30 | re >>> 2, Ee = re << 30 | H >>> 2, ve = z << 6 | se >>> 26, Te = se << 6 | z >>> 26, wt = te << 11 | de >>> 21, Rt = de << 11 | te >>> 21, cn = _e << 15 | be >>> 17, Bt = be << 15 | _e >>> 17, dn = O << 29 | R >>> 3, Mn = R << 29 | O >>> 3, hn = W << 28 | ie >>> 4, gn = ie << 28 | W >>> 4, Zr = d << 23 | ye >>> 9, Gt = ye << 23 | d >>> 9, Pr = g << 25 | _ >>> 7, mr = _ << 25 | g >>> 7, ir = E << 21 | K >>> 11, Ht = K << 21 | E >>> 11, Pi = oe << 24 | ne >>> 8, Bi = ne << 24 | oe >>> 8, xn = Ie << 27 | Be >>> 5, pn = Be << 27 | Ie >>> 5, bn = Ce << 20 | Ue >>> 12, Br = Ue << 20 | Ce >>> 12, Ni = He << 7 | Re >>> 25, _n = Re << 7 | He >>> 25, oi = _t << 8 | tt >>> 24, si = tt << 8 | _t >>> 24, ai = yt << 14 | Xe >>> 18, ui = Xe << 14 | yt >>> 18;
    e[0] = Ge ^ ~fn & wt, e[1] = jt ^ ~rr & Rt, e[10] = hn ^ ~bn & Nt, e[11] = gn ^ ~Br & lr, e[20] = Yr ^ ~ve & Pr, e[21] = un ^ ~Te & mr, e[30] = xn ^ ~Pt & Lr, e[31] = pn ^ ~ut & nr, e[40] = D ^ ~Zr & Ni, e[41] = Ee ^ ~Gt & _n, e[2] = fn ^ ~wt & ir, e[3] = rr ^ ~Rt & Ht, e[12] = bn ^ ~Nt & $n, e[13] = Br ^ ~lr & Xr, e[22] = ve ^ ~Pr & oi, e[23] = Te ^ ~mr & si, e[32] = Pt ^ ~Lr & cn, e[33] = ut ^ ~nr & Bt, e[42] = Zr ^ ~Ni & tr, e[43] = Gt ^ ~_n & Ft, e[4] = wt ^ ~ir & ai, e[5] = Rt ^ ~Ht & ui, e[14] = Nt ^ ~$n & dn, e[15] = lr ^ ~Xr & Mn, e[24] = Pr ^ ~oi & cr, e[25] = mr ^ ~si & Jr, e[34] = Lr ^ ~cn & Pi, e[35] = nr ^ ~Bt & Bi, e[44] = Ni ^ ~tr & ln, e[45] = _n ^ ~Ft & N, e[6] = ir ^ ~ai & Ge, e[7] = Ht ^ ~ui & jt, e[16] = $n ^ ~dn & hn, e[17] = Xr ^ ~Mn & gn, e[26] = oi ^ ~cr & Yr, e[27] = si ^ ~Jr & un, e[36] = cn ^ ~Pi & xn, e[37] = Bt ^ ~Bi & pn, e[46] = tr ^ ~ln & D, e[47] = Ft ^ ~N & Ee, e[8] = ai ^ ~Ge & fn, e[9] = ui ^ ~jt & rr, e[18] = dn ^ ~hn & bn, e[19] = Mn ^ ~gn & Br, e[28] = cr ^ ~Yr & ve, e[29] = Jr ^ ~un & Te, e[38] = Pi ^ ~xn & Pt, e[39] = Bi ^ ~pn & ut, e[48] = ln ^ ~D & Zr, e[49] = N ^ ~Ee & Gt, e[0] ^= sp[t * 2], e[1] ^= sp[t * 2 + 1];
  }
};
const yu = l_;
function Fs() {
  this.state = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ], this.blockSize = null, this.count = 0, this.squeezing = !1;
}
Fs.prototype.initialize = function(e, t) {
  for (let r = 0; r < 50; ++r) this.state[r] = 0;
  this.blockSize = e / 8, this.count = 0, this.squeezing = !1;
};
Fs.prototype.absorb = function(e) {
  for (let t = 0; t < e.length; ++t)
    this.state[~~(this.count / 4)] ^= e[t] << 8 * (this.count % 4), this.count += 1, this.count === this.blockSize && (yu.p1600(this.state), this.count = 0);
};
Fs.prototype.absorbLastFewBits = function(e) {
  this.state[~~(this.count / 4)] ^= e << 8 * (this.count % 4), e & 128 && this.count === this.blockSize - 1 && yu.p1600(this.state), this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4), yu.p1600(this.state), this.count = 0, this.squeezing = !0;
};
Fs.prototype.squeeze = function(e) {
  this.squeezing || this.absorbLastFewBits(1);
  const t = le.Buffer.alloc(e);
  for (let r = 0; r < e; ++r)
    t[r] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255, this.count += 1, this.count === this.blockSize && (yu.p1600(this.state), this.count = 0);
  return t;
};
Fs.prototype.copy = function(e) {
  for (let t = 0; t < 50; ++t) e.state[t] = this.state[t];
  e.blockSize = this.blockSize, e.count = this.count, e.squeezing = this.squeezing;
};
var PA = BA;
function BA(e) {
  e = e || {};
  var t = e.max || Number.MAX_SAFE_INTEGER, r = typeof e.start < "u" ? e.start : Math.floor(Math.random() * t);
  return function() {
    return r = r % t, r++;
  };
}
const NA = /* @__PURE__ */ Oi(PA);
var Rc = { exports: {} }, jl, ap;
function $A() {
  if (ap) return jl;
  ap = 1;
  var e = 1e3, t = e * 60, r = t * 60, o = r * 24, s = o * 7, u = o * 365.25;
  jl = function(b, w) {
    w = w || {};
    var I = typeof b;
    if (I === "string" && b.length > 0)
      return f(b);
    if (I === "number" && isFinite(b))
      return w.long ? l(b) : h(b);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(b)
    );
  };
  function f(b) {
    if (b = String(b), !(b.length > 100)) {
      var w = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        b
      );
      if (w) {
        var I = parseFloat(w[1]), A = (w[2] || "ms").toLowerCase();
        switch (A) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return I * u;
          case "weeks":
          case "week":
          case "w":
            return I * s;
          case "days":
          case "day":
          case "d":
            return I * o;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return I * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return I * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return I * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return I;
          default:
            return;
        }
      }
    }
  }
  function h(b) {
    var w = Math.abs(b);
    return w >= o ? Math.round(b / o) + "d" : w >= r ? Math.round(b / r) + "h" : w >= t ? Math.round(b / t) + "m" : w >= e ? Math.round(b / e) + "s" : b + "ms";
  }
  function l(b) {
    var w = Math.abs(b);
    return w >= o ? p(b, w, o, "day") : w >= r ? p(b, w, r, "hour") : w >= t ? p(b, w, t, "minute") : w >= e ? p(b, w, e, "second") : b + " ms";
  }
  function p(b, w, I, A) {
    var x = w >= I * 1.5;
    return Math.round(b / I) + " " + A + (x ? "s" : "");
  }
  return jl;
}
function MA(e) {
  r.debug = r, r.default = r, r.coerce = l, r.disable = f, r.enable = s, r.enabled = h, r.humanize = $A(), r.destroy = p, Object.keys(e).forEach((b) => {
    r[b] = e[b];
  }), r.names = [], r.skips = [], r.formatters = {};
  function t(b) {
    let w = 0;
    for (let I = 0; I < b.length; I++)
      w = (w << 5) - w + b.charCodeAt(I), w |= 0;
    return r.colors[Math.abs(w) % r.colors.length];
  }
  r.selectColor = t;
  function r(b) {
    let w, I = null, A, x;
    function v(...C) {
      if (!v.enabled)
        return;
      const B = v, P = Number(/* @__PURE__ */ new Date()), S = P - (w || P);
      B.diff = S, B.prev = w, B.curr = P, w = P, C[0] = r.coerce(C[0]), typeof C[0] != "string" && C.unshift("%O");
      let m = 0;
      C[0] = C[0].replace(/%([a-zA-Z%])/g, (Z, ce) => {
        if (Z === "%%")
          return "%";
        m++;
        const ae = r.formatters[ce];
        if (typeof ae == "function") {
          const ee = C[m];
          Z = ae.call(B, ee), C.splice(m, 1), m--;
        }
        return Z;
      }), r.formatArgs.call(B, C), (B.log || r.log).apply(B, C);
    }
    return v.namespace = b, v.useColors = r.useColors(), v.color = r.selectColor(b), v.extend = o, v.destroy = r.destroy, Object.defineProperty(v, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => I !== null ? I : (A !== r.namespaces && (A = r.namespaces, x = r.enabled(b)), x),
      set: (C) => {
        I = C;
      }
    }), typeof r.init == "function" && r.init(v), v;
  }
  function o(b, w) {
    const I = r(this.namespace + (typeof w > "u" ? ":" : w) + b);
    return I.log = this.log, I;
  }
  function s(b) {
    r.save(b), r.namespaces = b, r.names = [], r.skips = [];
    const w = (typeof b == "string" ? b : "").trim().replace(" ", ",").split(",").filter(Boolean);
    for (const I of w)
      I[0] === "-" ? r.skips.push(I.slice(1)) : r.names.push(I);
  }
  function u(b, w) {
    let I = 0, A = 0, x = -1, v = 0;
    for (; I < b.length; )
      if (A < w.length && (w[A] === b[I] || w[A] === "*"))
        w[A] === "*" ? (x = A, v = I, A++) : (I++, A++);
      else if (x !== -1)
        A = x + 1, v++, I = v;
      else
        return !1;
    for (; A < w.length && w[A] === "*"; )
      A++;
    return A === w.length;
  }
  function f() {
    const b = [
      ...r.names,
      ...r.skips.map((w) => "-" + w)
    ].join(",");
    return r.enable(""), b;
  }
  function h(b) {
    for (const w of r.skips)
      if (u(b, w))
        return !1;
    for (const w of r.names)
      if (u(b, w))
        return !0;
    return !1;
  }
  function l(b) {
    return b instanceof Error ? b.stack || b.message : b;
  }
  function p() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return r.enable(r.load()), r;
}
var xA = MA;
(function(e, t) {
  t.formatArgs = o, t.save = s, t.load = u, t.useColors = r, t.storage = f(), t.destroy = /* @__PURE__ */ (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function r() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let l;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function o(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
      return;
    const p = "color: " + this.color;
    l.splice(1, 0, p, "color: inherit");
    let b = 0, w = 0;
    l[0].replace(/%[a-zA-Z%]/g, (I) => {
      I !== "%%" && (b++, I === "%c" && (w = b));
    }), l.splice(w, 0, p);
  }
  t.log = console.debug || console.log || (() => {
  });
  function s(l) {
    try {
      l ? t.storage.setItem("debug", l) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function u() {
    let l;
    try {
      l = t.storage.getItem("debug");
    } catch {
    }
    return !l && typeof le.process < "u" && "env" in le.process && (l = le.process.env.DEBUG), l;
  }
  function f() {
    try {
      return localStorage;
    } catch {
    }
  }
  e.exports = xA(t);
  const { formatters: h } = e.exports;
  h.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (p) {
      return "[UnexpectedJSONParseError]: " + p.message;
    }
  };
})(Rc, Rc.exports);
var DA = Rc.exports, sn = {}, Ai = {}, Zc = Ns;
Ns.default = Ns;
Ns.stable = h_;
Ns.stableStringify = h_;
var wu = "[...]", c_ = "[Circular]", Ki = [], Gi = [];
function d_() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function Ns(e, t, r, o) {
  typeof o > "u" && (o = d_()), Ac(e, "", 0, [], void 0, 0, o);
  var s;
  try {
    Gi.length === 0 ? s = JSON.stringify(e, t, r) : s = JSON.stringify(e, g_(t), r);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; Ki.length !== 0; ) {
      var u = Ki.pop();
      u.length === 4 ? Object.defineProperty(u[0], u[1], u[3]) : u[0][u[1]] = u[2];
    }
  }
  return s;
}
function Co(e, t, r, o) {
  var s = Object.getOwnPropertyDescriptor(o, r);
  s.get !== void 0 ? s.configurable ? (Object.defineProperty(o, r, { value: e }), Ki.push([o, r, t, s])) : Gi.push([t, r, e]) : (o[r] = e, Ki.push([o, r, t]));
}
function Ac(e, t, r, o, s, u, f) {
  u += 1;
  var h;
  if (typeof e == "object" && e !== null) {
    for (h = 0; h < o.length; h++)
      if (o[h] === e) {
        Co(c_, e, t, s);
        return;
      }
    if (typeof f.depthLimit < "u" && u > f.depthLimit) {
      Co(wu, e, t, s);
      return;
    }
    if (typeof f.edgesLimit < "u" && r + 1 > f.edgesLimit) {
      Co(wu, e, t, s);
      return;
    }
    if (o.push(e), Array.isArray(e))
      for (h = 0; h < e.length; h++)
        Ac(e[h], h, h, o, e, u, f);
    else {
      var l = Object.keys(e);
      for (h = 0; h < l.length; h++) {
        var p = l[h];
        Ac(e[p], p, h, o, e, u, f);
      }
    }
    o.pop();
  }
}
function jA(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function h_(e, t, r, o) {
  typeof o > "u" && (o = d_());
  var s = Tc(e, "", 0, [], void 0, 0, o) || e, u;
  try {
    Gi.length === 0 ? u = JSON.stringify(s, t, r) : u = JSON.stringify(s, g_(t), r);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; Ki.length !== 0; ) {
      var f = Ki.pop();
      f.length === 4 ? Object.defineProperty(f[0], f[1], f[3]) : f[0][f[1]] = f[2];
    }
  }
  return u;
}
function Tc(e, t, r, o, s, u, f) {
  u += 1;
  var h;
  if (typeof e == "object" && e !== null) {
    for (h = 0; h < o.length; h++)
      if (o[h] === e) {
        Co(c_, e, t, s);
        return;
      }
    try {
      if (typeof e.toJSON == "function")
        return;
    } catch {
      return;
    }
    if (typeof f.depthLimit < "u" && u > f.depthLimit) {
      Co(wu, e, t, s);
      return;
    }
    if (typeof f.edgesLimit < "u" && r + 1 > f.edgesLimit) {
      Co(wu, e, t, s);
      return;
    }
    if (o.push(e), Array.isArray(e))
      for (h = 0; h < e.length; h++)
        Tc(e[h], h, h, o, e, u, f);
    else {
      var l = {}, p = Object.keys(e).sort(jA);
      for (h = 0; h < p.length; h++) {
        var b = p[h];
        Tc(e[b], b, h, o, e, u, f), l[b] = e[b];
      }
      if (typeof s < "u")
        Ki.push([s, t, e]), s[t] = l;
      else
        return l;
    }
    o.pop();
  }
}
function g_(e) {
  return e = typeof e < "u" ? e : function(t, r) {
    return r;
  }, function(t, r) {
    if (Gi.length > 0)
      for (var o = 0; o < Gi.length; o++) {
        var s = Gi[o];
        if (s[1] === t && s[0] === r) {
          r = s[2], Gi.splice(o, 1);
          break;
        }
      }
    return e.call(this, t, r);
  };
}
const UA = /* @__PURE__ */ Oi(Zc);
Object.defineProperty(Ai, "__esModule", { value: !0 });
Ai.EthereumProviderError = Ai.EthereumRpcError = void 0;
const kA = Zc;
class p_ extends Error {
  constructor(t, r, o) {
    if (!Number.isInteger(t))
      throw new Error('"code" must be an integer.');
    if (!r || typeof r != "string")
      throw new Error('"message" must be a nonempty string.');
    super(r), this.code = t, o !== void 0 && (this.data = o);
  }
  /**
   * Returns a plain object with all public class properties.
   */
  serialize() {
    const t = {
      code: this.code,
      message: this.message
    };
    return this.data !== void 0 && (t.data = this.data), this.stack && (t.stack = this.stack), t;
  }
  /**
   * Return a string representation of the serialized error, omitting
   * any circular references.
   */
  toString() {
    return kA.default(this.serialize(), WA, 2);
  }
}
Ai.EthereumRpcError = p_;
let FA = class extends p_ {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(t, r, o) {
    if (!HA(t))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(t, r, o);
  }
};
Ai.EthereumProviderError = FA;
function HA(e) {
  return Number.isInteger(e) && e >= 1e3 && e <= 4999;
}
function WA(e, t) {
  if (t !== "[Circular]")
    return t;
}
var Qc = {}, Ti = {};
Object.defineProperty(Ti, "__esModule", { value: !0 });
Ti.errorValues = Ti.errorCodes = void 0;
Ti.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
Ti.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.serializeError = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const t = Ti, r = Ai, o = t.errorCodes.rpc.internal, s = "Unspecified error message. This is a bug, please report it.", u = {
    code: o,
    message: f(o)
  };
  e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function f(I, A = s) {
    if (Number.isInteger(I)) {
      const x = I.toString();
      if (w(t.errorValues, x))
        return t.errorValues[x].message;
      if (p(I))
        return e.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return A;
  }
  e.getMessageFromCode = f;
  function h(I) {
    if (!Number.isInteger(I))
      return !1;
    const A = I.toString();
    return !!(t.errorValues[A] || p(I));
  }
  e.isValidCode = h;
  function l(I, { fallbackError: A = u, shouldIncludeStack: x = !1 } = {}) {
    var v, C;
    if (!A || !Number.isInteger(A.code) || typeof A.message != "string")
      throw new Error("Must provide fallback error with integer number code and string message.");
    if (I instanceof r.EthereumRpcError)
      return I.serialize();
    const B = {};
    if (I && typeof I == "object" && !Array.isArray(I) && w(I, "code") && h(I.code)) {
      const S = I;
      B.code = S.code, S.message && typeof S.message == "string" ? (B.message = S.message, w(S, "data") && (B.data = S.data)) : (B.message = f(B.code), B.data = { originalError: b(I) });
    } else {
      B.code = A.code;
      const S = (v = I) === null || v === void 0 ? void 0 : v.message;
      B.message = S && typeof S == "string" ? S : A.message, B.data = { originalError: b(I) };
    }
    const P = (C = I) === null || C === void 0 ? void 0 : C.stack;
    return x && I && P && typeof P == "string" && (B.stack = P), B;
  }
  e.serializeError = l;
  function p(I) {
    return I >= -32099 && I <= -32e3;
  }
  function b(I) {
    return I && typeof I == "object" && !Array.isArray(I) ? Object.assign({}, I) : I;
  }
  function w(I, A) {
    return Object.prototype.hasOwnProperty.call(I, A);
  }
})(Qc);
var Bu = {};
Object.defineProperty(Bu, "__esModule", { value: !0 });
Bu.ethErrors = void 0;
const ed = Ai, b_ = Qc, Xt = Ti;
Bu.ethErrors = {
  rpc: {
    /**
     * Get a JSON RPC 2.0 Parse (-32700) error.
     */
    parse: (e) => kr(Xt.errorCodes.rpc.parse, e),
    /**
     * Get a JSON RPC 2.0 Invalid Request (-32600) error.
     */
    invalidRequest: (e) => kr(Xt.errorCodes.rpc.invalidRequest, e),
    /**
     * Get a JSON RPC 2.0 Invalid Params (-32602) error.
     */
    invalidParams: (e) => kr(Xt.errorCodes.rpc.invalidParams, e),
    /**
     * Get a JSON RPC 2.0 Method Not Found (-32601) error.
     */
    methodNotFound: (e) => kr(Xt.errorCodes.rpc.methodNotFound, e),
    /**
     * Get a JSON RPC 2.0 Internal (-32603) error.
     */
    internal: (e) => kr(Xt.errorCodes.rpc.internal, e),
    /**
     * Get a JSON RPC 2.0 Server error.
     * Permits integer error codes in the [ -32099 <= -32005 ] range.
     * Codes -32000 through -32004 are reserved by EIP-1474.
     */
    server: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      const { code: t } = e;
      if (!Number.isInteger(t) || t > -32005 || t < -32099)
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      return kr(t, e);
    },
    /**
     * Get an Ethereum JSON RPC Invalid Input (-32000) error.
     */
    invalidInput: (e) => kr(Xt.errorCodes.rpc.invalidInput, e),
    /**
     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
     */
    resourceNotFound: (e) => kr(Xt.errorCodes.rpc.resourceNotFound, e),
    /**
     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
     */
    resourceUnavailable: (e) => kr(Xt.errorCodes.rpc.resourceUnavailable, e),
    /**
     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
     */
    transactionRejected: (e) => kr(Xt.errorCodes.rpc.transactionRejected, e),
    /**
     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
     */
    methodNotSupported: (e) => kr(Xt.errorCodes.rpc.methodNotSupported, e),
    /**
     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
     */
    limitExceeded: (e) => kr(Xt.errorCodes.rpc.limitExceeded, e)
  },
  provider: {
    /**
     * Get an Ethereum Provider User Rejected Request (4001) error.
     */
    userRejectedRequest: (e) => _s(Xt.errorCodes.provider.userRejectedRequest, e),
    /**
     * Get an Ethereum Provider Unauthorized (4100) error.
     */
    unauthorized: (e) => _s(Xt.errorCodes.provider.unauthorized, e),
    /**
     * Get an Ethereum Provider Unsupported Method (4200) error.
     */
    unsupportedMethod: (e) => _s(Xt.errorCodes.provider.unsupportedMethod, e),
    /**
     * Get an Ethereum Provider Not Connected (4900) error.
     */
    disconnected: (e) => _s(Xt.errorCodes.provider.disconnected, e),
    /**
     * Get an Ethereum Provider Chain Not Connected (4901) error.
     */
    chainDisconnected: (e) => _s(Xt.errorCodes.provider.chainDisconnected, e),
    /**
     * Get a custom Ethereum Provider error.
     */
    custom: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      const { code: t, message: r, data: o } = e;
      if (!r || typeof r != "string")
        throw new Error('"message" must be a nonempty string');
      return new ed.EthereumProviderError(t, r, o);
    }
  }
};
function kr(e, t) {
  const [r, o] = __(t);
  return new ed.EthereumRpcError(e, r || b_.getMessageFromCode(e), o);
}
function _s(e, t) {
  const [r, o] = __(t);
  return new ed.EthereumProviderError(e, r || b_.getMessageFromCode(e), o);
}
function __(e) {
  if (e) {
    if (typeof e == "string")
      return [e];
    if (typeof e == "object" && !Array.isArray(e)) {
      const { message: t, data: r } = e;
      if (t && typeof t != "string")
        throw new Error("Must specify string message.");
      return [t || void 0, r];
    }
  }
  return [];
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getMessageFromCode = e.serializeError = e.EthereumProviderError = e.EthereumRpcError = e.ethErrors = e.errorCodes = void 0;
  const t = Ai;
  Object.defineProperty(e, "EthereumRpcError", { enumerable: !0, get: function() {
    return t.EthereumRpcError;
  } }), Object.defineProperty(e, "EthereumProviderError", { enumerable: !0, get: function() {
    return t.EthereumProviderError;
  } });
  const r = Qc;
  Object.defineProperty(e, "serializeError", { enumerable: !0, get: function() {
    return r.serializeError;
  } }), Object.defineProperty(e, "getMessageFromCode", { enumerable: !0, get: function() {
    return r.getMessageFromCode;
  } });
  const o = Bu;
  Object.defineProperty(e, "ethErrors", { enumerable: !0, get: function() {
    return o.ethErrors;
  } });
  const s = Ti;
  Object.defineProperty(e, "errorCodes", { enumerable: !0, get: function() {
    return s.errorCodes;
  } });
})(sn);
function Ne(e, t, r) {
  return (t = Z1(t)) in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
var qA = { exports: {} }, Ul = { exports: {} };
let VA = class extends Error {
  constructor(t) {
    if (!Array.isArray(t))
      throw new TypeError(`Expected input to be an Array, got ${typeof t}`);
    let r = "";
    for (let o = 0; o < t.length; o++)
      r += `    ${t[o].stack}
`;
    super(r), this.name = "AggregateError", this.errors = t;
  }
};
var St = {
  AggregateError: VA,
  ArrayIsArray(e) {
    return Array.isArray(e);
  },
  ArrayPrototypeIncludes(e, t) {
    return e.includes(t);
  },
  ArrayPrototypeIndexOf(e, t) {
    return e.indexOf(t);
  },
  ArrayPrototypeJoin(e, t) {
    return e.join(t);
  },
  ArrayPrototypeMap(e, t) {
    return e.map(t);
  },
  ArrayPrototypePop(e, t) {
    return e.pop(t);
  },
  ArrayPrototypePush(e, t) {
    return e.push(t);
  },
  ArrayPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  Error,
  FunctionPrototypeCall(e, t, ...r) {
    return e.call(t, ...r);
  },
  FunctionPrototypeSymbolHasInstance(e, t) {
    return Function.prototype[Symbol.hasInstance].call(e, t);
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(e, t) {
    return Object.defineProperties(e, t);
  },
  ObjectDefineProperty(e, t, r) {
    return Object.defineProperty(e, t, r);
  },
  ObjectGetOwnPropertyDescriptor(e, t) {
    return Object.getOwnPropertyDescriptor(e, t);
  },
  ObjectKeys(e) {
    return Object.keys(e);
  },
  ObjectSetPrototypeOf(e, t) {
    return Object.setPrototypeOf(e, t);
  },
  Promise,
  PromisePrototypeCatch(e, t) {
    return e.catch(t);
  },
  PromisePrototypeThen(e, t, r) {
    return e.then(t, r);
  },
  PromiseReject(e) {
    return Promise.reject(e);
  },
  PromiseResolve(e) {
    return Promise.resolve(e);
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(e, t) {
    return e.test(t);
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  StringPrototypeToLowerCase(e) {
    return e.toLowerCase();
  },
  StringPrototypeToUpperCase(e) {
    return e.toUpperCase();
  },
  StringPrototypeTrim(e) {
    return e.trim();
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
  SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
  TypedArrayPrototypeSet(e, t, r) {
    return e.set(t, r);
  },
  Boolean,
  Uint8Array
}, y_ = { exports: {} }, w_ = {
  format(e, ...t) {
    return e.replace(/%([sdifj])/g, function(...[r, o]) {
      const s = t.shift();
      return o === "f" ? s.toFixed(6) : o === "j" ? JSON.stringify(s) : o === "s" && typeof s == "object" ? `${s.constructor !== Object ? s.constructor.name : ""} {}`.trim() : s.toString();
    });
  },
  inspect(e) {
    switch (typeof e) {
      case "string":
        if (e.includes("'"))
          if (e.includes('"')) {
            if (!e.includes("`") && !e.includes("${"))
              return `\`${e}\``;
          } else return `"${e}"`;
        return `'${e}'`;
      case "number":
        return isNaN(e) ? "NaN" : Object.is(e, -0) ? String(e) : e;
      case "bigint":
        return `${String(e)}n`;
      case "boolean":
      case "undefined":
        return String(e);
      case "object":
        return "{}";
    }
  }
};
const { format: GA, inspect: mu } = w_, { AggregateError: zA } = St, KA = globalThis.AggregateError || zA, JA = Symbol("kIsNodeError"), YA = [
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
], XA = /^([A-Z][a-z0-9]*)+$/, ZA = "__node_internal_", Nu = {};
function zi(e, t) {
  if (!e)
    throw new Nu.ERR_INTERNAL_ASSERTION(t);
}
function up(e) {
  let t = "", r = e.length;
  const o = e[0] === "-" ? 1 : 0;
  for (; r >= o + 4; r -= 3)
    t = `_${e.slice(r - 3, r)}${t}`;
  return `${e.slice(0, r)}${t}`;
}
function QA(e, t, r) {
  if (typeof t == "function")
    return zi(
      t.length <= r.length,
      // Default options do not count.
      `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`
    ), t(...r);
  const o = (t.match(/%[dfijoOs]/g) || []).length;
  return zi(
    o === r.length,
    `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${o}).`
  ), r.length === 0 ? t : GA(t, ...r);
}
function Vt(e, t, r) {
  r || (r = Error);
  class o extends r {
    constructor(...u) {
      super(QA(e, t, u));
    }
    toString() {
      return `${this.name} [${e}]: ${this.message}`;
    }
  }
  Object.defineProperties(o.prototype, {
    name: {
      value: r.name,
      writable: !0,
      enumerable: !1,
      configurable: !0
    },
    toString: {
      value() {
        return `${this.name} [${e}]: ${this.message}`;
      },
      writable: !0,
      enumerable: !1,
      configurable: !0
    }
  }), o.prototype.code = e, o.prototype[JA] = !0, Nu[e] = o;
}
function fp(e) {
  const t = ZA + e.name;
  return Object.defineProperty(e, "name", {
    value: t
  }), e;
}
function eT(e, t) {
  if (e && t && e !== t) {
    if (Array.isArray(t.errors))
      return t.errors.push(e), t;
    const r = new KA([t, e], t.message);
    return r.code = t.code, r;
  }
  return e || t;
}
let tT = class extends Error {
  constructor(t = "The operation was aborted", r = void 0) {
    if (r !== void 0 && typeof r != "object")
      throw new Nu.ERR_INVALID_ARG_TYPE("options", "Object", r);
    super(t, r), this.code = "ABORT_ERR", this.name = "AbortError";
  }
};
Vt("ERR_ASSERTION", "%s", Error);
Vt(
  "ERR_INVALID_ARG_TYPE",
  (e, t, r) => {
    zi(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let o = "The ";
    e.endsWith(" argument") ? o += `${e} ` : o += `"${e}" ${e.includes(".") ? "property" : "argument"} `, o += "must be ";
    const s = [], u = [], f = [];
    for (const l of t)
      zi(typeof l == "string", "All expected entries have to be of type string"), YA.includes(l) ? s.push(l.toLowerCase()) : XA.test(l) ? u.push(l) : (zi(l !== "object", 'The value "object" should be written as "Object"'), f.push(l));
    if (u.length > 0) {
      const l = s.indexOf("object");
      l !== -1 && (s.splice(s, l, 1), u.push("Object"));
    }
    if (s.length > 0) {
      switch (s.length) {
        case 1:
          o += `of type ${s[0]}`;
          break;
        case 2:
          o += `one of type ${s[0]} or ${s[1]}`;
          break;
        default: {
          const l = s.pop();
          o += `one of type ${s.join(", ")}, or ${l}`;
        }
      }
      (u.length > 0 || f.length > 0) && (o += " or ");
    }
    if (u.length > 0) {
      switch (u.length) {
        case 1:
          o += `an instance of ${u[0]}`;
          break;
        case 2:
          o += `an instance of ${u[0]} or ${u[1]}`;
          break;
        default: {
          const l = u.pop();
          o += `an instance of ${u.join(", ")}, or ${l}`;
        }
      }
      f.length > 0 && (o += " or ");
    }
    switch (f.length) {
      case 0:
        break;
      case 1:
        f[0].toLowerCase() !== f[0] && (o += "an "), o += `${f[0]}`;
        break;
      case 2:
        o += `one of ${f[0]} or ${f[1]}`;
        break;
      default: {
        const l = f.pop();
        o += `one of ${f.join(", ")}, or ${l}`;
      }
    }
    if (r == null)
      o += `. Received ${r}`;
    else if (typeof r == "function" && r.name)
      o += `. Received function ${r.name}`;
    else if (typeof r == "object") {
      var h;
      if ((h = r.constructor) !== null && h !== void 0 && h.name)
        o += `. Received an instance of ${r.constructor.name}`;
      else {
        const l = mu(r, {
          depth: -1
        });
        o += `. Received ${l}`;
      }
    } else {
      let l = mu(r, {
        colors: !1
      });
      l.length > 25 && (l = `${l.slice(0, 25)}...`), o += `. Received type ${typeof r} (${l})`;
    }
    return o;
  },
  TypeError
);
Vt(
  "ERR_INVALID_ARG_VALUE",
  (e, t, r = "is invalid") => {
    let o = mu(t);
    return o.length > 128 && (o = o.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${o}`;
  },
  TypeError
);
Vt(
  "ERR_INVALID_RETURN_VALUE",
  (e, t, r) => {
    var o;
    const s = r != null && (o = r.constructor) !== null && o !== void 0 && o.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
    return `Expected ${e} to be returned from the "${t}" function but got ${s}.`;
  },
  TypeError
);
Vt(
  "ERR_MISSING_ARGS",
  (...e) => {
    zi(e.length > 0, "At least one arg needs to be specified");
    let t;
    const r = e.length;
    switch (e = (Array.isArray(e) ? e : [e]).map((o) => `"${o}"`).join(" or "), r) {
      case 1:
        t += `The ${e[0]} argument`;
        break;
      case 2:
        t += `The ${e[0]} and ${e[1]} arguments`;
        break;
      default:
        {
          const o = e.pop();
          t += `The ${e.join(", ")}, and ${o} arguments`;
        }
        break;
    }
    return `${t} must be specified`;
  },
  TypeError
);
Vt(
  "ERR_OUT_OF_RANGE",
  (e, t, r) => {
    zi(t, 'Missing "range" argument');
    let o;
    if (Number.isInteger(r) && Math.abs(r) > 2 ** 32)
      o = up(String(r));
    else if (typeof r == "bigint") {
      o = String(r);
      const s = BigInt(2) ** BigInt(32);
      (r > s || r < -s) && (o = up(o)), o += "n";
    } else
      o = mu(r);
    return `The value of "${e}" is out of range. It must be ${t}. Received ${o}`;
  },
  RangeError
);
Vt("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
Vt("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
Vt("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
Vt("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
Vt("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
Vt("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Vt("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
Vt("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
Vt("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
Vt("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
Vt("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
var fr = {
  AbortError: tT,
  aggregateTwoErrors: fp(eT),
  hideStackFrames: fp,
  codes: Nu
}, ys = { exports: {} }, lp;
function $s() {
  if (lp) return ys.exports;
  lp = 1;
  const { AbortController: e, AbortSignal: t } = typeof self < "u" ? self : typeof window < "u" ? window : (
    /* otherwise */
    void 0
  );
  return ys.exports = e, ys.exports.AbortSignal = t, ys.exports.default = e, ys.exports;
}
(function(e) {
  const t = _r, { format: r, inspect: o } = w_, {
    codes: { ERR_INVALID_ARG_TYPE: s }
  } = fr, { kResistStopPropagation: u, AggregateError: f, SymbolDispose: h } = St, l = globalThis.AbortSignal || $s().AbortSignal, p = globalThis.AbortController || $s().AbortController, b = Object.getPrototypeOf(async function() {
  }).constructor, w = globalThis.Blob || t.Blob, I = typeof w < "u" ? function(C) {
    return C instanceof w;
  } : function(C) {
    return !1;
  }, A = (v, C) => {
    if (v !== void 0 && (v === null || typeof v != "object" || !("aborted" in v)))
      throw new s(C, "AbortSignal", v);
  }, x = (v, C) => {
    if (typeof v != "function")
      throw new s(C, "Function", v);
  };
  e.exports = {
    AggregateError: f,
    kEmptyObject: Object.freeze({}),
    once(v) {
      let C = !1;
      return function(...B) {
        C || (C = !0, v.apply(this, B));
      };
    },
    createDeferredPromise: function() {
      let v, C;
      return {
        promise: new Promise((P, S) => {
          v = P, C = S;
        }),
        resolve: v,
        reject: C
      };
    },
    promisify(v) {
      return new Promise((C, B) => {
        v((P, ...S) => P ? B(P) : C(...S));
      });
    },
    debuglog() {
      return function() {
      };
    },
    format: r,
    inspect: o,
    types: {
      isAsyncFunction(v) {
        return v instanceof b;
      },
      isArrayBufferView(v) {
        return ArrayBuffer.isView(v);
      }
    },
    isBlob: I,
    deprecate(v, C) {
      return v;
    },
    addAbortListener: Pn.addAbortListener || function(C, B) {
      if (C === void 0)
        throw new s("signal", "AbortSignal", C);
      A(C, "signal"), x(B, "listener");
      let P;
      return C.aborted ? queueMicrotask(() => B()) : (C.addEventListener("abort", B, {
        __proto__: null,
        once: !0,
        [u]: !0
      }), P = () => {
        C.removeEventListener("abort", B);
      }), {
        __proto__: null,
        [h]() {
          var S;
          (S = P) === null || S === void 0 || S();
        }
      };
    },
    AbortSignalAny: l.any || function(C) {
      if (C.length === 1)
        return C[0];
      const B = new p(), P = () => B.abort();
      return C.forEach((S) => {
        A(S, "signals"), S.addEventListener("abort", P, {
          once: !0
        });
      }), B.signal.addEventListener(
        "abort",
        () => {
          C.forEach((S) => S.removeEventListener("abort", P));
        },
        {
          once: !0
        }
      ), B.signal;
    }
  }, e.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
})(y_);
var yr = y_.exports, td = {};
const {
  ArrayIsArray: m_,
  ArrayPrototypeIncludes: rT,
  ArrayPrototypeJoin: nT,
  ArrayPrototypeMap: iT,
  NumberIsInteger: rd,
  NumberIsNaN: qN,
  NumberMAX_SAFE_INTEGER: oT,
  NumberMIN_SAFE_INTEGER: sT,
  NumberParseInt: VN,
  ObjectPrototypeHasOwnProperty: aT,
  RegExpPrototypeExec: GN,
  String: uT,
  StringPrototypeToUpperCase: zN,
  StringPrototypeTrim: KN
} = St, {
  hideStackFrames: Gr,
  codes: { ERR_SOCKET_BAD_PORT: JN, ERR_INVALID_ARG_TYPE: zr, ERR_INVALID_ARG_VALUE: E_, ERR_OUT_OF_RANGE: $o, ERR_UNKNOWN_SIGNAL: YN }
} = fr, { normalizeEncoding: XN } = yr, { isAsyncFunction: fT, isArrayBufferView: lT } = yr.types, cT = Gr((e, t, r = sT, o = oT) => {
  if (typeof e != "number") throw new zr(t, "number", e);
  if (!rd(e)) throw new $o(t, "an integer", e);
  if (e < r || e > o) throw new $o(t, `>= ${r} && <= ${o}`, e);
});
Gr((e, t, r = -2147483648, o = 2147483647) => {
  if (typeof e != "number")
    throw new zr(t, "number", e);
  if (!rd(e))
    throw new $o(t, "an integer", e);
  if (e < r || e > o)
    throw new $o(t, `>= ${r} && <= ${o}`, e);
});
Gr((e, t, r = !1) => {
  if (typeof e != "number")
    throw new zr(t, "number", e);
  if (!rd(e))
    throw new $o(t, "an integer", e);
  const o = r ? 1 : 0, s = 4294967295;
  if (e < o || e > s)
    throw new $o(t, `>= ${o} && <= ${s}`, e);
});
Gr((e, t, r) => {
  if (!rT(r, e)) {
    const s = "must be one of: " + nT(
      iT(r, (u) => typeof u == "string" ? `'${u}'` : uT(u)),
      ", "
    );
    throw new E_(t, e, s);
  }
});
function dT(e, t) {
  if (typeof e != "boolean") throw new zr(t, "boolean", e);
}
function kl(e, t, r) {
  return e == null || !aT(e, t) ? r : e[t];
}
const hT = Gr((e, t, r = null) => {
  const o = kl(r, "allowArray", !1), s = kl(r, "allowFunction", !1);
  if (!kl(r, "nullable", !1) && e === null || !o && m_(e) || typeof e != "object" && (!s || typeof e != "function"))
    throw new zr(t, "Object", e);
});
Gr((e, t) => {
  if (e != null && typeof e != "object" && typeof e != "function")
    throw new zr(t, "a dictionary", e);
});
Gr((e, t, r = 0) => {
  if (!m_(e))
    throw new zr(t, "Array", e);
  if (e.length < r) {
    const o = `must be longer than ${r}`;
    throw new E_(t, e, o);
  }
});
Gr((e, t = "buffer") => {
  if (!lT(e))
    throw new zr(t, ["Buffer", "TypedArray", "DataView"], e);
});
const gT = Gr((e, t) => {
  if (e !== void 0 && (e === null || typeof e != "object" || !("aborted" in e)))
    throw new zr(t, "AbortSignal", e);
}), pT = Gr((e, t) => {
  if (typeof e != "function") throw new zr(t, "Function", e);
});
Gr((e, t) => {
  if (typeof e != "function" || fT(e)) throw new zr(t, "Function", e);
});
Gr((e, t) => {
  if (e !== void 0) throw new zr(t, "undefined", e);
});
var Hs = {
  validateBoolean: dT,
  validateFunction: pT,
  validateInteger: cT,
  validateObject: hT,
  validateAbortSignal: gT
}, nd = { exports: {} };
const { SymbolAsyncIterator: cp, SymbolIterator: dp, SymbolFor: Qi } = St, v_ = Qi("nodejs.stream.destroyed"), bT = Qi("nodejs.stream.errored"), hp = Qi("nodejs.stream.readable"), gp = Qi("nodejs.stream.writable"), _T = Qi("nodejs.stream.disturbed"), yT = Qi("nodejs.webstream.isClosedPromise"), wT = Qi("nodejs.webstream.controllerErrorFunction");
function id(e, t = !1) {
  var r;
  return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r = e._readableState) === null || r === void 0 ? void 0 : r.readable) !== !1) && // Duplex
  (!e._writableState || e._readableState));
}
function $u(e) {
  var t;
  return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
}
function mT(e) {
  return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
}
function Nn(e) {
  return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
}
function S_(e) {
  return !!(e && !Nn(e) && typeof e.pipeThrough == "function" && typeof e.getReader == "function" && typeof e.cancel == "function");
}
function R_(e) {
  return !!(e && !Nn(e) && typeof e.getWriter == "function" && typeof e.abort == "function");
}
function A_(e) {
  return !!(e && !Nn(e) && typeof e.readable == "object" && typeof e.writable == "object");
}
function ET(e) {
  return S_(e) || R_(e) || A_(e);
}
function vT(e, t) {
  return e == null ? !1 : t === !0 ? typeof e[cp] == "function" : t === !1 ? typeof e[dp] == "function" : typeof e[cp] == "function" || typeof e[dp] == "function";
}
function Mu(e) {
  if (!Nn(e)) return null;
  const t = e._writableState, r = e._readableState, o = t || r;
  return !!(e.destroyed || e[v_] || o != null && o.destroyed);
}
function ST(e) {
  if (!$u(e)) return null;
  if (e.writableEnded === !0) return !0;
  const t = e._writableState;
  return t != null && t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function RT(e, t) {
  if (!$u(e)) return null;
  if (e.writableFinished === !0) return !0;
  const r = e._writableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.finished) != "boolean" ? null : !!(r.finished || t === !1 && r.ended === !0 && r.length === 0);
}
function T_(e, t) {
  if (!id(e)) return null;
  const r = e._readableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.endEmitted) != "boolean" ? null : !!(r.endEmitted || t === !1 && r.ended === !0 && r.length === 0);
}
function I_(e) {
  return e && e[hp] != null ? e[hp] : typeof (e == null ? void 0 : e.readable) != "boolean" ? null : Mu(e) ? !1 : id(e) && e.readable && !T_(e);
}
function O_(e) {
  return e && e[gp] != null ? e[gp] : typeof (e == null ? void 0 : e.writable) != "boolean" ? null : Mu(e) ? !1 : $u(e) && e.writable && !ST(e);
}
function AT(e, t) {
  return Nn(e) ? Mu(e) ? !0 : !((t == null ? void 0 : t.readable) !== !1 && I_(e) || (t == null ? void 0 : t.writable) !== !1 && O_(e)) : null;
}
function TT(e) {
  var t, r;
  return Nn(e) ? e.writableErrored ? e.writableErrored : (t = (r = e._writableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function IT(e) {
  var t, r;
  return Nn(e) ? e.readableErrored ? e.readableErrored : (t = (r = e._readableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function OT(e) {
  if (!Nn(e))
    return null;
  if (typeof e.closed == "boolean")
    return e.closed;
  const t = e._writableState, r = e._readableState;
  return typeof (t == null ? void 0 : t.closed) == "boolean" || typeof (r == null ? void 0 : r.closed) == "boolean" ? (t == null ? void 0 : t.closed) || (r == null ? void 0 : r.closed) : typeof e._closed == "boolean" && C_(e) ? e._closed : null;
}
function C_(e) {
  return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
}
function CT(e) {
  return typeof e._sent100 == "boolean" && C_(e);
}
function LT(e) {
  var t;
  return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
}
function PT(e) {
  if (!Nn(e)) return null;
  const t = e._writableState, r = e._readableState, o = t || r;
  return !o && CT(e) || !!(o && o.autoDestroy && o.emitClose && o.closed === !1);
}
function BT(e) {
  var t;
  return !!(e && ((t = e[_T]) !== null && t !== void 0 ? t : e.readableDidRead || e.readableAborted));
}
function NT(e) {
  var t, r, o, s, u, f, h, l, p, b;
  return !!(e && ((t = (r = (o = (s = (u = (f = e[bT]) !== null && f !== void 0 ? f : e.readableErrored) !== null && u !== void 0 ? u : e.writableErrored) !== null && s !== void 0 ? s : (h = e._readableState) === null || h === void 0 ? void 0 : h.errorEmitted) !== null && o !== void 0 ? o : (l = e._writableState) === null || l === void 0 ? void 0 : l.errorEmitted) !== null && r !== void 0 ? r : (p = e._readableState) === null || p === void 0 ? void 0 : p.errored) !== null && t !== void 0 ? t : !((b = e._writableState) === null || b === void 0) && b.errored));
}
var ii = {
  isDestroyed: Mu,
  kIsDestroyed: v_,
  isDisturbed: BT,
  isErrored: NT,
  isReadable: I_,
  kIsClosedPromise: yT,
  kControllerErrorFunction: wT,
  isClosed: OT,
  isDuplexNodeStream: mT,
  isFinished: AT,
  isIterable: vT,
  isReadableNodeStream: id,
  isReadableStream: S_,
  isReadableFinished: T_,
  isReadableErrored: IT,
  isNodeStream: Nn,
  isWebStream: ET,
  isWritable: O_,
  isWritableNodeStream: $u,
  isWritableStream: R_,
  isWritableFinished: RT,
  isWritableErrored: TT,
  isServerRequest: LT,
  willEmitClose: PT,
  isTransformStream: A_
};
const Ei = Xi, { AbortError: L_, codes: $T } = fr, { ERR_INVALID_ARG_TYPE: MT, ERR_STREAM_PREMATURE_CLOSE: pp } = $T, { kEmptyObject: Ic, once: Oc } = yr, { validateAbortSignal: xT, validateFunction: DT, validateObject: jT, validateBoolean: UT } = Hs, { Promise: kT, PromisePrototypeThen: FT, SymbolDispose: P_ } = St, {
  isClosed: HT,
  isReadable: bp,
  isReadableNodeStream: Fl,
  isReadableStream: WT,
  isReadableFinished: _p,
  isReadableErrored: yp,
  isWritable: wp,
  isWritableNodeStream: mp,
  isWritableStream: qT,
  isWritableFinished: Ep,
  isWritableErrored: vp,
  isNodeStream: VT,
  willEmitClose: GT,
  kIsClosedPromise: zT
} = ii;
let Lo;
function KT(e) {
  return e.setHeader && typeof e.abort == "function";
}
const Cc = () => {
};
function B_(e, t, r) {
  var o, s;
  if (arguments.length === 2 ? (r = t, t = Ic) : t == null ? t = Ic : jT(t, "options"), DT(r, "callback"), xT(t.signal, "options.signal"), r = Oc(r), WT(e) || qT(e))
    return JT(e, t, r);
  if (!VT(e))
    throw new MT("stream", ["ReadableStream", "WritableStream", "Stream"], e);
  const u = (o = t.readable) !== null && o !== void 0 ? o : Fl(e), f = (s = t.writable) !== null && s !== void 0 ? s : mp(e), h = e._writableState, l = e._readableState, p = () => {
    e.writable || I();
  };
  let b = GT(e) && Fl(e) === u && mp(e) === f, w = Ep(e, !1);
  const I = () => {
    w = !0, e.destroyed && (b = !1), !(b && (!e.readable || u)) && (!u || A) && r.call(e);
  };
  let A = _p(e, !1);
  const x = () => {
    A = !0, e.destroyed && (b = !1), !(b && (!e.writable || f)) && (!f || w) && r.call(e);
  }, v = (j) => {
    r.call(e, j);
  };
  let C = HT(e);
  const B = () => {
    C = !0;
    const j = vp(e) || yp(e);
    if (j && typeof j != "boolean")
      return r.call(e, j);
    if (u && !A && Fl(e, !0) && !_p(e, !1))
      return r.call(e, new pp());
    if (f && !w && !Ep(e, !1))
      return r.call(e, new pp());
    r.call(e);
  }, P = () => {
    C = !0;
    const j = vp(e) || yp(e);
    if (j && typeof j != "boolean")
      return r.call(e, j);
    r.call(e);
  }, S = () => {
    e.req.on("finish", I);
  };
  KT(e) ? (e.on("complete", I), b || e.on("abort", B), e.req ? S() : e.on("request", S)) : f && !h && (e.on("end", p), e.on("close", p)), !b && typeof e.aborted == "boolean" && e.on("aborted", B), e.on("end", x), e.on("finish", I), t.error !== !1 && e.on("error", v), e.on("close", B), C ? Ei.nextTick(B) : h != null && h.errorEmitted || l != null && l.errorEmitted ? b || Ei.nextTick(P) : (!u && (!b || bp(e)) && (w || wp(e) === !1) || !f && (!b || wp(e)) && (A || bp(e) === !1) || l && e.req && e.aborted) && Ei.nextTick(P);
  const m = () => {
    r = Cc, e.removeListener("aborted", B), e.removeListener("complete", I), e.removeListener("abort", B), e.removeListener("request", S), e.req && e.req.removeListener("finish", I), e.removeListener("end", p), e.removeListener("close", p), e.removeListener("finish", I), e.removeListener("end", x), e.removeListener("error", v), e.removeListener("close", B);
  };
  if (t.signal && !C) {
    const j = () => {
      const Z = r;
      m(), Z.call(
        e,
        new L_(void 0, {
          cause: t.signal.reason
        })
      );
    };
    if (t.signal.aborted)
      Ei.nextTick(j);
    else {
      Lo = Lo || yr.addAbortListener;
      const Z = Lo(t.signal, j), ce = r;
      r = Oc((...ae) => {
        Z[P_](), ce.apply(e, ae);
      });
    }
  }
  return m;
}
function JT(e, t, r) {
  let o = !1, s = Cc;
  if (t.signal)
    if (s = () => {
      o = !0, r.call(
        e,
        new L_(void 0, {
          cause: t.signal.reason
        })
      );
    }, t.signal.aborted)
      Ei.nextTick(s);
    else {
      Lo = Lo || yr.addAbortListener;
      const f = Lo(t.signal, s), h = r;
      r = Oc((...l) => {
        f[P_](), h.apply(e, l);
      });
    }
  const u = (...f) => {
    o || Ei.nextTick(() => r.apply(e, f));
  };
  return FT(e[zT].promise, u, u), Cc;
}
function YT(e, t) {
  var r;
  let o = !1;
  return t === null && (t = Ic), (r = t) !== null && r !== void 0 && r.cleanup && (UT(t.cleanup, "cleanup"), o = t.cleanup), new kT((s, u) => {
    const f = B_(e, t, (h) => {
      o && f(), h ? u(h) : s();
    });
  });
}
nd.exports = B_;
nd.exports.finished = YT;
var Ci = nd.exports;
const On = Xi, {
  aggregateTwoErrors: XT,
  codes: { ERR_MULTIPLE_CALLBACK: ZT },
  AbortError: QT
} = fr, { Symbol: N_ } = St, { kIsDestroyed: eI, isDestroyed: tI, isFinished: rI, isServerRequest: nI } = ii, $_ = N_("kDestroy"), Lc = N_("kConstruct");
function M_(e, t, r) {
  e && (e.stack, t && !t.errored && (t.errored = e), r && !r.errored && (r.errored = e));
}
function iI(e, t) {
  const r = this._readableState, o = this._writableState, s = o || r;
  return o != null && o.destroyed || r != null && r.destroyed ? (typeof t == "function" && t(), this) : (M_(e, o, r), o && (o.destroyed = !0), r && (r.destroyed = !0), s.constructed ? Sp(this, e, t) : this.once($_, function(u) {
    Sp(this, XT(u, e), t);
  }), this);
}
function Sp(e, t, r) {
  let o = !1;
  function s(u) {
    if (o)
      return;
    o = !0;
    const f = e._readableState, h = e._writableState;
    M_(u, h, f), h && (h.closed = !0), f && (f.closed = !0), typeof r == "function" && r(u), u ? On.nextTick(oI, e, u) : On.nextTick(x_, e);
  }
  try {
    e._destroy(t || null, s);
  } catch (u) {
    s(u);
  }
}
function oI(e, t) {
  Pc(e, t), x_(e);
}
function x_(e) {
  const t = e._readableState, r = e._writableState;
  r && (r.closeEmitted = !0), t && (t.closeEmitted = !0), (r != null && r.emitClose || t != null && t.emitClose) && e.emit("close");
}
function Pc(e, t) {
  const r = e._readableState, o = e._writableState;
  o != null && o.errorEmitted || r != null && r.errorEmitted || (o && (o.errorEmitted = !0), r && (r.errorEmitted = !0), e.emit("error", t));
}
function sI() {
  const e = this._readableState, t = this._writableState;
  e && (e.constructed = !0, e.closed = !1, e.closeEmitted = !1, e.destroyed = !1, e.errored = null, e.errorEmitted = !1, e.reading = !1, e.ended = e.readable === !1, e.endEmitted = e.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
}
function Bc(e, t, r) {
  const o = e._readableState, s = e._writableState;
  if (s != null && s.destroyed || o != null && o.destroyed)
    return this;
  o != null && o.autoDestroy || s != null && s.autoDestroy ? e.destroy(t) : t && (t.stack, s && !s.errored && (s.errored = t), o && !o.errored && (o.errored = t), r ? On.nextTick(Pc, e, t) : Pc(e, t));
}
function aI(e, t) {
  if (typeof e._construct != "function")
    return;
  const r = e._readableState, o = e._writableState;
  r && (r.constructed = !1), o && (o.constructed = !1), e.once(Lc, t), !(e.listenerCount(Lc) > 1) && On.nextTick(uI, e);
}
function uI(e) {
  let t = !1;
  function r(o) {
    if (t) {
      Bc(e, o ?? new ZT());
      return;
    }
    t = !0;
    const s = e._readableState, u = e._writableState, f = u || s;
    s && (s.constructed = !0), u && (u.constructed = !0), f.destroyed ? e.emit($_, o) : o ? Bc(e, o, !0) : On.nextTick(fI, e);
  }
  try {
    e._construct((o) => {
      On.nextTick(r, o);
    });
  } catch (o) {
    On.nextTick(r, o);
  }
}
function fI(e) {
  e.emit(Lc);
}
function Rp(e) {
  return (e == null ? void 0 : e.setHeader) && typeof e.abort == "function";
}
function D_(e) {
  e.emit("close");
}
function lI(e, t) {
  e.emit("error", t), On.nextTick(D_, e);
}
function cI(e, t) {
  !e || tI(e) || (!t && !rI(e) && (t = new QT()), nI(e) ? (e.socket = null, e.destroy(t)) : Rp(e) ? e.abort() : Rp(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? On.nextTick(lI, e, t) : On.nextTick(D_, e), e.destroyed || (e[eI] = !0));
}
var Ho = {
  construct: aI,
  destroyer: cI,
  destroy: iI,
  undestroy: sI,
  errorOrDestroy: Bc
};
const { ArrayIsArray: dI, ObjectSetPrototypeOf: j_ } = St, { EventEmitter: xu } = Pn;
function Du(e) {
  xu.call(this, e);
}
j_(Du.prototype, xu.prototype);
j_(Du, xu);
Du.prototype.pipe = function(e, t) {
  const r = this;
  function o(b) {
    e.writable && e.write(b) === !1 && r.pause && r.pause();
  }
  r.on("data", o);
  function s() {
    r.readable && r.resume && r.resume();
  }
  e.on("drain", s), !e._isStdio && (!t || t.end !== !1) && (r.on("end", f), r.on("close", h));
  let u = !1;
  function f() {
    u || (u = !0, e.end());
  }
  function h() {
    u || (u = !0, typeof e.destroy == "function" && e.destroy());
  }
  function l(b) {
    p(), xu.listenerCount(this, "error") === 0 && this.emit("error", b);
  }
  Nc(r, "error", l), Nc(e, "error", l);
  function p() {
    r.removeListener("data", o), e.removeListener("drain", s), r.removeListener("end", f), r.removeListener("close", h), r.removeListener("error", l), e.removeListener("error", l), r.removeListener("end", p), r.removeListener("close", p), e.removeListener("close", p);
  }
  return r.on("end", p), r.on("close", p), e.on("close", p), e.emit("pipe", r), e;
};
function Nc(e, t, r) {
  if (typeof e.prependListener == "function") return e.prependListener(t, r);
  !e._events || !e._events[t] ? e.on(t, r) : dI(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
}
var od = {
  Stream: Du,
  prependListener: Nc
}, U_ = { exports: {} };
(function(e) {
  const { SymbolDispose: t } = St, { AbortError: r, codes: o } = fr, { isNodeStream: s, isWebStream: u, kControllerErrorFunction: f } = ii, h = Ci, { ERR_INVALID_ARG_TYPE: l } = o;
  let p;
  const b = (w, I) => {
    if (typeof w != "object" || !("aborted" in w))
      throw new l(I, "AbortSignal", w);
  };
  e.exports.addAbortSignal = function(I, A) {
    if (b(I, "signal"), !s(A) && !u(A))
      throw new l("stream", ["ReadableStream", "WritableStream", "Stream"], A);
    return e.exports.addAbortSignalNoValidate(I, A);
  }, e.exports.addAbortSignalNoValidate = function(w, I) {
    if (typeof w != "object" || !("aborted" in w))
      return I;
    const A = s(I) ? () => {
      I.destroy(
        new r(void 0, {
          cause: w.reason
        })
      );
    } : () => {
      I[f](
        new r(void 0, {
          cause: w.reason
        })
      );
    };
    if (w.aborted)
      A();
    else {
      p = p || yr.addAbortListener;
      const x = p(w, A);
      h(I, x[t]);
    }
    return I;
  };
})(U_);
var ju = U_.exports;
const { StringPrototypeSlice: Ap, SymbolIterator: hI, TypedArrayPrototypeSet: tu, Uint8Array: gI } = St, { Buffer: Hl } = _r, { inspect: pI } = yr;
var bI = class {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  push(t) {
    const r = {
      data: t,
      next: null
    };
    this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
  }
  unshift(t) {
    const r = {
      data: t,
      next: this.head
    };
    this.length === 0 && (this.tail = r), this.head = r, ++this.length;
  }
  shift() {
    if (this.length === 0) return;
    const t = this.head.data;
    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
  }
  clear() {
    this.head = this.tail = null, this.length = 0;
  }
  join(t) {
    if (this.length === 0) return "";
    let r = this.head, o = "" + r.data;
    for (; (r = r.next) !== null; ) o += t + r.data;
    return o;
  }
  concat(t) {
    if (this.length === 0) return Hl.alloc(0);
    const r = Hl.allocUnsafe(t >>> 0);
    let o = this.head, s = 0;
    for (; o; )
      tu(r, o.data, s), s += o.data.length, o = o.next;
    return r;
  }
  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(t, r) {
    const o = this.head.data;
    if (t < o.length) {
      const s = o.slice(0, t);
      return this.head.data = o.slice(t), s;
    }
    return t === o.length ? this.shift() : r ? this._getString(t) : this._getBuffer(t);
  }
  first() {
    return this.head.data;
  }
  *[hI]() {
    for (let t = this.head; t; t = t.next)
      yield t.data;
  }
  // Consumes a specified amount of characters from the buffered data.
  _getString(t) {
    let r = "", o = this.head, s = 0;
    do {
      const u = o.data;
      if (t > u.length)
        r += u, t -= u.length;
      else {
        t === u.length ? (r += u, ++s, o.next ? this.head = o.next : this.head = this.tail = null) : (r += Ap(u, 0, t), this.head = o, o.data = Ap(u, t));
        break;
      }
      ++s;
    } while ((o = o.next) !== null);
    return this.length -= s, r;
  }
  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(t) {
    const r = Hl.allocUnsafe(t), o = t;
    let s = this.head, u = 0;
    do {
      const f = s.data;
      if (t > f.length)
        tu(r, f, o - t), t -= f.length;
      else {
        t === f.length ? (tu(r, f, o - t), ++u, s.next ? this.head = s.next : this.head = this.tail = null) : (tu(r, new gI(f.buffer, f.byteOffset, t), o - t), this.head = s, s.data = f.slice(t));
        break;
      }
      ++u;
    } while ((s = s.next) !== null);
    return this.length -= u, r;
  }
  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for("nodejs.util.inspect.custom")](t, r) {
    return pI(this, {
      ...r,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: !1
    });
  }
};
const { MathFloor: _I, NumberIsInteger: yI } = St, { validateInteger: wI } = Hs, { ERR_INVALID_ARG_VALUE: mI } = fr.codes;
let k_ = 16 * 1024, F_ = 16;
function EI(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function H_(e) {
  return e ? F_ : k_;
}
function vI(e, t) {
  wI(t, "value", 0), e ? F_ = t : k_ = t;
}
function SI(e, t, r, o) {
  const s = EI(t, o, r);
  if (s != null) {
    if (!yI(s) || s < 0) {
      const u = o ? `options.${r}` : "options.highWaterMark";
      throw new mI(u, s);
    }
    return _I(s);
  }
  return H_(e.objectMode);
}
var Uu = {
  getHighWaterMark: SI,
  getDefaultHighWaterMark: H_,
  setDefaultHighWaterMark: vI
};
const Tp = Xi, { PromisePrototypeThen: RI, SymbolAsyncIterator: Ip, SymbolIterator: Op } = St, { Buffer: AI } = _r, { ERR_INVALID_ARG_TYPE: TI, ERR_STREAM_NULL_VALUES: II } = fr.codes;
function OI(e, t, r) {
  let o;
  if (typeof t == "string" || t instanceof AI)
    return new e({
      objectMode: !0,
      ...r,
      read() {
        this.push(t), this.push(null);
      }
    });
  let s;
  if (t && t[Ip])
    s = !0, o = t[Ip]();
  else if (t && t[Op])
    s = !1, o = t[Op]();
  else
    throw new TI("iterable", ["Iterable"], t);
  const u = new e({
    objectMode: !0,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...r
  });
  let f = !1;
  u._read = function() {
    f || (f = !0, l());
  }, u._destroy = function(p, b) {
    RI(
      h(p),
      () => Tp.nextTick(b, p),
      // nextTick is here in case cb throws
      (w) => Tp.nextTick(b, w || p)
    );
  };
  async function h(p) {
    const b = p != null, w = typeof o.throw == "function";
    if (b && w) {
      const { value: I, done: A } = await o.throw(p);
      if (await I, A)
        return;
    }
    if (typeof o.return == "function") {
      const { value: I } = await o.return();
      await I;
    }
  }
  async function l() {
    for (; ; ) {
      try {
        const { value: p, done: b } = s ? await o.next() : o.next();
        if (b)
          u.push(null);
        else {
          const w = p && typeof p.then == "function" ? await p : p;
          if (w === null)
            throw f = !1, new II();
          if (u.push(w))
            continue;
          f = !1;
        }
      } catch (p) {
        u.destroy(p);
      }
      break;
    }
  }
  return u;
}
var W_ = OI, Wl, Cp;
function ku() {
  if (Cp) return Wl;
  Cp = 1;
  const e = Xi, {
    ArrayPrototypeIndexOf: t,
    NumberIsInteger: r,
    NumberIsNaN: o,
    NumberParseInt: s,
    ObjectDefineProperties: u,
    ObjectKeys: f,
    ObjectSetPrototypeOf: h,
    Promise: l,
    SafeSet: p,
    SymbolAsyncDispose: b,
    SymbolAsyncIterator: w,
    Symbol: I
  } = St;
  Wl = Re, Re.ReadableState = Ue;
  const { EventEmitter: A } = Pn, { Stream: x, prependListener: v } = od, { Buffer: C } = _r, { addAbortSignal: B } = ju, P = Ci;
  let S = yr.debuglog("stream", (N) => {
    S = N;
  });
  const m = bI, j = Ho, { getHighWaterMark: Z, getDefaultHighWaterMark: ce } = Uu, {
    aggregateTwoErrors: ae,
    codes: {
      ERR_INVALID_ARG_TYPE: ee,
      ERR_METHOD_NOT_IMPLEMENTED: Se,
      ERR_OUT_OF_RANGE: me,
      ERR_STREAM_PUSH_AFTER_EOF: F,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT: U
    },
    AbortError: $
  } = fr, { validateObject: q } = Hs, J = I("kPaused"), { StringDecoder: V } = Ls(), re = W_;
  h(Re.prototype, x.prototype), h(Re, x);
  const H = () => {
  }, { errorOrDestroy: z } = j, se = 1, de = 2, te = 4, _e = 8, be = 16, R = 32, O = 64, W = 128, ie = 256, ye = 512, d = 1024, g = 2048, _ = 4096, E = 8192, K = 16384, ne = 32768, oe = 65536, Ie = 1 << 17, Be = 1 << 18;
  function Ce(N) {
    return {
      enumerable: !1,
      get() {
        return (this.state & N) !== 0;
      },
      set(D) {
        D ? this.state |= N : this.state &= ~N;
      }
    };
  }
  u(Ue.prototype, {
    objectMode: Ce(se),
    ended: Ce(de),
    endEmitted: Ce(te),
    reading: Ce(_e),
    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    constructed: Ce(be),
    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    sync: Ce(R),
    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    needReadable: Ce(O),
    emittedReadable: Ce(W),
    readableListening: Ce(ie),
    resumeScheduled: Ce(ye),
    // True if the error was already emitted and should not be thrown again.
    errorEmitted: Ce(d),
    emitClose: Ce(g),
    autoDestroy: Ce(_),
    // Has it been destroyed.
    destroyed: Ce(E),
    // Indicates whether the stream has finished destroying.
    closed: Ce(K),
    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    closeEmitted: Ce(ne),
    multiAwaitDrain: Ce(oe),
    // If true, a maybeReadMore has been scheduled.
    readingMore: Ce(Ie),
    dataEmitted: Ce(Be)
  });
  function Ue(N, D, Ee) {
    typeof Ee != "boolean" && (Ee = D instanceof ei()), this.state = g | _ | be | R, N && N.objectMode && (this.state |= se), Ee && N && N.readableObjectMode && (this.state |= se), this.highWaterMark = N ? Z(this, N, "readableHighWaterMark", Ee) : ce(!1), this.buffer = new m(), this.length = 0, this.pipes = [], this.flowing = null, this[J] = null, N && N.emitClose === !1 && (this.state &= -2049), N && N.autoDestroy === !1 && (this.state &= -4097), this.errored = null, this.defaultEncoding = N && N.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, N && N.encoding && (this.decoder = new V(N.encoding), this.encoding = N.encoding);
  }
  function Re(N) {
    if (!(this instanceof Re)) return new Re(N);
    const D = this instanceof ei();
    this._readableState = new Ue(N, this, D), N && (typeof N.read == "function" && (this._read = N.read), typeof N.destroy == "function" && (this._destroy = N.destroy), typeof N.construct == "function" && (this._construct = N.construct), N.signal && !D && B(N.signal, this)), x.call(this, N), j.construct(this, () => {
      this._readableState.needReadable && ut(this, this._readableState);
    });
  }
  Re.prototype.destroy = j.destroy, Re.prototype._undestroy = j.undestroy, Re.prototype._destroy = function(N, D) {
    D(N);
  }, Re.prototype[A.captureRejectionSymbol] = function(N) {
    this.destroy(N);
  }, Re.prototype[b] = function() {
    let N;
    return this.destroyed || (N = this.readableEnded ? null : new $(), this.destroy(N)), new l((D, Ee) => P(this, (ve) => ve && ve !== N ? Ee(ve) : D(null)));
  }, Re.prototype.push = function(N, D) {
    return He(this, N, D, !1);
  }, Re.prototype.unshift = function(N, D) {
    return He(this, N, D, !0);
  };
  function He(N, D, Ee, ve) {
    S("readableAddChunk", D);
    const Te = N._readableState;
    let wt;
    if (Te.state & se || (typeof D == "string" ? (Ee = Ee || Te.defaultEncoding, Te.encoding !== Ee && (ve && Te.encoding ? D = C.from(D, Ee).toString(Te.encoding) : (D = C.from(D, Ee), Ee = ""))) : D instanceof C ? Ee = "" : x._isUint8Array(D) ? (D = x._uint8ArrayToBuffer(D), Ee = "") : D != null && (wt = new ee("chunk", ["string", "Buffer", "Uint8Array"], D))), wt)
      z(N, wt);
    else if (D === null)
      Te.state &= -9, Ge(N, Te);
    else if (Te.state & se || D && D.length > 0)
      if (ve)
        if (Te.state & te) z(N, new U());
        else {
          if (Te.destroyed || Te.errored) return !1;
          _t(N, Te, D, !0);
        }
      else if (Te.ended)
        z(N, new F());
      else {
        if (Te.destroyed || Te.errored)
          return !1;
        Te.state &= -9, Te.decoder && !Ee ? (D = Te.decoder.write(D), Te.objectMode || D.length !== 0 ? _t(N, Te, D, !1) : ut(N, Te)) : _t(N, Te, D, !1);
      }
    else ve || (Te.state &= -9, ut(N, Te));
    return !Te.ended && (Te.length < Te.highWaterMark || Te.length === 0);
  }
  function _t(N, D, Ee, ve) {
    D.flowing && D.length === 0 && !D.sync && N.listenerCount("data") > 0 ? (D.state & oe ? D.awaitDrainWriters.clear() : D.awaitDrainWriters = null, D.dataEmitted = !0, N.emit("data", Ee)) : (D.length += D.objectMode ? 1 : Ee.length, ve ? D.buffer.unshift(Ee) : D.buffer.push(Ee), D.state & O && jt(N)), ut(N, D);
  }
  Re.prototype.isPaused = function() {
    const N = this._readableState;
    return N[J] === !0 || N.flowing === !1;
  }, Re.prototype.setEncoding = function(N) {
    const D = new V(N);
    this._readableState.decoder = D, this._readableState.encoding = this._readableState.decoder.encoding;
    const Ee = this._readableState.buffer;
    let ve = "";
    for (const Te of Ee)
      ve += D.write(Te);
    return Ee.clear(), ve !== "" && Ee.push(ve), this._readableState.length = ve.length, this;
  };
  const tt = 1073741824;
  function yt(N) {
    if (N > tt)
      throw new me("size", "<= 1GiB", N);
    return N--, N |= N >>> 1, N |= N >>> 2, N |= N >>> 4, N |= N >>> 8, N |= N >>> 16, N++, N;
  }
  function Xe(N, D) {
    return N <= 0 || D.length === 0 && D.ended ? 0 : D.state & se ? 1 : o(N) ? D.flowing && D.length ? D.buffer.first().length : D.length : N <= D.length ? N : D.ended ? D.length : 0;
  }
  Re.prototype.read = function(N) {
    S("read", N), N === void 0 ? N = NaN : r(N) || (N = s(N, 10));
    const D = this._readableState, Ee = N;
    if (N > D.highWaterMark && (D.highWaterMark = yt(N)), N !== 0 && (D.state &= -129), N === 0 && D.needReadable && ((D.highWaterMark !== 0 ? D.length >= D.highWaterMark : D.length > 0) || D.ended))
      return S("read: emitReadable", D.length, D.ended), D.length === 0 && D.ended ? Lr(this) : jt(this), null;
    if (N = Xe(N, D), N === 0 && D.ended)
      return D.length === 0 && Lr(this), null;
    let ve = (D.state & O) !== 0;
    if (S("need readable", ve), (D.length === 0 || D.length - N < D.highWaterMark) && (ve = !0, S("length less than watermark", ve)), D.ended || D.reading || D.destroyed || D.errored || !D.constructed)
      ve = !1, S("reading, ended or constructing", ve);
    else if (ve) {
      S("do read"), D.state |= _e | R, D.length === 0 && (D.state |= O);
      try {
        this._read(D.highWaterMark);
      } catch (wt) {
        z(this, wt);
      }
      D.state &= -33, D.reading || (N = Xe(Ee, D));
    }
    let Te;
    return N > 0 ? Te = rr(N, D) : Te = null, Te === null ? (D.needReadable = D.length <= D.highWaterMark, N = 0) : (D.length -= N, D.multiAwaitDrain ? D.awaitDrainWriters.clear() : D.awaitDrainWriters = null), D.length === 0 && (D.ended || (D.needReadable = !0), Ee !== N && D.ended && Lr(this)), Te !== null && !D.errorEmitted && !D.closeEmitted && (D.dataEmitted = !0, this.emit("data", Te)), Te;
  };
  function Ge(N, D) {
    if (S("onEofChunk"), !D.ended) {
      if (D.decoder) {
        const Ee = D.decoder.end();
        Ee && Ee.length && (D.buffer.push(Ee), D.length += D.objectMode ? 1 : Ee.length);
      }
      D.ended = !0, D.sync ? jt(N) : (D.needReadable = !1, D.emittedReadable = !0, Pt(N));
    }
  }
  function jt(N) {
    const D = N._readableState;
    S("emitReadable", D.needReadable, D.emittedReadable), D.needReadable = !1, D.emittedReadable || (S("emitReadable", D.flowing), D.emittedReadable = !0, e.nextTick(Pt, N));
  }
  function Pt(N) {
    const D = N._readableState;
    S("emitReadable_", D.destroyed, D.length, D.ended), !D.destroyed && !D.errored && (D.length || D.ended) && (N.emit("readable"), D.emittedReadable = !1), D.needReadable = !D.flowing && !D.ended && D.length <= D.highWaterMark, Yr(N);
  }
  function ut(N, D) {
    !D.readingMore && D.constructed && (D.readingMore = !0, e.nextTick(Nt, N, D));
  }
  function Nt(N, D) {
    for (; !D.reading && !D.ended && (D.length < D.highWaterMark || D.flowing && D.length === 0); ) {
      const Ee = D.length;
      if (S("maybeReadMore read 0"), N.read(0), Ee === D.length)
        break;
    }
    D.readingMore = !1;
  }
  Re.prototype._read = function(N) {
    throw new Se("_read()");
  }, Re.prototype.pipe = function(N, D) {
    const Ee = this, ve = this._readableState;
    ve.pipes.length === 1 && (ve.multiAwaitDrain || (ve.multiAwaitDrain = !0, ve.awaitDrainWriters = new p(ve.awaitDrainWriters ? [ve.awaitDrainWriters] : []))), ve.pipes.push(N), S("pipe count=%d opts=%j", ve.pipes.length, D);
    const wt = (!D || D.end !== !1) && N !== e.stdout && N !== e.stderr ? cn : mr;
    ve.endEmitted ? e.nextTick(wt) : Ee.once("end", wt), N.on("unpipe", Rt);
    function Rt(ir, Ht) {
      S("onunpipe"), ir === Ee && Ht && Ht.hasUnpiped === !1 && (Ht.hasUnpiped = !0, Mn());
    }
    function cn() {
      S("onend"), N.end();
    }
    let Bt, dn = !1;
    function Mn() {
      S("cleanup"), N.removeListener("close", Gt), N.removeListener("finish", Pr), Bt && N.removeListener("drain", Bt), N.removeListener("error", Zr), N.removeListener("unpipe", Rt), Ee.removeListener("end", cn), Ee.removeListener("end", mr), Ee.removeListener("data", gn), dn = !0, Bt && ve.awaitDrainWriters && (!N._writableState || N._writableState.needDrain) && Bt();
    }
    function hn() {
      dn || (ve.pipes.length === 1 && ve.pipes[0] === N ? (S("false write response, pause", 0), ve.awaitDrainWriters = N, ve.multiAwaitDrain = !1) : ve.pipes.length > 1 && ve.pipes.includes(N) && (S("false write response, pause", ve.awaitDrainWriters.size), ve.awaitDrainWriters.add(N)), Ee.pause()), Bt || (Bt = lr(Ee, N), N.on("drain", Bt));
    }
    Ee.on("data", gn);
    function gn(ir) {
      S("ondata");
      const Ht = N.write(ir);
      S("dest.write", Ht), Ht === !1 && hn();
    }
    function Zr(ir) {
      if (S("onerror", ir), mr(), N.removeListener("error", Zr), N.listenerCount("error") === 0) {
        const Ht = N._writableState || N._readableState;
        Ht && !Ht.errorEmitted ? z(N, ir) : N.emit("error", ir);
      }
    }
    v(N, "error", Zr);
    function Gt() {
      N.removeListener("finish", Pr), mr();
    }
    N.once("close", Gt);
    function Pr() {
      S("onfinish"), N.removeListener("close", Gt), mr();
    }
    N.once("finish", Pr);
    function mr() {
      S("unpipe"), Ee.unpipe(N);
    }
    return N.emit("pipe", Ee), N.writableNeedDrain === !0 ? hn() : ve.flowing || (S("pipe resume"), Ee.resume()), N;
  };
  function lr(N, D) {
    return function() {
      const ve = N._readableState;
      ve.awaitDrainWriters === D ? (S("pipeOnDrain", 1), ve.awaitDrainWriters = null) : ve.multiAwaitDrain && (S("pipeOnDrain", ve.awaitDrainWriters.size), ve.awaitDrainWriters.delete(D)), (!ve.awaitDrainWriters || ve.awaitDrainWriters.size === 0) && N.listenerCount("data") && N.resume();
    };
  }
  Re.prototype.unpipe = function(N) {
    const D = this._readableState, Ee = {
      hasUnpiped: !1
    };
    if (D.pipes.length === 0) return this;
    if (!N) {
      const Te = D.pipes;
      D.pipes = [], this.pause();
      for (let wt = 0; wt < Te.length; wt++)
        Te[wt].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    const ve = t(D.pipes, N);
    return ve === -1 ? this : (D.pipes.splice(ve, 1), D.pipes.length === 0 && this.pause(), N.emit("unpipe", this, Ee), this);
  }, Re.prototype.on = function(N, D) {
    const Ee = x.prototype.on.call(this, N, D), ve = this._readableState;
    return N === "data" ? (ve.readableListening = this.listenerCount("readable") > 0, ve.flowing !== !1 && this.resume()) : N === "readable" && !ve.endEmitted && !ve.readableListening && (ve.readableListening = ve.needReadable = !0, ve.flowing = !1, ve.emittedReadable = !1, S("on readable", ve.length, ve.reading), ve.length ? jt(this) : ve.reading || e.nextTick(Ft, this)), Ee;
  }, Re.prototype.addListener = Re.prototype.on, Re.prototype.removeListener = function(N, D) {
    const Ee = x.prototype.removeListener.call(this, N, D);
    return N === "readable" && e.nextTick(tr, this), Ee;
  }, Re.prototype.off = Re.prototype.removeListener, Re.prototype.removeAllListeners = function(N) {
    const D = x.prototype.removeAllListeners.apply(this, arguments);
    return (N === "readable" || N === void 0) && e.nextTick(tr, this), D;
  };
  function tr(N) {
    const D = N._readableState;
    D.readableListening = N.listenerCount("readable") > 0, D.resumeScheduled && D[J] === !1 ? D.flowing = !0 : N.listenerCount("data") > 0 ? N.resume() : D.readableListening || (D.flowing = null);
  }
  function Ft(N) {
    S("readable nexttick read 0"), N.read(0);
  }
  Re.prototype.resume = function() {
    const N = this._readableState;
    return N.flowing || (S("resume"), N.flowing = !N.readableListening, cr(this, N)), N[J] = !1, this;
  };
  function cr(N, D) {
    D.resumeScheduled || (D.resumeScheduled = !0, e.nextTick(Jr, N, D));
  }
  function Jr(N, D) {
    S("resume", D.reading), D.reading || N.read(0), D.resumeScheduled = !1, N.emit("resume"), Yr(N), D.flowing && !D.reading && N.read(0);
  }
  Re.prototype.pause = function() {
    return S("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (S("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[J] = !0, this;
  };
  function Yr(N) {
    const D = N._readableState;
    for (S("flow", D.flowing); D.flowing && N.read() !== null; ) ;
  }
  Re.prototype.wrap = function(N) {
    let D = !1;
    N.on("data", (ve) => {
      !this.push(ve) && N.pause && (D = !0, N.pause());
    }), N.on("end", () => {
      this.push(null);
    }), N.on("error", (ve) => {
      z(this, ve);
    }), N.on("close", () => {
      this.destroy();
    }), N.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      D && N.resume && (D = !1, N.resume());
    };
    const Ee = f(N);
    for (let ve = 1; ve < Ee.length; ve++) {
      const Te = Ee[ve];
      this[Te] === void 0 && typeof N[Te] == "function" && (this[Te] = N[Te].bind(N));
    }
    return this;
  }, Re.prototype[w] = function() {
    return un(this);
  }, Re.prototype.iterator = function(N) {
    return N !== void 0 && q(N, "options"), un(this, N);
  };
  function un(N, D) {
    typeof N.read != "function" && (N = Re.wrap(N, {
      objectMode: !0
    }));
    const Ee = fn(N, D);
    return Ee.stream = N, Ee;
  }
  async function* fn(N, D) {
    let Ee = H;
    function ve(Rt) {
      this === N ? (Ee(), Ee = H) : Ee = Rt;
    }
    N.on("readable", ve);
    let Te;
    const wt = P(
      N,
      {
        writable: !1
      },
      (Rt) => {
        Te = Rt ? ae(Te, Rt) : null, Ee(), Ee = H;
      }
    );
    try {
      for (; ; ) {
        const Rt = N.destroyed ? null : N.read();
        if (Rt !== null)
          yield Rt;
        else {
          if (Te)
            throw Te;
          if (Te === null)
            return;
          await new l(ve);
        }
      }
    } catch (Rt) {
      throw Te = ae(Te, Rt), Te;
    } finally {
      (Te || (D == null ? void 0 : D.destroyOnReturn) !== !1) && (Te === void 0 || N._readableState.autoDestroy) ? j.destroyer(N, null) : (N.off("readable", ve), wt());
    }
  }
  u(Re.prototype, {
    readable: {
      __proto__: null,
      get() {
        const N = this._readableState;
        return !!N && N.readable !== !1 && !N.destroyed && !N.errorEmitted && !N.endEmitted;
      },
      set(N) {
        this._readableState && (this._readableState.readable = !!N);
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(N) {
        this._readableState && (this._readableState.flowing = N);
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(N) {
        this._readableState && (this._readableState.destroyed = N);
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  }), u(Ue.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[J] !== !1;
      },
      set(N) {
        this[J] = !!N;
      }
    }
  }), Re._fromList = rr;
  function rr(N, D) {
    if (D.length === 0) return null;
    let Ee;
    return D.objectMode ? Ee = D.buffer.shift() : !N || N >= D.length ? (D.decoder ? Ee = D.buffer.join("") : D.buffer.length === 1 ? Ee = D.buffer.first() : Ee = D.buffer.concat(D.length), D.buffer.clear()) : Ee = D.buffer.consume(N, D.decoder), Ee;
  }
  function Lr(N) {
    const D = N._readableState;
    S("endReadable", D.endEmitted), D.endEmitted || (D.ended = !0, e.nextTick(nr, D, N));
  }
  function nr(N, D) {
    if (S("endReadableNT", N.endEmitted, N.length), !N.errored && !N.closeEmitted && !N.endEmitted && N.length === 0) {
      if (N.endEmitted = !0, D.emit("end"), D.writable && D.allowHalfOpen === !1)
        e.nextTick($n, D);
      else if (N.autoDestroy) {
        const Ee = D._writableState;
        (!Ee || Ee.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (Ee.finished || Ee.writable === !1)) && D.destroy();
      }
    }
  }
  function $n(N) {
    N.writable && !N.writableEnded && !N.destroyed && N.end();
  }
  Re.from = function(N, D) {
    return re(Re, N, D);
  };
  let Xr;
  function ln() {
    return Xr === void 0 && (Xr = {}), Xr;
  }
  return Re.fromWeb = function(N, D) {
    return ln().newStreamReadableFromReadableStream(N, D);
  }, Re.toWeb = function(N, D) {
    return ln().newReadableStreamFromStreamReadable(N, D);
  }, Re.wrap = function(N, D) {
    var Ee, ve;
    return new Re({
      objectMode: (Ee = (ve = N.readableObjectMode) !== null && ve !== void 0 ? ve : N.objectMode) !== null && Ee !== void 0 ? Ee : !0,
      ...D,
      destroy(Te, wt) {
        j.destroyer(N, Te), wt(Te);
      }
    }).wrap(N);
  }, Wl;
}
var ql, Lp;
function sd() {
  if (Lp) return ql;
  Lp = 1;
  const e = Xi, {
    ArrayPrototypeSlice: t,
    Error: r,
    FunctionPrototypeSymbolHasInstance: o,
    ObjectDefineProperty: s,
    ObjectDefineProperties: u,
    ObjectSetPrototypeOf: f,
    StringPrototypeToLowerCase: h,
    Symbol: l,
    SymbolHasInstance: p
  } = St;
  ql = q, q.WritableState = U;
  const { EventEmitter: b } = Pn, w = od.Stream, { Buffer: I } = _r, A = Ho, { addAbortSignal: x } = ju, { getHighWaterMark: v, getDefaultHighWaterMark: C } = Uu, {
    ERR_INVALID_ARG_TYPE: B,
    ERR_METHOD_NOT_IMPLEMENTED: P,
    ERR_MULTIPLE_CALLBACK: S,
    ERR_STREAM_CANNOT_PIPE: m,
    ERR_STREAM_DESTROYED: j,
    ERR_STREAM_ALREADY_FINISHED: Z,
    ERR_STREAM_NULL_VALUES: ce,
    ERR_STREAM_WRITE_AFTER_END: ae,
    ERR_UNKNOWN_ENCODING: ee
  } = fr.codes, { errorOrDestroy: Se } = A;
  f(q.prototype, w.prototype), f(q, w);
  function me() {
  }
  const F = l("kOnFinished");
  function U(_, E, K) {
    typeof K != "boolean" && (K = E instanceof ei()), this.objectMode = !!(_ && _.objectMode), K && (this.objectMode = this.objectMode || !!(_ && _.writableObjectMode)), this.highWaterMark = _ ? v(this, _, "writableHighWaterMark", K) : C(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    const ne = !!(_ && _.decodeStrings === !1);
    this.decodeStrings = !ne, this.defaultEncoding = _ && _.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = z.bind(void 0, E), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, $(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !_ || _.emitClose !== !1, this.autoDestroy = !_ || _.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[F] = [];
  }
  function $(_) {
    _.buffered = [], _.bufferedIndex = 0, _.allBuffers = !0, _.allNoop = !0;
  }
  U.prototype.getBuffer = function() {
    return t(this.buffered, this.bufferedIndex);
  }, s(U.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function q(_) {
    const E = this instanceof ei();
    if (!E && !o(q, this)) return new q(_);
    this._writableState = new U(_, this, E), _ && (typeof _.write == "function" && (this._write = _.write), typeof _.writev == "function" && (this._writev = _.writev), typeof _.destroy == "function" && (this._destroy = _.destroy), typeof _.final == "function" && (this._final = _.final), typeof _.construct == "function" && (this._construct = _.construct), _.signal && x(_.signal, this)), w.call(this, _), A.construct(this, () => {
      const K = this._writableState;
      K.writing || _e(this, K), W(this, K);
    });
  }
  s(q, p, {
    __proto__: null,
    value: function(_) {
      return o(this, _) ? !0 : this !== q ? !1 : _ && _._writableState instanceof U;
    }
  }), q.prototype.pipe = function() {
    Se(this, new m());
  };
  function J(_, E, K, ne) {
    const oe = _._writableState;
    if (typeof K == "function")
      ne = K, K = oe.defaultEncoding;
    else {
      if (!K) K = oe.defaultEncoding;
      else if (K !== "buffer" && !I.isEncoding(K)) throw new ee(K);
      typeof ne != "function" && (ne = me);
    }
    if (E === null)
      throw new ce();
    if (!oe.objectMode)
      if (typeof E == "string")
        oe.decodeStrings !== !1 && (E = I.from(E, K), K = "buffer");
      else if (E instanceof I)
        K = "buffer";
      else if (w._isUint8Array(E))
        E = w._uint8ArrayToBuffer(E), K = "buffer";
      else
        throw new B("chunk", ["string", "Buffer", "Uint8Array"], E);
    let Ie;
    return oe.ending ? Ie = new ae() : oe.destroyed && (Ie = new j("write")), Ie ? (e.nextTick(ne, Ie), Se(_, Ie, !0), Ie) : (oe.pendingcb++, V(_, oe, E, K, ne));
  }
  q.prototype.write = function(_, E, K) {
    return J(this, _, E, K) === !0;
  }, q.prototype.cork = function() {
    this._writableState.corked++;
  }, q.prototype.uncork = function() {
    const _ = this._writableState;
    _.corked && (_.corked--, _.writing || _e(this, _));
  }, q.prototype.setDefaultEncoding = function(E) {
    if (typeof E == "string" && (E = h(E)), !I.isEncoding(E)) throw new ee(E);
    return this._writableState.defaultEncoding = E, this;
  };
  function V(_, E, K, ne, oe) {
    const Ie = E.objectMode ? 1 : K.length;
    E.length += Ie;
    const Be = E.length < E.highWaterMark;
    return Be || (E.needDrain = !0), E.writing || E.corked || E.errored || !E.constructed ? (E.buffered.push({
      chunk: K,
      encoding: ne,
      callback: oe
    }), E.allBuffers && ne !== "buffer" && (E.allBuffers = !1), E.allNoop && oe !== me && (E.allNoop = !1)) : (E.writelen = Ie, E.writecb = oe, E.writing = !0, E.sync = !0, _._write(K, ne, E.onwrite), E.sync = !1), Be && !E.errored && !E.destroyed;
  }
  function re(_, E, K, ne, oe, Ie, Be) {
    E.writelen = ne, E.writecb = Be, E.writing = !0, E.sync = !0, E.destroyed ? E.onwrite(new j("write")) : K ? _._writev(oe, E.onwrite) : _._write(oe, Ie, E.onwrite), E.sync = !1;
  }
  function H(_, E, K, ne) {
    --E.pendingcb, ne(K), te(E), Se(_, K);
  }
  function z(_, E) {
    const K = _._writableState, ne = K.sync, oe = K.writecb;
    if (typeof oe != "function") {
      Se(_, new S());
      return;
    }
    K.writing = !1, K.writecb = null, K.length -= K.writelen, K.writelen = 0, E ? (E.stack, K.errored || (K.errored = E), _._readableState && !_._readableState.errored && (_._readableState.errored = E), ne ? e.nextTick(H, _, K, E, oe) : H(_, K, E, oe)) : (K.buffered.length > K.bufferedIndex && _e(_, K), ne ? K.afterWriteTickInfo !== null && K.afterWriteTickInfo.cb === oe ? K.afterWriteTickInfo.count++ : (K.afterWriteTickInfo = {
      count: 1,
      cb: oe,
      stream: _,
      state: K
    }, e.nextTick(se, K.afterWriteTickInfo)) : de(_, K, 1, oe));
  }
  function se({ stream: _, state: E, count: K, cb: ne }) {
    return E.afterWriteTickInfo = null, de(_, E, K, ne);
  }
  function de(_, E, K, ne) {
    for (!E.ending && !_.destroyed && E.length === 0 && E.needDrain && (E.needDrain = !1, _.emit("drain")); K-- > 0; )
      E.pendingcb--, ne();
    E.destroyed && te(E), W(_, E);
  }
  function te(_) {
    if (_.writing)
      return;
    for (let oe = _.bufferedIndex; oe < _.buffered.length; ++oe) {
      var E;
      const { chunk: Ie, callback: Be } = _.buffered[oe], Ce = _.objectMode ? 1 : Ie.length;
      _.length -= Ce, Be(
        (E = _.errored) !== null && E !== void 0 ? E : new j("write")
      );
    }
    const K = _[F].splice(0);
    for (let oe = 0; oe < K.length; oe++) {
      var ne;
      K[oe](
        (ne = _.errored) !== null && ne !== void 0 ? ne : new j("end")
      );
    }
    $(_);
  }
  function _e(_, E) {
    if (E.corked || E.bufferProcessing || E.destroyed || !E.constructed)
      return;
    const { buffered: K, bufferedIndex: ne, objectMode: oe } = E, Ie = K.length - ne;
    if (!Ie)
      return;
    let Be = ne;
    if (E.bufferProcessing = !0, Ie > 1 && _._writev) {
      E.pendingcb -= Ie - 1;
      const Ce = E.allNoop ? me : (Re) => {
        for (let He = Be; He < K.length; ++He)
          K[He].callback(Re);
      }, Ue = E.allNoop && Be === 0 ? K : t(K, Be);
      Ue.allBuffers = E.allBuffers, re(_, E, !0, E.length, Ue, "", Ce), $(E);
    } else {
      do {
        const { chunk: Ce, encoding: Ue, callback: Re } = K[Be];
        K[Be++] = null;
        const He = oe ? 1 : Ce.length;
        re(_, E, !1, He, Ce, Ue, Re);
      } while (Be < K.length && !E.writing);
      Be === K.length ? $(E) : Be > 256 ? (K.splice(0, Be), E.bufferedIndex = 0) : E.bufferedIndex = Be;
    }
    E.bufferProcessing = !1;
  }
  q.prototype._write = function(_, E, K) {
    if (this._writev)
      this._writev(
        [
          {
            chunk: _,
            encoding: E
          }
        ],
        K
      );
    else
      throw new P("_write()");
  }, q.prototype._writev = null, q.prototype.end = function(_, E, K) {
    const ne = this._writableState;
    typeof _ == "function" ? (K = _, _ = null, E = null) : typeof E == "function" && (K = E, E = null);
    let oe;
    if (_ != null) {
      const Ie = J(this, _, E);
      Ie instanceof r && (oe = Ie);
    }
    return ne.corked && (ne.corked = 1, this.uncork()), oe || (!ne.errored && !ne.ending ? (ne.ending = !0, W(this, ne, !0), ne.ended = !0) : ne.finished ? oe = new Z("end") : ne.destroyed && (oe = new j("end"))), typeof K == "function" && (oe || ne.finished ? e.nextTick(K, oe) : ne[F].push(K)), this;
  };
  function be(_) {
    return _.ending && !_.destroyed && _.constructed && _.length === 0 && !_.errored && _.buffered.length === 0 && !_.finished && !_.writing && !_.errorEmitted && !_.closeEmitted;
  }
  function R(_, E) {
    let K = !1;
    function ne(oe) {
      if (K) {
        Se(_, oe ?? S());
        return;
      }
      if (K = !0, E.pendingcb--, oe) {
        const Ie = E[F].splice(0);
        for (let Be = 0; Be < Ie.length; Be++)
          Ie[Be](oe);
        Se(_, oe, E.sync);
      } else be(E) && (E.prefinished = !0, _.emit("prefinish"), E.pendingcb++, e.nextTick(ie, _, E));
    }
    E.sync = !0, E.pendingcb++;
    try {
      _._final(ne);
    } catch (oe) {
      ne(oe);
    }
    E.sync = !1;
  }
  function O(_, E) {
    !E.prefinished && !E.finalCalled && (typeof _._final == "function" && !E.destroyed ? (E.finalCalled = !0, R(_, E)) : (E.prefinished = !0, _.emit("prefinish")));
  }
  function W(_, E, K) {
    be(E) && (O(_, E), E.pendingcb === 0 && (K ? (E.pendingcb++, e.nextTick(
      (ne, oe) => {
        be(oe) ? ie(ne, oe) : oe.pendingcb--;
      },
      _,
      E
    )) : be(E) && (E.pendingcb++, ie(_, E))));
  }
  function ie(_, E) {
    E.pendingcb--, E.finished = !0;
    const K = E[F].splice(0);
    for (let ne = 0; ne < K.length; ne++)
      K[ne]();
    if (_.emit("finish"), E.autoDestroy) {
      const ne = _._readableState;
      (!ne || ne.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (ne.endEmitted || ne.readable === !1)) && _.destroy();
    }
  }
  u(q.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(_) {
        this._writableState && (this._writableState.destroyed = _);
      }
    },
    writable: {
      __proto__: null,
      get() {
        const _ = this._writableState;
        return !!_ && _.writable !== !1 && !_.destroyed && !_.errored && !_.ending && !_.ended;
      },
      set(_) {
        this._writableState && (this._writableState.writable = !!_);
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const _ = this._writableState;
        return _ ? !_.destroyed && !_.ending && _.needDrain : !1;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  const ye = A.destroy;
  q.prototype.destroy = function(_, E) {
    const K = this._writableState;
    return !K.destroyed && (K.bufferedIndex < K.buffered.length || K[F].length) && e.nextTick(te, K), ye.call(this, _, E), this;
  }, q.prototype._undestroy = A.undestroy, q.prototype._destroy = function(_, E) {
    E(_);
  }, q.prototype[b.captureRejectionSymbol] = function(_) {
    this.destroy(_);
  };
  let d;
  function g() {
    return d === void 0 && (d = {}), d;
  }
  return q.fromWeb = function(_, E) {
    return g().newStreamWritableFromWritableStream(_, E);
  }, q.toWeb = function(_) {
    return g().newWritableStreamFromStreamWritable(_);
  }, ql;
}
var Vl, Pp;
function CI() {
  if (Pp) return Vl;
  Pp = 1;
  const e = Xi, t = _r, {
    isReadable: r,
    isWritable: o,
    isIterable: s,
    isNodeStream: u,
    isReadableNodeStream: f,
    isWritableNodeStream: h,
    isDuplexNodeStream: l,
    isReadableStream: p,
    isWritableStream: b
  } = ii, w = Ci, {
    AbortError: I,
    codes: { ERR_INVALID_ARG_TYPE: A, ERR_INVALID_RETURN_VALUE: x }
  } = fr, { destroyer: v } = Ho, C = ei(), B = ku(), P = sd(), { createDeferredPromise: S } = yr, m = W_, j = globalThis.Blob || t.Blob, Z = typeof j < "u" ? function(U) {
    return U instanceof j;
  } : function(U) {
    return !1;
  }, ce = globalThis.AbortController || $s().AbortController, { FunctionPrototypeCall: ae } = St;
  class ee extends C {
    constructor(U) {
      super(U), (U == null ? void 0 : U.readable) === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), (U == null ? void 0 : U.writable) === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
    }
  }
  Vl = function F(U, $) {
    if (l(U))
      return U;
    if (f(U))
      return me({
        readable: U
      });
    if (h(U))
      return me({
        writable: U
      });
    if (u(U))
      return me({
        writable: !1,
        readable: !1
      });
    if (p(U))
      return me({
        readable: B.fromWeb(U)
      });
    if (b(U))
      return me({
        writable: P.fromWeb(U)
      });
    if (typeof U == "function") {
      const { value: J, write: V, final: re, destroy: H } = Se(U);
      if (s(J))
        return m(ee, J, {
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          write: V,
          final: re,
          destroy: H
        });
      const z = J == null ? void 0 : J.then;
      if (typeof z == "function") {
        let se;
        const de = ae(
          z,
          J,
          (te) => {
            if (te != null)
              throw new x("nully", "body", te);
          },
          (te) => {
            v(se, te);
          }
        );
        return se = new ee({
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          readable: !1,
          write: V,
          final(te) {
            re(async () => {
              try {
                await de, e.nextTick(te, null);
              } catch (_e) {
                e.nextTick(te, _e);
              }
            });
          },
          destroy: H
        });
      }
      throw new x("Iterable, AsyncIterable or AsyncFunction", $, J);
    }
    if (Z(U))
      return F(U.arrayBuffer());
    if (s(U))
      return m(ee, U, {
        // TODO (ronag): highWaterMark?
        objectMode: !0,
        writable: !1
      });
    if (p(U == null ? void 0 : U.readable) && b(U == null ? void 0 : U.writable))
      return ee.fromWeb(U);
    if (typeof (U == null ? void 0 : U.writable) == "object" || typeof (U == null ? void 0 : U.readable) == "object") {
      const J = U != null && U.readable ? f(U == null ? void 0 : U.readable) ? U == null ? void 0 : U.readable : F(U.readable) : void 0, V = U != null && U.writable ? h(U == null ? void 0 : U.writable) ? U == null ? void 0 : U.writable : F(U.writable) : void 0;
      return me({
        readable: J,
        writable: V
      });
    }
    const q = U == null ? void 0 : U.then;
    if (typeof q == "function") {
      let J;
      return ae(
        q,
        U,
        (V) => {
          V != null && J.push(V), J.push(null);
        },
        (V) => {
          v(J, V);
        }
      ), J = new ee({
        objectMode: !0,
        writable: !1,
        read() {
        }
      });
    }
    throw new A(
      $,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      U
    );
  };
  function Se(F) {
    let { promise: U, resolve: $ } = S();
    const q = new ce(), J = q.signal;
    return {
      value: F(
        async function* () {
          for (; ; ) {
            const re = U;
            U = null;
            const { chunk: H, done: z, cb: se } = await re;
            if (e.nextTick(se), z) return;
            if (J.aborted)
              throw new I(void 0, {
                cause: J.reason
              });
            ({ promise: U, resolve: $ } = S()), yield H;
          }
        }(),
        {
          signal: J
        }
      ),
      write(re, H, z) {
        const se = $;
        $ = null, se({
          chunk: re,
          done: !1,
          cb: z
        });
      },
      final(re) {
        const H = $;
        $ = null, H({
          done: !0,
          cb: re
        });
      },
      destroy(re, H) {
        q.abort(), H(re);
      }
    };
  }
  function me(F) {
    const U = F.readable && typeof F.readable.read != "function" ? B.wrap(F.readable) : F.readable, $ = F.writable;
    let q = !!r(U), J = !!o($), V, re, H, z, se;
    function de(te) {
      const _e = z;
      z = null, _e ? _e(te) : te && se.destroy(te);
    }
    return se = new ee({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!(U != null && U.readableObjectMode),
      writableObjectMode: !!($ != null && $.writableObjectMode),
      readable: q,
      writable: J
    }), J && (w($, (te) => {
      J = !1, te && v(U, te), de(te);
    }), se._write = function(te, _e, be) {
      $.write(te, _e) ? be() : V = be;
    }, se._final = function(te) {
      $.end(), re = te;
    }, $.on("drain", function() {
      if (V) {
        const te = V;
        V = null, te();
      }
    }), $.on("finish", function() {
      if (re) {
        const te = re;
        re = null, te();
      }
    })), q && (w(U, (te) => {
      q = !1, te && v(U, te), de(te);
    }), U.on("readable", function() {
      if (H) {
        const te = H;
        H = null, te();
      }
    }), U.on("end", function() {
      se.push(null);
    }), se._read = function() {
      for (; ; ) {
        const te = U.read();
        if (te === null) {
          H = se._read;
          return;
        }
        if (!se.push(te))
          return;
      }
    }), se._destroy = function(te, _e) {
      !te && z !== null && (te = new I()), H = null, V = null, re = null, z === null ? _e(te) : (z = _e, v($, te), v(U, te));
    }, se;
  }
  return Vl;
}
var Gl, Bp;
function ei() {
  if (Bp) return Gl;
  Bp = 1;
  const {
    ObjectDefineProperties: e,
    ObjectGetOwnPropertyDescriptor: t,
    ObjectKeys: r,
    ObjectSetPrototypeOf: o
  } = St;
  Gl = f;
  const s = ku(), u = sd();
  o(f.prototype, s.prototype), o(f, s);
  {
    const b = r(u.prototype);
    for (let w = 0; w < b.length; w++) {
      const I = b[w];
      f.prototype[I] || (f.prototype[I] = u.prototype[I]);
    }
  }
  function f(b) {
    if (!(this instanceof f)) return new f(b);
    s.call(this, b), u.call(this, b), b ? (this.allowHalfOpen = b.allowHalfOpen !== !1, b.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), b.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
  }
  e(f.prototype, {
    writable: {
      __proto__: null,
      ...t(u.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...t(u.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...t(u.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...t(u.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...t(u.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...t(u.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...t(u.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...t(u.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...t(u.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set(b) {
        this._readableState && this._writableState && (this._readableState.destroyed = b, this._writableState.destroyed = b);
      }
    }
  });
  let h;
  function l() {
    return h === void 0 && (h = {}), h;
  }
  f.fromWeb = function(b, w) {
    return l().newStreamDuplexFromReadableWritablePair(b, w);
  }, f.toWeb = function(b) {
    return l().newReadableWritablePairFromDuplex(b);
  };
  let p;
  return f.from = function(b) {
    return p || (p = CI()), p(b, "body");
  }, Gl;
}
const { ObjectSetPrototypeOf: q_, Symbol: LI } = St;
var V_ = ti;
const { ERR_METHOD_NOT_IMPLEMENTED: PI } = fr.codes, ad = ei(), { getHighWaterMark: BI } = Uu;
q_(ti.prototype, ad.prototype);
q_(ti, ad);
const Is = LI("kCallback");
function ti(e) {
  if (!(this instanceof ti)) return new ti(e);
  const t = e ? BI(this, e, "readableHighWaterMark", !0) : null;
  t === 0 && (e = {
    ...e,
    highWaterMark: null,
    readableHighWaterMark: t,
    // TODO (ronag): 0 is not optimal since we have
    // a "bug" where we check needDrain before calling _write and not after.
    // Refs: https://github.com/nodejs/node/pull/32887
    // Refs: https://github.com/nodejs/node/pull/35941
    writableHighWaterMark: e.writableHighWaterMark || 0
  }), ad.call(this, e), this._readableState.sync = !1, this[Is] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", NI);
}
function $c(e) {
  typeof this._flush == "function" && !this.destroyed ? this._flush((t, r) => {
    if (t) {
      e ? e(t) : this.destroy(t);
      return;
    }
    r != null && this.push(r), this.push(null), e && e();
  }) : (this.push(null), e && e());
}
function NI() {
  this._final !== $c && $c.call(this);
}
ti.prototype._final = $c;
ti.prototype._transform = function(e, t, r) {
  throw new PI("_transform()");
};
ti.prototype._write = function(e, t, r) {
  const o = this._readableState, s = this._writableState, u = o.length;
  this._transform(e, t, (f, h) => {
    if (f) {
      r(f);
      return;
    }
    h != null && this.push(h), s.ended || // Backwards compat.
    u === o.length || // Backwards compat.
    o.length < o.highWaterMark ? r() : this[Is] = r;
  });
};
ti.prototype._read = function() {
  if (this[Is]) {
    const e = this[Is];
    this[Is] = null, e();
  }
};
const { ObjectSetPrototypeOf: G_ } = St;
var z_ = Mo;
const ud = V_;
G_(Mo.prototype, ud.prototype);
G_(Mo, ud);
function Mo(e) {
  if (!(this instanceof Mo)) return new Mo(e);
  ud.call(this, e);
}
Mo.prototype._transform = function(e, t, r) {
  r(null, e);
};
const As = Xi, { ArrayIsArray: $I, Promise: MI, SymbolAsyncIterator: xI, SymbolDispose: DI } = St, Eu = Ci, { once: jI } = yr, UI = Ho, Np = ei(), {
  aggregateTwoErrors: kI,
  codes: {
    ERR_INVALID_ARG_TYPE: Mc,
    ERR_INVALID_RETURN_VALUE: zl,
    ERR_MISSING_ARGS: FI,
    ERR_STREAM_DESTROYED: HI,
    ERR_STREAM_PREMATURE_CLOSE: WI
  },
  AbortError: qI
} = fr, { validateFunction: VI, validateAbortSignal: GI } = Hs, {
  isIterable: Vi,
  isReadable: Kl,
  isReadableNodeStream: gu,
  isNodeStream: $p,
  isTransformStream: Oo,
  isWebStream: zI,
  isReadableStream: Jl,
  isReadableFinished: KI
} = ii, JI = globalThis.AbortController || $s().AbortController;
let Yl, Xl, Zl;
function Mp(e, t, r) {
  let o = !1;
  e.on("close", () => {
    o = !0;
  });
  const s = Eu(
    e,
    {
      readable: t,
      writable: r
    },
    (u) => {
      o = !u;
    }
  );
  return {
    destroy: (u) => {
      o || (o = !0, UI.destroyer(e, u || new HI("pipe")));
    },
    cleanup: s
  };
}
function YI(e) {
  return VI(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
}
function Ql(e) {
  if (Vi(e))
    return e;
  if (gu(e))
    return XI(e);
  throw new Mc("val", ["Readable", "Iterable", "AsyncIterable"], e);
}
async function* XI(e) {
  Xl || (Xl = ku()), yield* Xl.prototype[xI].call(e);
}
async function ru(e, t, r, { end: o }) {
  let s, u = null;
  const f = (p) => {
    if (p && (s = p), u) {
      const b = u;
      u = null, b();
    }
  }, h = () => new MI((p, b) => {
    s ? b(s) : u = () => {
      s ? b(s) : p();
    };
  });
  t.on("drain", f);
  const l = Eu(
    t,
    {
      readable: !1
    },
    f
  );
  try {
    t.writableNeedDrain && await h();
    for await (const p of e)
      t.write(p) || await h();
    o && (t.end(), await h()), r();
  } catch (p) {
    r(s !== p ? kI(s, p) : p);
  } finally {
    l(), t.off("drain", f);
  }
}
async function ec(e, t, r, { end: o }) {
  Oo(t) && (t = t.writable);
  const s = t.getWriter();
  try {
    for await (const u of e)
      await s.ready, s.write(u).catch(() => {
      });
    await s.ready, o && await s.close(), r();
  } catch (u) {
    try {
      await s.abort(u), r(u);
    } catch (f) {
      r(f);
    }
  }
}
function ZI(...e) {
  return K_(e, jI(YI(e)));
}
function K_(e, t, r) {
  if (e.length === 1 && $I(e[0]) && (e = e[0]), e.length < 2)
    throw new FI("streams");
  const o = new JI(), s = o.signal, u = r == null ? void 0 : r.signal, f = [];
  GI(u, "options.signal");
  function h() {
    x(new qI());
  }
  Zl = Zl || yr.addAbortListener;
  let l;
  u && (l = Zl(u, h));
  let p, b;
  const w = [];
  let I = 0;
  function A(P) {
    x(P, --I === 0);
  }
  function x(P, S) {
    var m;
    if (P && (!p || p.code === "ERR_STREAM_PREMATURE_CLOSE") && (p = P), !(!p && !S)) {
      for (; w.length; )
        w.shift()(p);
      (m = l) === null || m === void 0 || m[DI](), o.abort(), S && (p || f.forEach((j) => j()), As.nextTick(t, p, b));
    }
  }
  let v;
  for (let P = 0; P < e.length; P++) {
    const S = e[P], m = P < e.length - 1, j = P > 0, Z = m || (r == null ? void 0 : r.end) !== !1, ce = P === e.length - 1;
    if ($p(S)) {
      let ae = function(ee) {
        ee && ee.name !== "AbortError" && ee.code !== "ERR_STREAM_PREMATURE_CLOSE" && A(ee);
      };
      if (Z) {
        const { destroy: ee, cleanup: Se } = Mp(S, m, j);
        w.push(ee), Kl(S) && ce && f.push(Se);
      }
      S.on("error", ae), Kl(S) && ce && f.push(() => {
        S.removeListener("error", ae);
      });
    }
    if (P === 0)
      if (typeof S == "function") {
        if (v = S({
          signal: s
        }), !Vi(v))
          throw new zl("Iterable, AsyncIterable or Stream", "source", v);
      } else Vi(S) || gu(S) || Oo(S) ? v = S : v = Np.from(S);
    else if (typeof S == "function") {
      if (Oo(v)) {
        var C;
        v = Ql((C = v) === null || C === void 0 ? void 0 : C.readable);
      } else
        v = Ql(v);
      if (v = S(v, {
        signal: s
      }), m) {
        if (!Vi(v, !0))
          throw new zl("AsyncIterable", `transform[${P - 1}]`, v);
      } else {
        var B;
        Yl || (Yl = z_);
        const ae = new Yl({
          objectMode: !0
        }), ee = (B = v) === null || B === void 0 ? void 0 : B.then;
        if (typeof ee == "function")
          I++, ee.call(
            v,
            (F) => {
              b = F, F != null && ae.write(F), Z && ae.end(), As.nextTick(A);
            },
            (F) => {
              ae.destroy(F), As.nextTick(A, F);
            }
          );
        else if (Vi(v, !0))
          I++, ru(v, ae, A, {
            end: Z
          });
        else if (Jl(v) || Oo(v)) {
          const F = v.readable || v;
          I++, ru(F, ae, A, {
            end: Z
          });
        } else
          throw new zl("AsyncIterable or Promise", "destination", v);
        v = ae;
        const { destroy: Se, cleanup: me } = Mp(v, !1, !0);
        w.push(Se), ce && f.push(me);
      }
    } else if ($p(S)) {
      if (gu(v)) {
        I += 2;
        const ae = QI(v, S, A, {
          end: Z
        });
        Kl(S) && ce && f.push(ae);
      } else if (Oo(v) || Jl(v)) {
        const ae = v.readable || v;
        I++, ru(ae, S, A, {
          end: Z
        });
      } else if (Vi(v))
        I++, ru(v, S, A, {
          end: Z
        });
      else
        throw new Mc(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          v
        );
      v = S;
    } else if (zI(S)) {
      if (gu(v))
        I++, ec(Ql(v), S, A, {
          end: Z
        });
      else if (Jl(v) || Vi(v))
        I++, ec(v, S, A, {
          end: Z
        });
      else if (Oo(v))
        I++, ec(v.readable, S, A, {
          end: Z
        });
      else
        throw new Mc(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          v
        );
      v = S;
    } else
      v = Np.from(S);
  }
  return (s != null && s.aborted || u != null && u.aborted) && As.nextTick(h), v;
}
function QI(e, t, r, { end: o }) {
  let s = !1;
  if (t.on("close", () => {
    s || r(new WI());
  }), e.pipe(t, {
    end: !1
  }), o) {
    let u = function() {
      s = !0, t.end();
    };
    KI(e) ? As.nextTick(u) : e.once("end", u);
  } else
    r();
  return Eu(
    e,
    {
      readable: !0,
      writable: !1
    },
    (u) => {
      const f = e._readableState;
      u && u.code === "ERR_STREAM_PREMATURE_CLOSE" && f && f.ended && !f.errored && !f.errorEmitted ? e.once("end", r).once("error", r) : r(u);
    }
  ), Eu(
    t,
    {
      readable: !1,
      writable: !0
    },
    r
  );
}
var fd = {
  pipelineImpl: K_,
  pipeline: ZI
};
const { pipeline: eO } = fd, nu = ei(), { destroyer: tO } = Ho, {
  isNodeStream: iu,
  isReadable: xp,
  isWritable: Dp,
  isWebStream: tc,
  isTransformStream: qi,
  isWritableStream: jp,
  isReadableStream: Up
} = ii, {
  AbortError: rO,
  codes: { ERR_INVALID_ARG_VALUE: kp, ERR_MISSING_ARGS: nO }
} = fr, iO = Ci;
var J_ = function(...t) {
  if (t.length === 0)
    throw new nO("streams");
  if (t.length === 1)
    return nu.from(t[0]);
  const r = [...t];
  if (typeof t[0] == "function" && (t[0] = nu.from(t[0])), typeof t[t.length - 1] == "function") {
    const A = t.length - 1;
    t[A] = nu.from(t[A]);
  }
  for (let A = 0; A < t.length; ++A)
    if (!(!iu(t[A]) && !tc(t[A]))) {
      if (A < t.length - 1 && !(xp(t[A]) || Up(t[A]) || qi(t[A])))
        throw new kp(`streams[${A}]`, r[A], "must be readable");
      if (A > 0 && !(Dp(t[A]) || jp(t[A]) || qi(t[A])))
        throw new kp(`streams[${A}]`, r[A], "must be writable");
    }
  let o, s, u, f, h;
  function l(A) {
    const x = f;
    f = null, x ? x(A) : A ? h.destroy(A) : !I && !w && h.destroy();
  }
  const p = t[0], b = eO(t, l), w = !!(Dp(p) || jp(p) || qi(p)), I = !!(xp(b) || Up(b) || qi(b));
  if (h = new nu({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(p != null && p.writableObjectMode),
    readableObjectMode: !!(b != null && b.readableObjectMode),
    writable: w,
    readable: I
  }), w) {
    if (iu(p))
      h._write = function(x, v, C) {
        p.write(x, v) ? C() : o = C;
      }, h._final = function(x) {
        p.end(), s = x;
      }, p.on("drain", function() {
        if (o) {
          const x = o;
          o = null, x();
        }
      });
    else if (tc(p)) {
      const v = (qi(p) ? p.writable : p).getWriter();
      h._write = async function(C, B, P) {
        try {
          await v.ready, v.write(C).catch(() => {
          }), P();
        } catch (S) {
          P(S);
        }
      }, h._final = async function(C) {
        try {
          await v.ready, v.close().catch(() => {
          }), s = C;
        } catch (B) {
          C(B);
        }
      };
    }
    const A = qi(b) ? b.readable : b;
    iO(A, () => {
      if (s) {
        const x = s;
        s = null, x();
      }
    });
  }
  if (I) {
    if (iu(b))
      b.on("readable", function() {
        if (u) {
          const A = u;
          u = null, A();
        }
      }), b.on("end", function() {
        h.push(null);
      }), h._read = function() {
        for (; ; ) {
          const A = b.read();
          if (A === null) {
            u = h._read;
            return;
          }
          if (!h.push(A))
            return;
        }
      };
    else if (tc(b)) {
      const x = (qi(b) ? b.readable : b).getReader();
      h._read = async function() {
        for (; ; )
          try {
            const { value: v, done: C } = await x.read();
            if (!h.push(v))
              return;
            if (C) {
              h.push(null);
              return;
            }
          } catch {
            return;
          }
      };
    }
  }
  return h._destroy = function(A, x) {
    !A && f !== null && (A = new rO()), u = null, o = null, s = null, f === null ? x(A) : (f = x, iu(b) && tO(b, A));
  }, h;
};
const oO = globalThis.AbortController || $s().AbortController, {
  codes: { ERR_INVALID_ARG_VALUE: sO, ERR_INVALID_ARG_TYPE: Ws, ERR_MISSING_ARGS: aO, ERR_OUT_OF_RANGE: uO },
  AbortError: Ln
} = fr, { validateAbortSignal: eo, validateInteger: Fp, validateObject: to } = Hs, fO = St.Symbol("kWeak"), lO = St.Symbol("kResistStopPropagation"), { finished: cO } = Ci, dO = J_, { addAbortSignalNoValidate: hO } = ju, { isWritable: gO, isNodeStream: pO } = ii, { deprecate: bO } = yr, {
  ArrayPrototypePush: _O,
  Boolean: yO,
  MathFloor: Hp,
  Number: wO,
  NumberIsNaN: mO,
  Promise: Wp,
  PromiseReject: qp,
  PromiseResolve: EO,
  PromisePrototypeThen: Vp,
  Symbol: Y_
} = St, vu = Y_("kEmpty"), Gp = Y_("kEof");
function vO(e, t) {
  if (t != null && to(t, "options"), (t == null ? void 0 : t.signal) != null && eo(t.signal, "options.signal"), pO(e) && !gO(e))
    throw new sO("stream", e, "must be writable");
  const r = dO(this, e);
  return t != null && t.signal && hO(t.signal, r), r;
}
function Fu(e, t) {
  if (typeof e != "function")
    throw new Ws("fn", ["Function", "AsyncFunction"], e);
  t != null && to(t, "options"), (t == null ? void 0 : t.signal) != null && eo(t.signal, "options.signal");
  let r = 1;
  (t == null ? void 0 : t.concurrency) != null && (r = Hp(t.concurrency));
  let o = r - 1;
  return (t == null ? void 0 : t.highWaterMark) != null && (o = Hp(t.highWaterMark)), Fp(r, "options.concurrency", 1), Fp(o, "options.highWaterMark", 0), o += r, (async function* () {
    const u = yr.AbortSignalAny(
      [t == null ? void 0 : t.signal].filter(yO)
    ), f = this, h = [], l = {
      signal: u
    };
    let p, b, w = !1, I = 0;
    function A() {
      w = !0, x();
    }
    function x() {
      I -= 1, v();
    }
    function v() {
      b && !w && I < r && h.length < o && (b(), b = null);
    }
    async function C() {
      try {
        for await (let B of f) {
          if (w)
            return;
          if (u.aborted)
            throw new Ln();
          try {
            if (B = e(B, l), B === vu)
              continue;
            B = EO(B);
          } catch (P) {
            B = qp(P);
          }
          I += 1, Vp(B, x, A), h.push(B), p && (p(), p = null), !w && (h.length >= o || I >= r) && await new Wp((P) => {
            b = P;
          });
        }
        h.push(Gp);
      } catch (B) {
        const P = qp(B);
        Vp(P, x, A), h.push(P);
      } finally {
        w = !0, p && (p(), p = null);
      }
    }
    C();
    try {
      for (; ; ) {
        for (; h.length > 0; ) {
          const B = await h[0];
          if (B === Gp)
            return;
          if (u.aborted)
            throw new Ln();
          B !== vu && (yield B), h.shift(), v();
        }
        await new Wp((B) => {
          p = B;
        });
      }
    } finally {
      w = !0, b && (b(), b = null);
    }
  }).call(this);
}
function SO(e = void 0) {
  return e != null && to(e, "options"), (e == null ? void 0 : e.signal) != null && eo(e.signal, "options.signal"), (async function* () {
    let r = 0;
    for await (const s of this) {
      var o;
      if (e != null && (o = e.signal) !== null && o !== void 0 && o.aborted)
        throw new Ln({
          cause: e.signal.reason
        });
      yield [r++, s];
    }
  }).call(this);
}
async function X_(e, t = void 0) {
  for await (const r of ld.call(this, e, t))
    return !0;
  return !1;
}
async function RO(e, t = void 0) {
  if (typeof e != "function")
    throw new Ws("fn", ["Function", "AsyncFunction"], e);
  return !await X_.call(
    this,
    async (...r) => !await e(...r),
    t
  );
}
async function AO(e, t) {
  for await (const r of ld.call(this, e, t))
    return r;
}
async function TO(e, t) {
  if (typeof e != "function")
    throw new Ws("fn", ["Function", "AsyncFunction"], e);
  async function r(o, s) {
    return await e(o, s), vu;
  }
  for await (const o of Fu.call(this, r, t)) ;
}
function ld(e, t) {
  if (typeof e != "function")
    throw new Ws("fn", ["Function", "AsyncFunction"], e);
  async function r(o, s) {
    return await e(o, s) ? o : vu;
  }
  return Fu.call(this, r, t);
}
class IO extends aO {
  constructor() {
    super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
  }
}
async function OO(e, t, r) {
  var o;
  if (typeof e != "function")
    throw new Ws("reducer", ["Function", "AsyncFunction"], e);
  r != null && to(r, "options"), (r == null ? void 0 : r.signal) != null && eo(r.signal, "options.signal");
  let s = arguments.length > 1;
  if (r != null && (o = r.signal) !== null && o !== void 0 && o.aborted) {
    const p = new Ln(void 0, {
      cause: r.signal.reason
    });
    throw this.once("error", () => {
    }), await cO(this.destroy(p)), p;
  }
  const u = new oO(), f = u.signal;
  if (r != null && r.signal) {
    const p = {
      once: !0,
      [fO]: this,
      [lO]: !0
    };
    r.signal.addEventListener("abort", () => u.abort(), p);
  }
  let h = !1;
  try {
    for await (const p of this) {
      var l;
      if (h = !0, r != null && (l = r.signal) !== null && l !== void 0 && l.aborted)
        throw new Ln();
      s ? t = await e(t, p, {
        signal: f
      }) : (t = p, s = !0);
    }
    if (!h && !s)
      throw new IO();
  } finally {
    u.abort();
  }
  return t;
}
async function CO(e) {
  e != null && to(e, "options"), (e == null ? void 0 : e.signal) != null && eo(e.signal, "options.signal");
  const t = [];
  for await (const o of this) {
    var r;
    if (e != null && (r = e.signal) !== null && r !== void 0 && r.aborted)
      throw new Ln(void 0, {
        cause: e.signal.reason
      });
    _O(t, o);
  }
  return t;
}
function LO(e, t) {
  const r = Fu.call(this, e, t);
  return (async function* () {
    for await (const s of r)
      yield* s;
  }).call(this);
}
function Z_(e) {
  if (e = wO(e), mO(e))
    return 0;
  if (e < 0)
    throw new uO("number", ">= 0", e);
  return e;
}
function PO(e, t = void 0) {
  return t != null && to(t, "options"), (t == null ? void 0 : t.signal) != null && eo(t.signal, "options.signal"), e = Z_(e), (async function* () {
    var o;
    if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
      throw new Ln();
    for await (const u of this) {
      var s;
      if (t != null && (s = t.signal) !== null && s !== void 0 && s.aborted)
        throw new Ln();
      e-- <= 0 && (yield u);
    }
  }).call(this);
}
function BO(e, t = void 0) {
  return t != null && to(t, "options"), (t == null ? void 0 : t.signal) != null && eo(t.signal, "options.signal"), e = Z_(e), (async function* () {
    var o;
    if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
      throw new Ln();
    for await (const u of this) {
      var s;
      if (t != null && (s = t.signal) !== null && s !== void 0 && s.aborted)
        throw new Ln();
      if (e-- > 0 && (yield u), e <= 0)
        return;
    }
  }).call(this);
}
td.streamReturningOperators = {
  asIndexedPairs: bO(SO, "readable.asIndexedPairs will be removed in a future version."),
  drop: PO,
  filter: ld,
  flatMap: LO,
  map: Fu,
  take: BO,
  compose: vO
};
td.promiseReturningOperators = {
  every: RO,
  forEach: TO,
  reduce: OO,
  toArray: CO,
  some: X_,
  find: AO
};
var rc, zp;
function Q_() {
  if (zp) return rc;
  zp = 1;
  const { ArrayPrototypePop: e, Promise: t } = St, { isIterable: r, isNodeStream: o, isWebStream: s } = ii, { pipelineImpl: u } = fd, { finished: f } = Ci;
  ey();
  function h(...l) {
    return new t((p, b) => {
      let w, I;
      const A = l[l.length - 1];
      if (A && typeof A == "object" && !o(A) && !r(A) && !s(A)) {
        const x = e(l);
        w = x.signal, I = x.end;
      }
      u(
        l,
        (x, v) => {
          x ? b(x) : p(v);
        },
        {
          signal: w,
          end: I
        }
      );
    });
  }
  return rc = {
    finished: f,
    pipeline: h
  }, rc;
}
var Kp;
function ey() {
  if (Kp) return Ul.exports;
  Kp = 1;
  const { Buffer: e } = _r, { ObjectDefineProperty: t, ObjectKeys: r, ReflectApply: o } = St, {
    promisify: { custom: s }
  } = yr, { streamReturningOperators: u, promiseReturningOperators: f } = td, {
    codes: { ERR_ILLEGAL_CONSTRUCTOR: h }
  } = fr, l = J_, { setDefaultHighWaterMark: p, getDefaultHighWaterMark: b } = Uu, { pipeline: w } = fd, { destroyer: I } = Ho, A = Ci, x = Q_(), v = ii, C = Ul.exports = od.Stream;
  C.isDestroyed = v.isDestroyed, C.isDisturbed = v.isDisturbed, C.isErrored = v.isErrored, C.isReadable = v.isReadable, C.isWritable = v.isWritable, C.Readable = ku();
  for (const P of r(u)) {
    let m = function(...j) {
      if (new.target)
        throw h();
      return C.Readable.from(o(S, this, j));
    };
    const S = u[P];
    t(m, "name", {
      __proto__: null,
      value: S.name
    }), t(m, "length", {
      __proto__: null,
      value: S.length
    }), t(C.Readable.prototype, P, {
      __proto__: null,
      value: m,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  for (const P of r(f)) {
    let m = function(...j) {
      if (new.target)
        throw h();
      return o(S, this, j);
    };
    const S = f[P];
    t(m, "name", {
      __proto__: null,
      value: S.name
    }), t(m, "length", {
      __proto__: null,
      value: S.length
    }), t(C.Readable.prototype, P, {
      __proto__: null,
      value: m,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  C.Writable = sd(), C.Duplex = ei(), C.Transform = V_, C.PassThrough = z_, C.pipeline = w;
  const { addAbortSignal: B } = ju;
  return C.addAbortSignal = B, C.finished = A, C.destroy = I, C.compose = l, C.setDefaultHighWaterMark = p, C.getDefaultHighWaterMark = b, t(C, "promises", {
    __proto__: null,
    configurable: !0,
    enumerable: !0,
    get() {
      return x;
    }
  }), t(w, s, {
    __proto__: null,
    enumerable: !0,
    get() {
      return x.pipeline;
    }
  }), t(A, s, {
    __proto__: null,
    enumerable: !0,
    get() {
      return x.finished;
    }
  }), C.Stream = C, C._isUint8Array = function(S) {
    return S instanceof Uint8Array;
  }, C._uint8ArrayToBuffer = function(S) {
    return e.from(S.buffer, S.byteOffset, S.byteLength);
  }, Ul.exports;
}
(function(e) {
  const t = ey(), r = Q_(), o = t.Readable.destroy;
  e.exports = t.Readable, e.exports._uint8ArrayToBuffer = t._uint8ArrayToBuffer, e.exports._isUint8Array = t._isUint8Array, e.exports.isDisturbed = t.isDisturbed, e.exports.isErrored = t.isErrored, e.exports.isReadable = t.isReadable, e.exports.Readable = t.Readable, e.exports.Writable = t.Writable, e.exports.Duplex = t.Duplex, e.exports.Transform = t.Transform, e.exports.PassThrough = t.PassThrough, e.exports.addAbortSignal = t.addAbortSignal, e.exports.finished = t.finished, e.exports.destroy = t.destroy, e.exports.destroy = o, e.exports.pipeline = t.pipeline, e.exports.compose = t.compose, Object.defineProperty(t, "promises", {
    configurable: !0,
    enumerable: !0,
    get() {
      return r;
    }
  }), e.exports.Stream = t.Stream, e.exports.default = e.exports;
})(qA);
var NO = {}, Ji = {}, cd = {}, qt = {};
class ty extends TypeError {
  constructor(t, r) {
    let o;
    const { message: s, explanation: u, ...f } = t, { path: h } = t, l = h.length === 0 ? s : `At path: ${h.join(".")} -- ${s}`;
    super(u ?? l), u != null && (this.cause = l), Object.assign(this, f), this.name = this.constructor.name, this.failures = () => o ?? (o = [t, ...r()]);
  }
}
function $O(e) {
  return qr(e) && typeof e[Symbol.iterator] == "function";
}
function qr(e) {
  return typeof e == "object" && e != null;
}
function Jp(e) {
  if (Object.prototype.toString.call(e) !== "[object Object]")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype;
}
function Dt(e) {
  return typeof e == "symbol" ? e.toString() : typeof e == "string" ? JSON.stringify(e) : `${e}`;
}
function MO(e) {
  const { done: t, value: r } = e.next();
  return t ? void 0 : r;
}
function xO(e, t, r, o) {
  if (e === !0)
    return;
  e === !1 ? e = {} : typeof e == "string" && (e = { message: e });
  const { path: s, branch: u } = t, { type: f } = r, { refinement: h, message: l = `Expected a value of type \`${f}\`${h ? ` with refinement \`${h}\`` : ""}, but received: \`${Dt(o)}\`` } = e;
  return {
    value: o,
    type: f,
    refinement: h,
    key: s[s.length - 1],
    path: s,
    branch: u,
    ...e,
    message: l
  };
}
function* xc(e, t, r, o) {
  $O(e) || (e = [e]);
  for (const s of e) {
    const u = xO(s, t, r, o);
    u && (yield u);
  }
}
function* dd(e, t, r = {}) {
  const { path: o = [], branch: s = [e], coerce: u = !1, mask: f = !1 } = r, h = { path: o, branch: s };
  if (u && (e = t.coercer(e, h), f && t.type !== "type" && qr(t.schema) && qr(e) && !Array.isArray(e)))
    for (const p in e)
      t.schema[p] === void 0 && delete e[p];
  let l = "valid";
  for (const p of t.validator(e, h))
    p.explanation = r.message, l = "not_valid", yield [p, void 0];
  for (let [p, b, w] of t.entries(e, h)) {
    const I = dd(b, w, {
      path: p === void 0 ? o : [...o, p],
      branch: p === void 0 ? s : [...s, b],
      coerce: u,
      mask: f,
      message: r.message
    });
    for (const A of I)
      A[0] ? (l = A[0].refinement != null ? "not_refined" : "not_valid", yield [A[0], void 0]) : u && (b = A[1], p === void 0 ? e = b : e instanceof Map ? e.set(p, b) : e instanceof Set ? e.add(b) : qr(e) && (b !== void 0 || p in e) && (e[p] = b));
  }
  if (l !== "not_valid")
    for (const p of t.refiner(e, h))
      p.explanation = r.message, l = "not_refined", yield [p, void 0];
  l === "valid" && (yield [void 0, e]);
}
class Lt {
  constructor(t) {
    const { type: r, schema: o, validator: s, refiner: u, coercer: f = (l) => l, entries: h = function* () {
    } } = t;
    this.type = r, this.schema = o, this.entries = h, this.coercer = f, s ? this.validator = (l, p) => {
      const b = s(l, p);
      return xc(b, p, this, l);
    } : this.validator = () => [], u ? this.refiner = (l, p) => {
      const b = u(l, p);
      return xc(b, p, this, l);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(t, r) {
    return ry(t, this, r);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(t, r) {
    return ny(t, this, r);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(t) {
    return hd(t, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(t, r) {
    return iy(t, this, r);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(t, r = {}) {
    return Wo(t, this, r);
  }
}
function ry(e, t, r) {
  const o = Wo(e, t, { message: r });
  if (o[0])
    throw o[0];
}
function ny(e, t, r) {
  const o = Wo(e, t, { coerce: !0, message: r });
  if (o[0])
    throw o[0];
  return o[1];
}
function iy(e, t, r) {
  const o = Wo(e, t, { coerce: !0, mask: !0, message: r });
  if (o[0])
    throw o[0];
  return o[1];
}
function hd(e, t) {
  return !Wo(e, t)[0];
}
function Wo(e, t, r = {}) {
  const o = dd(e, t, r), s = MO(o);
  return s[0] ? [new ty(s[0], function* () {
    for (const f of o)
      f[0] && (yield f[0]);
  }), void 0] : [void 0, s[1]];
}
function DO(...e) {
  const t = e[0].type === "type", r = e.map((s) => s.schema), o = Object.assign({}, ...r);
  return t ? Vs(o) : qs(o);
}
function wr(e, t) {
  return new Lt({ type: e, schema: null, validator: t });
}
function jO(e, t) {
  return new Lt({
    ...e,
    refiner: (r, o) => r === void 0 || e.refiner(r, o),
    validator(r, o) {
      return r === void 0 ? !0 : (t(r, o), e.validator(r, o));
    }
  });
}
function UO(e) {
  return new Lt({
    type: "dynamic",
    schema: null,
    *entries(t, r) {
      yield* e(t, r).entries(t, r);
    },
    validator(t, r) {
      return e(t, r).validator(t, r);
    },
    coercer(t, r) {
      return e(t, r).coercer(t, r);
    },
    refiner(t, r) {
      return e(t, r).refiner(t, r);
    }
  });
}
function kO(e) {
  let t;
  return new Lt({
    type: "lazy",
    schema: null,
    *entries(r, o) {
      t ?? (t = e()), yield* t.entries(r, o);
    },
    validator(r, o) {
      return t ?? (t = e()), t.validator(r, o);
    },
    coercer(r, o) {
      return t ?? (t = e()), t.coercer(r, o);
    },
    refiner(r, o) {
      return t ?? (t = e()), t.refiner(r, o);
    }
  });
}
function FO(e, t) {
  const { schema: r } = e, o = { ...r };
  for (const s of t)
    delete o[s];
  switch (e.type) {
    case "type":
      return Vs(o);
    default:
      return qs(o);
  }
}
function HO(e) {
  const t = e instanceof Lt, r = t ? { ...e.schema } : { ...e };
  for (const o in r)
    r[o] = oy(r[o]);
  return t && e.type === "type" ? Vs(r) : qs(r);
}
function WO(e, t) {
  const { schema: r } = e, o = {};
  for (const s of t)
    o[s] = r[s];
  switch (e.type) {
    case "type":
      return Vs(o);
    default:
      return qs(o);
  }
}
function qO(e, t) {
  return console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`."), wr(e, t);
}
function VO() {
  return wr("any", () => !0);
}
function GO(e) {
  return new Lt({
    type: "array",
    schema: e,
    *entries(t) {
      if (e && Array.isArray(t))
        for (const [r, o] of t.entries())
          yield [r, o, e];
    },
    coercer(t) {
      return Array.isArray(t) ? t.slice() : t;
    },
    validator(t) {
      return Array.isArray(t) || `Expected an array value, but received: ${Dt(t)}`;
    }
  });
}
function zO() {
  return wr("bigint", (e) => typeof e == "bigint");
}
function KO() {
  return wr("boolean", (e) => typeof e == "boolean");
}
function JO() {
  return wr("date", (e) => e instanceof Date && !isNaN(e.getTime()) || `Expected a valid \`Date\` object, but received: ${Dt(e)}`);
}
function YO(e) {
  const t = {}, r = e.map((o) => Dt(o)).join();
  for (const o of e)
    t[o] = o;
  return new Lt({
    type: "enums",
    schema: t,
    validator(o) {
      return e.includes(o) || `Expected one of \`${r}\`, but received: ${Dt(o)}`;
    }
  });
}
function XO() {
  return wr("func", (e) => typeof e == "function" || `Expected a function, but received: ${Dt(e)}`);
}
function ZO(e) {
  return wr("instance", (t) => t instanceof e || `Expected a \`${e.name}\` instance, but received: ${Dt(t)}`);
}
function QO() {
  return wr("integer", (e) => typeof e == "number" && !isNaN(e) && Number.isInteger(e) || `Expected an integer, but received: ${Dt(e)}`);
}
function e2(e) {
  return new Lt({
    type: "intersection",
    schema: null,
    *entries(t, r) {
      for (const o of e)
        yield* o.entries(t, r);
    },
    *validator(t, r) {
      for (const o of e)
        yield* o.validator(t, r);
    },
    *refiner(t, r) {
      for (const o of e)
        yield* o.refiner(t, r);
    }
  });
}
function t2(e) {
  const t = Dt(e), r = typeof e;
  return new Lt({
    type: "literal",
    schema: r === "string" || r === "number" || r === "boolean" ? e : null,
    validator(o) {
      return o === e || `Expected the literal \`${t}\`, but received: ${Dt(o)}`;
    }
  });
}
function r2(e, t) {
  return new Lt({
    type: "map",
    schema: null,
    *entries(r) {
      if (e && t && r instanceof Map)
        for (const [o, s] of r.entries())
          yield [o, o, e], yield [o, s, t];
    },
    coercer(r) {
      return r instanceof Map ? new Map(r) : r;
    },
    validator(r) {
      return r instanceof Map || `Expected a \`Map\` object, but received: ${Dt(r)}`;
    }
  });
}
function gd() {
  return wr("never", () => !1);
}
function n2(e) {
  return new Lt({
    ...e,
    validator: (t, r) => t === null || e.validator(t, r),
    refiner: (t, r) => t === null || e.refiner(t, r)
  });
}
function i2() {
  return wr("number", (e) => typeof e == "number" && !isNaN(e) || `Expected a number, but received: ${Dt(e)}`);
}
function qs(e) {
  const t = e ? Object.keys(e) : [], r = gd();
  return new Lt({
    type: "object",
    schema: e || null,
    *entries(o) {
      if (e && qr(o)) {
        const s = new Set(Object.keys(o));
        for (const u of t)
          s.delete(u), yield [u, o[u], e[u]];
        for (const u of s)
          yield [u, o[u], r];
      }
    },
    validator(o) {
      return qr(o) || `Expected an object, but received: ${Dt(o)}`;
    },
    coercer(o) {
      return qr(o) ? { ...o } : o;
    }
  });
}
function oy(e) {
  return new Lt({
    ...e,
    validator: (t, r) => t === void 0 || e.validator(t, r),
    refiner: (t, r) => t === void 0 || e.refiner(t, r)
  });
}
function o2(e, t) {
  return new Lt({
    type: "record",
    schema: null,
    *entries(r) {
      if (qr(r))
        for (const o in r) {
          const s = r[o];
          yield [o, o, e], yield [o, s, t];
        }
    },
    validator(r) {
      return qr(r) || `Expected an object, but received: ${Dt(r)}`;
    }
  });
}
function s2() {
  return wr("regexp", (e) => e instanceof RegExp);
}
function a2(e) {
  return new Lt({
    type: "set",
    schema: null,
    *entries(t) {
      if (e && t instanceof Set)
        for (const r of t)
          yield [r, r, e];
    },
    coercer(t) {
      return t instanceof Set ? new Set(t) : t;
    },
    validator(t) {
      return t instanceof Set || `Expected a \`Set\` object, but received: ${Dt(t)}`;
    }
  });
}
function sy() {
  return wr("string", (e) => typeof e == "string" || `Expected a string, but received: ${Dt(e)}`);
}
function u2(e) {
  const t = gd();
  return new Lt({
    type: "tuple",
    schema: null,
    *entries(r) {
      if (Array.isArray(r)) {
        const o = Math.max(e.length, r.length);
        for (let s = 0; s < o; s++)
          yield [s, r[s], e[s] || t];
      }
    },
    validator(r) {
      return Array.isArray(r) || `Expected an array, but received: ${Dt(r)}`;
    }
  });
}
function Vs(e) {
  const t = Object.keys(e);
  return new Lt({
    type: "type",
    schema: e,
    *entries(r) {
      if (qr(r))
        for (const o of t)
          yield [o, r[o], e[o]];
    },
    validator(r) {
      return qr(r) || `Expected an object, but received: ${Dt(r)}`;
    },
    coercer(r) {
      return qr(r) ? { ...r } : r;
    }
  });
}
function f2(e) {
  const t = e.map((r) => r.type).join(" | ");
  return new Lt({
    type: "union",
    schema: null,
    coercer(r) {
      for (const o of e) {
        const [s, u] = o.validate(r, { coerce: !0 });
        if (!s)
          return u;
      }
      return r;
    },
    validator(r, o) {
      const s = [];
      for (const u of e) {
        const [...f] = dd(r, u, o), [h] = f;
        if (h[0])
          for (const [l] of f)
            l && s.push(l);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${t}\`, but received: ${Dt(r)}`,
        ...s
      ];
    }
  });
}
function ay() {
  return wr("unknown", () => !0);
}
function pd(e, t, r) {
  return new Lt({
    ...e,
    coercer: (o, s) => hd(o, t) ? e.coercer(r(o, s), s) : e.coercer(o, s)
  });
}
function l2(e, t, r = {}) {
  return pd(e, ay(), (o) => {
    const s = typeof t == "function" ? t() : t;
    if (o === void 0)
      return s;
    if (!r.strict && Jp(o) && Jp(s)) {
      const u = { ...o };
      let f = !1;
      for (const h in s)
        u[h] === void 0 && (u[h] = s[h], f = !0);
      if (f)
        return u;
    }
    return o;
  });
}
function c2(e) {
  return pd(e, sy(), (t) => t.trim());
}
function d2(e) {
  return ro(e, "empty", (t) => {
    const r = uy(t);
    return r === 0 || `Expected an empty ${e.type} but received one with a size of \`${r}\``;
  });
}
function uy(e) {
  return e instanceof Map || e instanceof Set ? e.size : e.length;
}
function h2(e, t, r = {}) {
  const { exclusive: o } = r;
  return ro(e, "max", (s) => o ? s < t : s <= t || `Expected a ${e.type} less than ${o ? "" : "or equal to "}${t} but received \`${s}\``);
}
function g2(e, t, r = {}) {
  const { exclusive: o } = r;
  return ro(e, "min", (s) => o ? s > t : s >= t || `Expected a ${e.type} greater than ${o ? "" : "or equal to "}${t} but received \`${s}\``);
}
function p2(e) {
  return ro(e, "nonempty", (t) => uy(t) > 0 || `Expected a nonempty ${e.type} but received an empty one`);
}
function b2(e, t) {
  return ro(e, "pattern", (r) => t.test(r) || `Expected a ${e.type} matching \`/${t.source}/\` but received "${r}"`);
}
function _2(e, t, r = t) {
  const o = `Expected a ${e.type}`, s = t === r ? `of \`${t}\`` : `between \`${t}\` and \`${r}\``;
  return ro(e, "size", (u) => {
    if (typeof u == "number" || u instanceof Date)
      return t <= u && u <= r || `${o} ${s} but received \`${u}\``;
    if (u instanceof Map || u instanceof Set) {
      const { size: f } = u;
      return t <= f && f <= r || `${o} with a size ${s} but received one with a size of \`${f}\``;
    } else {
      const { length: f } = u;
      return t <= f && f <= r || `${o} with a length ${s} but received one with a length of \`${f}\``;
    }
  });
}
function ro(e, t, r) {
  return new Lt({
    ...e,
    *refiner(o, s) {
      yield* e.refiner(o, s);
      const u = r(o, s), f = xc(u, s, e, o);
      for (const h of f)
        yield { ...h, refinement: t };
    }
  });
}
const y2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Struct: Lt,
  StructError: ty,
  any: VO,
  array: GO,
  assert: ry,
  assign: DO,
  bigint: zO,
  boolean: KO,
  coerce: pd,
  create: ny,
  date: JO,
  defaulted: l2,
  define: wr,
  deprecated: jO,
  dynamic: UO,
  empty: d2,
  enums: YO,
  func: XO,
  instance: ZO,
  integer: QO,
  intersection: e2,
  is: hd,
  lazy: kO,
  literal: t2,
  map: r2,
  mask: iy,
  max: h2,
  min: g2,
  never: gd,
  nonempty: p2,
  nullable: n2,
  number: i2,
  object: qs,
  omit: FO,
  optional: oy,
  partial: HO,
  pattern: b2,
  pick: WO,
  record: o2,
  refine: ro,
  regexp: s2,
  set: a2,
  size: _2,
  string: sy,
  struct: qO,
  trimmed: c2,
  tuple: u2,
  type: Vs,
  union: f2,
  unknown: ay,
  validate: Wo
}, Symbol.toStringTag, { value: "Module" })), no = /* @__PURE__ */ q1(y2);
Object.defineProperty(qt, "__esModule", { value: !0 });
qt.assertExhaustive = qt.assertStruct = qt.assert = qt.AssertionError = void 0;
const w2 = no;
function m2(e) {
  return typeof e == "object" && e !== null && "message" in e;
}
function E2(e) {
  var t, r;
  return typeof ((r = (t = e == null ? void 0 : e.prototype) === null || t === void 0 ? void 0 : t.constructor) === null || r === void 0 ? void 0 : r.name) == "string";
}
function v2(e) {
  const t = m2(e) ? e.message : String(e);
  return t.endsWith(".") ? t.slice(0, -1) : t;
}
function fy(e, t) {
  return E2(e) ? new e({
    message: t
  }) : e({
    message: t
  });
}
class bd extends Error {
  constructor(t) {
    super(t.message), this.code = "ERR_ASSERTION";
  }
}
qt.AssertionError = bd;
function S2(e, t = "Assertion failed.", r = bd) {
  if (!e)
    throw t instanceof Error ? t : fy(r, t);
}
qt.assert = S2;
function R2(e, t, r = "Assertion failed", o = bd) {
  try {
    (0, w2.assert)(e, t);
  } catch (s) {
    throw fy(o, `${r}: ${v2(s)}.`);
  }
}
qt.assertStruct = R2;
function A2(e) {
  throw new Error("Invalid branch reached. Should be detected during compilation.");
}
qt.assertExhaustive = A2;
var Gs = {};
Object.defineProperty(Gs, "__esModule", { value: !0 });
Gs.base64 = void 0;
const T2 = no, I2 = qt, O2 = (e, t = {}) => {
  var r, o;
  const s = (r = t.paddingRequired) !== null && r !== void 0 ? r : !1, u = (o = t.characterSet) !== null && o !== void 0 ? o : "base64";
  let f;
  u === "base64" ? f = String.raw`[A-Za-z0-9+\/]` : ((0, I2.assert)(u === "base64url"), f = String.raw`[-_A-Za-z0-9]`);
  let h;
  return s ? h = new RegExp(`^(?:${f}{4})*(?:${f}{3}=|${f}{2}==)?$`, "u") : h = new RegExp(`^(?:${f}{4})*(?:${f}{2,3}|${f}{3}=|${f}{2}==)?$`, "u"), (0, T2.pattern)(e, h);
};
Gs.base64 = O2;
var Qe = {}, zs = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.remove0x = e.add0x = e.assertIsStrictHexString = e.assertIsHexString = e.isStrictHexString = e.isHexString = e.StrictHexStruct = e.HexStruct = void 0;
  const t = no, r = qt;
  e.HexStruct = (0, t.pattern)((0, t.string)(), /^(?:0x)?[0-9a-f]+$/iu), e.StrictHexStruct = (0, t.pattern)((0, t.string)(), /^0x[0-9a-f]+$/iu);
  function o(p) {
    return (0, t.is)(p, e.HexStruct);
  }
  e.isHexString = o;
  function s(p) {
    return (0, t.is)(p, e.StrictHexStruct);
  }
  e.isStrictHexString = s;
  function u(p) {
    (0, r.assert)(o(p), "Value must be a hexadecimal string.");
  }
  e.assertIsHexString = u;
  function f(p) {
    (0, r.assert)(s(p), 'Value must be a hexadecimal string, starting with "0x".');
  }
  e.assertIsStrictHexString = f;
  function h(p) {
    return p.startsWith("0x") ? p : p.startsWith("0X") ? `0x${p.substring(2)}` : `0x${p}`;
  }
  e.add0x = h;
  function l(p) {
    return p.startsWith("0x") || p.startsWith("0X") ? p.substring(2) : p;
  }
  e.remove0x = l;
})(zs);
Object.defineProperty(Qe, "__esModule", { value: !0 });
Qe.createDataView = Qe.concatBytes = Qe.valueToBytes = Qe.stringToBytes = Qe.numberToBytes = Qe.signedBigIntToBytes = Qe.bigIntToBytes = Qe.hexToBytes = Qe.bytesToString = Qe.bytesToNumber = Qe.bytesToSignedBigInt = Qe.bytesToBigInt = Qe.bytesToHex = Qe.assertIsBytes = Qe.isBytes = void 0;
const Cr = qt, Dc = zs, Yp = 48, Xp = 58, Zp = 87;
function C2() {
  const e = [];
  return () => {
    if (e.length === 0)
      for (let t = 0; t < 256; t++)
        e.push(t.toString(16).padStart(2, "0"));
    return e;
  };
}
const L2 = C2();
function _d(e) {
  return e instanceof Uint8Array;
}
Qe.isBytes = _d;
function qo(e) {
  (0, Cr.assert)(_d(e), "Value must be a Uint8Array.");
}
Qe.assertIsBytes = qo;
function ly(e) {
  if (qo(e), e.length === 0)
    return "0x";
  const t = L2(), r = new Array(e.length);
  for (let o = 0; o < e.length; o++)
    r[o] = t[e[o]];
  return (0, Dc.add0x)(r.join(""));
}
Qe.bytesToHex = ly;
function cy(e) {
  qo(e);
  const t = ly(e);
  return BigInt(t);
}
Qe.bytesToBigInt = cy;
function P2(e) {
  qo(e);
  let t = BigInt(0);
  for (const r of e)
    t = (t << BigInt(8)) + BigInt(r);
  return BigInt.asIntN(e.length * 8, t);
}
Qe.bytesToSignedBigInt = P2;
function B2(e) {
  qo(e);
  const t = cy(e);
  return (0, Cr.assert)(t <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead."), Number(t);
}
Qe.bytesToNumber = B2;
function N2(e) {
  return qo(e), new TextDecoder().decode(e);
}
Qe.bytesToString = N2;
function Hu(e) {
  var t;
  if (((t = e == null ? void 0 : e.toLowerCase) === null || t === void 0 ? void 0 : t.call(e)) === "0x")
    return new Uint8Array();
  (0, Dc.assertIsHexString)(e);
  const r = (0, Dc.remove0x)(e).toLowerCase(), o = r.length % 2 === 0 ? r : `0${r}`, s = new Uint8Array(o.length / 2);
  for (let u = 0; u < s.length; u++) {
    const f = o.charCodeAt(u * 2), h = o.charCodeAt(u * 2 + 1), l = f - (f < Xp ? Yp : Zp), p = h - (h < Xp ? Yp : Zp);
    s[u] = l * 16 + p;
  }
  return s;
}
Qe.hexToBytes = Hu;
function dy(e) {
  (0, Cr.assert)(typeof e == "bigint", "Value must be a bigint."), (0, Cr.assert)(e >= BigInt(0), "Value must be a non-negative bigint.");
  const t = e.toString(16);
  return Hu(t);
}
Qe.bigIntToBytes = dy;
function $2(e, t) {
  (0, Cr.assert)(t > 0);
  const r = e >> BigInt(31);
  return !((~e & r) + (e & ~r) >> BigInt(t * 8 + -1));
}
function M2(e, t) {
  (0, Cr.assert)(typeof e == "bigint", "Value must be a bigint."), (0, Cr.assert)(typeof t == "number", "Byte length must be a number."), (0, Cr.assert)(t > 0, "Byte length must be greater than 0."), (0, Cr.assert)($2(e, t), "Byte length is too small to represent the given value.");
  let r = e;
  const o = new Uint8Array(t);
  for (let s = 0; s < o.length; s++)
    o[s] = Number(BigInt.asUintN(8, r)), r >>= BigInt(8);
  return o.reverse();
}
Qe.signedBigIntToBytes = M2;
function hy(e) {
  (0, Cr.assert)(typeof e == "number", "Value must be a number."), (0, Cr.assert)(e >= 0, "Value must be a non-negative number."), (0, Cr.assert)(Number.isSafeInteger(e), "Value is not a safe integer. Use `bigIntToBytes` instead.");
  const t = e.toString(16);
  return Hu(t);
}
Qe.numberToBytes = hy;
function gy(e) {
  return (0, Cr.assert)(typeof e == "string", "Value must be a string."), new TextEncoder().encode(e);
}
Qe.stringToBytes = gy;
function py(e) {
  if (typeof e == "bigint")
    return dy(e);
  if (typeof e == "number")
    return hy(e);
  if (typeof e == "string")
    return e.startsWith("0x") ? Hu(e) : gy(e);
  if (_d(e))
    return e;
  throw new TypeError(`Unsupported value type: "${typeof e}".`);
}
Qe.valueToBytes = py;
function x2(e) {
  const t = new Array(e.length);
  let r = 0;
  for (let s = 0; s < e.length; s++) {
    const u = py(e[s]);
    t[s] = u, r += u.length;
  }
  const o = new Uint8Array(r);
  for (let s = 0, u = 0; s < t.length; s++)
    o.set(t[s], u), u += t[s].length;
  return o;
}
Qe.concatBytes = x2;
function D2(e) {
  if (typeof le.Buffer < "u" && e instanceof le.Buffer) {
    const t = e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
    return new DataView(t);
  }
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
Qe.createDataView = D2;
var Wu = {};
Object.defineProperty(Wu, "__esModule", { value: !0 });
Wu.ChecksumStruct = void 0;
const Qp = no, j2 = Gs;
Wu.ChecksumStruct = (0, Qp.size)((0, j2.base64)((0, Qp.string)(), { paddingRequired: !0 }), 44, 44);
var Rn = {};
Object.defineProperty(Rn, "__esModule", { value: !0 });
Rn.createHex = Rn.createBytes = Rn.createBigInt = Rn.createNumber = void 0;
const vt = no, U2 = qt, by = Qe, qu = zs, _y = (0, vt.union)([(0, vt.number)(), (0, vt.bigint)(), (0, vt.string)(), qu.StrictHexStruct]), k2 = (0, vt.coerce)((0, vt.number)(), _y, Number), F2 = (0, vt.coerce)((0, vt.bigint)(), _y, BigInt);
(0, vt.union)([qu.StrictHexStruct, (0, vt.instance)(Uint8Array)]);
const H2 = (0, vt.coerce)((0, vt.instance)(Uint8Array), (0, vt.union)([qu.StrictHexStruct]), by.hexToBytes), W2 = (0, vt.coerce)(qu.StrictHexStruct, (0, vt.instance)(Uint8Array), by.bytesToHex);
function q2(e) {
  try {
    const t = (0, vt.create)(e, k2);
    return (0, U2.assert)(Number.isFinite(t), `Expected a number-like value, got "${e}".`), t;
  } catch (t) {
    throw t instanceof vt.StructError ? new Error(`Expected a number-like value, got "${e}".`) : t;
  }
}
Rn.createNumber = q2;
function V2(e) {
  try {
    return (0, vt.create)(e, F2);
  } catch (t) {
    throw t instanceof vt.StructError ? new Error(`Expected a number-like value, got "${String(t.value)}".`) : t;
  }
}
Rn.createBigInt = V2;
function G2(e) {
  if (typeof e == "string" && e.toLowerCase() === "0x")
    return new Uint8Array();
  try {
    return (0, vt.create)(e, H2);
  } catch (t) {
    throw t instanceof vt.StructError ? new Error(`Expected a bytes-like value, got "${String(t.value)}".`) : t;
  }
}
Rn.createBytes = G2;
function z2(e) {
  if (e instanceof Uint8Array && e.length === 0 || typeof e == "string" && e.toLowerCase() === "0x")
    return "0x";
  try {
    return (0, vt.create)(e, W2);
  } catch (t) {
    throw t instanceof vt.StructError ? new Error(`Expected a bytes-like value, got "${String(t.value)}".`) : t;
  }
}
Rn.createHex = z2;
var xo = {}, yy = Ye && Ye.__classPrivateFieldSet || function(e, t, r, o, s) {
  if (o === "m") throw new TypeError("Private method is not writable");
  if (o === "a" && !s) throw new TypeError("Private accessor was defined without a setter");
  if (typeof t == "function" ? e !== t || !s : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return o === "a" ? s.call(e, r) : s ? s.value = r : t.set(e, r), r;
}, ur = Ye && Ye.__classPrivateFieldGet || function(e, t, r, o) {
  if (r === "a" && !o) throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !o : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? o : r === "a" ? o.call(e) : o ? o.value : t.get(e);
}, nn, En;
Object.defineProperty(xo, "__esModule", { value: !0 });
xo.FrozenSet = xo.FrozenMap = void 0;
class yd {
  constructor(t) {
    nn.set(this, void 0), yy(this, nn, new Map(t), "f"), Object.freeze(this);
  }
  get size() {
    return ur(this, nn, "f").size;
  }
  [(nn = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return ur(this, nn, "f")[Symbol.iterator]();
  }
  entries() {
    return ur(this, nn, "f").entries();
  }
  forEach(t, r) {
    return ur(this, nn, "f").forEach((o, s, u) => t.call(r, o, s, this));
  }
  get(t) {
    return ur(this, nn, "f").get(t);
  }
  has(t) {
    return ur(this, nn, "f").has(t);
  }
  keys() {
    return ur(this, nn, "f").keys();
  }
  values() {
    return ur(this, nn, "f").values();
  }
  toString() {
    return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([t, r]) => `${String(t)} => ${String(r)}`).join(", ")} ` : ""}}`;
  }
}
xo.FrozenMap = yd;
class wd {
  constructor(t) {
    En.set(this, void 0), yy(this, En, new Set(t), "f"), Object.freeze(this);
  }
  get size() {
    return ur(this, En, "f").size;
  }
  [(En = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return ur(this, En, "f")[Symbol.iterator]();
  }
  entries() {
    return ur(this, En, "f").entries();
  }
  forEach(t, r) {
    return ur(this, En, "f").forEach((o, s, u) => t.call(r, o, s, this));
  }
  has(t) {
    return ur(this, En, "f").has(t);
  }
  keys() {
    return ur(this, En, "f").keys();
  }
  values() {
    return ur(this, En, "f").values();
  }
  toString() {
    return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((t) => String(t)).join(", ")} ` : ""}}`;
  }
}
xo.FrozenSet = wd;
Object.freeze(yd);
Object.freeze(yd.prototype);
Object.freeze(wd);
Object.freeze(wd.prototype);
var wy = {};
Object.defineProperty(wy, "__esModule", { value: !0 });
var my = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getJsonRpcIdValidator = e.assertIsJsonRpcError = e.isJsonRpcError = e.assertIsJsonRpcFailure = e.isJsonRpcFailure = e.assertIsJsonRpcSuccess = e.isJsonRpcSuccess = e.assertIsJsonRpcResponse = e.isJsonRpcResponse = e.assertIsPendingJsonRpcResponse = e.isPendingJsonRpcResponse = e.JsonRpcResponseStruct = e.JsonRpcFailureStruct = e.JsonRpcSuccessStruct = e.PendingJsonRpcResponseStruct = e.assertIsJsonRpcRequest = e.isJsonRpcRequest = e.assertIsJsonRpcNotification = e.isJsonRpcNotification = e.JsonRpcNotificationStruct = e.JsonRpcRequestStruct = e.JsonRpcParamsStruct = e.JsonRpcErrorStruct = e.JsonRpcIdStruct = e.JsonRpcVersionStruct = e.jsonrpc2 = e.getJsonSize = e.isValidJson = e.JsonStruct = e.UnsafeJsonStruct = void 0;
  const t = no, r = qt, o = () => (0, t.define)("finite number", (j) => (0, t.is)(j, (0, t.number)()) && Number.isFinite(j));
  e.UnsafeJsonStruct = (0, t.union)([
    (0, t.literal)(null),
    (0, t.boolean)(),
    o(),
    (0, t.string)(),
    (0, t.array)((0, t.lazy)(() => e.UnsafeJsonStruct)),
    (0, t.record)((0, t.string)(), (0, t.lazy)(() => e.UnsafeJsonStruct))
  ]), e.JsonStruct = (0, t.define)("Json", (j, Z) => {
    function ce(ae, ee) {
      const me = [...ee.validator(ae, Z)];
      return me.length > 0 ? me : !0;
    }
    try {
      const ae = ce(j, e.UnsafeJsonStruct);
      return ae !== !0 ? ae : ce(JSON.parse(JSON.stringify(j)), e.UnsafeJsonStruct);
    } catch (ae) {
      return ae instanceof RangeError ? "Circular reference detected" : !1;
    }
  });
  function s(j) {
    return (0, t.is)(j, e.JsonStruct);
  }
  e.isValidJson = s;
  function u(j) {
    (0, r.assertStruct)(j, e.JsonStruct, "Invalid JSON value");
    const Z = JSON.stringify(j);
    return new TextEncoder().encode(Z).byteLength;
  }
  e.getJsonSize = u, e.jsonrpc2 = "2.0", e.JsonRpcVersionStruct = (0, t.literal)(e.jsonrpc2), e.JsonRpcIdStruct = (0, t.nullable)((0, t.union)([(0, t.number)(), (0, t.string)()])), e.JsonRpcErrorStruct = (0, t.object)({
    code: (0, t.integer)(),
    message: (0, t.string)(),
    data: (0, t.optional)(e.JsonStruct),
    stack: (0, t.optional)((0, t.string)())
  }), e.JsonRpcParamsStruct = (0, t.optional)((0, t.union)([(0, t.record)((0, t.string)(), e.JsonStruct), (0, t.array)(e.JsonStruct)])), e.JsonRpcRequestStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    method: (0, t.string)(),
    params: e.JsonRpcParamsStruct
  }), e.JsonRpcNotificationStruct = (0, t.omit)(e.JsonRpcRequestStruct, ["id"]);
  function f(j) {
    return (0, t.is)(j, e.JsonRpcNotificationStruct);
  }
  e.isJsonRpcNotification = f;
  function h(j, Z) {
    (0, r.assertStruct)(j, e.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", Z);
  }
  e.assertIsJsonRpcNotification = h;
  function l(j) {
    return (0, t.is)(j, e.JsonRpcRequestStruct);
  }
  e.isJsonRpcRequest = l;
  function p(j, Z) {
    (0, r.assertStruct)(j, e.JsonRpcRequestStruct, "Invalid JSON-RPC request", Z);
  }
  e.assertIsJsonRpcRequest = p, e.PendingJsonRpcResponseStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    result: (0, t.optional)((0, t.unknown)()),
    error: (0, t.optional)(e.JsonRpcErrorStruct)
  }), e.JsonRpcSuccessStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    result: e.JsonStruct
  }), e.JsonRpcFailureStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    error: e.JsonRpcErrorStruct
  }), e.JsonRpcResponseStruct = (0, t.union)([
    e.JsonRpcSuccessStruct,
    e.JsonRpcFailureStruct
  ]);
  function b(j) {
    return (0, t.is)(j, e.PendingJsonRpcResponseStruct);
  }
  e.isPendingJsonRpcResponse = b;
  function w(j, Z) {
    (0, r.assertStruct)(j, e.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", Z);
  }
  e.assertIsPendingJsonRpcResponse = w;
  function I(j) {
    return (0, t.is)(j, e.JsonRpcResponseStruct);
  }
  e.isJsonRpcResponse = I;
  function A(j, Z) {
    (0, r.assertStruct)(j, e.JsonRpcResponseStruct, "Invalid JSON-RPC response", Z);
  }
  e.assertIsJsonRpcResponse = A;
  function x(j) {
    return (0, t.is)(j, e.JsonRpcSuccessStruct);
  }
  e.isJsonRpcSuccess = x;
  function v(j, Z) {
    (0, r.assertStruct)(j, e.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", Z);
  }
  e.assertIsJsonRpcSuccess = v;
  function C(j) {
    return (0, t.is)(j, e.JsonRpcFailureStruct);
  }
  e.isJsonRpcFailure = C;
  function B(j, Z) {
    (0, r.assertStruct)(j, e.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", Z);
  }
  e.assertIsJsonRpcFailure = B;
  function P(j) {
    return (0, t.is)(j, e.JsonRpcErrorStruct);
  }
  e.isJsonRpcError = P;
  function S(j, Z) {
    (0, r.assertStruct)(j, e.JsonRpcErrorStruct, "Invalid JSON-RPC error", Z);
  }
  e.assertIsJsonRpcError = S;
  function m(j) {
    const { permitEmptyString: Z, permitFractions: ce, permitNull: ae } = Object.assign({ permitEmptyString: !0, permitFractions: !1, permitNull: !0 }, j);
    return (Se) => !!(typeof Se == "number" && (ce || Number.isInteger(Se)) || typeof Se == "string" && (Z || Se.length > 0) || ae && Se === null);
  }
  e.getJsonRpcIdValidator = m;
})(my);
var Ey = {};
Object.defineProperty(Ey, "__esModule", { value: !0 });
var Do = {}, K2 = Ye && Ye.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Do, "__esModule", { value: !0 });
Do.createModuleLogger = Do.createProjectLogger = void 0;
const J2 = K2(DA), Y2 = (0, J2.default)("metamask");
function X2(e) {
  return Y2.extend(e);
}
Do.createProjectLogger = X2;
function Z2(e, t) {
  return e.extend(t);
}
Do.createModuleLogger = Z2;
var vy = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.calculateNumberSize = e.calculateStringSize = e.isASCII = e.isPlainObject = e.ESCAPE_CHARACTERS_REGEXP = e.JsonSize = e.hasProperty = e.isObject = e.isNullOrUndefined = e.isNonEmptyArray = void 0;
  function t(p) {
    return Array.isArray(p) && p.length > 0;
  }
  e.isNonEmptyArray = t;
  function r(p) {
    return p == null;
  }
  e.isNullOrUndefined = r;
  function o(p) {
    return !!p && typeof p == "object" && !Array.isArray(p);
  }
  e.isObject = o;
  const s = (p, b) => Object.hasOwnProperty.call(p, b);
  e.hasProperty = s, function(p) {
    p[p.Null = 4] = "Null", p[p.Comma = 1] = "Comma", p[p.Wrapper = 1] = "Wrapper", p[p.True = 4] = "True", p[p.False = 5] = "False", p[p.Quote = 1] = "Quote", p[p.Colon = 1] = "Colon", p[p.Date = 24] = "Date";
  }(e.JsonSize || (e.JsonSize = {})), e.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
  function u(p) {
    if (typeof p != "object" || p === null)
      return !1;
    try {
      let b = p;
      for (; Object.getPrototypeOf(b) !== null; )
        b = Object.getPrototypeOf(b);
      return Object.getPrototypeOf(p) === b;
    } catch {
      return !1;
    }
  }
  e.isPlainObject = u;
  function f(p) {
    return p.charCodeAt(0) <= 127;
  }
  e.isASCII = f;
  function h(p) {
    var b;
    return p.split("").reduce((I, A) => f(A) ? I + 1 : I + 2, 0) + ((b = p.match(e.ESCAPE_CHARACTERS_REGEXP)) !== null && b !== void 0 ? b : []).length;
  }
  e.calculateStringSize = h;
  function l(p) {
    return p.toString().length;
  }
  e.calculateNumberSize = l;
})(vy);
var An = {};
Object.defineProperty(An, "__esModule", { value: !0 });
An.hexToBigInt = An.hexToNumber = An.bigIntToHex = An.numberToHex = void 0;
const Po = qt, Ms = zs, Q2 = (e) => ((0, Po.assert)(typeof e == "number", "Value must be a number."), (0, Po.assert)(e >= 0, "Value must be a non-negative number."), (0, Po.assert)(Number.isSafeInteger(e), "Value is not a safe integer. Use `bigIntToHex` instead."), (0, Ms.add0x)(e.toString(16)));
An.numberToHex = Q2;
const eC = (e) => ((0, Po.assert)(typeof e == "bigint", "Value must be a bigint."), (0, Po.assert)(e >= 0, "Value must be a non-negative bigint."), (0, Ms.add0x)(e.toString(16)));
An.bigIntToHex = eC;
const tC = (e) => {
  (0, Ms.assertIsHexString)(e);
  const t = parseInt(e, 16);
  return (0, Po.assert)(Number.isSafeInteger(t), "Value is not a safe integer. Use `hexToBigInt` instead."), t;
};
An.hexToNumber = tC;
const rC = (e) => ((0, Ms.assertIsHexString)(e), BigInt((0, Ms.add0x)(e)));
An.hexToBigInt = rC;
var Sy = {};
Object.defineProperty(Sy, "__esModule", { value: !0 });
var Ry = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.timeSince = e.inMilliseconds = e.Duration = void 0, function(u) {
    u[u.Millisecond = 1] = "Millisecond", u[u.Second = 1e3] = "Second", u[u.Minute = 6e4] = "Minute", u[u.Hour = 36e5] = "Hour", u[u.Day = 864e5] = "Day", u[u.Week = 6048e5] = "Week", u[u.Year = 31536e6] = "Year";
  }(e.Duration || (e.Duration = {}));
  const t = (u) => Number.isInteger(u) && u >= 0, r = (u, f) => {
    if (!t(u))
      throw new Error(`"${f}" must be a non-negative integer. Received: "${u}".`);
  };
  function o(u, f) {
    return r(u, "count"), u * f;
  }
  e.inMilliseconds = o;
  function s(u) {
    return r(u, "timestamp"), Date.now() - u;
  }
  e.timeSince = s;
})(Ry);
var Ay = {};
Object.defineProperty(Ay, "__esModule", { value: !0 });
var Ty = {}, jc = { exports: {} };
const nC = "2.0.0", Iy = 256, iC = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, oC = 16, sC = Iy - 6, aC = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var Vu = {
  MAX_LENGTH: Iy,
  MAX_SAFE_COMPONENT_LENGTH: oC,
  MAX_SAFE_BUILD_LENGTH: sC,
  MAX_SAFE_INTEGER: iC,
  RELEASE_TYPES: aC,
  SEMVER_SPEC_VERSION: nC,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const uC = typeof le.process == "object" && le.process.env && le.process.env.NODE_DEBUG && /\bsemver\b/i.test(le.process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var Gu = uC;
(function(e, t) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: r,
    MAX_SAFE_BUILD_LENGTH: o,
    MAX_LENGTH: s
  } = Vu, u = Gu;
  t = e.exports = {};
  const f = t.re = [], h = t.safeRe = [], l = t.src = [], p = t.safeSrc = [], b = t.t = {};
  let w = 0;
  const I = "[a-zA-Z0-9-]", A = [
    ["\\s", 1],
    ["\\d", s],
    [I, o]
  ], x = (C) => {
    for (const [B, P] of A)
      C = C.split(`${B}*`).join(`${B}{0,${P}}`).split(`${B}+`).join(`${B}{1,${P}}`);
    return C;
  }, v = (C, B, P) => {
    const S = x(B), m = w++;
    u(C, m, B), b[C] = m, l[m] = B, p[m] = S, f[m] = new RegExp(B, P ? "g" : void 0), h[m] = new RegExp(S, P ? "g" : void 0);
  };
  v("NUMERICIDENTIFIER", "0|[1-9]\\d*"), v("NUMERICIDENTIFIERLOOSE", "\\d+"), v("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${I}*`), v("MAINVERSION", `(${l[b.NUMERICIDENTIFIER]})\\.(${l[b.NUMERICIDENTIFIER]})\\.(${l[b.NUMERICIDENTIFIER]})`), v("MAINVERSIONLOOSE", `(${l[b.NUMERICIDENTIFIERLOOSE]})\\.(${l[b.NUMERICIDENTIFIERLOOSE]})\\.(${l[b.NUMERICIDENTIFIERLOOSE]})`), v("PRERELEASEIDENTIFIER", `(?:${l[b.NUMERICIDENTIFIER]}|${l[b.NONNUMERICIDENTIFIER]})`), v("PRERELEASEIDENTIFIERLOOSE", `(?:${l[b.NUMERICIDENTIFIERLOOSE]}|${l[b.NONNUMERICIDENTIFIER]})`), v("PRERELEASE", `(?:-(${l[b.PRERELEASEIDENTIFIER]}(?:\\.${l[b.PRERELEASEIDENTIFIER]})*))`), v("PRERELEASELOOSE", `(?:-?(${l[b.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${l[b.PRERELEASEIDENTIFIERLOOSE]})*))`), v("BUILDIDENTIFIER", `${I}+`), v("BUILD", `(?:\\+(${l[b.BUILDIDENTIFIER]}(?:\\.${l[b.BUILDIDENTIFIER]})*))`), v("FULLPLAIN", `v?${l[b.MAINVERSION]}${l[b.PRERELEASE]}?${l[b.BUILD]}?`), v("FULL", `^${l[b.FULLPLAIN]}$`), v("LOOSEPLAIN", `[v=\\s]*${l[b.MAINVERSIONLOOSE]}${l[b.PRERELEASELOOSE]}?${l[b.BUILD]}?`), v("LOOSE", `^${l[b.LOOSEPLAIN]}$`), v("GTLT", "((?:<|>)?=?)"), v("XRANGEIDENTIFIERLOOSE", `${l[b.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), v("XRANGEIDENTIFIER", `${l[b.NUMERICIDENTIFIER]}|x|X|\\*`), v("XRANGEPLAIN", `[v=\\s]*(${l[b.XRANGEIDENTIFIER]})(?:\\.(${l[b.XRANGEIDENTIFIER]})(?:\\.(${l[b.XRANGEIDENTIFIER]})(?:${l[b.PRERELEASE]})?${l[b.BUILD]}?)?)?`), v("XRANGEPLAINLOOSE", `[v=\\s]*(${l[b.XRANGEIDENTIFIERLOOSE]})(?:\\.(${l[b.XRANGEIDENTIFIERLOOSE]})(?:\\.(${l[b.XRANGEIDENTIFIERLOOSE]})(?:${l[b.PRERELEASELOOSE]})?${l[b.BUILD]}?)?)?`), v("XRANGE", `^${l[b.GTLT]}\\s*${l[b.XRANGEPLAIN]}$`), v("XRANGELOOSE", `^${l[b.GTLT]}\\s*${l[b.XRANGEPLAINLOOSE]}$`), v("COERCEPLAIN", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?`), v("COERCE", `${l[b.COERCEPLAIN]}(?:$|[^\\d])`), v("COERCEFULL", l[b.COERCEPLAIN] + `(?:${l[b.PRERELEASE]})?(?:${l[b.BUILD]})?(?:$|[^\\d])`), v("COERCERTL", l[b.COERCE], !0), v("COERCERTLFULL", l[b.COERCEFULL], !0), v("LONETILDE", "(?:~>?)"), v("TILDETRIM", `(\\s*)${l[b.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", v("TILDE", `^${l[b.LONETILDE]}${l[b.XRANGEPLAIN]}$`), v("TILDELOOSE", `^${l[b.LONETILDE]}${l[b.XRANGEPLAINLOOSE]}$`), v("LONECARET", "(?:\\^)"), v("CARETTRIM", `(\\s*)${l[b.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", v("CARET", `^${l[b.LONECARET]}${l[b.XRANGEPLAIN]}$`), v("CARETLOOSE", `^${l[b.LONECARET]}${l[b.XRANGEPLAINLOOSE]}$`), v("COMPARATORLOOSE", `^${l[b.GTLT]}\\s*(${l[b.LOOSEPLAIN]})$|^$`), v("COMPARATOR", `^${l[b.GTLT]}\\s*(${l[b.FULLPLAIN]})$|^$`), v("COMPARATORTRIM", `(\\s*)${l[b.GTLT]}\\s*(${l[b.LOOSEPLAIN]}|${l[b.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", v("HYPHENRANGE", `^\\s*(${l[b.XRANGEPLAIN]})\\s+-\\s+(${l[b.XRANGEPLAIN]})\\s*$`), v("HYPHENRANGELOOSE", `^\\s*(${l[b.XRANGEPLAINLOOSE]})\\s+-\\s+(${l[b.XRANGEPLAINLOOSE]})\\s*$`), v("STAR", "(<|>)?=?\\s*\\*"), v("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), v("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(jc, jc.exports);
var Ks = jc.exports;
const fC = Object.freeze({ loose: !0 }), lC = Object.freeze({}), cC = (e) => e ? typeof e != "object" ? fC : e : lC;
var md = cC;
const eb = /^[0-9]+$/, Oy = (e, t) => {
  const r = eb.test(e), o = eb.test(t);
  return r && o && (e = +e, t = +t), e === t ? 0 : r && !o ? -1 : o && !r ? 1 : e < t ? -1 : 1;
}, dC = (e, t) => Oy(t, e);
var Cy = {
  compareIdentifiers: Oy,
  rcompareIdentifiers: dC
};
const ou = Gu, { MAX_LENGTH: tb, MAX_SAFE_INTEGER: su } = Vu, { safeRe: rb, safeSrc: nb, t: au } = Ks, hC = md, { compareIdentifiers: Ao } = Cy;
let gC = class vn {
  constructor(t, r) {
    if (r = hC(r), t instanceof vn) {
      if (t.loose === !!r.loose && t.includePrerelease === !!r.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
    if (t.length > tb)
      throw new TypeError(
        `version is longer than ${tb} characters`
      );
    ou("SemVer", t, r), this.options = r, this.loose = !!r.loose, this.includePrerelease = !!r.includePrerelease;
    const o = t.trim().match(r.loose ? rb[au.LOOSE] : rb[au.FULL]);
    if (!o)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +o[1], this.minor = +o[2], this.patch = +o[3], this.major > su || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > su || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > su || this.patch < 0)
      throw new TypeError("Invalid patch version");
    o[4] ? this.prerelease = o[4].split(".").map((s) => {
      if (/^[0-9]+$/.test(s)) {
        const u = +s;
        if (u >= 0 && u < su)
          return u;
      }
      return s;
    }) : this.prerelease = [], this.build = o[5] ? o[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (ou("SemVer.compare", this.version, this.options, t), !(t instanceof vn)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new vn(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return t instanceof vn || (t = new vn(t, this.options)), Ao(this.major, t.major) || Ao(this.minor, t.minor) || Ao(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof vn || (t = new vn(t, this.options)), this.prerelease.length && !t.prerelease.length)
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
      return 0;
    let r = 0;
    do {
      const o = this.prerelease[r], s = t.prerelease[r];
      if (ou("prerelease compare", r, o, s), o === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (o === void 0)
        return -1;
      if (o === s)
        continue;
      return Ao(o, s);
    } while (++r);
  }
  compareBuild(t) {
    t instanceof vn || (t = new vn(t, this.options));
    let r = 0;
    do {
      const o = this.build[r], s = t.build[r];
      if (ou("build compare", r, o, s), o === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (o === void 0)
        return -1;
      if (o === s)
        continue;
      return Ao(o, s);
    } while (++r);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(t, r, o) {
    if (t.startsWith("pre")) {
      if (!r && o === !1)
        throw new Error("invalid increment argument: identifier is empty");
      if (r) {
        const s = new RegExp(`^${this.options.loose ? nb[au.PRERELEASELOOSE] : nb[au.PRERELEASE]}$`), u = `-${r}`.match(s);
        if (!u || u[1] !== r)
          throw new Error(`invalid identifier: ${r}`);
      }
    }
    switch (t) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", r, o);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", r, o);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", r, o), this.inc("pre", r, o);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", r, o), this.inc("pre", r, o);
        break;
      case "release":
        if (this.prerelease.length === 0)
          throw new Error(`version ${this.raw} is not a prerelease`);
        this.prerelease.length = 0;
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const s = Number(o) ? 1 : 0;
        if (this.prerelease.length === 0)
          this.prerelease = [s];
        else {
          let u = this.prerelease.length;
          for (; --u >= 0; )
            typeof this.prerelease[u] == "number" && (this.prerelease[u]++, u = -2);
          if (u === -1) {
            if (r === this.prerelease.join(".") && o === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(s);
          }
        }
        if (r) {
          let u = [r, s];
          o === !1 && (u = [r]), Ao(this.prerelease[0], r) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = u) : this.prerelease = u;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var Js = gC;
const ib = Js, pC = (e, t, r = !1) => {
  if (e instanceof ib)
    return e;
  try {
    return new ib(e, t);
  } catch (o) {
    if (!r)
      return null;
    throw o;
  }
};
var bC = pC;
const _C = bC, yC = (e, t) => {
  const r = _C(e, t);
  return r ? r.version : null;
};
var wC = yC;
const ob = Js, mC = (e, t, r) => new ob(e, r).compare(new ob(t, r));
var Vo = mC;
const EC = Vo, vC = (e, t, r) => EC(e, t, r) > 0;
var Ed = vC;
const SC = Vo, RC = (e, t, r) => SC(e, t, r) < 0;
var Ly = RC;
const AC = Vo, TC = (e, t, r) => AC(e, t, r) === 0;
var IC = TC;
const OC = Vo, CC = (e, t, r) => OC(e, t, r) !== 0;
var LC = CC;
const PC = Vo, BC = (e, t, r) => PC(e, t, r) >= 0;
var Py = BC;
const NC = Vo, $C = (e, t, r) => NC(e, t, r) <= 0;
var By = $C;
const MC = IC, xC = LC, DC = Ed, jC = Py, UC = Ly, kC = By, FC = (e, t, r, o) => {
  switch (t) {
    case "===":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e === r;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e !== r;
    case "":
    case "=":
    case "==":
      return MC(e, r, o);
    case "!=":
      return xC(e, r, o);
    case ">":
      return DC(e, r, o);
    case ">=":
      return jC(e, r, o);
    case "<":
      return UC(e, r, o);
    case "<=":
      return kC(e, r, o);
    default:
      throw new TypeError(`Invalid operator: ${t}`);
  }
};
var HC = FC;
const { safeRe: QN, t: e$ } = Ks;
class WC {
  constructor() {
    this.max = 1e3, this.map = /* @__PURE__ */ new Map();
  }
  get(t) {
    const r = this.map.get(t);
    if (r !== void 0)
      return this.map.delete(t), this.map.set(t, r), r;
  }
  delete(t) {
    return this.map.delete(t);
  }
  set(t, r) {
    if (!this.delete(t) && r !== void 0) {
      if (this.map.size >= this.max) {
        const s = this.map.keys().next().value;
        this.delete(s);
      }
      this.map.set(t, r);
    }
    return this;
  }
}
var qC = WC, nc, sb;
function an() {
  if (sb) return nc;
  sb = 1;
  const e = /\s+/g;
  class t {
    constructor(q, J) {
      if (J = s(J), q instanceof t)
        return q.loose === !!J.loose && q.includePrerelease === !!J.includePrerelease ? q : new t(q.raw, J);
      if (q instanceof u)
        return this.raw = q.value, this.set = [[q]], this.formatted = void 0, this;
      if (this.options = J, this.loose = !!J.loose, this.includePrerelease = !!J.includePrerelease, this.raw = q.trim().replace(e, " "), this.set = this.raw.split("||").map((V) => this.parseRange(V.trim())).filter((V) => V.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const V = this.set[0];
        if (this.set = this.set.filter((re) => !v(re[0])), this.set.length === 0)
          this.set = [V];
        else if (this.set.length > 1) {
          for (const re of this.set)
            if (re.length === 1 && C(re[0])) {
              this.set = [re];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let q = 0; q < this.set.length; q++) {
          q > 0 && (this.formatted += "||");
          const J = this.set[q];
          for (let V = 0; V < J.length; V++)
            V > 0 && (this.formatted += " "), this.formatted += J[V].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(q) {
      const V = ((this.options.includePrerelease && A) | (this.options.loose && x)) + ":" + q, re = o.get(V);
      if (re)
        return re;
      const H = this.options.loose, z = H ? l[p.HYPHENRANGELOOSE] : l[p.HYPHENRANGE];
      q = q.replace(z, F(this.options.includePrerelease)), f("hyphen replace", q), q = q.replace(l[p.COMPARATORTRIM], b), f("comparator trim", q), q = q.replace(l[p.TILDETRIM], w), f("tilde trim", q), q = q.replace(l[p.CARETTRIM], I), f("caret trim", q);
      let se = q.split(" ").map((be) => P(be, this.options)).join(" ").split(/\s+/).map((be) => me(be, this.options));
      H && (se = se.filter((be) => (f("loose invalid filter", be, this.options), !!be.match(l[p.COMPARATORLOOSE])))), f("range list", se);
      const de = /* @__PURE__ */ new Map(), te = se.map((be) => new u(be, this.options));
      for (const be of te) {
        if (v(be))
          return [be];
        de.set(be.value, be);
      }
      de.size > 1 && de.has("") && de.delete("");
      const _e = [...de.values()];
      return o.set(V, _e), _e;
    }
    intersects(q, J) {
      if (!(q instanceof t))
        throw new TypeError("a Range is required");
      return this.set.some((V) => B(V, J) && q.set.some((re) => B(re, J) && V.every((H) => re.every((z) => H.intersects(z, J)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(q) {
      if (!q)
        return !1;
      if (typeof q == "string")
        try {
          q = new h(q, this.options);
        } catch {
          return !1;
        }
      for (let J = 0; J < this.set.length; J++)
        if (U(this.set[J], q, this.options))
          return !0;
      return !1;
    }
  }
  nc = t;
  const r = qC, o = new r(), s = md, u = zu(), f = Gu, h = Js, {
    safeRe: l,
    t: p,
    comparatorTrimReplace: b,
    tildeTrimReplace: w,
    caretTrimReplace: I
  } = Ks, { FLAG_INCLUDE_PRERELEASE: A, FLAG_LOOSE: x } = Vu, v = ($) => $.value === "<0.0.0-0", C = ($) => $.value === "", B = ($, q) => {
    let J = !0;
    const V = $.slice();
    let re = V.pop();
    for (; J && V.length; )
      J = V.every((H) => re.intersects(H, q)), re = V.pop();
    return J;
  }, P = ($, q) => (f("comp", $, q), $ = Z($, q), f("caret", $), $ = m($, q), f("tildes", $), $ = ae($, q), f("xrange", $), $ = Se($, q), f("stars", $), $), S = ($) => !$ || $.toLowerCase() === "x" || $ === "*", m = ($, q) => $.trim().split(/\s+/).map((J) => j(J, q)).join(" "), j = ($, q) => {
    const J = q.loose ? l[p.TILDELOOSE] : l[p.TILDE];
    return $.replace(J, (V, re, H, z, se) => {
      f("tilde", $, V, re, H, z, se);
      let de;
      return S(re) ? de = "" : S(H) ? de = `>=${re}.0.0 <${+re + 1}.0.0-0` : S(z) ? de = `>=${re}.${H}.0 <${re}.${+H + 1}.0-0` : se ? (f("replaceTilde pr", se), de = `>=${re}.${H}.${z}-${se} <${re}.${+H + 1}.0-0`) : de = `>=${re}.${H}.${z} <${re}.${+H + 1}.0-0`, f("tilde return", de), de;
    });
  }, Z = ($, q) => $.trim().split(/\s+/).map((J) => ce(J, q)).join(" "), ce = ($, q) => {
    f("caret", $, q);
    const J = q.loose ? l[p.CARETLOOSE] : l[p.CARET], V = q.includePrerelease ? "-0" : "";
    return $.replace(J, (re, H, z, se, de) => {
      f("caret", $, re, H, z, se, de);
      let te;
      return S(H) ? te = "" : S(z) ? te = `>=${H}.0.0${V} <${+H + 1}.0.0-0` : S(se) ? H === "0" ? te = `>=${H}.${z}.0${V} <${H}.${+z + 1}.0-0` : te = `>=${H}.${z}.0${V} <${+H + 1}.0.0-0` : de ? (f("replaceCaret pr", de), H === "0" ? z === "0" ? te = `>=${H}.${z}.${se}-${de} <${H}.${z}.${+se + 1}-0` : te = `>=${H}.${z}.${se}-${de} <${H}.${+z + 1}.0-0` : te = `>=${H}.${z}.${se}-${de} <${+H + 1}.0.0-0`) : (f("no pr"), H === "0" ? z === "0" ? te = `>=${H}.${z}.${se}${V} <${H}.${z}.${+se + 1}-0` : te = `>=${H}.${z}.${se}${V} <${H}.${+z + 1}.0-0` : te = `>=${H}.${z}.${se} <${+H + 1}.0.0-0`), f("caret return", te), te;
    });
  }, ae = ($, q) => (f("replaceXRanges", $, q), $.split(/\s+/).map((J) => ee(J, q)).join(" ")), ee = ($, q) => {
    $ = $.trim();
    const J = q.loose ? l[p.XRANGELOOSE] : l[p.XRANGE];
    return $.replace(J, (V, re, H, z, se, de) => {
      f("xRange", $, V, re, H, z, se, de);
      const te = S(H), _e = te || S(z), be = _e || S(se), R = be;
      return re === "=" && R && (re = ""), de = q.includePrerelease ? "-0" : "", te ? re === ">" || re === "<" ? V = "<0.0.0-0" : V = "*" : re && R ? (_e && (z = 0), se = 0, re === ">" ? (re = ">=", _e ? (H = +H + 1, z = 0, se = 0) : (z = +z + 1, se = 0)) : re === "<=" && (re = "<", _e ? H = +H + 1 : z = +z + 1), re === "<" && (de = "-0"), V = `${re + H}.${z}.${se}${de}`) : _e ? V = `>=${H}.0.0${de} <${+H + 1}.0.0-0` : be && (V = `>=${H}.${z}.0${de} <${H}.${+z + 1}.0-0`), f("xRange return", V), V;
    });
  }, Se = ($, q) => (f("replaceStars", $, q), $.trim().replace(l[p.STAR], "")), me = ($, q) => (f("replaceGTE0", $, q), $.trim().replace(l[q.includePrerelease ? p.GTE0PRE : p.GTE0], "")), F = ($) => (q, J, V, re, H, z, se, de, te, _e, be, R) => (S(V) ? J = "" : S(re) ? J = `>=${V}.0.0${$ ? "-0" : ""}` : S(H) ? J = `>=${V}.${re}.0${$ ? "-0" : ""}` : z ? J = `>=${J}` : J = `>=${J}${$ ? "-0" : ""}`, S(te) ? de = "" : S(_e) ? de = `<${+te + 1}.0.0-0` : S(be) ? de = `<${te}.${+_e + 1}.0-0` : R ? de = `<=${te}.${_e}.${be}-${R}` : $ ? de = `<${te}.${_e}.${+be + 1}-0` : de = `<=${de}`, `${J} ${de}`.trim()), U = ($, q, J) => {
    for (let V = 0; V < $.length; V++)
      if (!$[V].test(q))
        return !1;
    if (q.prerelease.length && !J.includePrerelease) {
      for (let V = 0; V < $.length; V++)
        if (f($[V].semver), $[V].semver !== u.ANY && $[V].semver.prerelease.length > 0) {
          const re = $[V].semver;
          if (re.major === q.major && re.minor === q.minor && re.patch === q.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return nc;
}
var ic, ab;
function zu() {
  if (ab) return ic;
  ab = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(b, w) {
      if (w = r(w), b instanceof t) {
        if (b.loose === !!w.loose)
          return b;
        b = b.value;
      }
      b = b.trim().split(/\s+/).join(" "), f("comparator", b, w), this.options = w, this.loose = !!w.loose, this.parse(b), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, f("comp", this);
    }
    parse(b) {
      const w = this.options.loose ? o[s.COMPARATORLOOSE] : o[s.COMPARATOR], I = b.match(w);
      if (!I)
        throw new TypeError(`Invalid comparator: ${b}`);
      this.operator = I[1] !== void 0 ? I[1] : "", this.operator === "=" && (this.operator = ""), I[2] ? this.semver = new h(I[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(b) {
      if (f("Comparator.test", b, this.options.loose), this.semver === e || b === e)
        return !0;
      if (typeof b == "string")
        try {
          b = new h(b, this.options);
        } catch {
          return !1;
        }
      return u(b, this.operator, this.semver, this.options);
    }
    intersects(b, w) {
      if (!(b instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new l(b.value, w).test(this.value) : b.operator === "" ? b.value === "" ? !0 : new l(this.value, w).test(b.semver) : (w = r(w), w.includePrerelease && (this.value === "<0.0.0-0" || b.value === "<0.0.0-0") || !w.includePrerelease && (this.value.startsWith("<0.0.0") || b.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && b.operator.startsWith(">") || this.operator.startsWith("<") && b.operator.startsWith("<") || this.semver.version === b.semver.version && this.operator.includes("=") && b.operator.includes("=") || u(this.semver, "<", b.semver, w) && this.operator.startsWith(">") && b.operator.startsWith("<") || u(this.semver, ">", b.semver, w) && this.operator.startsWith("<") && b.operator.startsWith(">")));
    }
  }
  ic = t;
  const r = md, { safeRe: o, t: s } = Ks, u = HC, f = Gu, h = Js, l = an();
  return ic;
}
const VC = an(), GC = (e, t, r) => {
  try {
    t = new VC(t, r);
  } catch {
    return !1;
  }
  return t.test(e);
};
var Ny = GC;
an();
an();
an();
an();
const zC = an(), KC = (e, t) => {
  try {
    return new zC(e, t).range || "*";
  } catch {
    return null;
  }
};
var JC = KC;
const YC = Js, $y = zu(), { ANY: XC } = $y, ZC = an(), QC = Ny, ub = Ed, fb = Ly, eL = By, tL = Py, rL = (e, t, r, o) => {
  e = new YC(e, o), t = new ZC(t, o);
  let s, u, f, h, l;
  switch (r) {
    case ">":
      s = ub, u = eL, f = fb, h = ">", l = ">=";
      break;
    case "<":
      s = fb, u = tL, f = ub, h = "<", l = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (QC(e, t, o))
    return !1;
  for (let p = 0; p < t.set.length; ++p) {
    const b = t.set[p];
    let w = null, I = null;
    if (b.forEach((A) => {
      A.semver === XC && (A = new $y(">=0.0.0")), w = w || A, I = I || A, s(A.semver, w.semver, o) ? w = A : f(A.semver, I.semver, o) && (I = A);
    }), w.operator === h || w.operator === l || (!I.operator || I.operator === h) && u(e, I.semver))
      return !1;
    if (I.operator === l && f(e, I.semver))
      return !1;
  }
  return !0;
};
var nL = rL;
const iL = nL, oL = (e, t, r) => iL(e, t, ">", r);
var sL = oL;
an();
an();
const vd = zu(), { ANY: t$ } = vd;
new vd(">=0.0.0-0");
new vd(">=0.0.0");
const oc = Ks, lb = Vu, cb = Cy, aL = wC, uL = Ed;
zu();
an();
const fL = Ny, lL = JC, cL = sL;
var dL = {
  valid: aL,
  gt: uL,
  satisfies: fL,
  validRange: lL,
  gtr: cL,
  re: oc.re,
  src: oc.src,
  tokens: oc.t,
  SEMVER_SPEC_VERSION: lb.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: lb.RELEASE_TYPES,
  compareIdentifiers: cb.compareIdentifiers,
  rcompareIdentifiers: cb.rcompareIdentifiers
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.satisfiesVersionRange = e.gtRange = e.gtVersion = e.assertIsSemVerRange = e.assertIsSemVerVersion = e.isValidSemVerRange = e.isValidSemVerVersion = e.VersionRangeStruct = e.VersionStruct = void 0;
  const t = dL, r = no, o = qt;
  e.VersionStruct = (0, r.refine)((0, r.string)(), "Version", (w) => (0, t.valid)(w) === null ? `Expected SemVer version, got "${w}"` : !0), e.VersionRangeStruct = (0, r.refine)((0, r.string)(), "Version range", (w) => (0, t.validRange)(w) === null ? `Expected SemVer range, got "${w}"` : !0);
  function s(w) {
    return (0, r.is)(w, e.VersionStruct);
  }
  e.isValidSemVerVersion = s;
  function u(w) {
    return (0, r.is)(w, e.VersionRangeStruct);
  }
  e.isValidSemVerRange = u;
  function f(w) {
    (0, o.assertStruct)(w, e.VersionStruct);
  }
  e.assertIsSemVerVersion = f;
  function h(w) {
    (0, o.assertStruct)(w, e.VersionRangeStruct);
  }
  e.assertIsSemVerRange = h;
  function l(w, I) {
    return (0, t.gt)(w, I);
  }
  e.gtVersion = l;
  function p(w, I) {
    return (0, t.gtr)(w, I);
  }
  e.gtRange = p;
  function b(w, I) {
    return (0, t.satisfies)(w, I, {
      includePrerelease: !0
    });
  }
  e.satisfiesVersionRange = b;
})(Ty);
(function(e) {
  var t = Ye && Ye.__createBinding || (Object.create ? function(o, s, u, f) {
    f === void 0 && (f = u);
    var h = Object.getOwnPropertyDescriptor(s, u);
    (!h || ("get" in h ? !s.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return s[u];
    } }), Object.defineProperty(o, f, h);
  } : function(o, s, u, f) {
    f === void 0 && (f = u), o[f] = s[u];
  }), r = Ye && Ye.__exportStar || function(o, s) {
    for (var u in o) u !== "default" && !Object.prototype.hasOwnProperty.call(s, u) && t(s, o, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(qt, e), r(Gs, e), r(Qe, e), r(Wu, e), r(Rn, e), r(xo, e), r(wy, e), r(zs, e), r(my, e), r(Ey, e), r(Do, e), r(vy, e), r(An, e), r(Sy, e), r(Ry, e), r(Ay, e), r(Ty, e);
})(cd);
var Ku = {}, Ii = {};
Object.defineProperty(Ii, "__esModule", { value: !0 });
Ii.errorValues = Ii.errorCodes = void 0;
Ii.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
Ii.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.serializeCause = e.serializeError = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const t = cd, r = Ii, o = r.errorCodes.rpc.internal, s = "Unspecified error message. This is a bug, please report it.", u = {
    code: o,
    message: f(o)
  };
  e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function f(A, x = s) {
    if (h(A)) {
      const v = A.toString();
      if ((0, t.hasProperty)(r.errorValues, v))
        return r.errorValues[v].message;
      if (b(A))
        return e.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return x;
  }
  e.getMessageFromCode = f;
  function h(A) {
    return Number.isInteger(A);
  }
  e.isValidCode = h;
  function l(A, { fallbackError: x = u, shouldIncludeStack: v = !0 } = {}) {
    if (!(0, t.isJsonRpcError)(x))
      throw new Error("Must provide fallback error with integer number code and string message.");
    const C = p(A, x);
    return v || delete C.stack, C;
  }
  e.serializeError = l;
  function p(A, x) {
    if (A && typeof A == "object" && "serialize" in A && typeof A.serialize == "function")
      return A.serialize();
    if ((0, t.isJsonRpcError)(A))
      return A;
    const v = w(A);
    return {
      ...x,
      data: { cause: v }
    };
  }
  function b(A) {
    return A >= -32099 && A <= -32e3;
  }
  function w(A) {
    return Array.isArray(A) ? A.map((x) => (0, t.isValidJson)(x) ? x : (0, t.isObject)(x) ? I(x) : null) : (0, t.isObject)(A) ? I(A) : (0, t.isValidJson)(A) ? A : null;
  }
  e.serializeCause = w;
  function I(A) {
    return Object.getOwnPropertyNames(A).reduce((x, v) => {
      const C = A[v];
      return (0, t.isValidJson)(C) && (x[v] = C), x;
    }, {});
  }
})(Ku);
var hL = Ye && Ye.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ji, "__esModule", { value: !0 });
Ji.EthereumProviderError = Ji.JsonRpcError = void 0;
const gL = cd, pL = hL(Zc), bL = Ku;
class My extends Error {
  constructor(t, r, o) {
    if (!Number.isInteger(t))
      throw new Error('"code" must be an integer.');
    if (!r || typeof r != "string")
      throw new Error('"message" must be a non-empty string.');
    super(r), this.code = t, o !== void 0 && (this.data = o);
  }
  /**
   * Get the error as JSON-serializable object.
   *
   * @returns A plain object with all public class properties.
   */
  serialize() {
    const t = {
      code: this.code,
      message: this.message
    };
    return this.data !== void 0 && (t.data = this.data, (0, gL.isPlainObject)(this.data) && (t.data.cause = (0, bL.serializeCause)(this.data.cause))), this.stack && (t.stack = this.stack), t;
  }
  /**
   * Get a string representation of the serialized error, omitting any circular
   * references.
   *
   * @returns A string representation of the serialized error.
   */
  toString() {
    return (0, pL.default)(this.serialize(), wL, 2);
  }
}
Ji.JsonRpcError = My;
class _L extends My {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   *
   * @param code - The JSON-RPC error code. Must be an integer in the
   * `1000 <= n <= 4999` range.
   * @param message - The JSON-RPC error message.
   * @param data - Optional data to include in the error.
   */
  constructor(t, r, o) {
    if (!yL(t))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(t, r, o);
  }
}
Ji.EthereumProviderError = _L;
function yL(e) {
  return Number.isInteger(e) && e >= 1e3 && e <= 4999;
}
function wL(e, t) {
  if (t !== "[Circular]")
    return t;
}
var jo = {};
Object.defineProperty(jo, "__esModule", { value: !0 });
jo.providerErrors = jo.rpcErrors = void 0;
const Sd = Ji, Zt = Ii, xy = Ku;
jo.rpcErrors = {
  /**
   * Get a JSON RPC 2.0 Parse (-32700) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  parse: (e) => Fr(Zt.errorCodes.rpc.parse, e),
  /**
   * Get a JSON RPC 2.0 Invalid Request (-32600) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  invalidRequest: (e) => Fr(Zt.errorCodes.rpc.invalidRequest, e),
  /**
   * Get a JSON RPC 2.0 Invalid Params (-32602) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  invalidParams: (e) => Fr(Zt.errorCodes.rpc.invalidParams, e),
  /**
   * Get a JSON RPC 2.0 Method Not Found (-32601) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  methodNotFound: (e) => Fr(Zt.errorCodes.rpc.methodNotFound, e),
  /**
   * Get a JSON RPC 2.0 Internal (-32603) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  internal: (e) => Fr(Zt.errorCodes.rpc.internal, e),
  /**
   * Get a JSON RPC 2.0 Server error.
   * Permits integer error codes in the [ -32099 <= -32005 ] range.
   * Codes -32000 through -32004 are reserved by EIP-1474.
   *
   * @param opts - The error options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  server: (e) => {
    if (!e || typeof e != "object" || Array.isArray(e))
      throw new Error("Ethereum RPC Server errors must provide single object argument.");
    const { code: t } = e;
    if (!Number.isInteger(t) || t > -32005 || t < -32099)
      throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
    return Fr(t, e);
  },
  /**
   * Get an Ethereum JSON RPC Invalid Input (-32000) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  invalidInput: (e) => Fr(Zt.errorCodes.rpc.invalidInput, e),
  /**
   * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  resourceNotFound: (e) => Fr(Zt.errorCodes.rpc.resourceNotFound, e),
  /**
   * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  resourceUnavailable: (e) => Fr(Zt.errorCodes.rpc.resourceUnavailable, e),
  /**
   * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  transactionRejected: (e) => Fr(Zt.errorCodes.rpc.transactionRejected, e),
  /**
   * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  methodNotSupported: (e) => Fr(Zt.errorCodes.rpc.methodNotSupported, e),
  /**
   * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  limitExceeded: (e) => Fr(Zt.errorCodes.rpc.limitExceeded, e)
};
jo.providerErrors = {
  /**
   * Get an Ethereum Provider User Rejected Request (4001) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */
  userRejectedRequest: (e) => ws(Zt.errorCodes.provider.userRejectedRequest, e),
  /**
   * Get an Ethereum Provider Unauthorized (4100) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */
  unauthorized: (e) => ws(Zt.errorCodes.provider.unauthorized, e),
  /**
   * Get an Ethereum Provider Unsupported Method (4200) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */
  unsupportedMethod: (e) => ws(Zt.errorCodes.provider.unsupportedMethod, e),
  /**
   * Get an Ethereum Provider Not Connected (4900) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */
  disconnected: (e) => ws(Zt.errorCodes.provider.disconnected, e),
  /**
   * Get an Ethereum Provider Chain Not Connected (4901) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */
  chainDisconnected: (e) => ws(Zt.errorCodes.provider.chainDisconnected, e),
  /**
   * Get a custom Ethereum Provider error.
   *
   * @param opts - The error options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */
  custom: (e) => {
    if (!e || typeof e != "object" || Array.isArray(e))
      throw new Error("Ethereum Provider custom errors must provide single object argument.");
    const { code: t, message: r, data: o } = e;
    if (!r || typeof r != "string")
      throw new Error('"message" must be a nonempty string');
    return new Sd.EthereumProviderError(t, r, o);
  }
};
function Fr(e, t) {
  const [r, o] = Dy(t);
  return new Sd.JsonRpcError(e, r ?? (0, xy.getMessageFromCode)(e), o);
}
function ws(e, t) {
  const [r, o] = Dy(t);
  return new Sd.EthereumProviderError(e, r ?? (0, xy.getMessageFromCode)(e), o);
}
function Dy(e) {
  if (e) {
    if (typeof e == "string")
      return [e];
    if (typeof e == "object" && !Array.isArray(e)) {
      const { message: t, data: r } = e;
      if (t && typeof t != "string")
        throw new Error("Must specify string message.");
      return [t ?? void 0, r];
    }
  }
  return [];
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.errorCodes = e.providerErrors = e.rpcErrors = e.getMessageFromCode = e.serializeError = e.serializeCause = e.EthereumProviderError = e.JsonRpcError = void 0;
  var t = Ji;
  Object.defineProperty(e, "JsonRpcError", { enumerable: !0, get: function() {
    return t.JsonRpcError;
  } }), Object.defineProperty(e, "EthereumProviderError", { enumerable: !0, get: function() {
    return t.EthereumProviderError;
  } });
  var r = Ku;
  Object.defineProperty(e, "serializeCause", { enumerable: !0, get: function() {
    return r.serializeCause;
  } }), Object.defineProperty(e, "serializeError", { enumerable: !0, get: function() {
    return r.serializeError;
  } }), Object.defineProperty(e, "getMessageFromCode", { enumerable: !0, get: function() {
    return r.getMessageFromCode;
  } });
  var o = jo;
  Object.defineProperty(e, "rpcErrors", { enumerable: !0, get: function() {
    return o.rpcErrors;
  } }), Object.defineProperty(e, "providerErrors", { enumerable: !0, get: function() {
    return o.providerErrors;
  } });
  var s = Ii;
  Object.defineProperty(e, "errorCodes", { enumerable: !0, get: function() {
    return s.errorCodes;
  } });
})(NO);
var Rd = { exports: {} }, mL = jy;
function jy(e, t) {
  if (e && t) return jy(e)(t);
  if (typeof e != "function")
    throw new TypeError("need wrapper function");
  return Object.keys(e).forEach(function(o) {
    r[o] = e[o];
  }), r;
  function r() {
    for (var o = new Array(arguments.length), s = 0; s < o.length; s++)
      o[s] = arguments[s];
    var u = e.apply(this, o), f = o[o.length - 1];
    return typeof u == "function" && u !== f && Object.keys(f).forEach(function(h) {
      u[h] = f[h];
    }), u;
  }
}
var Uy = mL;
Rd.exports = Uy(pu);
Rd.exports.strict = Uy(ky);
pu.proto = pu(function() {
  Object.defineProperty(Function.prototype, "once", {
    value: function() {
      return pu(this);
    },
    configurable: !0
  }), Object.defineProperty(Function.prototype, "onceStrict", {
    value: function() {
      return ky(this);
    },
    configurable: !0
  });
});
function pu(e) {
  var t = function() {
    return t.called ? t.value : (t.called = !0, t.value = e.apply(this, arguments));
  };
  return t.called = !1, t;
}
function ky(e) {
  var t = function() {
    if (t.called)
      throw new Error(t.onceError);
    return t.called = !0, t.value = e.apply(this, arguments);
  }, r = e.name || "Function wrapped with `once`";
  return t.onceError = r + " shouldn't be called more than once", t.called = !1, t;
}
var Ad = Rd.exports;
const EL = /* @__PURE__ */ Oi(Ad);
var vL = Ad, SL = function() {
}, RL = function(e) {
  return e.setHeader && typeof e.abort == "function";
}, AL = function(e) {
  return e.stdio && Array.isArray(e.stdio) && e.stdio.length === 3;
}, Fy = function(e, t, r) {
  if (typeof t == "function") return Fy(e, null, t);
  t || (t = {}), r = vL(r || SL);
  var o = e._writableState, s = e._readableState, u = t.readable || t.readable !== !1 && e.readable, f = t.writable || t.writable !== !1 && e.writable, h = !1, l = function() {
    e.writable || p();
  }, p = function() {
    f = !1, u || r.call(e);
  }, b = function() {
    u = !1, f || r.call(e);
  }, w = function(C) {
    r.call(e, C ? new Error("exited with error code: " + C) : null);
  }, I = function(C) {
    r.call(e, C);
  }, A = function() {
    le.process.nextTick(x);
  }, x = function() {
    if (!h) {
      if (u && !(s && s.ended && !s.destroyed)) return r.call(e, new Error("premature close"));
      if (f && !(o && o.ended && !o.destroyed)) return r.call(e, new Error("premature close"));
    }
  }, v = function() {
    e.req.on("finish", p);
  };
  return RL(e) ? (e.on("complete", p), e.on("abort", A), e.req ? v() : e.on("request", v)) : f && !o && (e.on("end", l), e.on("close", l)), AL(e) && e.on("exit", w), e.on("end", b), e.on("finish", p), t.error !== !1 && e.on("error", I), e.on("close", A), function() {
    h = !0, e.removeListener("complete", p), e.removeListener("abort", A), e.removeListener("request", v), e.req && e.req.removeListener("finish", p), e.removeListener("end", l), e.removeListener("close", l), e.removeListener("finish", p), e.removeListener("exit", w), e.removeListener("end", b), e.removeListener("error", I), e.removeListener("close", A);
  };
}, Hy = Fy;
const db = /* @__PURE__ */ Oi(Hy);
var TL = Ad, IL = Hy, bu;
try {
  bu = ks;
} catch {
}
var xs = function() {
}, OL = /^v?\.0/.test(le.process.version), Ju = function(e) {
  return typeof e == "function";
}, CL = function(e) {
  return !OL || !bu ? !1 : (e instanceof (bu.ReadStream || xs) || e instanceof (bu.WriteStream || xs)) && Ju(e.close);
}, LL = function(e) {
  return e.setHeader && Ju(e.abort);
}, PL = function(e, t, r, o) {
  o = TL(o);
  var s = !1;
  e.on("close", function() {
    s = !0;
  }), IL(e, { readable: t, writable: r }, function(f) {
    if (f) return o(f);
    s = !0, o();
  });
  var u = !1;
  return function(f) {
    if (!s && !u) {
      if (u = !0, CL(e)) return e.close(xs);
      if (LL(e)) return e.abort();
      if (Ju(e.destroy)) return e.destroy();
      o(f || new Error("stream was destroyed"));
    }
  };
}, hb = function(e) {
  e();
}, BL = function(e, t) {
  return e.pipe(t);
}, NL = function() {
  var e = Array.prototype.slice.call(arguments), t = Ju(e[e.length - 1] || xs) && e.pop() || xs;
  if (Array.isArray(e[0]) && (e = e[0]), e.length < 2) throw new Error("pump requires two streams per minimum");
  var r, o = e.map(function(s, u) {
    var f = u < e.length - 1, h = u > 0;
    return PL(s, f, h, function(l) {
      r || (r = l), l && o.forEach(hb), !f && (o.forEach(hb), t(r));
    });
  });
  return e.reduce(BL);
}, $L = NL;
const gb = /* @__PURE__ */ Oi($L);
var ML = {}, Yu = {}, Xu = {}, Wy = {}, Uo = {}, Ri = {}, Ct = {};
Object.defineProperty(Ct, "__esModule", { value: !0 });
Ct.output = Ct.exists = Ct.hash = Ct.bytes = Ct.bool = Ct.number = Ct.isBytes = void 0;
function Su(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
Ct.number = Su;
function qy(e) {
  if (typeof e != "boolean")
    throw new Error(`boolean expected, not ${e}`);
}
Ct.bool = qy;
function Vy(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
Ct.isBytes = Vy;
function Td(e, ...t) {
  if (!Vy(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
Ct.bytes = Td;
function Gy(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Su(e.outputLen), Su(e.blockLen);
}
Ct.hash = Gy;
function zy(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
Ct.exists = zy;
function Ky(e, t) {
  Td(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
Ct.output = Ky;
const xL = { number: Su, bool: qy, bytes: Td, hash: Gy, exists: zy, output: Ky };
Ct.default = xL;
var ri = {}, Zu = {};
Object.defineProperty(Zu, "__esModule", { value: !0 });
Zu.crypto = void 0;
Zu.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.randomBytes = e.wrapXOFConstructorWithOpts = e.wrapConstructorWithOpts = e.wrapConstructor = e.checkOpts = e.Hash = e.concatBytes = e.toBytes = e.utf8ToBytes = e.asyncLoop = e.nextTick = e.hexToBytes = e.bytesToHex = e.byteSwap32 = e.byteSwapIfBE = e.byteSwap = e.isLE = e.rotl = e.rotr = e.createView = e.u32 = e.u8 = e.isBytes = void 0;
  const t = Zu, r = Ct;
  function o(F) {
    return F instanceof Uint8Array || F != null && typeof F == "object" && F.constructor.name === "Uint8Array";
  }
  e.isBytes = o;
  const s = (F) => new Uint8Array(F.buffer, F.byteOffset, F.byteLength);
  e.u8 = s;
  const u = (F) => new Uint32Array(F.buffer, F.byteOffset, Math.floor(F.byteLength / 4));
  e.u32 = u;
  const f = (F) => new DataView(F.buffer, F.byteOffset, F.byteLength);
  e.createView = f;
  const h = (F, U) => F << 32 - U | F >>> U;
  e.rotr = h;
  const l = (F, U) => F << U | F >>> 32 - U >>> 0;
  e.rotl = l, e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  const p = (F) => F << 24 & 4278190080 | F << 8 & 16711680 | F >>> 8 & 65280 | F >>> 24 & 255;
  e.byteSwap = p, e.byteSwapIfBE = e.isLE ? (F) => F : (F) => (0, e.byteSwap)(F);
  function b(F) {
    for (let U = 0; U < F.length; U++)
      F[U] = (0, e.byteSwap)(F[U]);
  }
  e.byteSwap32 = b;
  const w = /* @__PURE__ */ Array.from({ length: 256 }, (F, U) => U.toString(16).padStart(2, "0"));
  function I(F) {
    (0, r.bytes)(F);
    let U = "";
    for (let $ = 0; $ < F.length; $++)
      U += w[F[$]];
    return U;
  }
  e.bytesToHex = I;
  const A = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function x(F) {
    if (F >= A._0 && F <= A._9)
      return F - A._0;
    if (F >= A._A && F <= A._F)
      return F - (A._A - 10);
    if (F >= A._a && F <= A._f)
      return F - (A._a - 10);
  }
  function v(F) {
    if (typeof F != "string")
      throw new Error("hex string expected, got " + typeof F);
    const U = F.length, $ = U / 2;
    if (U % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + U);
    const q = new Uint8Array($);
    for (let J = 0, V = 0; J < $; J++, V += 2) {
      const re = x(F.charCodeAt(V)), H = x(F.charCodeAt(V + 1));
      if (re === void 0 || H === void 0) {
        const z = F[V] + F[V + 1];
        throw new Error('hex string expected, got non-hex character "' + z + '" at index ' + V);
      }
      q[J] = re * 16 + H;
    }
    return q;
  }
  e.hexToBytes = v;
  const C = async () => {
  };
  e.nextTick = C;
  async function B(F, U, $) {
    let q = Date.now();
    for (let J = 0; J < F; J++) {
      $(J);
      const V = Date.now() - q;
      V >= 0 && V < U || (await (0, e.nextTick)(), q += V);
    }
  }
  e.asyncLoop = B;
  function P(F) {
    if (typeof F != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof F}`);
    return new Uint8Array(new TextEncoder().encode(F));
  }
  e.utf8ToBytes = P;
  function S(F) {
    return typeof F == "string" && (F = P(F)), (0, r.bytes)(F), F;
  }
  e.toBytes = S;
  function m(...F) {
    let U = 0;
    for (let q = 0; q < F.length; q++) {
      const J = F[q];
      (0, r.bytes)(J), U += J.length;
    }
    const $ = new Uint8Array(U);
    for (let q = 0, J = 0; q < F.length; q++) {
      const V = F[q];
      $.set(V, J), J += V.length;
    }
    return $;
  }
  e.concatBytes = m;
  class j {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  e.Hash = j;
  const Z = {}.toString;
  function ce(F, U) {
    if (U !== void 0 && Z.call(U) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(F, U);
  }
  e.checkOpts = ce;
  function ae(F) {
    const U = (q) => F().update(S(q)).digest(), $ = F();
    return U.outputLen = $.outputLen, U.blockLen = $.blockLen, U.create = () => F(), U;
  }
  e.wrapConstructor = ae;
  function ee(F) {
    const U = (q, J) => F(J).update(S(q)).digest(), $ = F({});
    return U.outputLen = $.outputLen, U.blockLen = $.blockLen, U.create = (q) => F(q), U;
  }
  e.wrapConstructorWithOpts = ee;
  function Se(F) {
    const U = (q, J) => F(J).update(S(q)).digest(), $ = F({});
    return U.outputLen = $.outputLen, U.blockLen = $.blockLen, U.create = (q) => F(q), U;
  }
  e.wrapXOFConstructorWithOpts = Se;
  function me(F = 32) {
    if (t.crypto && typeof t.crypto.getRandomValues == "function")
      return t.crypto.getRandomValues(new Uint8Array(F));
    throw new Error("crypto.getRandomValues must be defined");
  }
  e.randomBytes = me;
})(ri);
Object.defineProperty(Ri, "__esModule", { value: !0 });
Ri.HashMD = Ri.Maj = Ri.Chi = void 0;
const sc = Ct, ms = ri;
function DL(e, t, r, o) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, o);
  const s = BigInt(32), u = BigInt(4294967295), f = Number(r >> s & u), h = Number(r & u), l = o ? 4 : 0, p = o ? 0 : 4;
  e.setUint32(t + l, f, o), e.setUint32(t + p, h, o);
}
const jL = (e, t, r) => e & t ^ ~e & r;
Ri.Chi = jL;
const UL = (e, t, r) => e & t ^ e & r ^ t & r;
Ri.Maj = UL;
class kL extends ms.Hash {
  constructor(t, r, o, s) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = o, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = (0, ms.createView)(this.buffer);
  }
  update(t) {
    (0, sc.exists)(this);
    const { view: r, buffer: o, blockLen: s } = this;
    t = (0, ms.toBytes)(t);
    const u = t.length;
    for (let f = 0; f < u; ) {
      const h = Math.min(s - this.pos, u - f);
      if (h === s) {
        const l = (0, ms.createView)(t);
        for (; s <= u - f; f += s)
          this.process(l, f);
        continue;
      }
      o.set(t.subarray(f, f + h), this.pos), this.pos += h, f += h, this.pos === s && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    (0, sc.exists)(this), (0, sc.output)(t, this), this.finished = !0;
    const { buffer: r, view: o, blockLen: s, isLE: u } = this;
    let { pos: f } = this;
    r[f++] = 128, this.buffer.subarray(f).fill(0), this.padOffset > s - f && (this.process(o, 0), f = 0);
    for (let w = f; w < s; w++)
      r[w] = 0;
    DL(o, s - 8, BigInt(this.length * 8), u), this.process(o, 0);
    const h = (0, ms.createView)(t), l = this.outputLen;
    if (l % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const p = l / 4, b = this.get();
    if (p > b.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let w = 0; w < p; w++)
      h.setUint32(4 * w, b[w], u);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const o = t.slice(0, r);
    return this.destroy(), o;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: o, length: s, finished: u, destroyed: f, pos: h } = this;
    return t.length = s, t.pos = h, t.finished = u, t.destroyed = f, s % r && t.buffer.set(o), t;
  }
}
Ri.HashMD = kL;
Object.defineProperty(Uo, "__esModule", { value: !0 });
Uo.sha224 = Uo.sha256 = void 0;
const ac = Ri, Hr = ri, FL = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), wi = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), mi = /* @__PURE__ */ new Uint32Array(64);
class Jy extends ac.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = wi[0] | 0, this.B = wi[1] | 0, this.C = wi[2] | 0, this.D = wi[3] | 0, this.E = wi[4] | 0, this.F = wi[5] | 0, this.G = wi[6] | 0, this.H = wi[7] | 0;
  }
  get() {
    const { A: t, B: r, C: o, D: s, E: u, F: f, G: h, H: l } = this;
    return [t, r, o, s, u, f, h, l];
  }
  // prettier-ignore
  set(t, r, o, s, u, f, h, l) {
    this.A = t | 0, this.B = r | 0, this.C = o | 0, this.D = s | 0, this.E = u | 0, this.F = f | 0, this.G = h | 0, this.H = l | 0;
  }
  process(t, r) {
    for (let w = 0; w < 16; w++, r += 4)
      mi[w] = t.getUint32(r, !1);
    for (let w = 16; w < 64; w++) {
      const I = mi[w - 15], A = mi[w - 2], x = (0, Hr.rotr)(I, 7) ^ (0, Hr.rotr)(I, 18) ^ I >>> 3, v = (0, Hr.rotr)(A, 17) ^ (0, Hr.rotr)(A, 19) ^ A >>> 10;
      mi[w] = v + mi[w - 7] + x + mi[w - 16] | 0;
    }
    let { A: o, B: s, C: u, D: f, E: h, F: l, G: p, H: b } = this;
    for (let w = 0; w < 64; w++) {
      const I = (0, Hr.rotr)(h, 6) ^ (0, Hr.rotr)(h, 11) ^ (0, Hr.rotr)(h, 25), A = b + I + (0, ac.Chi)(h, l, p) + FL[w] + mi[w] | 0, v = ((0, Hr.rotr)(o, 2) ^ (0, Hr.rotr)(o, 13) ^ (0, Hr.rotr)(o, 22)) + (0, ac.Maj)(o, s, u) | 0;
      b = p, p = l, l = h, h = f + A | 0, f = u, u = s, s = o, o = A + v | 0;
    }
    o = o + this.A | 0, s = s + this.B | 0, u = u + this.C | 0, f = f + this.D | 0, h = h + this.E | 0, l = l + this.F | 0, p = p + this.G | 0, b = b + this.H | 0, this.set(o, s, u, f, h, l, p, b);
  }
  roundClean() {
    mi.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class HL extends Jy {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
Uo.sha256 = (0, Hr.wrapConstructor)(() => new Jy());
Uo.sha224 = (0, Hr.wrapConstructor)(() => new HL());
var Qu = {}, Yy = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.hmac = e.HMAC = void 0;
  const t = Ct, r = ri;
  class o extends r.Hash {
    constructor(f, h) {
      super(), this.finished = !1, this.destroyed = !1, (0, t.hash)(f);
      const l = (0, r.toBytes)(h);
      if (this.iHash = f.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const p = this.blockLen, b = new Uint8Array(p);
      b.set(l.length > p ? f.create().update(l).digest() : l);
      for (let w = 0; w < b.length; w++)
        b[w] ^= 54;
      this.iHash.update(b), this.oHash = f.create();
      for (let w = 0; w < b.length; w++)
        b[w] ^= 106;
      this.oHash.update(b), b.fill(0);
    }
    update(f) {
      return (0, t.exists)(this), this.iHash.update(f), this;
    }
    digestInto(f) {
      (0, t.exists)(this), (0, t.bytes)(f, this.outputLen), this.finished = !0, this.iHash.digestInto(f), this.oHash.update(f), this.oHash.digestInto(f), this.destroy();
    }
    digest() {
      const f = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(f), f;
    }
    _cloneInto(f) {
      f || (f = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: h, iHash: l, finished: p, destroyed: b, blockLen: w, outputLen: I } = this;
      return f = f, f.finished = p, f.destroyed = b, f.blockLen = w, f.outputLen = I, f.oHash = h._cloneInto(f.oHash), f.iHash = l._cloneInto(f.iHash), f;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e.HMAC = o;
  const s = (u, f, h) => new o(u, f).update(h).digest();
  e.hmac = s, e.hmac.create = (u, f) => new o(u, f);
})(Yy);
var Id = {}, ef = {}, bt = {}, st = {};
Object.defineProperty(st, "__esModule", { value: !0 });
st.bitMask = void 0;
st.isBytes = rf;
st.abytes = nf;
st.bytesToHex = Od;
st.numberToHexUnpadded = Zy;
st.hexToNumber = Cd;
st.hexToBytes = of;
st.bytesToNumberBE = VL;
st.bytesToNumberLE = GL;
st.numberToBytesBE = Qy;
st.numberToBytesLE = zL;
st.numberToVarBytesBE = KL;
st.ensureBytes = JL;
st.concatBytes = e0;
st.equalBytes = YL;
st.utf8ToBytes = XL;
st.bitLen = ZL;
st.bitGet = QL;
st.bitSet = eP;
st.createHmacDrbg = rP;
st.validateObject = iP;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Xy = /* @__PURE__ */ BigInt(0), tf = /* @__PURE__ */ BigInt(1), WL = /* @__PURE__ */ BigInt(2);
function rf(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function nf(e) {
  if (!rf(e))
    throw new Error("Uint8Array expected");
}
const qL = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Od(e) {
  nf(e);
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += qL[e[r]];
  return t;
}
function Zy(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function Cd(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
const Jn = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function pb(e) {
  if (e >= Jn._0 && e <= Jn._9)
    return e - Jn._0;
  if (e >= Jn._A && e <= Jn._F)
    return e - (Jn._A - 10);
  if (e >= Jn._a && e <= Jn._f)
    return e - (Jn._a - 10);
}
function of(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length, r = t / 2;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const o = new Uint8Array(r);
  for (let s = 0, u = 0; s < r; s++, u += 2) {
    const f = pb(e.charCodeAt(u)), h = pb(e.charCodeAt(u + 1));
    if (f === void 0 || h === void 0) {
      const l = e[u] + e[u + 1];
      throw new Error('hex string expected, got non-hex character "' + l + '" at index ' + u);
    }
    o[s] = f * 16 + h;
  }
  return o;
}
function VL(e) {
  return Cd(Od(e));
}
function GL(e) {
  return nf(e), Cd(Od(Uint8Array.from(e).reverse()));
}
function Qy(e, t) {
  return of(e.toString(16).padStart(t * 2, "0"));
}
function zL(e, t) {
  return Qy(e, t).reverse();
}
function KL(e) {
  return of(Zy(e));
}
function JL(e, t, r) {
  let o;
  if (typeof t == "string")
    try {
      o = of(t);
    } catch (u) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${u}`);
    }
  else if (rf(t))
    o = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const s = o.length;
  if (typeof r == "number" && s !== r)
    throw new Error(`${e} expected ${r} bytes, got ${s}`);
  return o;
}
function e0(...e) {
  let t = 0;
  for (let o = 0; o < e.length; o++) {
    const s = e[o];
    nf(s), t += s.length;
  }
  const r = new Uint8Array(t);
  for (let o = 0, s = 0; o < e.length; o++) {
    const u = e[o];
    r.set(u, s), s += u.length;
  }
  return r;
}
function YL(e, t) {
  if (e.length !== t.length)
    return !1;
  let r = 0;
  for (let o = 0; o < e.length; o++)
    r |= e[o] ^ t[o];
  return r === 0;
}
function XL(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function ZL(e) {
  let t;
  for (t = 0; e > Xy; e >>= tf, t += 1)
    ;
  return t;
}
function QL(e, t) {
  return e >> BigInt(t) & tf;
}
function eP(e, t, r) {
  return e | (r ? tf : Xy) << BigInt(t);
}
const tP = (e) => (WL << BigInt(e - 1)) - tf;
st.bitMask = tP;
const uc = (e) => new Uint8Array(e), bb = (e) => Uint8Array.from(e);
function rP(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let o = uc(e), s = uc(e), u = 0;
  const f = () => {
    o.fill(1), s.fill(0), u = 0;
  }, h = (...w) => r(s, o, ...w), l = (w = uc()) => {
    s = h(bb([0]), w), o = h(), w.length !== 0 && (s = h(bb([1]), w), o = h());
  }, p = () => {
    if (u++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let w = 0;
    const I = [];
    for (; w < t; ) {
      o = h();
      const A = o.slice();
      I.push(A), w += o.length;
    }
    return e0(...I);
  };
  return (w, I) => {
    f(), l(w);
    let A;
    for (; !(A = I(p())); )
      l();
    return f(), A;
  };
}
const nP = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  stringOrUint8Array: (e) => typeof e == "string" || rf(e),
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function iP(e, t, r = {}) {
  const o = (s, u, f) => {
    const h = nP[u];
    if (typeof h != "function")
      throw new Error(`Invalid validator "${u}", expected function`);
    const l = e[s];
    if (!(f && l === void 0) && !h(l, e))
      throw new Error(`Invalid param ${String(s)}=${l} (${typeof l}), expected ${u}`);
  };
  for (const [s, u] of Object.entries(t))
    o(s, u, !1);
  for (const [s, u] of Object.entries(r))
    o(s, u, !0);
  return e;
}
Object.defineProperty(bt, "__esModule", { value: !0 });
bt.isNegativeLE = void 0;
bt.mod = Ir;
bt.pow = t0;
bt.pow2 = sP;
bt.invert = Ru;
bt.tonelliShanks = r0;
bt.FpSqrt = n0;
bt.validateField = fP;
bt.FpPow = i0;
bt.FpInvertBatch = o0;
bt.FpDiv = lP;
bt.FpIsSquare = cP;
bt.nLength = Ld;
bt.Field = dP;
bt.FpSqrtOdd = hP;
bt.FpSqrtEven = gP;
bt.hashToPrivateScalar = pP;
bt.getFieldBytesLength = Pd;
bt.getMinHashLength = s0;
bt.mapHashToField = bP;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Or = st, kt = BigInt(0), pt = BigInt(1), Si = BigInt(2), oP = BigInt(3), Uc = BigInt(4), _b = BigInt(5), yb = BigInt(8);
BigInt(9);
BigInt(16);
function Ir(e, t) {
  const r = e % t;
  return r >= kt ? r : t + r;
}
function t0(e, t, r) {
  if (r <= kt || t < kt)
    throw new Error("Expected power/modulo > 0");
  if (r === pt)
    return kt;
  let o = pt;
  for (; t > kt; )
    t & pt && (o = o * e % r), e = e * e % r, t >>= pt;
  return o;
}
function sP(e, t, r) {
  let o = e;
  for (; t-- > kt; )
    o *= o, o %= r;
  return o;
}
function Ru(e, t) {
  if (e === kt || t <= kt)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = Ir(e, t), o = t, s = kt, u = pt;
  for (; r !== kt; ) {
    const h = o / r, l = o % r, p = s - u * h;
    o = r, r = l, s = u, u = p;
  }
  if (o !== pt)
    throw new Error("invert: does not exist");
  return Ir(s, t);
}
function r0(e) {
  const t = (e - pt) / Si;
  let r, o, s;
  for (r = e - pt, o = 0; r % Si === kt; r /= Si, o++)
    ;
  for (s = Si; s < e && t0(s, t, e) !== e - pt; s++)
    ;
  if (o === 1) {
    const f = (e + pt) / Uc;
    return function(l, p) {
      const b = l.pow(p, f);
      if (!l.eql(l.sqr(b), p))
        throw new Error("Cannot find square root");
      return b;
    };
  }
  const u = (r + pt) / Si;
  return function(h, l) {
    if (h.pow(l, t) === h.neg(h.ONE))
      throw new Error("Cannot find square root");
    let p = o, b = h.pow(h.mul(h.ONE, s), r), w = h.pow(l, u), I = h.pow(l, r);
    for (; !h.eql(I, h.ONE); ) {
      if (h.eql(I, h.ZERO))
        return h.ZERO;
      let A = 1;
      for (let v = h.sqr(I); A < p && !h.eql(v, h.ONE); A++)
        v = h.sqr(v);
      const x = h.pow(b, pt << BigInt(p - A - 1));
      b = h.sqr(x), w = h.mul(w, x), I = h.mul(I, b), p = A;
    }
    return w;
  };
}
function n0(e) {
  if (e % Uc === oP) {
    const t = (e + pt) / Uc;
    return function(o, s) {
      const u = o.pow(s, t);
      if (!o.eql(o.sqr(u), s))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  if (e % yb === _b) {
    const t = (e - _b) / yb;
    return function(o, s) {
      const u = o.mul(s, Si), f = o.pow(u, t), h = o.mul(s, f), l = o.mul(o.mul(h, Si), f), p = o.mul(h, o.sub(l, o.ONE));
      if (!o.eql(o.sqr(p), s))
        throw new Error("Cannot find square root");
      return p;
    };
  }
  return r0(e);
}
const aP = (e, t) => (Ir(e, t) & pt) === pt;
bt.isNegativeLE = aP;
const uP = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function fP(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = uP.reduce((o, s) => (o[s] = "function", o), t);
  return (0, Or.validateObject)(e, r);
}
function i0(e, t, r) {
  if (r < kt)
    throw new Error("Expected power > 0");
  if (r === kt)
    return e.ONE;
  if (r === pt)
    return t;
  let o = e.ONE, s = t;
  for (; r > kt; )
    r & pt && (o = e.mul(o, s)), s = e.sqr(s), r >>= pt;
  return o;
}
function o0(e, t) {
  const r = new Array(t.length), o = t.reduce((u, f, h) => e.is0(f) ? u : (r[h] = u, e.mul(u, f)), e.ONE), s = e.inv(o);
  return t.reduceRight((u, f, h) => e.is0(f) ? u : (r[h] = e.mul(u, r[h]), e.mul(u, f)), s), r;
}
function lP(e, t, r) {
  return e.mul(t, typeof r == "bigint" ? Ru(r, e.ORDER) : e.inv(r));
}
function cP(e) {
  const t = (e.ORDER - pt) / Si;
  return (r) => {
    const o = e.pow(r, t);
    return e.eql(o, e.ZERO) || e.eql(o, e.ONE);
  };
}
function Ld(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, o = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: o };
}
function dP(e, t, r = !1, o = {}) {
  if (e <= kt)
    throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const { nBitLength: s, nByteLength: u } = Ld(e, t);
  if (u > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const f = n0(e), h = Object.freeze({
    ORDER: e,
    BITS: s,
    BYTES: u,
    MASK: (0, Or.bitMask)(s),
    ZERO: kt,
    ONE: pt,
    create: (l) => Ir(l, e),
    isValid: (l) => {
      if (typeof l != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof l}`);
      return kt <= l && l < e;
    },
    is0: (l) => l === kt,
    isOdd: (l) => (l & pt) === pt,
    neg: (l) => Ir(-l, e),
    eql: (l, p) => l === p,
    sqr: (l) => Ir(l * l, e),
    add: (l, p) => Ir(l + p, e),
    sub: (l, p) => Ir(l - p, e),
    mul: (l, p) => Ir(l * p, e),
    pow: (l, p) => i0(h, l, p),
    div: (l, p) => Ir(l * Ru(p, e), e),
    // Same as above, but doesn't normalize
    sqrN: (l) => l * l,
    addN: (l, p) => l + p,
    subN: (l, p) => l - p,
    mulN: (l, p) => l * p,
    inv: (l) => Ru(l, e),
    sqrt: o.sqrt || ((l) => f(h, l)),
    invertBatch: (l) => o0(h, l),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (l, p, b) => b ? p : l,
    toBytes: (l) => r ? (0, Or.numberToBytesLE)(l, u) : (0, Or.numberToBytesBE)(l, u),
    fromBytes: (l) => {
      if (l.length !== u)
        throw new Error(`Fp.fromBytes: expected ${u}, got ${l.length}`);
      return r ? (0, Or.bytesToNumberLE)(l) : (0, Or.bytesToNumberBE)(l);
    }
  });
  return Object.freeze(h);
}
function hP(e, t) {
  if (!e.isOdd)
    throw new Error("Field doesn't have isOdd");
  const r = e.sqrt(t);
  return e.isOdd(r) ? r : e.neg(r);
}
function gP(e, t) {
  if (!e.isOdd)
    throw new Error("Field doesn't have isOdd");
  const r = e.sqrt(t);
  return e.isOdd(r) ? e.neg(r) : r;
}
function pP(e, t, r = !1) {
  e = (0, Or.ensureBytes)("privateHash", e);
  const o = e.length, s = Ld(t).nByteLength + 8;
  if (s < 24 || o < s || o > 1024)
    throw new Error(`hashToPrivateScalar: expected ${s}-1024 bytes of input, got ${o}`);
  const u = r ? (0, Or.bytesToNumberLE)(e) : (0, Or.bytesToNumberBE)(e);
  return Ir(u, t - pt) + pt;
}
function Pd(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function s0(e) {
  const t = Pd(e);
  return t + Math.ceil(t / 2);
}
function bP(e, t, r = !1) {
  const o = e.length, s = Pd(t), u = s0(t);
  if (o < 16 || o < u || o > 1024)
    throw new Error(`expected ${u}-1024 bytes of input, got ${o}`);
  const f = r ? (0, Or.bytesToNumberBE)(e) : (0, Or.bytesToNumberLE)(e), h = Ir(f, t - pt) + pt;
  return r ? (0, Or.numberToBytesLE)(h, s) : (0, Or.numberToBytesBE)(h, s);
}
Object.defineProperty(ef, "__esModule", { value: !0 });
ef.wNAF = wP;
ef.validateBasic = mP;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const wb = bt, _P = st, yP = BigInt(0), fc = BigInt(1);
function wP(e, t) {
  const r = (s, u) => {
    const f = u.negate();
    return s ? f : u;
  }, o = (s) => {
    const u = Math.ceil(t / s) + 1, f = 2 ** (s - 1);
    return { windows: u, windowSize: f };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(s, u) {
      let f = e.ZERO, h = s;
      for (; u > yP; )
        u & fc && (f = f.add(h)), h = h.double(), u >>= fc;
      return f;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(s, u) {
      const { windows: f, windowSize: h } = o(u), l = [];
      let p = s, b = p;
      for (let w = 0; w < f; w++) {
        b = p, l.push(b);
        for (let I = 1; I < h; I++)
          b = b.add(p), l.push(b);
        p = b.double();
      }
      return l;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(s, u, f) {
      const { windows: h, windowSize: l } = o(s);
      let p = e.ZERO, b = e.BASE;
      const w = BigInt(2 ** s - 1), I = 2 ** s, A = BigInt(s);
      for (let x = 0; x < h; x++) {
        const v = x * l;
        let C = Number(f & w);
        f >>= A, C > l && (C -= I, f += fc);
        const B = v, P = v + Math.abs(C) - 1, S = x % 2 !== 0, m = C < 0;
        C === 0 ? b = b.add(r(S, u[B])) : p = p.add(r(m, u[P]));
      }
      return { p, f: b };
    },
    wNAFCached(s, u, f, h) {
      const l = s._WINDOW_SIZE || 1;
      let p = u.get(s);
      return p || (p = this.precomputeWindow(s, l), l !== 1 && u.set(s, h(p))), this.wNAF(l, p, f);
    }
  };
}
function mP(e) {
  return (0, wb.validateField)(e.Fp), (0, _P.validateObject)(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...(0, wb.nLength)(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DER = void 0, e.weierstrassPoints = A, e.weierstrass = v, e.SWUFpSqrtRatio = C, e.mapToCurveSimpleSWU = B;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const t = ef, r = bt, o = st, s = st;
  function u(P) {
    const S = (0, t.validateBasic)(P);
    o.validateObject(S, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo: m, Fp: j, a: Z } = S;
    if (m) {
      if (!j.eql(Z, j.ZERO))
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      if (typeof m != "object" || typeof m.beta != "bigint" || typeof m.splitScalar != "function")
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({ ...S });
  }
  const { bytesToNumberBE: f, hexToBytes: h } = o;
  e.DER = {
    // asn.1 DER encoding utils
    Err: class extends Error {
      constructor(S = "") {
        super(S);
      }
    },
    _parseInt(P) {
      const { Err: S } = e.DER;
      if (P.length < 2 || P[0] !== 2)
        throw new S("Invalid signature integer tag");
      const m = P[1], j = P.subarray(2, m + 2);
      if (!m || j.length !== m)
        throw new S("Invalid signature integer: wrong length");
      if (j[0] & 128)
        throw new S("Invalid signature integer: negative");
      if (j[0] === 0 && !(j[1] & 128))
        throw new S("Invalid signature integer: unnecessary leading zero");
      return { d: f(j), l: P.subarray(m + 2) };
    },
    toSig(P) {
      const { Err: S } = e.DER, m = typeof P == "string" ? h(P) : P;
      o.abytes(m);
      let j = m.length;
      if (j < 2 || m[0] != 48)
        throw new S("Invalid signature tag");
      if (m[1] !== j - 2)
        throw new S("Invalid signature: incorrect length");
      const { d: Z, l: ce } = e.DER._parseInt(m.subarray(2)), { d: ae, l: ee } = e.DER._parseInt(ce);
      if (ee.length)
        throw new S("Invalid signature: left bytes after parsing");
      return { r: Z, s: ae };
    },
    hexFromSig(P) {
      const S = (me) => Number.parseInt(me[0], 16) & 8 ? "00" + me : me, m = (me) => {
        const F = me.toString(16);
        return F.length & 1 ? `0${F}` : F;
      }, j = S(m(P.s)), Z = S(m(P.r)), ce = j.length / 2, ae = Z.length / 2, ee = m(ce), Se = m(ae);
      return `30${m(ae + ce + 4)}02${Se}${Z}02${ee}${j}`;
    }
  };
  const l = BigInt(0), p = BigInt(1), b = BigInt(2), w = BigInt(3), I = BigInt(4);
  function A(P) {
    const S = u(P), { Fp: m } = S, j = S.toBytes || ((J, V, re) => {
      const H = V.toAffine();
      return o.concatBytes(Uint8Array.from([4]), m.toBytes(H.x), m.toBytes(H.y));
    }), Z = S.fromBytes || ((J) => {
      const V = J.subarray(1), re = m.fromBytes(V.subarray(0, m.BYTES)), H = m.fromBytes(V.subarray(m.BYTES, 2 * m.BYTES));
      return { x: re, y: H };
    });
    function ce(J) {
      const { a: V, b: re } = S, H = m.sqr(J), z = m.mul(H, J);
      return m.add(m.add(z, m.mul(J, V)), re);
    }
    if (!m.eql(m.sqr(S.Gy), ce(S.Gx)))
      throw new Error("bad generator point: equation left != right");
    function ae(J) {
      return typeof J == "bigint" && l < J && J < S.n;
    }
    function ee(J) {
      if (!ae(J))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function Se(J) {
      const { allowedPrivateKeyLengths: V, nByteLength: re, wrapPrivateKey: H, n: z } = S;
      if (V && typeof J != "bigint") {
        if (o.isBytes(J) && (J = o.bytesToHex(J)), typeof J != "string" || !V.includes(J.length))
          throw new Error("Invalid key");
        J = J.padStart(re * 2, "0");
      }
      let se;
      try {
        se = typeof J == "bigint" ? J : o.bytesToNumberBE((0, s.ensureBytes)("private key", J, re));
      } catch {
        throw new Error(`private key must be ${re} bytes, hex or bigint, not ${typeof J}`);
      }
      return H && (se = r.mod(se, z)), ee(se), se;
    }
    const me = /* @__PURE__ */ new Map();
    function F(J) {
      if (!(J instanceof U))
        throw new Error("ProjectivePoint expected");
    }
    class U {
      constructor(V, re, H) {
        if (this.px = V, this.py = re, this.pz = H, V == null || !m.isValid(V))
          throw new Error("x required");
        if (re == null || !m.isValid(re))
          throw new Error("y required");
        if (H == null || !m.isValid(H))
          throw new Error("z required");
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(V) {
        const { x: re, y: H } = V || {};
        if (!V || !m.isValid(re) || !m.isValid(H))
          throw new Error("invalid affine point");
        if (V instanceof U)
          throw new Error("projective point not allowed");
        const z = (se) => m.eql(se, m.ZERO);
        return z(re) && z(H) ? U.ZERO : new U(re, H, m.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(V) {
        const re = m.invertBatch(V.map((H) => H.pz));
        return V.map((H, z) => H.toAffine(re[z])).map(U.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(V) {
        const re = U.fromAffine(Z((0, s.ensureBytes)("pointHex", V)));
        return re.assertValidity(), re;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(V) {
        return U.BASE.multiply(Se(V));
      }
      // "Private method", don't use it directly
      _setWindowSize(V) {
        this._WINDOW_SIZE = V, me.delete(this);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        if (this.is0()) {
          if (S.allowInfinityPoint && !m.is0(this.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x: V, y: re } = this.toAffine();
        if (!m.isValid(V) || !m.isValid(re))
          throw new Error("bad point: x or y not FE");
        const H = m.sqr(re), z = ce(V);
        if (!m.eql(H, z))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y: V } = this.toAffine();
        if (m.isOdd)
          return !m.isOdd(V);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(V) {
        F(V);
        const { px: re, py: H, pz: z } = this, { px: se, py: de, pz: te } = V, _e = m.eql(m.mul(re, te), m.mul(se, z)), be = m.eql(m.mul(H, te), m.mul(de, z));
        return _e && be;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new U(this.px, m.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a: V, b: re } = S, H = m.mul(re, w), { px: z, py: se, pz: de } = this;
        let te = m.ZERO, _e = m.ZERO, be = m.ZERO, R = m.mul(z, z), O = m.mul(se, se), W = m.mul(de, de), ie = m.mul(z, se);
        return ie = m.add(ie, ie), be = m.mul(z, de), be = m.add(be, be), te = m.mul(V, be), _e = m.mul(H, W), _e = m.add(te, _e), te = m.sub(O, _e), _e = m.add(O, _e), _e = m.mul(te, _e), te = m.mul(ie, te), be = m.mul(H, be), W = m.mul(V, W), ie = m.sub(R, W), ie = m.mul(V, ie), ie = m.add(ie, be), be = m.add(R, R), R = m.add(be, R), R = m.add(R, W), R = m.mul(R, ie), _e = m.add(_e, R), W = m.mul(se, de), W = m.add(W, W), R = m.mul(W, ie), te = m.sub(te, R), be = m.mul(W, O), be = m.add(be, be), be = m.add(be, be), new U(te, _e, be);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(V) {
        F(V);
        const { px: re, py: H, pz: z } = this, { px: se, py: de, pz: te } = V;
        let _e = m.ZERO, be = m.ZERO, R = m.ZERO;
        const O = S.a, W = m.mul(S.b, w);
        let ie = m.mul(re, se), ye = m.mul(H, de), d = m.mul(z, te), g = m.add(re, H), _ = m.add(se, de);
        g = m.mul(g, _), _ = m.add(ie, ye), g = m.sub(g, _), _ = m.add(re, z);
        let E = m.add(se, te);
        return _ = m.mul(_, E), E = m.add(ie, d), _ = m.sub(_, E), E = m.add(H, z), _e = m.add(de, te), E = m.mul(E, _e), _e = m.add(ye, d), E = m.sub(E, _e), R = m.mul(O, _), _e = m.mul(W, d), R = m.add(_e, R), _e = m.sub(ye, R), R = m.add(ye, R), be = m.mul(_e, R), ye = m.add(ie, ie), ye = m.add(ye, ie), d = m.mul(O, d), _ = m.mul(W, _), ye = m.add(ye, d), d = m.sub(ie, d), d = m.mul(O, d), _ = m.add(_, d), ie = m.mul(ye, _), be = m.add(be, ie), ie = m.mul(E, _), _e = m.mul(g, _e), _e = m.sub(_e, ie), ie = m.mul(g, ye), R = m.mul(E, R), R = m.add(R, ie), new U(_e, be, R);
      }
      subtract(V) {
        return this.add(V.negate());
      }
      is0() {
        return this.equals(U.ZERO);
      }
      wNAF(V) {
        return q.wNAFCached(this, me, V, (re) => {
          const H = m.invertBatch(re.map((z) => z.pz));
          return re.map((z, se) => z.toAffine(H[se])).map(U.fromAffine);
        });
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(V) {
        const re = U.ZERO;
        if (V === l)
          return re;
        if (ee(V), V === p)
          return this;
        const { endo: H } = S;
        if (!H)
          return q.unsafeLadder(this, V);
        let { k1neg: z, k1: se, k2neg: de, k2: te } = H.splitScalar(V), _e = re, be = re, R = this;
        for (; se > l || te > l; )
          se & p && (_e = _e.add(R)), te & p && (be = be.add(R)), R = R.double(), se >>= p, te >>= p;
        return z && (_e = _e.negate()), de && (be = be.negate()), be = new U(m.mul(be.px, H.beta), be.py, be.pz), _e.add(be);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(V) {
        ee(V);
        let re = V, H, z;
        const { endo: se } = S;
        if (se) {
          const { k1neg: de, k1: te, k2neg: _e, k2: be } = se.splitScalar(re);
          let { p: R, f: O } = this.wNAF(te), { p: W, f: ie } = this.wNAF(be);
          R = q.constTimeNegate(de, R), W = q.constTimeNegate(_e, W), W = new U(m.mul(W.px, se.beta), W.py, W.pz), H = R.add(W), z = O.add(ie);
        } else {
          const { p: de, f: te } = this.wNAF(re);
          H = de, z = te;
        }
        return U.normalizeZ([H, z])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(V, re, H) {
        const z = U.BASE, se = (te, _e) => _e === l || _e === p || !te.equals(z) ? te.multiplyUnsafe(_e) : te.multiply(_e), de = se(this, re).add(se(V, H));
        return de.is0() ? void 0 : de;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z)  (x=x/z, y=y/z)
      toAffine(V) {
        const { px: re, py: H, pz: z } = this, se = this.is0();
        V == null && (V = se ? m.ONE : m.inv(z));
        const de = m.mul(re, V), te = m.mul(H, V), _e = m.mul(z, V);
        if (se)
          return { x: m.ZERO, y: m.ZERO };
        if (!m.eql(_e, m.ONE))
          throw new Error("invZ was invalid");
        return { x: de, y: te };
      }
      isTorsionFree() {
        const { h: V, isTorsionFree: re } = S;
        if (V === p)
          return !0;
        if (re)
          return re(U, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: V, clearCofactor: re } = S;
        return V === p ? this : re ? re(U, this) : this.multiplyUnsafe(S.h);
      }
      toRawBytes(V = !0) {
        return this.assertValidity(), j(U, this, V);
      }
      toHex(V = !0) {
        return o.bytesToHex(this.toRawBytes(V));
      }
    }
    U.BASE = new U(S.Gx, S.Gy, m.ONE), U.ZERO = new U(m.ZERO, m.ONE, m.ZERO);
    const $ = S.nBitLength, q = (0, t.wNAF)(U, S.endo ? Math.ceil($ / 2) : $);
    return {
      CURVE: S,
      ProjectivePoint: U,
      normPrivateKeyToScalar: Se,
      weierstrassEquation: ce,
      isWithinCurveOrder: ae
    };
  }
  function x(P) {
    const S = (0, t.validateBasic)(P);
    return o.validateObject(S, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    }), Object.freeze({ lowS: !0, ...S });
  }
  function v(P) {
    const S = x(P), { Fp: m, n: j } = S, Z = m.BYTES + 1, ce = 2 * m.BYTES + 1;
    function ae(_) {
      return l < _ && _ < m.ORDER;
    }
    function ee(_) {
      return r.mod(_, j);
    }
    function Se(_) {
      return r.invert(_, j);
    }
    const { ProjectivePoint: me, normPrivateKeyToScalar: F, weierstrassEquation: U, isWithinCurveOrder: $ } = A({
      ...S,
      toBytes(_, E, K) {
        const ne = E.toAffine(), oe = m.toBytes(ne.x), Ie = o.concatBytes;
        return K ? Ie(Uint8Array.from([E.hasEvenY() ? 2 : 3]), oe) : Ie(Uint8Array.from([4]), oe, m.toBytes(ne.y));
      },
      fromBytes(_) {
        const E = _.length, K = _[0], ne = _.subarray(1);
        if (E === Z && (K === 2 || K === 3)) {
          const oe = o.bytesToNumberBE(ne);
          if (!ae(oe))
            throw new Error("Point is not on curve");
          const Ie = U(oe);
          let Be;
          try {
            Be = m.sqrt(Ie);
          } catch (Re) {
            const He = Re instanceof Error ? ": " + Re.message : "";
            throw new Error("Point is not on curve" + He);
          }
          const Ce = (Be & p) === p;
          return (K & 1) === 1 !== Ce && (Be = m.neg(Be)), { x: oe, y: Be };
        } else if (E === ce && K === 4) {
          const oe = m.fromBytes(ne.subarray(0, m.BYTES)), Ie = m.fromBytes(ne.subarray(m.BYTES, 2 * m.BYTES));
          return { x: oe, y: Ie };
        } else
          throw new Error(`Point of length ${E} was invalid. Expected ${Z} compressed bytes or ${ce} uncompressed bytes`);
      }
    }), q = (_) => o.bytesToHex(o.numberToBytesBE(_, S.nByteLength));
    function J(_) {
      const E = j >> p;
      return _ > E;
    }
    function V(_) {
      return J(_) ? ee(-_) : _;
    }
    const re = (_, E, K) => o.bytesToNumberBE(_.slice(E, K));
    class H {
      constructor(E, K, ne) {
        this.r = E, this.s = K, this.recovery = ne, this.assertValidity();
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(E) {
        const K = S.nByteLength;
        return E = (0, s.ensureBytes)("compactSignature", E, K * 2), new H(re(E, 0, K), re(E, K, 2 * K));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(E) {
        const { r: K, s: ne } = e.DER.toSig((0, s.ensureBytes)("DER", E));
        return new H(K, ne);
      }
      assertValidity() {
        if (!$(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!$(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(E) {
        return new H(this.r, this.s, E);
      }
      recoverPublicKey(E) {
        const { r: K, s: ne, recovery: oe } = this, Ie = be((0, s.ensureBytes)("msgHash", E));
        if (oe == null || ![0, 1, 2, 3].includes(oe))
          throw new Error("recovery id invalid");
        const Be = oe === 2 || oe === 3 ? K + S.n : K;
        if (Be >= m.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const Ce = oe & 1 ? "03" : "02", Ue = me.fromHex(Ce + q(Be)), Re = Se(Be), He = ee(-Ie * Re), _t = ee(ne * Re), tt = me.BASE.multiplyAndAddUnsafe(Ue, He, _t);
        if (!tt)
          throw new Error("point at infinify");
        return tt.assertValidity(), tt;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return J(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new H(this.r, ee(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return o.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return e.DER.hexFromSig({ r: this.r, s: this.s });
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return o.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return q(this.r) + q(this.s);
      }
    }
    const z = {
      isValidPrivateKey(_) {
        try {
          return F(_), !0;
        } catch {
          return !1;
        }
      },
      normPrivateKeyToScalar: F,
      /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */
      randomPrivateKey: () => {
        const _ = r.getMinHashLength(S.n);
        return r.mapHashToField(S.randomBytes(_), S.n);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(_ = 8, E = me.BASE) {
        return E._setWindowSize(_), E.multiply(BigInt(3)), E;
      }
    };
    function se(_, E = !0) {
      return me.fromPrivateKey(_).toRawBytes(E);
    }
    function de(_) {
      const E = o.isBytes(_), K = typeof _ == "string", ne = (E || K) && _.length;
      return E ? ne === Z || ne === ce : K ? ne === 2 * Z || ne === 2 * ce : _ instanceof me;
    }
    function te(_, E, K = !0) {
      if (de(_))
        throw new Error("first arg must be private key");
      if (!de(E))
        throw new Error("second arg must be public key");
      return me.fromHex(E).multiply(F(_)).toRawBytes(K);
    }
    const _e = S.bits2int || function(_) {
      const E = o.bytesToNumberBE(_), K = _.length * 8 - S.nBitLength;
      return K > 0 ? E >> BigInt(K) : E;
    }, be = S.bits2int_modN || function(_) {
      return ee(_e(_));
    }, R = o.bitMask(S.nBitLength);
    function O(_) {
      if (typeof _ != "bigint")
        throw new Error("bigint expected");
      if (!(l <= _ && _ < R))
        throw new Error(`bigint expected < 2^${S.nBitLength}`);
      return o.numberToBytesBE(_, S.nByteLength);
    }
    function W(_, E, K = ie) {
      if (["recovered", "canonical"].some((Xe) => Xe in K))
        throw new Error("sign() legacy options not supported");
      const { hash: ne, randomBytes: oe } = S;
      let { lowS: Ie, prehash: Be, extraEntropy: Ce } = K;
      Ie == null && (Ie = !0), _ = (0, s.ensureBytes)("msgHash", _), Be && (_ = (0, s.ensureBytes)("prehashed msgHash", ne(_)));
      const Ue = be(_), Re = F(E), He = [O(Re), O(Ue)];
      if (Ce != null && Ce !== !1) {
        const Xe = Ce === !0 ? oe(m.BYTES) : Ce;
        He.push((0, s.ensureBytes)("extraEntropy", Xe));
      }
      const _t = o.concatBytes(...He), tt = Ue;
      function yt(Xe) {
        const Ge = _e(Xe);
        if (!$(Ge))
          return;
        const jt = Se(Ge), Pt = me.BASE.multiply(Ge).toAffine(), ut = ee(Pt.x);
        if (ut === l)
          return;
        const Nt = ee(jt * ee(tt + ut * Re));
        if (Nt === l)
          return;
        let lr = (Pt.x === ut ? 0 : 2) | Number(Pt.y & p), tr = Nt;
        return Ie && J(Nt) && (tr = V(Nt), lr ^= 1), new H(ut, tr, lr);
      }
      return { seed: _t, k2sig: yt };
    }
    const ie = { lowS: S.lowS, prehash: !1 }, ye = { lowS: S.lowS, prehash: !1 };
    function d(_, E, K = ie) {
      const { seed: ne, k2sig: oe } = W(_, E, K), Ie = S;
      return o.createHmacDrbg(Ie.hash.outputLen, Ie.nByteLength, Ie.hmac)(ne, oe);
    }
    me.BASE._setWindowSize(8);
    function g(_, E, K, ne = ye) {
      var Pt;
      const oe = _;
      if (E = (0, s.ensureBytes)("msgHash", E), K = (0, s.ensureBytes)("publicKey", K), "strict" in ne)
        throw new Error("options.strict was renamed to lowS");
      const { lowS: Ie, prehash: Be } = ne;
      let Ce, Ue;
      try {
        if (typeof oe == "string" || o.isBytes(oe))
          try {
            Ce = H.fromDER(oe);
          } catch (ut) {
            if (!(ut instanceof e.DER.Err))
              throw ut;
            Ce = H.fromCompact(oe);
          }
        else if (typeof oe == "object" && typeof oe.r == "bigint" && typeof oe.s == "bigint") {
          const { r: ut, s: Nt } = oe;
          Ce = new H(ut, Nt);
        } else
          throw new Error("PARSE");
        Ue = me.fromHex(K);
      } catch (ut) {
        if (ut.message === "PARSE")
          throw new Error("signature must be Signature instance, Uint8Array or hex string");
        return !1;
      }
      if (Ie && Ce.hasHighS())
        return !1;
      Be && (E = S.hash(E));
      const { r: Re, s: He } = Ce, _t = be(E), tt = Se(He), yt = ee(_t * tt), Xe = ee(Re * tt), Ge = (Pt = me.BASE.multiplyAndAddUnsafe(Ue, yt, Xe)) == null ? void 0 : Pt.toAffine();
      return Ge ? ee(Ge.x) === Re : !1;
    }
    return {
      CURVE: S,
      getPublicKey: se,
      getSharedSecret: te,
      sign: d,
      verify: g,
      ProjectivePoint: me,
      Signature: H,
      utils: z
    };
  }
  function C(P, S) {
    const m = P.ORDER;
    let j = l;
    for (let J = m - p; J % b === l; J /= b)
      j += p;
    const Z = j, ce = b << Z - p - p, ae = ce * b, ee = (m - p) / ae, Se = (ee - p) / b, me = ae - p, F = ce, U = P.pow(S, ee), $ = P.pow(S, (ee + p) / b);
    let q = (J, V) => {
      let re = U, H = P.pow(V, me), z = P.sqr(H);
      z = P.mul(z, V);
      let se = P.mul(J, z);
      se = P.pow(se, Se), se = P.mul(se, H), H = P.mul(se, V), z = P.mul(se, J);
      let de = P.mul(z, H);
      se = P.pow(de, F);
      let te = P.eql(se, P.ONE);
      H = P.mul(z, $), se = P.mul(de, re), z = P.cmov(H, z, te), de = P.cmov(se, de, te);
      for (let _e = Z; _e > p; _e--) {
        let be = _e - b;
        be = b << be - p;
        let R = P.pow(de, be);
        const O = P.eql(R, P.ONE);
        H = P.mul(z, re), re = P.mul(re, re), R = P.mul(de, re), z = P.cmov(H, z, O), de = P.cmov(R, de, O);
      }
      return { isValid: te, value: z };
    };
    if (P.ORDER % I === w) {
      const J = (P.ORDER - w) / I, V = P.sqrt(P.neg(S));
      q = (re, H) => {
        let z = P.sqr(H);
        const se = P.mul(re, H);
        z = P.mul(z, se);
        let de = P.pow(z, J);
        de = P.mul(de, se);
        const te = P.mul(de, V), _e = P.mul(P.sqr(de), H), be = P.eql(_e, re);
        let R = P.cmov(te, de, be);
        return { isValid: be, value: R };
      };
    }
    return q;
  }
  function B(P, S) {
    if (r.validateField(P), !P.isValid(S.A) || !P.isValid(S.B) || !P.isValid(S.Z))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const m = C(P, S.Z);
    if (!P.isOdd)
      throw new Error("Fp.isOdd is not implemented!");
    return (j) => {
      let Z, ce, ae, ee, Se, me, F, U;
      Z = P.sqr(j), Z = P.mul(Z, S.Z), ce = P.sqr(Z), ce = P.add(ce, Z), ae = P.add(ce, P.ONE), ae = P.mul(ae, S.B), ee = P.cmov(S.Z, P.neg(ce), !P.eql(ce, P.ZERO)), ee = P.mul(ee, S.A), ce = P.sqr(ae), me = P.sqr(ee), Se = P.mul(me, S.A), ce = P.add(ce, Se), ce = P.mul(ce, ae), me = P.mul(me, ee), Se = P.mul(me, S.B), ce = P.add(ce, Se), F = P.mul(Z, ae);
      const { isValid: $, value: q } = m(ce, me);
      U = P.mul(Z, j), U = P.mul(U, q), F = P.cmov(F, ae, $), U = P.cmov(U, q, $);
      const J = P.isOdd(j) === P.isOdd(U);
      return U = P.cmov(P.neg(U), U, J), F = P.div(F, ee), { x: F, y: U };
    };
  }
})(Id);
Object.defineProperty(Qu, "__esModule", { value: !0 });
Qu.getHash = a0;
Qu.createCurve = SP;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const EP = Yy, mb = ri, vP = Id;
function a0(e) {
  return {
    hash: e,
    hmac: (t, ...r) => (0, EP.hmac)(e, t, (0, mb.concatBytes)(...r)),
    randomBytes: mb.randomBytes
  };
}
function SP(e, t) {
  const r = (o) => (0, vP.weierstrass)({ ...e, ...a0(o) });
  return Object.freeze({ ...r(t), create: r });
}
var io = {};
Object.defineProperty(io, "__esModule", { value: !0 });
io.expand_message_xmd = u0;
io.expand_message_xof = f0;
io.hash_to_field = kc;
io.isogenyMap = IP;
io.createHasher = OP;
const RP = bt, Qt = st, AP = Qt.bytesToNumberBE;
function vi(e, t) {
  if (e < 0 || e >= 1 << 8 * t)
    throw new Error(`bad I2OSP call: value=${e} length=${t}`);
  const r = Array.from({ length: t }).fill(0);
  for (let o = t - 1; o >= 0; o--)
    r[o] = e & 255, e >>>= 8;
  return new Uint8Array(r);
}
function TP(e, t) {
  const r = new Uint8Array(e.length);
  for (let o = 0; o < e.length; o++)
    r[o] = e[o] ^ t[o];
  return r;
}
function Bd(e) {
  if (!Number.isSafeInteger(e))
    throw new Error("number expected");
}
function u0(e, t, r, o) {
  (0, Qt.abytes)(e), (0, Qt.abytes)(t), Bd(r), t.length > 255 && (t = o((0, Qt.concatBytes)((0, Qt.utf8ToBytes)("H2C-OVERSIZE-DST-"), t)));
  const { outputLen: s, blockLen: u } = o, f = Math.ceil(r / s);
  if (f > 255)
    throw new Error("Invalid xmd length");
  const h = (0, Qt.concatBytes)(t, vi(t.length, 1)), l = vi(0, u), p = vi(r, 2), b = new Array(f), w = o((0, Qt.concatBytes)(l, e, p, vi(0, 1), h));
  b[0] = o((0, Qt.concatBytes)(w, vi(1, 1), h));
  for (let A = 1; A <= f; A++) {
    const x = [TP(w, b[A - 1]), vi(A + 1, 1), h];
    b[A] = o((0, Qt.concatBytes)(...x));
  }
  return (0, Qt.concatBytes)(...b).slice(0, r);
}
function f0(e, t, r, o, s) {
  if ((0, Qt.abytes)(e), (0, Qt.abytes)(t), Bd(r), t.length > 255) {
    const u = Math.ceil(2 * o / 8);
    t = s.create({ dkLen: u }).update((0, Qt.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest();
  }
  if (r > 65535 || t.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return s.create({ dkLen: r }).update(e).update(vi(r, 2)).update(t).update(vi(t.length, 1)).digest();
}
function kc(e, t, r) {
  (0, Qt.validateObject)(r, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: o, k: s, m: u, hash: f, expand: h, DST: l } = r;
  (0, Qt.abytes)(e), Bd(t);
  const p = typeof l == "string" ? (0, Qt.utf8ToBytes)(l) : l, b = o.toString(2).length, w = Math.ceil((b + s) / 8), I = t * u * w;
  let A;
  if (h === "xmd")
    A = u0(e, p, I, f);
  else if (h === "xof")
    A = f0(e, p, I, s, f);
  else if (h === "_internal_pass")
    A = e;
  else
    throw new Error('expand must be "xmd" or "xof"');
  const x = new Array(t);
  for (let v = 0; v < t; v++) {
    const C = new Array(u);
    for (let B = 0; B < u; B++) {
      const P = w * (B + v * u), S = A.subarray(P, P + w);
      C[B] = (0, RP.mod)(AP(S), o);
    }
    x[v] = C;
  }
  return x;
}
function IP(e, t) {
  const r = t.map((o) => Array.from(o).reverse());
  return (o, s) => {
    const [u, f, h, l] = r.map((p) => p.reduce((b, w) => e.add(e.mul(b, o), w)));
    return o = e.div(u, f), s = e.mul(s, e.div(h, l)), { x: o, y: s };
  };
}
function OP(e, t, r) {
  if (typeof t != "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(o, s) {
      const u = kc(o, 2, { ...r, DST: r.DST, ...s }), f = e.fromAffine(t(u[0])), h = e.fromAffine(t(u[1])), l = f.add(h).clearCofactor();
      return l.assertValidity(), l;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(o, s) {
      const u = kc(o, 1, { ...r, DST: r.encodeDST, ...s }), f = e.fromAffine(t(u[0])).clearCofactor();
      return f.assertValidity(), f;
    },
    // Same as encodeToCurve, but without hash
    mapToCurve(o) {
      if (!Array.isArray(o))
        throw new Error("mapToCurve: expected array of bigints");
      for (const u of o)
        if (typeof u != "bigint")
          throw new Error(`mapToCurve: expected array of bigints, got ${u} in array`);
      const s = e.fromAffine(t(o)).clearCofactor();
      return s.assertValidity(), s;
    }
  };
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.encodeToCurve = e.hashToCurve = e.schnorr = e.secp256k1 = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const t = Uo, r = ri, o = Qu, s = io, u = bt, f = st, h = Id, l = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), p = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), b = BigInt(1), w = BigInt(2), I = (H, z) => (H + z / w) / z;
  function A(H) {
    const z = l, se = BigInt(3), de = BigInt(6), te = BigInt(11), _e = BigInt(22), be = BigInt(23), R = BigInt(44), O = BigInt(88), W = H * H * H % z, ie = W * W * H % z, ye = (0, u.pow2)(ie, se, z) * ie % z, d = (0, u.pow2)(ye, se, z) * ie % z, g = (0, u.pow2)(d, w, z) * W % z, _ = (0, u.pow2)(g, te, z) * g % z, E = (0, u.pow2)(_, _e, z) * _ % z, K = (0, u.pow2)(E, R, z) * E % z, ne = (0, u.pow2)(K, O, z) * K % z, oe = (0, u.pow2)(ne, R, z) * E % z, Ie = (0, u.pow2)(oe, se, z) * ie % z, Be = (0, u.pow2)(Ie, be, z) * _ % z, Ce = (0, u.pow2)(Be, de, z) * W % z, Ue = (0, u.pow2)(Ce, w, z);
    if (!x.eql(x.sqr(Ue), H))
      throw new Error("Cannot find square root");
    return Ue;
  }
  const x = (0, u.Field)(l, void 0, void 0, { sqrt: A });
  e.secp256k1 = (0, o.createCurve)({
    a: BigInt(0),
    // equation params: a, b
    b: BigInt(7),
    // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
    Fp: x,
    // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
    n: p,
    // Curve order, total count of valid points in the field
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    // Cofactor
    lowS: !0,
    // Allow only low-S signatures by default in sign() and verify()
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (H) => {
        const z = p, se = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), de = -b * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), te = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), _e = se, be = BigInt("0x100000000000000000000000000000000"), R = I(_e * H, z), O = I(-de * H, z);
        let W = (0, u.mod)(H - R * se - O * te, z), ie = (0, u.mod)(-R * de - O * _e, z);
        const ye = W > be, d = ie > be;
        if (ye && (W = z - W), d && (ie = z - ie), W > be || ie > be)
          throw new Error("splitScalar: Endomorphism failed, k=" + H);
        return { k1neg: ye, k1: W, k2neg: d, k2: ie };
      }
    }
  }, t.sha256);
  const v = BigInt(0), C = (H) => typeof H == "bigint" && v < H && H < l, B = (H) => typeof H == "bigint" && v < H && H < p, P = {};
  function S(H, ...z) {
    let se = P[H];
    if (se === void 0) {
      const de = (0, t.sha256)(Uint8Array.from(H, (te) => te.charCodeAt(0)));
      se = (0, f.concatBytes)(de, de), P[H] = se;
    }
    return (0, t.sha256)((0, f.concatBytes)(se, ...z));
  }
  const m = (H) => H.toRawBytes(!0).slice(1), j = (H) => (0, f.numberToBytesBE)(H, 32), Z = (H) => (0, u.mod)(H, l), ce = (H) => (0, u.mod)(H, p), ae = e.secp256k1.ProjectivePoint, ee = (H, z, se) => ae.BASE.multiplyAndAddUnsafe(H, z, se);
  function Se(H) {
    let z = e.secp256k1.utils.normPrivateKeyToScalar(H), se = ae.fromPrivateKey(z);
    return { scalar: se.hasEvenY() ? z : ce(-z), bytes: m(se) };
  }
  function me(H) {
    if (!C(H))
      throw new Error("bad x: need 0 < x < p");
    const z = Z(H * H), se = Z(z * H + BigInt(7));
    let de = A(se);
    de % w !== v && (de = Z(-de));
    const te = new ae(H, de, b);
    return te.assertValidity(), te;
  }
  function F(...H) {
    return ce((0, f.bytesToNumberBE)(S("BIP0340/challenge", ...H)));
  }
  function U(H) {
    return Se(H).bytes;
  }
  function $(H, z, se = (0, r.randomBytes)(32)) {
    const de = (0, f.ensureBytes)("message", H), { bytes: te, scalar: _e } = Se(z), be = (0, f.ensureBytes)("auxRand", se, 32), R = j(_e ^ (0, f.bytesToNumberBE)(S("BIP0340/aux", be))), O = S("BIP0340/nonce", R, te, de), W = ce((0, f.bytesToNumberBE)(O));
    if (W === v)
      throw new Error("sign failed: k is zero");
    const { bytes: ie, scalar: ye } = Se(W), d = F(ie, te, de), g = new Uint8Array(64);
    if (g.set(ie, 0), g.set(j(ce(ye + d * _e)), 32), !q(g, de, te))
      throw new Error("sign: Invalid signature produced");
    return g;
  }
  function q(H, z, se) {
    const de = (0, f.ensureBytes)("signature", H, 64), te = (0, f.ensureBytes)("message", z), _e = (0, f.ensureBytes)("publicKey", se, 32);
    try {
      const be = me((0, f.bytesToNumberBE)(_e)), R = (0, f.bytesToNumberBE)(de.subarray(0, 32));
      if (!C(R))
        return !1;
      const O = (0, f.bytesToNumberBE)(de.subarray(32, 64));
      if (!B(O))
        return !1;
      const W = F(j(R), m(be), te), ie = ee(be, O, ce(-W));
      return !(!ie || !ie.hasEvenY() || ie.toAffine().x !== R);
    } catch {
      return !1;
    }
  }
  e.schnorr = {
    getPublicKey: U,
    sign: $,
    verify: q,
    utils: {
      randomPrivateKey: e.secp256k1.utils.randomPrivateKey,
      lift_x: me,
      pointToBytes: m,
      numberToBytesBE: f.numberToBytesBE,
      bytesToNumberBE: f.bytesToNumberBE,
      taggedHash: S,
      mod: u.mod
    }
  };
  const J = (0, s.isogenyMap)(x, [
    // xNum
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    // xDen
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
      // LAST 1
    ],
    // yNum
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    // yDen
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
      // LAST 1
    ]
  ].map((H) => H.map((z) => BigInt(z)))), V = (0, h.mapToCurveSimpleSWU)(x, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: x.create(BigInt("-11"))
  }), re = (0, s.createHasher)(e.secp256k1.ProjectivePoint, (H) => {
    const { x: z, y: se } = V(x.create(H[0]));
    return J(z, se);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: x.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: t.sha256
  });
  e.hashToCurve = re.hashToCurve, e.encodeToCurve = re.encodeToCurve;
})(Wy);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.secp256k1 = void 0;
  var t = Wy;
  Object.defineProperty(e, "secp256k1", { enumerable: !0, get: function() {
    return t.secp256k1;
  } });
})(Xu);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MAX_WITHDRAWALS_PER_PAYLOAD = e.RLP_EMPTY_STRING = e.KECCAK256_RLP = e.KECCAK256_RLP_S = e.KECCAK256_RLP_ARRAY = e.KECCAK256_RLP_ARRAY_S = e.KECCAK256_NULL = e.KECCAK256_NULL_S = e.TWO_POW256 = e.SECP256K1_ORDER_DIV_2 = e.SECP256K1_ORDER = e.MAX_INTEGER_BIGINT = e.MAX_INTEGER = e.MAX_UINT64 = void 0;
  const t = _r, r = Xu;
  e.MAX_UINT64 = BigInt("0xffffffffffffffff"), e.MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), e.MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935"), e.SECP256K1_ORDER = r.secp256k1.CURVE.n, e.SECP256K1_ORDER_DIV_2 = r.secp256k1.CURVE.n / BigInt(2), e.TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"), e.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470", e.KECCAK256_NULL = t.Buffer.from(e.KECCAK256_NULL_S, "hex"), e.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347", e.KECCAK256_RLP_ARRAY = t.Buffer.from(e.KECCAK256_RLP_ARRAY_S, "hex"), e.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", e.KECCAK256_RLP = t.Buffer.from(e.KECCAK256_RLP_S, "hex"), e.RLP_EMPTY_STRING = t.Buffer.from([128]), e.MAX_WITHDRAWALS_PER_PAYLOAD = 16;
})(Yu);
var sf = {};
Object.defineProperty(sf, "__esModule", { value: !0 });
sf.GWEI_TO_WEI = void 0;
sf.GWEI_TO_WEI = BigInt(1e9);
var Nd = {}, Tn = {};
Object.defineProperty(Tn, "__esModule", { value: !0 });
Tn.RLP = Tn.utils = Tn.decode = Tn.encode = void 0;
function $d(e) {
  if (Array.isArray(e)) {
    const r = [];
    let o = 0;
    for (let s = 0; s < e.length; s++) {
      const u = $d(e[s]);
      r.push(u), o += u.length;
    }
    return Hc(vb(o, 192), ...r);
  }
  const t = p0(e);
  return t.length === 1 && t[0] < 128 ? t : Hc(vb(t.length, 128), t);
}
Tn.encode = $d;
function To(e, t, r) {
  if (r > e.length)
    throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
  return e.slice(t, r);
}
function Eb(e) {
  if (e[0] === 0)
    throw new Error("invalid RLP: extra zeros");
  return d0(c0(e));
}
function vb(e, t) {
  if (e < 56)
    return Uint8Array.from([e + t]);
  const r = Wc(e), o = r.length / 2, s = Wc(t + 55 + o);
  return Uint8Array.from(Au(s + r));
}
function l0(e, t = !1) {
  if (typeof e > "u" || e === null || e.length === 0)
    return Uint8Array.from([]);
  const r = p0(e), o = Fc(r);
  if (t)
    return o;
  if (o.remainder.length !== 0)
    throw new Error("invalid RLP: remainder must be zero");
  return o.data;
}
Tn.decode = l0;
function Fc(e) {
  let t, r, o, s, u;
  const f = [], h = e[0];
  if (h <= 127)
    return {
      data: e.slice(0, 1),
      remainder: e.slice(1)
    };
  if (h <= 183) {
    if (t = h - 127, h === 128 ? o = Uint8Array.from([]) : o = To(e, 1, t), t === 2 && o[0] < 128)
      throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
    return {
      data: o,
      remainder: e.slice(t)
    };
  } else if (h <= 191) {
    if (r = h - 182, e.length - 1 < r)
      throw new Error("invalid RLP: not enough bytes for string length");
    if (t = Eb(To(e, 1, r)), t <= 55)
      throw new Error("invalid RLP: expected string length to be greater than 55");
    return o = To(e, r, t + r), {
      data: o,
      remainder: e.slice(t + r)
    };
  } else if (h <= 247) {
    for (t = h - 191, s = To(e, 1, t); s.length; )
      u = Fc(s), f.push(u.data), s = u.remainder;
    return {
      data: f,
      remainder: e.slice(t)
    };
  } else {
    if (r = h - 246, t = Eb(To(e, 1, r)), t < 56)
      throw new Error("invalid RLP: encoded list too short");
    const l = r + t;
    if (l > e.length)
      throw new Error("invalid RLP: total length is larger than the data");
    for (s = To(e, r, l); s.length; )
      u = Fc(s), f.push(u.data), s = u.remainder;
    return {
      data: f,
      remainder: e.slice(l)
    };
  }
}
const CP = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function c0(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += CP[e[r]];
  return t;
}
function d0(e) {
  const t = Number.parseInt(e, 16);
  if (Number.isNaN(t))
    throw new Error("Invalid byte sequence");
  return t;
}
function Au(e) {
  if (typeof e != "string")
    throw new TypeError("hexToBytes: expected string, got " + typeof e);
  if (e.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const t = new Uint8Array(e.length / 2);
  for (let r = 0; r < t.length; r++) {
    const o = r * 2;
    t[r] = d0(e.slice(o, o + 2));
  }
  return t;
}
function Hc(...e) {
  if (e.length === 1)
    return e[0];
  const t = e.reduce((o, s) => o + s.length, 0), r = new Uint8Array(t);
  for (let o = 0, s = 0; o < e.length; o++) {
    const u = e[o];
    r.set(u, s), s += u.length;
  }
  return r;
}
function h0(e) {
  return new TextEncoder().encode(e);
}
function Wc(e) {
  if (e < 0)
    throw new Error("Invalid integer as argument, must be unsigned!");
  const t = e.toString(16);
  return t.length % 2 ? `0${t}` : t;
}
function LP(e) {
  return e.length % 2 ? `0${e}` : e;
}
function g0(e) {
  return e.length >= 2 && e[0] === "0" && e[1] === "x";
}
function PP(e) {
  return typeof e != "string" ? e : g0(e) ? e.slice(2) : e;
}
function p0(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return g0(e) ? Au(LP(PP(e))) : h0(e);
  if (typeof e == "number" || typeof e == "bigint")
    return e ? Au(Wc(e)) : Uint8Array.from([]);
  if (e == null)
    return Uint8Array.from([]);
  throw new Error("toBytes: received unsupported type " + typeof e);
}
Tn.utils = {
  bytesToHex: c0,
  concatBytes: Hc,
  hexToBytes: Au,
  utf8ToBytes: h0
};
Tn.RLP = { encode: $d, decode: l0 };
var on = {}, ht = {}, je = {};
Object.defineProperty(je, "__esModule", { value: !0 });
je.add5L = je.add5H = je.add4H = je.add4L = je.add3H = je.add3L = je.add = je.rotlBL = je.rotlBH = je.rotlSL = je.rotlSH = je.rotr32L = je.rotr32H = je.rotrBL = je.rotrBH = je.rotrSL = je.rotrSH = je.shrSL = je.shrSH = je.toBig = je.split = je.fromBig = void 0;
const uu = /* @__PURE__ */ BigInt(2 ** 32 - 1), qc = /* @__PURE__ */ BigInt(32);
function Md(e, t = !1) {
  return t ? { h: Number(e & uu), l: Number(e >> qc & uu) } : { h: Number(e >> qc & uu) | 0, l: Number(e & uu) | 0 };
}
je.fromBig = Md;
function b0(e, t = !1) {
  let r = new Uint32Array(e.length), o = new Uint32Array(e.length);
  for (let s = 0; s < e.length; s++) {
    const { h: u, l: f } = Md(e[s], t);
    [r[s], o[s]] = [u, f];
  }
  return [r, o];
}
je.split = b0;
const _0 = (e, t) => BigInt(e >>> 0) << qc | BigInt(t >>> 0);
je.toBig = _0;
const y0 = (e, t, r) => e >>> r;
je.shrSH = y0;
const w0 = (e, t, r) => e << 32 - r | t >>> r;
je.shrSL = w0;
const m0 = (e, t, r) => e >>> r | t << 32 - r;
je.rotrSH = m0;
const E0 = (e, t, r) => e << 32 - r | t >>> r;
je.rotrSL = E0;
const v0 = (e, t, r) => e << 64 - r | t >>> r - 32;
je.rotrBH = v0;
const S0 = (e, t, r) => e >>> r - 32 | t << 64 - r;
je.rotrBL = S0;
const R0 = (e, t) => t;
je.rotr32H = R0;
const A0 = (e, t) => e;
je.rotr32L = A0;
const T0 = (e, t, r) => e << r | t >>> 32 - r;
je.rotlSH = T0;
const I0 = (e, t, r) => t << r | e >>> 32 - r;
je.rotlSL = I0;
const O0 = (e, t, r) => t << r - 32 | e >>> 64 - r;
je.rotlBH = O0;
const C0 = (e, t, r) => e << r - 32 | t >>> 64 - r;
je.rotlBL = C0;
function L0(e, t, r, o) {
  const s = (t >>> 0) + (o >>> 0);
  return { h: e + r + (s / 2 ** 32 | 0) | 0, l: s | 0 };
}
je.add = L0;
const P0 = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0);
je.add3L = P0;
const B0 = (e, t, r, o) => t + r + o + (e / 2 ** 32 | 0) | 0;
je.add3H = B0;
const N0 = (e, t, r, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (o >>> 0);
je.add4L = N0;
const $0 = (e, t, r, o, s) => t + r + o + s + (e / 2 ** 32 | 0) | 0;
je.add4H = $0;
const M0 = (e, t, r, o, s) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (o >>> 0) + (s >>> 0);
je.add5L = M0;
const x0 = (e, t, r, o, s, u) => t + r + o + s + u + (e / 2 ** 32 | 0) | 0;
je.add5H = x0;
const BP = {
  fromBig: Md,
  split: b0,
  toBig: _0,
  shrSH: y0,
  shrSL: w0,
  rotrSH: m0,
  rotrSL: E0,
  rotrBH: v0,
  rotrBL: S0,
  rotr32H: R0,
  rotr32L: A0,
  rotlSH: T0,
  rotlSL: I0,
  rotlBH: O0,
  rotlBL: C0,
  add: L0,
  add3L: P0,
  add3H: B0,
  add4L: N0,
  add4H: $0,
  add5H: x0,
  add5L: M0
};
je.default = BP;
Object.defineProperty(ht, "__esModule", { value: !0 });
ht.shake256 = ht.shake128 = ht.keccak_512 = ht.keccak_384 = ht.keccak_256 = ht.keccak_224 = ht.sha3_512 = ht.sha3_384 = ht.sha3_256 = ht.sha3_224 = ht.Keccak = ht.keccakP = void 0;
const Io = Ct, Ds = je, Yn = ri, D0 = [], j0 = [], U0 = [], NP = /* @__PURE__ */ BigInt(0), Es = /* @__PURE__ */ BigInt(1), $P = /* @__PURE__ */ BigInt(2), MP = /* @__PURE__ */ BigInt(7), xP = /* @__PURE__ */ BigInt(256), DP = /* @__PURE__ */ BigInt(113);
for (let e = 0, t = Es, r = 1, o = 0; e < 24; e++) {
  [r, o] = [o, (2 * r + 3 * o) % 5], D0.push(2 * (5 * o + r)), j0.push((e + 1) * (e + 2) / 2 % 64);
  let s = NP;
  for (let u = 0; u < 7; u++)
    t = (t << Es ^ (t >> MP) * DP) % xP, t & $P && (s ^= Es << (Es << /* @__PURE__ */ BigInt(u)) - Es);
  U0.push(s);
}
const [jP, UP] = /* @__PURE__ */ (0, Ds.split)(U0, !0), Sb = (e, t, r) => r > 32 ? (0, Ds.rotlBH)(e, t, r) : (0, Ds.rotlSH)(e, t, r), Rb = (e, t, r) => r > 32 ? (0, Ds.rotlBL)(e, t, r) : (0, Ds.rotlSL)(e, t, r);
function k0(e, t = 24) {
  const r = new Uint32Array(10);
  for (let o = 24 - t; o < 24; o++) {
    for (let f = 0; f < 10; f++)
      r[f] = e[f] ^ e[f + 10] ^ e[f + 20] ^ e[f + 30] ^ e[f + 40];
    for (let f = 0; f < 10; f += 2) {
      const h = (f + 8) % 10, l = (f + 2) % 10, p = r[l], b = r[l + 1], w = Sb(p, b, 1) ^ r[h], I = Rb(p, b, 1) ^ r[h + 1];
      for (let A = 0; A < 50; A += 10)
        e[f + A] ^= w, e[f + A + 1] ^= I;
    }
    let s = e[2], u = e[3];
    for (let f = 0; f < 24; f++) {
      const h = j0[f], l = Sb(s, u, h), p = Rb(s, u, h), b = D0[f];
      s = e[b], u = e[b + 1], e[b] = l, e[b + 1] = p;
    }
    for (let f = 0; f < 50; f += 10) {
      for (let h = 0; h < 10; h++)
        r[h] = e[f + h];
      for (let h = 0; h < 10; h++)
        e[f + h] ^= ~r[(h + 2) % 10] & r[(h + 4) % 10];
    }
    e[0] ^= jP[o], e[1] ^= UP[o];
  }
  r.fill(0);
}
ht.keccakP = k0;
class Ys extends Yn.Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, r, o, s = !1, u = 24) {
    if (super(), this.blockLen = t, this.suffix = r, this.outputLen = o, this.enableXOF = s, this.rounds = u, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, (0, Io.number)(o), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = (0, Yn.u32)(this.state);
  }
  keccak() {
    Yn.isLE || (0, Yn.byteSwap32)(this.state32), k0(this.state32, this.rounds), Yn.isLE || (0, Yn.byteSwap32)(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    (0, Io.exists)(this);
    const { blockLen: r, state: o } = this;
    t = (0, Yn.toBytes)(t);
    const s = t.length;
    for (let u = 0; u < s; ) {
      const f = Math.min(r - this.pos, s - u);
      for (let h = 0; h < f; h++)
        o[this.pos++] ^= t[u++];
      this.pos === r && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: r, pos: o, blockLen: s } = this;
    t[o] ^= r, r & 128 && o === s - 1 && this.keccak(), t[s - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    (0, Io.exists)(this, !1), (0, Io.bytes)(t), this.finish();
    const r = this.state, { blockLen: o } = this;
    for (let s = 0, u = t.length; s < u; ) {
      this.posOut >= o && this.keccak();
      const f = Math.min(o - this.posOut, u - s);
      t.set(r.subarray(this.posOut, this.posOut + f), s), this.posOut += f, s += f;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return (0, Io.number)(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if ((0, Io.output)(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: r, suffix: o, outputLen: s, rounds: u, enableXOF: f } = this;
    return t || (t = new Ys(r, o, s, f, u)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = u, t.suffix = o, t.outputLen = s, t.enableXOF = f, t.destroyed = this.destroyed, t;
  }
}
ht.Keccak = Ys;
const Li = (e, t, r) => (0, Yn.wrapConstructor)(() => new Ys(t, e, r));
ht.sha3_224 = Li(6, 144, 224 / 8);
ht.sha3_256 = Li(6, 136, 256 / 8);
ht.sha3_384 = Li(6, 104, 384 / 8);
ht.sha3_512 = Li(6, 72, 512 / 8);
ht.keccak_224 = Li(1, 144, 224 / 8);
ht.keccak_256 = Li(1, 136, 256 / 8);
ht.keccak_384 = Li(1, 104, 384 / 8);
ht.keccak_512 = Li(1, 72, 512 / 8);
const F0 = (e, t, r) => (0, Yn.wrapXOFConstructorWithOpts)((o = {}) => new Ys(t, e, o.dkLen === void 0 ? r : o.dkLen, !0));
ht.shake128 = F0(31, 168, 128 / 8);
ht.shake256 = F0(31, 136, 256 / 8);
var Tu = { exports: {} };
Tu.exports;
(function(e, t) {
  var r = Ye && Ye.__importDefault || function(I) {
    return I && I.__esModule ? I : { default: I };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.crypto = t.utf8ToBytes = t.createView = t.concatBytes = t.toHex = t.bytesToHex = t.assertBytes = t.assertBool = void 0, t.bytesToUtf8 = l, t.hexToBytes = p, t.equalsBytes = b, t.wrapHash = w;
  const o = r(Ct), s = ri, u = o.default.bool;
  t.assertBool = u;
  const f = o.default.bytes;
  t.assertBytes = f;
  var h = ri;
  Object.defineProperty(t, "bytesToHex", { enumerable: !0, get: function() {
    return h.bytesToHex;
  } }), Object.defineProperty(t, "toHex", { enumerable: !0, get: function() {
    return h.bytesToHex;
  } }), Object.defineProperty(t, "concatBytes", { enumerable: !0, get: function() {
    return h.concatBytes;
  } }), Object.defineProperty(t, "createView", { enumerable: !0, get: function() {
    return h.createView;
  } }), Object.defineProperty(t, "utf8ToBytes", { enumerable: !0, get: function() {
    return h.utf8ToBytes;
  } });
  function l(I) {
    if (!(I instanceof Uint8Array))
      throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof I}`);
    return new TextDecoder().decode(I);
  }
  function p(I) {
    const A = I.startsWith("0x") ? I.substring(2) : I;
    return (0, s.hexToBytes)(A);
  }
  function b(I, A) {
    if (I.length !== A.length)
      return !1;
    for (let x = 0; x < I.length; x++)
      if (I[x] !== A[x])
        return !1;
    return !0;
  }
  function w(I) {
    return (A) => (o.default.bytes(A), I(A));
  }
  t.crypto = (() => {
    const I = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0, A = typeof Gg == "function" && Gg.bind(e);
    return {
      node: A && !I ? A("crypto") : void 0,
      web: I
    };
  })();
})(Tu, Tu.exports);
var H0 = Tu.exports;
Object.defineProperty(on, "__esModule", { value: !0 });
on.keccak512 = on.keccak384 = on.keccak256 = on.keccak224 = void 0;
const js = ht, af = H0;
on.keccak224 = (0, af.wrapHash)(js.keccak_224);
on.keccak256 = (() => {
  const e = (0, af.wrapHash)(js.keccak_256);
  return e.create = js.keccak_256.create, e;
})();
on.keccak384 = (0, af.wrapHash)(js.keccak_384);
on.keccak512 = (0, af.wrapHash)(js.keccak_512);
var oo = {}, Wr = {}, gt = {};
Object.defineProperty(gt, "__esModule", { value: !0 });
gt.isHexString = gt.getKeys = gt.fromAscii = gt.fromUtf8 = gt.toAscii = gt.arrayContainsArray = gt.getBinarySize = gt.padToEven = gt.stripHexPrefix = gt.isHexPrefixed = void 0;
function W0(e) {
  if (typeof e != "string")
    throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof e}`);
  return e[0] === "0" && e[1] === "x";
}
gt.isHexPrefixed = W0;
const kP = (e) => {
  if (typeof e != "string")
    throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof e}`);
  return W0(e) ? e.slice(2) : e;
};
gt.stripHexPrefix = kP;
function q0(e) {
  let t = e;
  if (typeof t != "string")
    throw new Error(`[padToEven] value must be type 'string', received ${typeof t}`);
  return t.length % 2 && (t = `0${t}`), t;
}
gt.padToEven = q0;
function FP(e) {
  if (typeof e != "string")
    throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof e}`);
  return le.Buffer.byteLength(e, "utf8");
}
gt.getBinarySize = FP;
function HP(e, t, r) {
  if (Array.isArray(e) !== !0)
    throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof e}'`);
  if (Array.isArray(t) !== !0)
    throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof t}'`);
  return t[r === !0 ? "some" : "every"]((o) => e.indexOf(o) >= 0);
}
gt.arrayContainsArray = HP;
function WP(e) {
  let t = "", r = 0;
  const o = e.length;
  for (e.substring(0, 2) === "0x" && (r = 2); r < o; r += 2) {
    const s = parseInt(e.substr(r, 2), 16);
    t += String.fromCharCode(s);
  }
  return t;
}
gt.toAscii = WP;
function qP(e) {
  const t = le.Buffer.from(e, "utf8");
  return `0x${q0(t.toString("hex")).replace(/^0+|0+$/g, "")}`;
}
gt.fromUtf8 = qP;
function VP(e) {
  let t = "";
  for (let r = 0; r < e.length; r++) {
    const s = e.charCodeAt(r).toString(16);
    t += s.length < 2 ? `0${s}` : s;
  }
  return `0x${t}`;
}
gt.fromAscii = VP;
function GP(e, t, r) {
  if (!Array.isArray(e))
    throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof e}`);
  if (typeof t != "string")
    throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof e}`);
  const o = [];
  for (let s = 0; s < e.length; s++) {
    let u = e[s][t];
    if (r === !0 && !u)
      u = "";
    else if (typeof u != "string")
      throw new Error(`invalid abi - expected type 'string', received ${typeof u}`);
    o.push(u);
  }
  return o;
}
gt.getKeys = GP;
function zP(e, t) {
  return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || typeof t < "u" && t > 0 && e.length !== 2 + 2 * t);
}
gt.isHexString = zP;
Object.defineProperty(Wr, "__esModule", { value: !0 });
Wr.assertIsString = Wr.assertIsArray = Wr.assertIsBuffer = Wr.assertIsHexString = void 0;
const KP = gt, JP = function(e) {
  if (!(0, KP.isHexString)(e)) {
    const t = `This method only supports 0x-prefixed hex strings but input was: ${e}`;
    throw new Error(t);
  }
};
Wr.assertIsHexString = JP;
const YP = function(e) {
  if (!le.Buffer.isBuffer(e)) {
    const t = `This method only supports Buffer but input was: ${e}`;
    throw new Error(t);
  }
};
Wr.assertIsBuffer = YP;
const XP = function(e) {
  if (!Array.isArray(e)) {
    const t = `This method only supports number arrays but input was: ${e}`;
    throw new Error(t);
  }
};
Wr.assertIsArray = XP;
const ZP = function(e) {
  if (typeof e != "string") {
    const t = `This method only supports strings but input was: ${e}`;
    throw new Error(t);
  }
};
Wr.assertIsString = ZP;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.intToUnpaddedBuffer = e.bigIntToUnpaddedBuffer = e.bigIntToHex = e.bufArrToArr = e.arrToBufArr = e.validateNoLeadingZeroes = e.baToJSON = e.toUtf8 = e.short = e.addHexPrefix = e.toUnsigned = e.fromSigned = e.bufferToInt = e.bigIntToBuffer = e.bufferToBigInt = e.bufferToHex = e.toBuffer = e.unpadHexString = e.unpadArray = e.unpadBuffer = e.setLengthRight = e.setLengthLeft = e.zeros = e.intToBuffer = e.intToHex = void 0;
  const t = Wr, r = gt, o = function($) {
    if (!Number.isSafeInteger($) || $ < 0)
      throw new Error(`Received an invalid integer type: ${$}`);
    return `0x${$.toString(16)}`;
  };
  e.intToHex = o;
  const s = function($) {
    const q = (0, e.intToHex)($);
    return le.Buffer.from((0, r.padToEven)(q.slice(2)), "hex");
  };
  e.intToBuffer = s;
  const u = function($) {
    return le.Buffer.allocUnsafe($).fill(0);
  };
  e.zeros = u;
  const f = function($, q, J) {
    const V = (0, e.zeros)(q);
    return J ? $.length < q ? ($.copy(V), V) : $.slice(0, q) : $.length < q ? ($.copy(V, q - $.length), V) : $.slice(-q);
  }, h = function($, q) {
    return (0, t.assertIsBuffer)($), f($, q, !1);
  };
  e.setLengthLeft = h;
  const l = function($, q) {
    return (0, t.assertIsBuffer)($), f($, q, !0);
  };
  e.setLengthRight = l;
  const p = function($) {
    let q = $[0];
    for (; $.length > 0 && q.toString() === "0"; )
      $ = $.slice(1), q = $[0];
    return $;
  }, b = function($) {
    return (0, t.assertIsBuffer)($), p($);
  };
  e.unpadBuffer = b;
  const w = function($) {
    return (0, t.assertIsArray)($), p($);
  };
  e.unpadArray = w;
  const I = function($) {
    return (0, t.assertIsHexString)($), $ = (0, r.stripHexPrefix)($), "0x" + p($);
  };
  e.unpadHexString = I;
  const A = function($) {
    if ($ == null)
      return le.Buffer.allocUnsafe(0);
    if (le.Buffer.isBuffer($))
      return le.Buffer.from($);
    if (Array.isArray($) || $ instanceof Uint8Array)
      return le.Buffer.from($);
    if (typeof $ == "string") {
      if (!(0, r.isHexString)($))
        throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${$}`);
      return le.Buffer.from((0, r.padToEven)((0, r.stripHexPrefix)($)), "hex");
    }
    if (typeof $ == "number")
      return (0, e.intToBuffer)($);
    if (typeof $ == "bigint") {
      if ($ < BigInt(0))
        throw new Error(`Cannot convert negative bigint to buffer. Given: ${$}`);
      let q = $.toString(16);
      return q.length % 2 && (q = "0" + q), le.Buffer.from(q, "hex");
    }
    if ($.toArray)
      return le.Buffer.from($.toArray());
    if ($.toBuffer)
      return le.Buffer.from($.toBuffer());
    throw new Error("invalid type");
  };
  e.toBuffer = A;
  const x = function($) {
    return $ = (0, e.toBuffer)($), "0x" + $.toString("hex");
  };
  e.bufferToHex = x;
  function v($) {
    const q = (0, e.bufferToHex)($);
    return BigInt(q === "0x" ? 0 : q);
  }
  e.bufferToBigInt = v;
  function C($) {
    return (0, e.toBuffer)("0x" + $.toString(16));
  }
  e.bigIntToBuffer = C;
  const B = function($) {
    const q = Number(v($));
    if (!Number.isSafeInteger(q))
      throw new Error("Number exceeds 53 bits");
    return q;
  };
  e.bufferToInt = B;
  const P = function($) {
    return BigInt.asIntN(256, v($));
  };
  e.fromSigned = P;
  const S = function($) {
    return C(BigInt.asUintN(256, $));
  };
  e.toUnsigned = S;
  const m = function($) {
    return typeof $ != "string" || (0, r.isHexPrefixed)($) ? $ : "0x" + $;
  };
  e.addHexPrefix = m;
  function j($, q = 50) {
    const J = le.Buffer.isBuffer($) ? $.toString("hex") : $;
    return J.length <= q ? J : J.slice(0, q) + "";
  }
  e.short = j;
  const Z = function($) {
    const q = /^(00)+|(00)+$/g;
    if ($ = (0, r.stripHexPrefix)($), $.length % 2 !== 0)
      throw new Error("Invalid non-even hex string input for toUtf8() provided");
    return le.Buffer.from($.replace(q, ""), "hex").toString("utf8");
  };
  e.toUtf8 = Z;
  const ce = function($) {
    if (le.Buffer.isBuffer($))
      return `0x${$.toString("hex")}`;
    if ($ instanceof Array) {
      const q = [];
      for (let J = 0; J < $.length; J++)
        q.push((0, e.baToJSON)($[J]));
      return q;
    }
  };
  e.baToJSON = ce;
  const ae = function($) {
    for (const [q, J] of Object.entries($))
      if (J !== void 0 && J.length > 0 && J[0] === 0)
        throw new Error(`${q} cannot have leading zeroes, received: ${J.toString("hex")}`);
  };
  e.validateNoLeadingZeroes = ae;
  function ee($) {
    return Array.isArray($) ? $.map((q) => ee(q)) : le.Buffer.from($);
  }
  e.arrToBufArr = ee;
  function Se($) {
    return Array.isArray($) ? $.map((q) => Se(q)) : Uint8Array.from($ ?? []);
  }
  e.bufArrToArr = Se;
  const me = ($) => "0x" + $.toString(16);
  e.bigIntToHex = me;
  function F($) {
    return (0, e.unpadBuffer)(C($));
  }
  e.bigIntToUnpaddedBuffer = F;
  function U($) {
    return (0, e.unpadBuffer)((0, e.intToBuffer)($));
  }
  e.intToUnpaddedBuffer = U;
})(oo);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.accountBodyToRLP = e.accountBodyToSlim = e.accountBodyFromSlim = e.isZeroAddress = e.zeroAddress = e.importPublic = e.privateToAddress = e.privateToPublic = e.publicToAddress = e.pubToAddress = e.isValidPublic = e.isValidPrivate = e.generateAddress2 = e.generateAddress = e.isValidChecksumAddress = e.toChecksumAddress = e.isValidAddress = e.Account = void 0;
  const t = Tn, r = on, o = Xu, s = H0, u = oo, f = Yu, h = Wr, l = gt, p = BigInt(0);
  class b {
    /**
     * This constructor assigns and validates the values.
     * Use the static factory methods to assist in creating an Account from varying data types.
     */
    constructor(U = p, $ = p, q = f.KECCAK256_RLP, J = f.KECCAK256_NULL) {
      this.nonce = U, this.balance = $, this.storageRoot = q, this.codeHash = J, this._validate();
    }
    static fromAccountData(U) {
      const { nonce: $, balance: q, storageRoot: J, codeHash: V } = U;
      return new b($ !== void 0 ? (0, u.bufferToBigInt)((0, u.toBuffer)($)) : void 0, q !== void 0 ? (0, u.bufferToBigInt)((0, u.toBuffer)(q)) : void 0, J !== void 0 ? (0, u.toBuffer)(J) : void 0, V !== void 0 ? (0, u.toBuffer)(V) : void 0);
    }
    static fromRlpSerializedAccount(U) {
      const $ = (0, u.arrToBufArr)(t.RLP.decode(Uint8Array.from(U)));
      if (!Array.isArray($))
        throw new Error("Invalid serialized account input. Must be array");
      return this.fromValuesArray($);
    }
    static fromValuesArray(U) {
      const [$, q, J, V] = U;
      return new b((0, u.bufferToBigInt)($), (0, u.bufferToBigInt)(q), J, V);
    }
    _validate() {
      if (this.nonce < p)
        throw new Error("nonce must be greater than zero");
      if (this.balance < p)
        throw new Error("balance must be greater than zero");
      if (this.storageRoot.length !== 32)
        throw new Error("storageRoot must have a length of 32");
      if (this.codeHash.length !== 32)
        throw new Error("codeHash must have a length of 32");
    }
    /**
     * Returns a Buffer Array of the raw Buffers for the account, in order.
     */
    raw() {
      return [
        (0, u.bigIntToUnpaddedBuffer)(this.nonce),
        (0, u.bigIntToUnpaddedBuffer)(this.balance),
        this.storageRoot,
        this.codeHash
      ];
    }
    /**
     * Returns the RLP serialization of the account as a `Buffer`.
     */
    serialize() {
      return le.Buffer.from(t.RLP.encode((0, u.bufArrToArr)(this.raw())));
    }
    /**
     * Returns a `Boolean` determining if the account is a contract.
     */
    isContract() {
      return !this.codeHash.equals(f.KECCAK256_NULL);
    }
    /**
     * Returns a `Boolean` determining if the account is empty complying to the definition of
     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
     * "An account is considered empty when it has no code and zero nonce and zero balance."
     */
    isEmpty() {
      return this.balance === p && this.nonce === p && this.codeHash.equals(f.KECCAK256_NULL);
    }
  }
  e.Account = b;
  const w = function(F) {
    try {
      (0, h.assertIsString)(F);
    } catch {
      return !1;
    }
    return /^0x[0-9a-fA-F]{40}$/.test(F);
  };
  e.isValidAddress = w;
  const I = function(F, U) {
    (0, h.assertIsHexString)(F);
    const $ = (0, l.stripHexPrefix)(F).toLowerCase();
    let q = "";
    U !== void 0 && (q = (0, u.bufferToBigInt)((0, u.toBuffer)(U)).toString() + "0x");
    const J = le.Buffer.from(q + $, "utf8"), V = (0, s.bytesToHex)((0, r.keccak256)(J));
    let re = "0x";
    for (let H = 0; H < $.length; H++)
      parseInt(V[H], 16) >= 8 ? re += $[H].toUpperCase() : re += $[H];
    return re;
  };
  e.toChecksumAddress = I;
  const A = function(F, U) {
    return (0, e.isValidAddress)(F) && (0, e.toChecksumAddress)(F, U) === F;
  };
  e.isValidChecksumAddress = A;
  const x = function(F, U) {
    return (0, h.assertIsBuffer)(F), (0, h.assertIsBuffer)(U), (0, u.bufferToBigInt)(U) === BigInt(0) ? le.Buffer.from((0, r.keccak256)(t.RLP.encode((0, u.bufArrToArr)([F, null])))).slice(-20) : le.Buffer.from((0, r.keccak256)(t.RLP.encode((0, u.bufArrToArr)([F, U])))).slice(-20);
  };
  e.generateAddress = x;
  const v = function(F, U, $) {
    if ((0, h.assertIsBuffer)(F), (0, h.assertIsBuffer)(U), (0, h.assertIsBuffer)($), F.length !== 20)
      throw new Error("Expected from to be of length 20");
    if (U.length !== 32)
      throw new Error("Expected salt to be of length 32");
    const q = (0, r.keccak256)(le.Buffer.concat([le.Buffer.from("ff", "hex"), F, U, (0, r.keccak256)($)]));
    return (0, u.toBuffer)(q).slice(-20);
  };
  e.generateAddress2 = v;
  const C = function(F) {
    return o.secp256k1.utils.isValidPrivateKey(F);
  };
  e.isValidPrivate = C;
  const B = function(F, U = !1) {
    if ((0, h.assertIsBuffer)(F), F.length === 64)
      try {
        return o.secp256k1.ProjectivePoint.fromHex(le.Buffer.concat([le.Buffer.from([4]), F])), !0;
      } catch {
        return !1;
      }
    if (!U)
      return !1;
    try {
      return o.secp256k1.ProjectivePoint.fromHex(F), !0;
    } catch {
      return !1;
    }
  };
  e.isValidPublic = B;
  const P = function(F, U = !1) {
    if ((0, h.assertIsBuffer)(F), U && F.length !== 64 && (F = le.Buffer.from(o.secp256k1.ProjectivePoint.fromHex(F).toRawBytes(!1).slice(1))), F.length !== 64)
      throw new Error("Expected pubKey to be of length 64");
    return le.Buffer.from((0, r.keccak256)(F)).slice(-20);
  };
  e.pubToAddress = P, e.publicToAddress = e.pubToAddress;
  const S = function(F) {
    return (0, h.assertIsBuffer)(F), le.Buffer.from(o.secp256k1.ProjectivePoint.fromPrivateKey(F).toRawBytes(!1).slice(1));
  };
  e.privateToPublic = S;
  const m = function(F) {
    return (0, e.publicToAddress)((0, e.privateToPublic)(F));
  };
  e.privateToAddress = m;
  const j = function(F) {
    return (0, h.assertIsBuffer)(F), F.length !== 64 && (F = le.Buffer.from(o.secp256k1.ProjectivePoint.fromHex(F).toRawBytes(!1).slice(1))), F;
  };
  e.importPublic = j;
  const Z = function() {
    const U = (0, u.zeros)(20);
    return (0, u.bufferToHex)(U);
  };
  e.zeroAddress = Z;
  const ce = function(F) {
    try {
      (0, h.assertIsString)(F);
    } catch {
      return !1;
    }
    return (0, e.zeroAddress)() === F;
  };
  e.isZeroAddress = ce;
  function ae(F) {
    const [U, $, q, J] = F;
    return [
      U,
      $,
      (0, u.arrToBufArr)(q).length === 0 ? f.KECCAK256_RLP : q,
      (0, u.arrToBufArr)(J).length === 0 ? f.KECCAK256_NULL : J
    ];
  }
  e.accountBodyFromSlim = ae;
  const ee = new Uint8Array(0);
  function Se(F) {
    const [U, $, q, J] = F;
    return [
      U,
      $,
      (0, u.arrToBufArr)(q).equals(f.KECCAK256_RLP) ? ee : q,
      (0, u.arrToBufArr)(J).equals(f.KECCAK256_NULL) ? ee : J
    ];
  }
  e.accountBodyToSlim = Se;
  function me(F, U = !0) {
    const $ = U ? ae(F) : F;
    return (0, u.arrToBufArr)(t.RLP.encode($));
  }
  e.accountBodyToRLP = me;
})(Nd);
var Xs = {};
Object.defineProperty(Xs, "__esModule", { value: !0 });
Xs.Address = void 0;
const vs = Nd, fu = oo;
class Xn {
  constructor(t) {
    if (t.length !== 20)
      throw new Error("Invalid address length");
    this.buf = t;
  }
  /**
   * Returns the zero address.
   */
  static zero() {
    return new Xn((0, fu.zeros)(20));
  }
  /**
   * Returns an Address object from a hex-encoded string.
   * @param str - Hex-encoded address
   */
  static fromString(t) {
    if (!(0, vs.isValidAddress)(t))
      throw new Error("Invalid address");
    return new Xn((0, fu.toBuffer)(t));
  }
  /**
   * Returns an address for a given public key.
   * @param pubKey The two points of an uncompressed key
   */
  static fromPublicKey(t) {
    if (!le.Buffer.isBuffer(t))
      throw new Error("Public key should be Buffer");
    const r = (0, vs.pubToAddress)(t);
    return new Xn(r);
  }
  /**
   * Returns an address for a given private key.
   * @param privateKey A private key must be 256 bits wide
   */
  static fromPrivateKey(t) {
    if (!le.Buffer.isBuffer(t))
      throw new Error("Private key should be Buffer");
    const r = (0, vs.privateToAddress)(t);
    return new Xn(r);
  }
  /**
   * Generates an address for a newly created contract.
   * @param from The address which is creating this new address
   * @param nonce The nonce of the from account
   */
  static generate(t, r) {
    if (typeof r != "bigint")
      throw new Error("Expected nonce to be a bigint");
    return new Xn((0, vs.generateAddress)(t.buf, (0, fu.bigIntToBuffer)(r)));
  }
  /**
   * Generates an address for a contract created using CREATE2.
   * @param from The address which is creating this new address
   * @param salt A salt
   * @param initCode The init code of the contract being created
   */
  static generate2(t, r, o) {
    if (!le.Buffer.isBuffer(r))
      throw new Error("Expected salt to be a Buffer");
    if (!le.Buffer.isBuffer(o))
      throw new Error("Expected initCode to be a Buffer");
    return new Xn((0, vs.generateAddress2)(t.buf, r, o));
  }
  /**
   * Is address equal to another.
   */
  equals(t) {
    return this.buf.equals(t.buf);
  }
  /**
   * Is address zero.
   */
  isZero() {
    return this.equals(Xn.zero());
  }
  /**
   * True if address is in the address range defined
   * by EIP-1352
   */
  isPrecompileOrSystemAddress() {
    const t = (0, fu.bufferToBigInt)(this.buf), r = BigInt(0), o = BigInt("0xffff");
    return t >= r && t <= o;
  }
  /**
   * Returns hex encoding of address.
   */
  toString() {
    return "0x" + this.buf.toString("hex");
  }
  /**
   * Returns Buffer representation of address.
   */
  toBuffer() {
    return le.Buffer.from(this.buf);
  }
}
Xs.Address = Xn;
var uf = {}, xd = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.toType = e.TypeOutput = void 0;
  const t = oo, r = gt;
  var o;
  (function(u) {
    u[u.Number = 0] = "Number", u[u.BigInt = 1] = "BigInt", u[u.Buffer = 2] = "Buffer", u[u.PrefixedHexString = 3] = "PrefixedHexString";
  })(o = e.TypeOutput || (e.TypeOutput = {}));
  function s(u, f) {
    if (u === null)
      return null;
    if (u === void 0)
      return;
    if (typeof u == "string" && !(0, r.isHexString)(u))
      throw new Error(`A string must be provided with a 0x-prefix, given: ${u}`);
    if (typeof u == "number" && !Number.isSafeInteger(u))
      throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
    const h = (0, t.toBuffer)(u);
    switch (f) {
      case o.Buffer:
        return h;
      case o.BigInt:
        return (0, t.bufferToBigInt)(h);
      case o.Number: {
        const l = (0, t.bufferToBigInt)(h);
        if (l > BigInt(Number.MAX_SAFE_INTEGER))
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
        return Number(l);
      }
      case o.PrefixedHexString:
        return (0, t.bufferToHex)(h);
      default:
        throw new Error("unknown outputType");
    }
  }
  e.toType = s;
})(xd);
Object.defineProperty(uf, "__esModule", { value: !0 });
uf.Withdrawal = void 0;
const Ab = Xs, lc = oo, Tt = xd;
class Os {
  /**
   * This constructor assigns and validates the values.
   * Use the static factory methods to assist in creating a Withdrawal object from varying data types.
   * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot
   */
  constructor(t, r, o, s) {
    this.index = t, this.validatorIndex = r, this.address = o, this.amount = s;
  }
  static fromWithdrawalData(t) {
    const { index: r, validatorIndex: o, address: s, amount: u } = t, f = (0, Tt.toType)(r, Tt.TypeOutput.BigInt), h = (0, Tt.toType)(o, Tt.TypeOutput.BigInt), l = new Ab.Address((0, Tt.toType)(s, Tt.TypeOutput.Buffer)), p = (0, Tt.toType)(u, Tt.TypeOutput.BigInt);
    return new Os(f, h, l, p);
  }
  static fromValuesArray(t) {
    if (t.length !== 4)
      throw Error(`Invalid withdrawalArray length expected=4 actual=${t.length}`);
    const [r, o, s, u] = t;
    return Os.fromWithdrawalData({ index: r, validatorIndex: o, address: s, amount: u });
  }
  /**
   * Convert a withdrawal to a buffer array
   * @param withdrawal the withdrawal to convert
   * @returns buffer array of the withdrawal
   */
  static toBufferArray(t) {
    const { index: r, validatorIndex: o, address: s, amount: u } = t, f = (0, Tt.toType)(r, Tt.TypeOutput.BigInt) === BigInt(0) ? le.Buffer.alloc(0) : (0, Tt.toType)(r, Tt.TypeOutput.Buffer), h = (0, Tt.toType)(o, Tt.TypeOutput.BigInt) === BigInt(0) ? le.Buffer.alloc(0) : (0, Tt.toType)(o, Tt.TypeOutput.Buffer);
    let l;
    s instanceof Ab.Address ? l = s.buf : l = (0, Tt.toType)(s, Tt.TypeOutput.Buffer);
    const p = (0, Tt.toType)(u, Tt.TypeOutput.BigInt) === BigInt(0) ? le.Buffer.alloc(0) : (0, Tt.toType)(u, Tt.TypeOutput.Buffer);
    return [f, h, l, p];
  }
  raw() {
    return Os.toBufferArray(this);
  }
  toValue() {
    return {
      index: this.index,
      validatorIndex: this.validatorIndex,
      address: this.address.buf,
      amount: this.amount
    };
  }
  toJSON() {
    return {
      index: (0, lc.bigIntToHex)(this.index),
      validatorIndex: (0, lc.bigIntToHex)(this.validatorIndex),
      address: "0x" + this.address.buf.toString("hex"),
      amount: (0, lc.bigIntToHex)(this.amount)
    };
  }
}
uf.Withdrawal = Os;
var er = {};
Object.defineProperty(er, "__esModule", { value: !0 });
er.hashPersonalMessage = er.isValidSignature = er.fromRpcSig = er.toCompactSig = er.toRpcSig = er.ecrecover = er.ecsign = void 0;
const QP = on, V0 = Xu, br = oo, cc = Yu, eB = Wr;
function tB(e, t, r) {
  const o = V0.secp256k1.sign(e, t), s = o.toCompactRawBytes(), u = le.Buffer.from(s.slice(0, 32)), f = le.Buffer.from(s.slice(32, 64)), h = r === void 0 ? BigInt(o.recovery + 27) : BigInt(o.recovery + 35) + BigInt(r) * BigInt(2);
  return { r: u, s: f, v: h };
}
er.ecsign = tB;
function ff(e, t) {
  return e === BigInt(0) || e === BigInt(1) ? e : t === void 0 ? e - BigInt(27) : e - (t * BigInt(2) + BigInt(35));
}
function lf(e) {
  return e === BigInt(0) || e === BigInt(1);
}
const rB = function(e, t, r, o, s) {
  const u = le.Buffer.concat([(0, br.setLengthLeft)(r, 32), (0, br.setLengthLeft)(o, 32)], 64), f = ff(t, s);
  if (!lf(f))
    throw new Error("Invalid signature v value");
  const l = V0.secp256k1.Signature.fromCompact(u).addRecoveryBit(Number(f)).recoverPublicKey(e);
  return le.Buffer.from(l.toRawBytes(!1).slice(1));
};
er.ecrecover = rB;
const nB = function(e, t, r, o) {
  const s = ff(e, o);
  if (!lf(s))
    throw new Error("Invalid signature v value");
  return (0, br.bufferToHex)(le.Buffer.concat([(0, br.setLengthLeft)(t, 32), (0, br.setLengthLeft)(r, 32), (0, br.toBuffer)(e)]));
};
er.toRpcSig = nB;
const iB = function(e, t, r, o) {
  const s = ff(e, o);
  if (!lf(s))
    throw new Error("Invalid signature v value");
  let u = r;
  return (e > BigInt(28) && e % BigInt(2) === BigInt(1) || e === BigInt(1) || e === BigInt(28)) && (u = le.Buffer.from(r), u[0] |= 128), (0, br.bufferToHex)(le.Buffer.concat([(0, br.setLengthLeft)(t, 32), (0, br.setLengthLeft)(u, 32)]));
};
er.toCompactSig = iB;
const oB = function(e) {
  const t = (0, br.toBuffer)(e);
  let r, o, s;
  if (t.length >= 65)
    r = t.slice(0, 32), o = t.slice(32, 64), s = (0, br.bufferToBigInt)(t.slice(64));
  else if (t.length === 64)
    r = t.slice(0, 32), o = t.slice(32, 64), s = BigInt((0, br.bufferToInt)(t.slice(32, 33)) >> 7), o[0] &= 127;
  else
    throw new Error("Invalid signature length");
  return s < 27 && (s = s + BigInt(27)), {
    v: s,
    r,
    s: o
  };
};
er.fromRpcSig = oB;
const sB = function(e, t, r, o = !0, s) {
  if (t.length !== 32 || r.length !== 32 || !lf(ff(e, s)))
    return !1;
  const u = (0, br.bufferToBigInt)(t), f = (0, br.bufferToBigInt)(r);
  return !(u === BigInt(0) || u >= cc.SECP256K1_ORDER || f === BigInt(0) || f >= cc.SECP256K1_ORDER || o && f >= cc.SECP256K1_ORDER_DIV_2);
};
er.isValidSignature = sB;
const aB = function(e) {
  (0, eB.assertIsBuffer)(e);
  const t = le.Buffer.from(`Ethereum Signed Message:
${e.length}`, "utf-8");
  return le.Buffer.from((0, QP.keccak256)(le.Buffer.concat([t, e])));
};
er.hashPersonalMessage = aB;
var G0 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.compactBytesToNibbles = e.bytesToNibbles = e.nibblesToCompactBytes = e.nibblesToBytes = e.hasTerminator = void 0;
  const t = (f) => f.length > 0 && f[f.length - 1] === 16;
  e.hasTerminator = t;
  const r = (f, h) => {
    for (let l = 0, p = 0; p < f.length; l += 1, p += 2)
      h[l] = f[p] << 4 | f[p + 1];
  };
  e.nibblesToBytes = r;
  const o = (f) => {
    let h = 0;
    (0, e.hasTerminator)(f) && (h = 1, f = f.subarray(0, f.length - 1));
    const l = new Uint8Array(f.length / 2 + 1);
    return l[0] = h << 5, (f.length & 1) === 1 && (l[0] |= 16, l[0] |= f[0], f = f.subarray(1)), (0, e.nibblesToBytes)(f, l.subarray(1)), l;
  };
  e.nibblesToCompactBytes = o;
  const s = (f) => {
    const h = f.length * 2 + 1, l = new Uint8Array(h);
    for (let p = 0; p < f.length; p++) {
      const b = f[p];
      l[p * 2] = b / 16, l[p * 2 + 1] = b % 16;
    }
    return l[h - 1] = 16, l;
  };
  e.bytesToNibbles = s;
  const u = (f) => {
    if (f.length === 0)
      return f;
    let h = (0, e.bytesToNibbles)(f);
    h[0] < 2 && (h = h.subarray(0, h.length - 1));
    const l = 2 - (h[0] & 1);
    return h.subarray(l);
  };
  e.compactBytesToNibbles = u;
})(G0);
var cf = {};
Object.defineProperty(cf, "__esModule", { value: !0 });
cf.AsyncEventEmitter = void 0;
const uB = Pn;
async function fB(e, t, r) {
  let o;
  for await (const s of t)
    try {
      s.length < 2 ? s.call(e, r) : await new Promise((u, f) => {
        s.call(e, r, (h) => {
          h ? f(h) : u();
        });
      });
    } catch (u) {
      o = u;
    }
  if (o)
    throw o;
}
class lB extends uB.EventEmitter {
  emit(t, ...r) {
    let [o, s] = r;
    const u = this;
    let f = u._events[t] ?? [];
    return s === void 0 && typeof o == "function" && (s = o, o = void 0), (t === "newListener" || t === "removeListener") && (o = {
      event: o,
      fn: s
    }, s = void 0), f = Array.isArray(f) ? f : [f], fB(u, f.slice(), o).then(s).catch(s), u.listenerCount(t) > 0;
  }
  once(t, r) {
    const o = this;
    let s;
    if (typeof r != "function")
      throw new TypeError("listener must be a function");
    return r.length >= 2 ? s = function(u, f) {
      o.removeListener(t, s), r(u, f);
    } : s = function(u) {
      o.removeListener(t, s), r(u, s);
    }, o.on(t, s), o;
  }
  first(t, r) {
    let o = this._events[t] ?? [];
    if (typeof r != "function")
      throw new TypeError("listener must be a function");
    return Array.isArray(o) || (this._events[t] = o = [o]), o.unshift(r), this;
  }
  before(t, r, o) {
    return this.beforeOrAfter(t, r, o);
  }
  after(t, r, o) {
    return this.beforeOrAfter(t, r, o, "after");
  }
  beforeOrAfter(t, r, o, s) {
    let u = this._events[t] ?? [], f, h;
    const l = s === "after" ? 1 : 0;
    if (typeof o != "function")
      throw new TypeError("listener must be a function");
    if (typeof r != "function")
      throw new TypeError("target must be a function");
    for (Array.isArray(u) || (this._events[t] = u = [u]), h = u.length, f = u.length; f--; )
      if (u[f] === r) {
        h = f + l;
        break;
      }
    return u.splice(h, 0, o), this;
  }
  on(t, r) {
    return super.on(t, r);
  }
  addListener(t, r) {
    return super.addListener(t, r);
  }
  prependListener(t, r) {
    return super.prependListener(t, r);
  }
  prependOnceListener(t, r) {
    return super.prependOnceListener(t, r);
  }
  removeAllListeners(t) {
    return super.removeAllListeners(t);
  }
  removeListener(t, r) {
    return super.removeListener(t, r);
  }
  eventNames() {
    return super.eventNames();
  }
  listeners(t) {
    return super.listeners(t);
  }
  listenerCount(t) {
    return super.listenerCount(t);
  }
  getMaxListeners() {
    return super.getMaxListeners();
  }
  setMaxListeners(t) {
    return super.setMaxListeners(t);
  }
}
cf.AsyncEventEmitter = lB;
var df = {};
Object.defineProperty(df, "__esModule", { value: !0 });
df.Lock = void 0;
class cB {
  constructor() {
    this.permits = 1, this.promiseResolverQueue = [];
  }
  /**
   * Returns a promise used to wait for a permit to become available. This method should be awaited on.
   * @returns  A promise that gets resolved when execution is allowed to proceed.
   */
  async acquire() {
    return this.permits > 0 ? (this.permits -= 1, Promise.resolve(!0)) : new Promise((t) => this.promiseResolverQueue.push(t));
  }
  /**
   * Increases the number of permits by one. If there are other functions waiting, one of them will
   * continue to execute in a future iteration of the event loop.
   */
  release() {
    if (this.permits += 1, this.permits > 1 && this.promiseResolverQueue.length > 0)
      console.warn("Lock.permits should never be > 0 when there is someone waiting.");
    else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {
      this.permits -= 1;
      const t = this.promiseResolverQueue.shift();
      t && t(!0);
    }
  }
}
df.Lock = cB;
var ko = {}, Yi = {};
Object.defineProperty(Yi, "__esModule", { value: !0 });
Yi.InvalidStatusCodeError = Yi.InvalidCertError = void 0;
const z0 = Object.freeze({
  redirect: !0,
  expectStatusCode: 200,
  headers: {},
  full: !1,
  keepAlive: !0,
  cors: !1,
  referrer: !1,
  sslAllowSelfSigned: !1,
  _redirectCount: 0
});
class Vc extends Error {
  constructor(t, r) {
    super(t), this.fingerprint256 = r;
  }
}
Yi.InvalidCertError = Vc;
class Dd extends Error {
  constructor(t) {
    super(`Request Failed. Status Code: ${t}`), this.statusCode = t;
  }
}
Yi.InvalidStatusCodeError = Dd;
function K0(e, t) {
  if (!t || t === "text" || t === "json")
    try {
      let r = new TextDecoder("utf8", { fatal: !0 }).decode(e);
      if (t === "text")
        return r;
      try {
        return JSON.parse(r);
      } catch (o) {
        if (t === "json")
          throw o;
        return r;
      }
    } catch (r) {
      if (t === "text" || t === "json")
        throw r;
    }
  return e;
}
let Tb = {};
function Gc(e, t) {
  var I;
  let r = { ...z0, ...t };
  const o = z1, s = G1, u = J1, { promisify: f } = K1, { resolve: h } = V1, l = !!/^https/.test(e);
  let p = {
    method: r.method || "GET",
    headers: { "Accept-Encoding": "gzip, deflate, br" }
  };
  const b = (A) => A.replace(/:| /g, "").toLowerCase();
  if (r.keepAlive) {
    const A = {
      keepAlive: !0,
      keepAliveMsecs: 3e4,
      maxFreeSockets: 1024,
      maxCachedSessions: 1024
    }, x = [
      l,
      l && ((I = r.sslPinnedCertificates) == null ? void 0 : I.map((v) => b(v)).sort())
    ].join();
    p.agent = Tb[x] || (Tb[x] = new (l ? s : o).Agent(A));
  }
  r.type === "json" && (p.headers["Content-Type"] = "application/json"), r.data && (r.method || (p.method = "POST"), p.body = r.type === "json" ? JSON.stringify(r.data) : r.data), p.headers = { ...p.headers, ...r.headers }, r.sslAllowSelfSigned && (p.rejectUnauthorized = !1);
  const w = async (A) => {
    const x = A.statusCode;
    if (r.redirect && 300 <= x && x < 400 && A.headers.location) {
      if (r._redirectCount == 10)
        throw new Error("Request failed. Too much redirects.");
      return r._redirectCount += 1, await Gc(h(e, A.headers.location), r);
    }
    if (r.expectStatusCode && x !== r.expectStatusCode)
      throw A.resume(), new Dd(x);
    let v = [];
    for await (const S of A)
      v.push(S);
    let C = le.Buffer.concat(v);
    const B = A.headers["content-encoding"];
    B === "br" && (C = await f(u.brotliDecompress)(C)), (B === "gzip" || B === "deflate") && (C = await f(u.unzip)(C));
    const P = K0(C, r.type);
    return r.full ? { headers: A.headers, status: x, body: P } : P;
  };
  return new Promise((A, x) => {
    var S;
    const v = async (m) => {
      if (m && m.code === "DEPTH_ZERO_SELF_SIGNED_CERT")
        try {
          await Gc(e, { ...r, sslAllowSelfSigned: !0, sslPinnedCertificates: [] });
        } catch (j) {
          j && j.fingerprint256 && (m = new Vc(`Self-signed SSL certificate: ${j.fingerprint256}`, j.fingerprint256));
        }
      x(m);
    }, C = (l ? s : o).request(e, p, (m) => {
      m.on("error", v), (async () => {
        try {
          A(await w(m));
        } catch (j) {
          x(j);
        }
      })();
    });
    C.on("error", v);
    const B = (S = r.sslPinnedCertificates) == null ? void 0 : S.map((m) => b(m)), P = (m) => {
      var Z;
      const j = b(((Z = m.getPeerCertificate()) == null ? void 0 : Z.fingerprint256) || "");
      if (!(!j && m.isSessionReused()) && !B.includes(j))
        return C.emit("error", new Vc(`Invalid SSL certificate: ${j} Expected: ${B}`, j)), C.abort();
    };
    r.sslPinnedCertificates && C.on("socket", (m) => {
      m.listeners("secureConnect").map((Z) => (Z.name || "").replace("bound ", "")).includes("mfetchSecureConnect") || m.on("secureConnect", P.bind(null, m));
    }), r.keepAlive && C.setNoDelay(!0), p.body && C.write(p.body), C.end();
  });
}
const dB = new Set(["Accept", "Accept-Language", "Content-Language", "Content-Type"].map((e) => e.toLowerCase())), hB = new Set([
  "Accept-Charset",
  "Accept-Encoding",
  "Access-Control-Request-Headers",
  "Access-Control-Request-Method",
  "Connection",
  "Content-Length",
  "Cookie",
  "Cookie2",
  "Date",
  "DNT",
  "Expect",
  "Host",
  "Keep-Alive",
  "Origin",
  "Referer",
  "TE",
  "Trailer",
  "Transfer-Encoding",
  "Upgrade",
  "Via"
].map((e) => e.toLowerCase()));
async function gB(e, t) {
  let r = { ...z0, ...t };
  const o = new Headers();
  r.type === "json" && o.set("Content-Type", "application/json");
  let s = new URL(e);
  if (s.username) {
    const l = btoa(`${s.username}:${s.password}`);
    o.set("Authorization", `Basic ${l}`), s.username = "", s.password = "";
  }
  e = "" + s;
  for (let l in r.headers) {
    const p = l.toLowerCase();
    (dB.has(p) || r.cors && !hB.has(p)) && o.set(l, r.headers[l]);
  }
  let u = { headers: o, redirect: r.redirect ? "follow" : "manual" };
  r.referrer || (u.referrerPolicy = "no-referrer"), r.cors && (u.mode = "cors"), r.data && (r.method || (u.method = "POST"), u.body = r.type === "json" ? JSON.stringify(r.data) : r.data);
  const f = await fetch(e, u);
  if (r.expectStatusCode && f.status !== r.expectStatusCode)
    throw new Dd(f.status);
  const h = K0(new Uint8Array(await f.arrayBuffer()), r.type);
  return r.full ? { headers: Object.fromEntries(f.headers.entries()), status: f.status, body: h } : h;
}
const pB = !!(typeof le.process == "object" && le.process.versions && le.process.versions.node && le.process.versions.v8);
function bB(e, t) {
  return (pB ? Gc : gB)(e, t);
}
Yi.default = bB;
Object.defineProperty(ko, "__esModule", { value: !0 });
ko.getProvider = ko.fetchFromProvider = void 0;
const _B = Yi, yB = async (e, t) => (await (0, _B.default)(e, {
  headers: {
    "content-type": "application/json"
  },
  type: "json",
  data: {
    method: t.method,
    params: t.params,
    jsonrpc: "2.0",
    id: 1
  }
})).result;
ko.fetchFromProvider = yB;
const wB = (e) => {
  var t;
  if (typeof e == "string")
    return e;
  if (((t = e == null ? void 0 : e.connection) == null ? void 0 : t.url) !== void 0)
    return e.connection.url;
  throw new Error("Must provide valid provider URL or Web3Provider");
};
ko.getProvider = wB;
(function(e) {
  var t = Ye && Ye.__createBinding || (Object.create ? function(s, u, f, h) {
    h === void 0 && (h = f);
    var l = Object.getOwnPropertyDescriptor(u, f);
    (!l || ("get" in l ? !u.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
      return u[f];
    } }), Object.defineProperty(s, h, l);
  } : function(s, u, f, h) {
    h === void 0 && (h = f), s[h] = u[f];
  }), r = Ye && Ye.__exportStar || function(s, u) {
    for (var f in s) f !== "default" && !Object.prototype.hasOwnProperty.call(u, f) && t(u, s, f);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.toAscii = e.stripHexPrefix = e.padToEven = e.isHexString = e.isHexPrefixed = e.getKeys = e.getBinarySize = e.fromUtf8 = e.fromAscii = e.arrayContainsArray = void 0, r(Yu, e), r(sf, e), r(Nd, e), r(Xs, e), r(uf, e), r(er, e), r(oo, e), r(xd, e), r(G0, e), r(cf, e);
  var o = gt;
  Object.defineProperty(e, "arrayContainsArray", { enumerable: !0, get: function() {
    return o.arrayContainsArray;
  } }), Object.defineProperty(e, "fromAscii", { enumerable: !0, get: function() {
    return o.fromAscii;
  } }), Object.defineProperty(e, "fromUtf8", { enumerable: !0, get: function() {
    return o.fromUtf8;
  } }), Object.defineProperty(e, "getBinarySize", { enumerable: !0, get: function() {
    return o.getBinarySize;
  } }), Object.defineProperty(e, "getKeys", { enumerable: !0, get: function() {
    return o.getKeys;
  } }), Object.defineProperty(e, "isHexPrefixed", { enumerable: !0, get: function() {
    return o.isHexPrefixed;
  } }), Object.defineProperty(e, "isHexString", { enumerable: !0, get: function() {
    return o.isHexString;
  } }), Object.defineProperty(e, "padToEven", { enumerable: !0, get: function() {
    return o.padToEven;
  } }), Object.defineProperty(e, "stripHexPrefix", { enumerable: !0, get: function() {
    return o.stripHexPrefix;
  } }), Object.defineProperty(e, "toAscii", { enumerable: !0, get: function() {
    return o.toAscii;
  } }), r(df, e), r(ko, e);
})(ML);
var J0 = { exports: {} };
(function(e) {
  (function(t, r) {
    e.exports ? e.exports = r() : t.log = r();
  })(Ye, function() {
    var t = function() {
    }, r = "undefined", o = typeof window !== r && typeof window.navigator !== r && /Trident\/|MSIE /.test(window.navigator.userAgent), s = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ], u = {}, f = null;
    function h(v, C) {
      var B = v[C];
      if (typeof B.bind == "function")
        return B.bind(v);
      try {
        return Function.prototype.bind.call(B, v);
      } catch {
        return function() {
          return Function.prototype.apply.apply(B, [v, arguments]);
        };
      }
    }
    function l() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function p(v) {
      return v === "debug" && (v = "log"), typeof console === r ? !1 : v === "trace" && o ? l : console[v] !== void 0 ? h(console, v) : console.log !== void 0 ? h(console, "log") : t;
    }
    function b() {
      for (var v = this.getLevel(), C = 0; C < s.length; C++) {
        var B = s[C];
        this[B] = C < v ? t : this.methodFactory(B, v, this.name);
      }
      if (this.log = this.debug, typeof console === r && v < this.levels.SILENT)
        return "No console available for logging";
    }
    function w(v) {
      return function() {
        typeof console !== r && (b.call(this), this[v].apply(this, arguments));
      };
    }
    function I(v, C, B) {
      return p(v) || w.apply(this, arguments);
    }
    function A(v, C) {
      var B = this, P, S, m, j = "loglevel";
      typeof v == "string" ? j += ":" + v : typeof v == "symbol" && (j = void 0);
      function Z(me) {
        var F = (s[me] || "silent").toUpperCase();
        if (!(typeof window === r || !j)) {
          try {
            window.localStorage[j] = F;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(j) + "=" + F + ";";
          } catch {
          }
        }
      }
      function ce() {
        var me;
        if (!(typeof window === r || !j)) {
          try {
            me = window.localStorage[j];
          } catch {
          }
          if (typeof me === r)
            try {
              var F = window.document.cookie, U = encodeURIComponent(j), $ = F.indexOf(U + "=");
              $ !== -1 && (me = /^([^;]+)/.exec(
                F.slice($ + U.length + 1)
              )[1]);
            } catch {
            }
          return B.levels[me] === void 0 && (me = void 0), me;
        }
      }
      function ae() {
        if (!(typeof window === r || !j)) {
          try {
            window.localStorage.removeItem(j);
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(j) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      function ee(me) {
        var F = me;
        if (typeof F == "string" && B.levels[F.toUpperCase()] !== void 0 && (F = B.levels[F.toUpperCase()]), typeof F == "number" && F >= 0 && F <= B.levels.SILENT)
          return F;
        throw new TypeError("log.setLevel() called with invalid level: " + me);
      }
      B.name = v, B.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, B.methodFactory = C || I, B.getLevel = function() {
        return m ?? S ?? P;
      }, B.setLevel = function(me, F) {
        return m = ee(me), F !== !1 && Z(m), b.call(B);
      }, B.setDefaultLevel = function(me) {
        S = ee(me), ce() || B.setLevel(me, !1);
      }, B.resetLevel = function() {
        m = null, ae(), b.call(B);
      }, B.enableAll = function(me) {
        B.setLevel(B.levels.TRACE, me);
      }, B.disableAll = function(me) {
        B.setLevel(B.levels.SILENT, me);
      }, B.rebuild = function() {
        if (f !== B && (P = ee(f.getLevel())), b.call(B), f === B)
          for (var me in u)
            u[me].rebuild();
      }, P = ee(
        f ? f.getLevel() : "WARN"
      );
      var Se = ce();
      Se != null && (m = ee(Se)), b.call(B);
    }
    f = new A(), f.getLogger = function(C) {
      if (typeof C != "symbol" && typeof C != "string" || C === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var B = u[C];
      return B || (B = u[C] = new A(
        C,
        f.methodFactory
      )), B;
    };
    var x = typeof window !== r ? window.log : void 0;
    return f.noConflict = function() {
      return typeof window !== r && window.log === f && (window.log = x), f;
    }, f.getLoggers = function() {
      return u;
    }, f.default = f, f;
  });
})(J0);
var Y0 = J0.exports;
const Iu = /* @__PURE__ */ Oi(Y0);
var Ou = { exports: {} };
Ou.exports;
(function(e, t) {
  var r = 200, o = "__lodash_hash_undefined__", s = 800, u = 16, f = 9007199254740991, h = "[object Arguments]", l = "[object Array]", p = "[object AsyncFunction]", b = "[object Boolean]", w = "[object Date]", I = "[object Error]", A = "[object Function]", x = "[object GeneratorFunction]", v = "[object Map]", C = "[object Number]", B = "[object Null]", P = "[object Object]", S = "[object Proxy]", m = "[object RegExp]", j = "[object Set]", Z = "[object String]", ce = "[object Undefined]", ae = "[object WeakMap]", ee = "[object ArrayBuffer]", Se = "[object DataView]", me = "[object Float32Array]", F = "[object Float64Array]", U = "[object Int8Array]", $ = "[object Int16Array]", q = "[object Int32Array]", J = "[object Uint8Array]", V = "[object Uint8ClampedArray]", re = "[object Uint16Array]", H = "[object Uint32Array]", z = /[\\^$.*+?()[\]{}|]/g, se = /^\[object .+?Constructor\]$/, de = /^(?:0|[1-9]\d*)$/, te = {};
  te[me] = te[F] = te[U] = te[$] = te[q] = te[J] = te[V] = te[re] = te[H] = !0, te[h] = te[l] = te[ee] = te[b] = te[Se] = te[w] = te[I] = te[A] = te[v] = te[C] = te[P] = te[m] = te[j] = te[Z] = te[ae] = !1;
  var _e = typeof Ye == "object" && Ye && Ye.Object === Object && Ye, be = typeof self == "object" && self && self.Object === Object && self, R = _e || be || Function("return this")(), O = t && !t.nodeType && t, W = O && !0 && e && !e.nodeType && e, ie = W && W.exports === O, ye = ie && _e.process, d = function() {
    try {
      var M = W && W.require && W.require("util").types;
      return M || ye && ye.binding && ye.binding("util");
    } catch {
    }
  }(), g = d && d.isTypedArray;
  function _(M, Y, fe) {
    switch (fe.length) {
      case 0:
        return M.call(Y);
      case 1:
        return M.call(Y, fe[0]);
      case 2:
        return M.call(Y, fe[0], fe[1]);
      case 3:
        return M.call(Y, fe[0], fe[1], fe[2]);
    }
    return M.apply(Y, fe);
  }
  function E(M, Y) {
    for (var fe = -1, Le = Array(M); ++fe < M; )
      Le[fe] = Y(fe);
    return Le;
  }
  function K(M) {
    return function(Y) {
      return M(Y);
    };
  }
  function ne(M, Y) {
    return M == null ? void 0 : M[Y];
  }
  function oe(M, Y) {
    return function(fe) {
      return M(Y(fe));
    };
  }
  var Ie = Array.prototype, Be = Function.prototype, Ce = Object.prototype, Ue = R["__core-js_shared__"], Re = Be.toString, He = Ce.hasOwnProperty, _t = function() {
    var M = /[^.]+$/.exec(Ue && Ue.keys && Ue.keys.IE_PROTO || "");
    return M ? "Symbol(src)_1." + M : "";
  }(), tt = Ce.toString, yt = Re.call(Object), Xe = RegExp(
    "^" + Re.call(He).replace(z, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Ge = ie ? R.Buffer : void 0, jt = R.Symbol, Pt = R.Uint8Array;
  Ge && Ge.allocUnsafe;
  var ut = oe(Object.getPrototypeOf, Object), Nt = Object.create, lr = Ce.propertyIsEnumerable, tr = Ie.splice, Ft = jt ? jt.toStringTag : void 0, cr = function() {
    try {
      var M = Ko(Object, "defineProperty");
      return M({}, "", {}), M;
    } catch {
    }
  }(), Jr = Ge ? Ge.isBuffer : void 0, Yr = Math.max, un = Date.now, fn = Ko(R, "Map"), rr = Ko(Object, "create"), Lr = /* @__PURE__ */ function() {
    function M() {
    }
    return function(Y) {
      if (!Dn(Y))
        return {};
      if (Nt)
        return Nt(Y);
      M.prototype = Y;
      var fe = new M();
      return M.prototype = void 0, fe;
    };
  }();
  function nr(M) {
    var Y = -1, fe = M == null ? 0 : M.length;
    for (this.clear(); ++Y < fe; ) {
      var Le = M[Y];
      this.set(Le[0], Le[1]);
    }
  }
  function $n() {
    this.__data__ = rr ? rr(null) : {}, this.size = 0;
  }
  function Xr(M) {
    var Y = this.has(M) && delete this.__data__[M];
    return this.size -= Y ? 1 : 0, Y;
  }
  function ln(M) {
    var Y = this.__data__;
    if (rr) {
      var fe = Y[M];
      return fe === o ? void 0 : fe;
    }
    return He.call(Y, M) ? Y[M] : void 0;
  }
  function N(M) {
    var Y = this.__data__;
    return rr ? Y[M] !== void 0 : He.call(Y, M);
  }
  function D(M, Y) {
    var fe = this.__data__;
    return this.size += this.has(M) ? 0 : 1, fe[M] = rr && Y === void 0 ? o : Y, this;
  }
  nr.prototype.clear = $n, nr.prototype.delete = Xr, nr.prototype.get = ln, nr.prototype.has = N, nr.prototype.set = D;
  function Ee(M) {
    var Y = -1, fe = M == null ? 0 : M.length;
    for (this.clear(); ++Y < fe; ) {
      var Le = M[Y];
      this.set(Le[0], Le[1]);
    }
  }
  function ve() {
    this.__data__ = [], this.size = 0;
  }
  function Te(M) {
    var Y = this.__data__, fe = bn(Y, M);
    if (fe < 0)
      return !1;
    var Le = Y.length - 1;
    return fe == Le ? Y.pop() : tr.call(Y, fe, 1), --this.size, !0;
  }
  function wt(M) {
    var Y = this.__data__, fe = bn(Y, M);
    return fe < 0 ? void 0 : Y[fe][1];
  }
  function Rt(M) {
    return bn(this.__data__, M) > -1;
  }
  function cn(M, Y) {
    var fe = this.__data__, Le = bn(fe, M);
    return Le < 0 ? (++this.size, fe.push([M, Y])) : fe[Le][1] = Y, this;
  }
  Ee.prototype.clear = ve, Ee.prototype.delete = Te, Ee.prototype.get = wt, Ee.prototype.has = Rt, Ee.prototype.set = cn;
  function Bt(M) {
    var Y = -1, fe = M == null ? 0 : M.length;
    for (this.clear(); ++Y < fe; ) {
      var Le = M[Y];
      this.set(Le[0], Le[1]);
    }
  }
  function dn() {
    this.size = 0, this.__data__ = {
      hash: new nr(),
      map: new (fn || Ee)(),
      string: new nr()
    };
  }
  function Mn(M) {
    var Y = $i(this, M).delete(M);
    return this.size -= Y ? 1 : 0, Y;
  }
  function hn(M) {
    return $i(this, M).get(M);
  }
  function gn(M) {
    return $i(this, M).has(M);
  }
  function Zr(M, Y) {
    var fe = $i(this, M), Le = fe.size;
    return fe.set(M, Y), this.size += fe.size == Le ? 0 : 1, this;
  }
  Bt.prototype.clear = dn, Bt.prototype.delete = Mn, Bt.prototype.get = hn, Bt.prototype.has = gn, Bt.prototype.set = Zr;
  function Gt(M) {
    var Y = this.__data__ = new Ee(M);
    this.size = Y.size;
  }
  function Pr() {
    this.__data__ = new Ee(), this.size = 0;
  }
  function mr(M) {
    var Y = this.__data__, fe = Y.delete(M);
    return this.size = Y.size, fe;
  }
  function ir(M) {
    return this.__data__.get(M);
  }
  function Ht(M) {
    return this.__data__.has(M);
  }
  function Pi(M, Y) {
    var fe = this.__data__;
    if (fe instanceof Ee) {
      var Le = fe.__data__;
      if (!fn || Le.length < r - 1)
        return Le.push([M, Y]), this.size = ++fe.size, this;
      fe = this.__data__ = new Bt(Le);
    }
    return fe.set(M, Y), this.size = fe.size, this;
  }
  Gt.prototype.clear = Pr, Gt.prototype.delete = mr, Gt.prototype.get = ir, Gt.prototype.has = Ht, Gt.prototype.set = Pi;
  function Bi(M, Y) {
    var fe = Zo(M), Le = !fe && Xo(M), Ke = !fe && !Le && da(M), rt = !fe && !Le && !Ke && ga(M), dt = fe || Le || Ke || rt, De = dt ? E(M.length, String) : [], at = De.length;
    for (var $t in M)
      dt && // Safari 9 has enumerable `arguments.length` in strict mode.
      ($t == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Ke && ($t == "offset" || $t == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      rt && ($t == "buffer" || $t == "byteLength" || $t == "byteOffset") || // Skip index properties.
      uo($t, at)) || De.push($t);
    return De;
  }
  function xn(M, Y, fe) {
    (fe !== void 0 && !Mi(M[Y], fe) || fe === void 0 && !(Y in M)) && Br(M, Y, fe);
  }
  function pn(M, Y, fe) {
    var Le = M[Y];
    (!(He.call(M, Y) && Mi(Le, fe)) || fe === void 0 && !(Y in M)) && Br(M, Y, fe);
  }
  function bn(M, Y) {
    for (var fe = M.length; fe--; )
      if (Mi(M[fe][0], Y))
        return fe;
    return -1;
  }
  function Br(M, Y, fe) {
    Y == "__proto__" && cr ? cr(M, Y, {
      configurable: !0,
      enumerable: !0,
      value: fe,
      writable: !0
    }) : M[Y] = fe;
  }
  var Ni = ao();
  function _n(M) {
    return M == null ? M === void 0 ? ce : B : Ft && Ft in Object(M) ? na(M) : sa(M);
  }
  function oi(M) {
    return jn(M) && _n(M) == h;
  }
  function si(M) {
    if (!Dn(M) || Jo(M))
      return !1;
    var Y = es(M) ? Xe : se;
    return Y.test(la(M));
  }
  function ai(M) {
    return jn(M) && ha(M.length) && !!te[_n(M)];
  }
  function ui(M) {
    if (!Dn(M))
      return fi(M);
    var Y = fo(M), fe = [];
    for (var Le in M)
      Le == "constructor" && (Y || !He.call(M, Le)) || fe.push(Le);
    return fe;
  }
  function Zs(M, Y, fe, Le, Ke) {
    M !== Y && Ni(Y, function(rt, dt) {
      if (Ke || (Ke = new Gt()), Dn(rt))
        wf(M, Y, dt, fe, Zs, Le, Ke);
      else {
        var De = Le ? Le(Yo(M, dt), rt, dt + "", M, Y, Ke) : void 0;
        De === void 0 && (De = rt), xn(M, dt, De);
      }
    }, pa);
  }
  function wf(M, Y, fe, Le, Ke, rt, dt) {
    var De = Yo(M, fe), at = Yo(Y, fe), $t = dt.get(at);
    if ($t) {
      xn(M, fe, $t);
      return;
    }
    var zt = rt ? rt(De, at, fe + "", M, Y, dt) : void 0, Un = zt === void 0;
    if (Un) {
      var Kt = Zo(at), lo = !Kt && da(at), ts = !Kt && !lo && ga(at);
      zt = at, Kt || lo || ts ? Zo(De) ? zt = De : ca(De) ? zt = zo(De) : lo ? (Un = !1, zt = Qs(at)) : ts ? (Un = !1, zt = ta(at)) : zt = [] : Rf(at) || Xo(at) ? (zt = De, Xo(De) ? zt = Af(De) : (!Dn(De) || es(De)) && (zt = ia(at))) : Un = !1;
    }
    Un && (dt.set(at, zt), Ke(zt, at, Le, rt, dt), dt.delete(at)), xn(M, fe, zt);
  }
  function mf(M, Y) {
    return ua(aa(M, Y, it), M + "");
  }
  var Ef = cr ? function(M, Y) {
    return cr(M, "toString", {
      configurable: !0,
      enumerable: !1,
      value: ft(Y),
      writable: !0
    });
  } : it;
  function Qs(M, Y) {
    return M.slice();
  }
  function ea(M) {
    var Y = new M.constructor(M.byteLength);
    return new Pt(Y).set(new Pt(M)), Y;
  }
  function ta(M, Y) {
    var fe = ea(M.buffer);
    return new M.constructor(fe, M.byteOffset, M.length);
  }
  function zo(M, Y) {
    var fe = -1, Le = M.length;
    for (Y || (Y = Array(Le)); ++fe < Le; )
      Y[fe] = M[fe];
    return Y;
  }
  function vf(M, Y, fe, Le) {
    var Ke = !fe;
    fe || (fe = {});
    for (var rt = -1, dt = Y.length; ++rt < dt; ) {
      var De = Y[rt], at = void 0;
      at === void 0 && (at = M[De]), Ke ? Br(fe, De, at) : pn(fe, De, at);
    }
    return fe;
  }
  function ra(M) {
    return mf(function(Y, fe) {
      var Le = -1, Ke = fe.length, rt = Ke > 1 ? fe[Ke - 1] : void 0, dt = Ke > 2 ? fe[2] : void 0;
      for (rt = M.length > 3 && typeof rt == "function" ? (Ke--, rt) : void 0, dt && Sf(fe[0], fe[1], dt) && (rt = Ke < 3 ? void 0 : rt, Ke = 1), Y = Object(Y); ++Le < Ke; ) {
        var De = fe[Le];
        De && M(Y, De, Le, rt);
      }
      return Y;
    });
  }
  function ao(M) {
    return function(Y, fe, Le) {
      for (var Ke = -1, rt = Object(Y), dt = Le(Y), De = dt.length; De--; ) {
        var at = dt[++Ke];
        if (fe(rt[at], at, rt) === !1)
          break;
      }
      return Y;
    };
  }
  function $i(M, Y) {
    var fe = M.__data__;
    return oa(Y) ? fe[typeof Y == "string" ? "string" : "hash"] : fe.map;
  }
  function Ko(M, Y) {
    var fe = ne(M, Y);
    return si(fe) ? fe : void 0;
  }
  function na(M) {
    var Y = He.call(M, Ft), fe = M[Ft];
    try {
      M[Ft] = void 0;
      var Le = !0;
    } catch {
    }
    var Ke = tt.call(M);
    return Le && (Y ? M[Ft] = fe : delete M[Ft]), Ke;
  }
  function ia(M) {
    return typeof M.constructor == "function" && !fo(M) ? Lr(ut(M)) : {};
  }
  function uo(M, Y) {
    var fe = typeof M;
    return Y = Y ?? f, !!Y && (fe == "number" || fe != "symbol" && de.test(M)) && M > -1 && M % 1 == 0 && M < Y;
  }
  function Sf(M, Y, fe) {
    if (!Dn(fe))
      return !1;
    var Le = typeof Y;
    return (Le == "number" ? Qo(fe) && uo(Y, fe.length) : Le == "string" && Y in fe) ? Mi(fe[Y], M) : !1;
  }
  function oa(M) {
    var Y = typeof M;
    return Y == "string" || Y == "number" || Y == "symbol" || Y == "boolean" ? M !== "__proto__" : M === null;
  }
  function Jo(M) {
    return !!_t && _t in M;
  }
  function fo(M) {
    var Y = M && M.constructor, fe = typeof Y == "function" && Y.prototype || Ce;
    return M === fe;
  }
  function fi(M) {
    var Y = [];
    if (M != null)
      for (var fe in Object(M))
        Y.push(fe);
    return Y;
  }
  function sa(M) {
    return tt.call(M);
  }
  function aa(M, Y, fe) {
    return Y = Yr(Y === void 0 ? M.length - 1 : Y, 0), function() {
      for (var Le = arguments, Ke = -1, rt = Yr(Le.length - Y, 0), dt = Array(rt); ++Ke < rt; )
        dt[Ke] = Le[Y + Ke];
      Ke = -1;
      for (var De = Array(Y + 1); ++Ke < Y; )
        De[Ke] = Le[Ke];
      return De[Y] = fe(dt), _(M, this, De);
    };
  }
  function Yo(M, Y) {
    if (!(Y === "constructor" && typeof M[Y] == "function") && Y != "__proto__")
      return M[Y];
  }
  var ua = fa(Ef);
  function fa(M) {
    var Y = 0, fe = 0;
    return function() {
      var Le = un(), Ke = u - (Le - fe);
      if (fe = Le, Ke > 0) {
        if (++Y >= s)
          return arguments[0];
      } else
        Y = 0;
      return M.apply(void 0, arguments);
    };
  }
  function la(M) {
    if (M != null) {
      try {
        return Re.call(M);
      } catch {
      }
      try {
        return M + "";
      } catch {
      }
    }
    return "";
  }
  function Mi(M, Y) {
    return M === Y || M !== M && Y !== Y;
  }
  var Xo = oi(/* @__PURE__ */ function() {
    return arguments;
  }()) ? oi : function(M) {
    return jn(M) && He.call(M, "callee") && !lr.call(M, "callee");
  }, Zo = Array.isArray;
  function Qo(M) {
    return M != null && ha(M.length) && !es(M);
  }
  function ca(M) {
    return jn(M) && Qo(M);
  }
  var da = Jr || If;
  function es(M) {
    if (!Dn(M))
      return !1;
    var Y = _n(M);
    return Y == A || Y == x || Y == p || Y == S;
  }
  function ha(M) {
    return typeof M == "number" && M > -1 && M % 1 == 0 && M <= f;
  }
  function Dn(M) {
    var Y = typeof M;
    return M != null && (Y == "object" || Y == "function");
  }
  function jn(M) {
    return M != null && typeof M == "object";
  }
  function Rf(M) {
    if (!jn(M) || _n(M) != P)
      return !1;
    var Y = ut(M);
    if (Y === null)
      return !0;
    var fe = He.call(Y, "constructor") && Y.constructor;
    return typeof fe == "function" && fe instanceof fe && Re.call(fe) == yt;
  }
  var ga = g ? K(g) : ai;
  function Af(M) {
    return vf(M, pa(M));
  }
  function pa(M) {
    return Qo(M) ? Bi(M) : ui(M);
  }
  var Tf = ra(function(M, Y, fe) {
    Zs(M, Y, fe);
  });
  function ft(M) {
    return function() {
      return M;
    };
  }
  function it(M) {
    return M;
  }
  function If() {
    return !1;
  }
  e.exports = Tf;
})(Ou, Ou.exports);
Ou.exports;
const mB = Iu.getLogger("http-helpers");
mB.setLevel(Y0.levels.INFO);
var Cu = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
Cu.exports;
(function(e, t) {
  (function() {
    var r, o = "4.17.21", s = 200, u = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", f = "Expected a function", h = "Invalid `variable` option passed into `_.template`", l = "__lodash_hash_undefined__", p = 500, b = "__lodash_placeholder__", w = 1, I = 2, A = 4, x = 1, v = 2, C = 1, B = 2, P = 4, S = 8, m = 16, j = 32, Z = 64, ce = 128, ae = 256, ee = 512, Se = 30, me = "...", F = 800, U = 16, $ = 1, q = 2, J = 3, V = 1 / 0, re = 9007199254740991, H = 17976931348623157e292, z = NaN, se = 4294967295, de = se - 1, te = se >>> 1, _e = [
      ["ary", ce],
      ["bind", C],
      ["bindKey", B],
      ["curry", S],
      ["curryRight", m],
      ["flip", ee],
      ["partial", j],
      ["partialRight", Z],
      ["rearg", ae]
    ], be = "[object Arguments]", R = "[object Array]", O = "[object AsyncFunction]", W = "[object Boolean]", ie = "[object Date]", ye = "[object DOMException]", d = "[object Error]", g = "[object Function]", _ = "[object GeneratorFunction]", E = "[object Map]", K = "[object Number]", ne = "[object Null]", oe = "[object Object]", Ie = "[object Promise]", Be = "[object Proxy]", Ce = "[object RegExp]", Ue = "[object Set]", Re = "[object String]", He = "[object Symbol]", _t = "[object Undefined]", tt = "[object WeakMap]", yt = "[object WeakSet]", Xe = "[object ArrayBuffer]", Ge = "[object DataView]", jt = "[object Float32Array]", Pt = "[object Float64Array]", ut = "[object Int8Array]", Nt = "[object Int16Array]", lr = "[object Int32Array]", tr = "[object Uint8Array]", Ft = "[object Uint8ClampedArray]", cr = "[object Uint16Array]", Jr = "[object Uint32Array]", Yr = /\b__p \+= '';/g, un = /\b(__p \+=) '' \+/g, fn = /(__e\(.*?\)|\b__t\)) \+\n'';/g, rr = /&(?:amp|lt|gt|quot|#39);/g, Lr = /[&<>"']/g, nr = RegExp(rr.source), $n = RegExp(Lr.source), Xr = /<%-([\s\S]+?)%>/g, ln = /<%([\s\S]+?)%>/g, N = /<%=([\s\S]+?)%>/g, D = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Ee = /^\w*$/, ve = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Te = /[\\^$.*+?()[\]{}|]/g, wt = RegExp(Te.source), Rt = /^\s+/, cn = /\s/, Bt = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, dn = /\{\n\/\* \[wrapped with (.+)\] \*/, Mn = /,? & /, hn = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, gn = /[()=,{}\[\]\/\s]/, Zr = /\\(\\)?/g, Gt = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Pr = /\w*$/, mr = /^[-+]0x[0-9a-f]+$/i, ir = /^0b[01]+$/i, Ht = /^\[object .+?Constructor\]$/, Pi = /^0o[0-7]+$/i, Bi = /^(?:0|[1-9]\d*)$/, xn = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, pn = /($^)/, bn = /['\n\r\u2028\u2029\\]/g, Br = "\\ud800-\\udfff", Ni = "\\u0300-\\u036f", _n = "\\ufe20-\\ufe2f", oi = "\\u20d0-\\u20ff", si = Ni + _n + oi, ai = "\\u2700-\\u27bf", ui = "a-z\\xdf-\\xf6\\xf8-\\xff", Zs = "\\xac\\xb1\\xd7\\xf7", wf = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", mf = "\\u2000-\\u206f", Ef = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Qs = "A-Z\\xc0-\\xd6\\xd8-\\xde", ea = "\\ufe0e\\ufe0f", ta = Zs + wf + mf + Ef, zo = "[']", vf = "[" + Br + "]", ra = "[" + ta + "]", ao = "[" + si + "]", $i = "\\d+", Ko = "[" + ai + "]", na = "[" + ui + "]", ia = "[^" + Br + ta + $i + ai + ui + Qs + "]", uo = "\\ud83c[\\udffb-\\udfff]", Sf = "(?:" + ao + "|" + uo + ")", oa = "[^" + Br + "]", Jo = "(?:\\ud83c[\\udde6-\\uddff]){2}", fo = "[\\ud800-\\udbff][\\udc00-\\udfff]", fi = "[" + Qs + "]", sa = "\\u200d", aa = "(?:" + na + "|" + ia + ")", Yo = "(?:" + fi + "|" + ia + ")", ua = "(?:" + zo + "(?:d|ll|m|re|s|t|ve))?", fa = "(?:" + zo + "(?:D|LL|M|RE|S|T|VE))?", la = Sf + "?", Mi = "[" + ea + "]?", Xo = "(?:" + sa + "(?:" + [oa, Jo, fo].join("|") + ")" + Mi + la + ")*", Zo = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Qo = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", ca = Mi + la + Xo, da = "(?:" + [Ko, Jo, fo].join("|") + ")" + ca, es = "(?:" + [oa + ao + "?", ao, Jo, fo, vf].join("|") + ")", ha = RegExp(zo, "g"), Dn = RegExp(ao, "g"), jn = RegExp(uo + "(?=" + uo + ")|" + es + ca, "g"), Rf = RegExp([
      fi + "?" + na + "+" + ua + "(?=" + [ra, fi, "$"].join("|") + ")",
      Yo + "+" + fa + "(?=" + [ra, fi + aa, "$"].join("|") + ")",
      fi + "?" + aa + "+" + ua,
      fi + "+" + fa,
      Qo,
      Zo,
      $i,
      da
    ].join("|"), "g"), ga = RegExp("[" + sa + Br + si + ea + "]"), Af = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, pa = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], Tf = -1, ft = {};
    ft[jt] = ft[Pt] = ft[ut] = ft[Nt] = ft[lr] = ft[tr] = ft[Ft] = ft[cr] = ft[Jr] = !0, ft[be] = ft[R] = ft[Xe] = ft[W] = ft[Ge] = ft[ie] = ft[d] = ft[g] = ft[E] = ft[K] = ft[oe] = ft[Ce] = ft[Ue] = ft[Re] = ft[tt] = !1;
    var it = {};
    it[be] = it[R] = it[Xe] = it[Ge] = it[W] = it[ie] = it[jt] = it[Pt] = it[ut] = it[Nt] = it[lr] = it[E] = it[K] = it[oe] = it[Ce] = it[Ue] = it[Re] = it[He] = it[tr] = it[Ft] = it[cr] = it[Jr] = !0, it[d] = it[g] = it[tt] = !1;
    var If = {
      // Latin-1 Supplement block.
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "C",
      : "c",
      : "D",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "N",
      : "n",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "Y",
      : "y",
      : "y",
      : "Ae",
      : "ae",
      : "Th",
      : "th",
      : "ss",
      // Latin Extended-A block.
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "C",
      : "C",
      : "C",
      : "C",
      : "c",
      : "c",
      : "c",
      : "c",
      : "D",
      : "D",
      : "d",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "e",
      : "G",
      : "G",
      : "G",
      : "G",
      : "g",
      : "g",
      : "g",
      : "g",
      : "H",
      : "H",
      : "h",
      : "h",
      : "I",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "i",
      : "J",
      : "j",
      : "K",
      : "k",
      : "k",
      : "L",
      : "L",
      : "L",
      : "L",
      : "L",
      : "l",
      : "l",
      : "l",
      : "l",
      : "l",
      : "N",
      : "N",
      : "N",
      : "N",
      : "n",
      : "n",
      : "n",
      : "n",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "R",
      : "R",
      : "R",
      : "r",
      : "r",
      : "r",
      : "S",
      : "S",
      : "S",
      : "S",
      : "s",
      : "s",
      : "s",
      : "s",
      : "T",
      : "T",
      : "T",
      : "t",
      : "t",
      : "t",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "W",
      : "w",
      : "Y",
      : "y",
      : "Y",
      : "Z",
      : "Z",
      : "Z",
      : "z",
      : "z",
      : "z",
      : "IJ",
      : "ij",
      : "Oe",
      : "oe",
      : "'n",
      : "s"
    }, M = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, Y = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, fe = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, Le = parseFloat, Ke = parseInt, rt = typeof Ye == "object" && Ye && Ye.Object === Object && Ye, dt = typeof self == "object" && self && self.Object === Object && self, De = rt || dt || Function("return this")(), at = t && !t.nodeType && t, $t = at && !0 && e && !e.nodeType && e, zt = $t && $t.exports === at, Un = zt && rt.process, Kt = function() {
      try {
        var X = $t && $t.require && $t.require("util").types;
        return X || Un && Un.binding && Un.binding("util");
      } catch {
      }
    }(), lo = Kt && Kt.isArrayBuffer, ts = Kt && Kt.isDate, Wd = Kt && Kt.isMap, qd = Kt && Kt.isRegExp, Vd = Kt && Kt.isSet, Gd = Kt && Kt.isTypedArray;
    function Er(X, he, ue) {
      switch (ue.length) {
        case 0:
          return X.call(he);
        case 1:
          return X.call(he, ue[0]);
        case 2:
          return X.call(he, ue[0], ue[1]);
        case 3:
          return X.call(he, ue[0], ue[1], ue[2]);
      }
      return X.apply(he, ue);
    }
    function hw(X, he, ue, Oe) {
      for (var ke = -1, et = X == null ? 0 : X.length; ++ke < et; ) {
        var Mt = X[ke];
        he(Oe, Mt, ue(Mt), X);
      }
      return Oe;
    }
    function Nr(X, he) {
      for (var ue = -1, Oe = X == null ? 0 : X.length; ++ue < Oe && he(X[ue], ue, X) !== !1; )
        ;
      return X;
    }
    function gw(X, he) {
      for (var ue = X == null ? 0 : X.length; ue-- && he(X[ue], ue, X) !== !1; )
        ;
      return X;
    }
    function zd(X, he) {
      for (var ue = -1, Oe = X == null ? 0 : X.length; ++ue < Oe; )
        if (!he(X[ue], ue, X))
          return !1;
      return !0;
    }
    function li(X, he) {
      for (var ue = -1, Oe = X == null ? 0 : X.length, ke = 0, et = []; ++ue < Oe; ) {
        var Mt = X[ue];
        he(Mt, ue, X) && (et[ke++] = Mt);
      }
      return et;
    }
    function ba(X, he) {
      var ue = X == null ? 0 : X.length;
      return !!ue && co(X, he, 0) > -1;
    }
    function Of(X, he, ue) {
      for (var Oe = -1, ke = X == null ? 0 : X.length; ++Oe < ke; )
        if (ue(he, X[Oe]))
          return !0;
      return !1;
    }
    function mt(X, he) {
      for (var ue = -1, Oe = X == null ? 0 : X.length, ke = Array(Oe); ++ue < Oe; )
        ke[ue] = he(X[ue], ue, X);
      return ke;
    }
    function ci(X, he) {
      for (var ue = -1, Oe = he.length, ke = X.length; ++ue < Oe; )
        X[ke + ue] = he[ue];
      return X;
    }
    function Cf(X, he, ue, Oe) {
      var ke = -1, et = X == null ? 0 : X.length;
      for (Oe && et && (ue = X[++ke]); ++ke < et; )
        ue = he(ue, X[ke], ke, X);
      return ue;
    }
    function pw(X, he, ue, Oe) {
      var ke = X == null ? 0 : X.length;
      for (Oe && ke && (ue = X[--ke]); ke--; )
        ue = he(ue, X[ke], ke, X);
      return ue;
    }
    function Lf(X, he) {
      for (var ue = -1, Oe = X == null ? 0 : X.length; ++ue < Oe; )
        if (he(X[ue], ue, X))
          return !0;
      return !1;
    }
    var bw = Pf("length");
    function _w(X) {
      return X.split("");
    }
    function yw(X) {
      return X.match(hn) || [];
    }
    function Kd(X, he, ue) {
      var Oe;
      return ue(X, function(ke, et, Mt) {
        if (he(ke, et, Mt))
          return Oe = et, !1;
      }), Oe;
    }
    function _a(X, he, ue, Oe) {
      for (var ke = X.length, et = ue + (Oe ? 1 : -1); Oe ? et-- : ++et < ke; )
        if (he(X[et], et, X))
          return et;
      return -1;
    }
    function co(X, he, ue) {
      return he === he ? Lw(X, he, ue) : _a(X, Jd, ue);
    }
    function ww(X, he, ue, Oe) {
      for (var ke = ue - 1, et = X.length; ++ke < et; )
        if (Oe(X[ke], he))
          return ke;
      return -1;
    }
    function Jd(X) {
      return X !== X;
    }
    function Yd(X, he) {
      var ue = X == null ? 0 : X.length;
      return ue ? Nf(X, he) / ue : z;
    }
    function Pf(X) {
      return function(he) {
        return he == null ? r : he[X];
      };
    }
    function Bf(X) {
      return function(he) {
        return X == null ? r : X[he];
      };
    }
    function Xd(X, he, ue, Oe, ke) {
      return ke(X, function(et, Mt, lt) {
        ue = Oe ? (Oe = !1, et) : he(ue, et, Mt, lt);
      }), ue;
    }
    function mw(X, he) {
      var ue = X.length;
      for (X.sort(he); ue--; )
        X[ue] = X[ue].value;
      return X;
    }
    function Nf(X, he) {
      for (var ue, Oe = -1, ke = X.length; ++Oe < ke; ) {
        var et = he(X[Oe]);
        et !== r && (ue = ue === r ? et : ue + et);
      }
      return ue;
    }
    function $f(X, he) {
      for (var ue = -1, Oe = Array(X); ++ue < X; )
        Oe[ue] = he(ue);
      return Oe;
    }
    function Ew(X, he) {
      return mt(he, function(ue) {
        return [ue, X[ue]];
      });
    }
    function Zd(X) {
      return X && X.slice(0, rh(X) + 1).replace(Rt, "");
    }
    function vr(X) {
      return function(he) {
        return X(he);
      };
    }
    function Mf(X, he) {
      return mt(he, function(ue) {
        return X[ue];
      });
    }
    function rs(X, he) {
      return X.has(he);
    }
    function Qd(X, he) {
      for (var ue = -1, Oe = X.length; ++ue < Oe && co(he, X[ue], 0) > -1; )
        ;
      return ue;
    }
    function eh(X, he) {
      for (var ue = X.length; ue-- && co(he, X[ue], 0) > -1; )
        ;
      return ue;
    }
    function vw(X, he) {
      for (var ue = X.length, Oe = 0; ue--; )
        X[ue] === he && ++Oe;
      return Oe;
    }
    var Sw = Bf(If), Rw = Bf(M);
    function Aw(X) {
      return "\\" + fe[X];
    }
    function Tw(X, he) {
      return X == null ? r : X[he];
    }
    function ho(X) {
      return ga.test(X);
    }
    function Iw(X) {
      return Af.test(X);
    }
    function Ow(X) {
      for (var he, ue = []; !(he = X.next()).done; )
        ue.push(he.value);
      return ue;
    }
    function xf(X) {
      var he = -1, ue = Array(X.size);
      return X.forEach(function(Oe, ke) {
        ue[++he] = [ke, Oe];
      }), ue;
    }
    function th(X, he) {
      return function(ue) {
        return X(he(ue));
      };
    }
    function di(X, he) {
      for (var ue = -1, Oe = X.length, ke = 0, et = []; ++ue < Oe; ) {
        var Mt = X[ue];
        (Mt === he || Mt === b) && (X[ue] = b, et[ke++] = ue);
      }
      return et;
    }
    function ya(X) {
      var he = -1, ue = Array(X.size);
      return X.forEach(function(Oe) {
        ue[++he] = Oe;
      }), ue;
    }
    function Cw(X) {
      var he = -1, ue = Array(X.size);
      return X.forEach(function(Oe) {
        ue[++he] = [Oe, Oe];
      }), ue;
    }
    function Lw(X, he, ue) {
      for (var Oe = ue - 1, ke = X.length; ++Oe < ke; )
        if (X[Oe] === he)
          return Oe;
      return -1;
    }
    function Pw(X, he, ue) {
      for (var Oe = ue + 1; Oe--; )
        if (X[Oe] === he)
          return Oe;
      return Oe;
    }
    function go(X) {
      return ho(X) ? Nw(X) : bw(X);
    }
    function Qr(X) {
      return ho(X) ? $w(X) : _w(X);
    }
    function rh(X) {
      for (var he = X.length; he-- && cn.test(X.charAt(he)); )
        ;
      return he;
    }
    var Bw = Bf(Y);
    function Nw(X) {
      for (var he = jn.lastIndex = 0; jn.test(X); )
        ++he;
      return he;
    }
    function $w(X) {
      return X.match(jn) || [];
    }
    function Mw(X) {
      return X.match(Rf) || [];
    }
    var xw = function X(he) {
      he = he == null ? De : po.defaults(De.Object(), he, po.pick(De, pa));
      var ue = he.Array, Oe = he.Date, ke = he.Error, et = he.Function, Mt = he.Math, lt = he.Object, Df = he.RegExp, Dw = he.String, $r = he.TypeError, wa = ue.prototype, jw = et.prototype, bo = lt.prototype, ma = he["__core-js_shared__"], Ea = jw.toString, ot = bo.hasOwnProperty, Uw = 0, nh = function() {
        var n = /[^.]+$/.exec(ma && ma.keys && ma.keys.IE_PROTO || "");
        return n ? "Symbol(src)_1." + n : "";
      }(), va = bo.toString, kw = Ea.call(lt), Fw = De._, Hw = Df(
        "^" + Ea.call(ot).replace(Te, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Sa = zt ? he.Buffer : r, hi = he.Symbol, Ra = he.Uint8Array, ih = Sa ? Sa.allocUnsafe : r, Aa = th(lt.getPrototypeOf, lt), oh = lt.create, sh = bo.propertyIsEnumerable, Ta = wa.splice, ah = hi ? hi.isConcatSpreadable : r, ns = hi ? hi.iterator : r, xi = hi ? hi.toStringTag : r, Ia = function() {
        try {
          var n = Fi(lt, "defineProperty");
          return n({}, "", {}), n;
        } catch {
        }
      }(), Ww = he.clearTimeout !== De.clearTimeout && he.clearTimeout, qw = Oe && Oe.now !== De.Date.now && Oe.now, Vw = he.setTimeout !== De.setTimeout && he.setTimeout, Oa = Mt.ceil, Ca = Mt.floor, jf = lt.getOwnPropertySymbols, Gw = Sa ? Sa.isBuffer : r, uh = he.isFinite, zw = wa.join, Kw = th(lt.keys, lt), xt = Mt.max, Jt = Mt.min, Jw = Oe.now, Yw = he.parseInt, fh = Mt.random, Xw = wa.reverse, Uf = Fi(he, "DataView"), is = Fi(he, "Map"), kf = Fi(he, "Promise"), _o = Fi(he, "Set"), os = Fi(he, "WeakMap"), ss = Fi(lt, "create"), La = os && new os(), yo = {}, Zw = Hi(Uf), Qw = Hi(is), em = Hi(kf), tm = Hi(_o), rm = Hi(os), Pa = hi ? hi.prototype : r, as = Pa ? Pa.valueOf : r, lh = Pa ? Pa.toString : r;
      function T(n) {
        if (At(n) && !Fe(n) && !(n instanceof Je)) {
          if (n instanceof Mr)
            return n;
          if (ot.call(n, "__wrapped__"))
            return cg(n);
        }
        return new Mr(n);
      }
      var wo = /* @__PURE__ */ function() {
        function n() {
        }
        return function(i) {
          if (!Et(i))
            return {};
          if (oh)
            return oh(i);
          n.prototype = i;
          var a = new n();
          return n.prototype = r, a;
        };
      }();
      function Ba() {
      }
      function Mr(n, i) {
        this.__wrapped__ = n, this.__actions__ = [], this.__chain__ = !!i, this.__index__ = 0, this.__values__ = r;
      }
      T.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Xr,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: ln,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: N,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: T
        }
      }, T.prototype = Ba.prototype, T.prototype.constructor = T, Mr.prototype = wo(Ba.prototype), Mr.prototype.constructor = Mr;
      function Je(n) {
        this.__wrapped__ = n, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = se, this.__views__ = [];
      }
      function nm() {
        var n = new Je(this.__wrapped__);
        return n.__actions__ = dr(this.__actions__), n.__dir__ = this.__dir__, n.__filtered__ = this.__filtered__, n.__iteratees__ = dr(this.__iteratees__), n.__takeCount__ = this.__takeCount__, n.__views__ = dr(this.__views__), n;
      }
      function im() {
        if (this.__filtered__) {
          var n = new Je(this);
          n.__dir__ = -1, n.__filtered__ = !0;
        } else
          n = this.clone(), n.__dir__ *= -1;
        return n;
      }
      function om() {
        var n = this.__wrapped__.value(), i = this.__dir__, a = Fe(n), c = i < 0, y = a ? n.length : 0, L = _E(0, y, this.__views__), k = L.start, G = L.end, Q = G - k, ge = c ? G : k - 1, pe = this.__iteratees__, we = pe.length, Ae = 0, Pe = Jt(Q, this.__takeCount__);
        if (!a || !c && y == Q && Pe == Q)
          return $h(n, this.__actions__);
        var Me = [];
        e:
          for (; Q-- && Ae < Pe; ) {
            ge += i;
            for (var qe = -1, xe = n[ge]; ++qe < we; ) {
              var ze = pe[qe], Ze = ze.iteratee, Ar = ze.type, ar = Ze(xe);
              if (Ar == q)
                xe = ar;
              else if (!ar) {
                if (Ar == $)
                  continue e;
                break e;
              }
            }
            Me[Ae++] = xe;
          }
        return Me;
      }
      Je.prototype = wo(Ba.prototype), Je.prototype.constructor = Je;
      function Di(n) {
        var i = -1, a = n == null ? 0 : n.length;
        for (this.clear(); ++i < a; ) {
          var c = n[i];
          this.set(c[0], c[1]);
        }
      }
      function sm() {
        this.__data__ = ss ? ss(null) : {}, this.size = 0;
      }
      function am(n) {
        var i = this.has(n) && delete this.__data__[n];
        return this.size -= i ? 1 : 0, i;
      }
      function um(n) {
        var i = this.__data__;
        if (ss) {
          var a = i[n];
          return a === l ? r : a;
        }
        return ot.call(i, n) ? i[n] : r;
      }
      function fm(n) {
        var i = this.__data__;
        return ss ? i[n] !== r : ot.call(i, n);
      }
      function lm(n, i) {
        var a = this.__data__;
        return this.size += this.has(n) ? 0 : 1, a[n] = ss && i === r ? l : i, this;
      }
      Di.prototype.clear = sm, Di.prototype.delete = am, Di.prototype.get = um, Di.prototype.has = fm, Di.prototype.set = lm;
      function kn(n) {
        var i = -1, a = n == null ? 0 : n.length;
        for (this.clear(); ++i < a; ) {
          var c = n[i];
          this.set(c[0], c[1]);
        }
      }
      function cm() {
        this.__data__ = [], this.size = 0;
      }
      function dm(n) {
        var i = this.__data__, a = Na(i, n);
        if (a < 0)
          return !1;
        var c = i.length - 1;
        return a == c ? i.pop() : Ta.call(i, a, 1), --this.size, !0;
      }
      function hm(n) {
        var i = this.__data__, a = Na(i, n);
        return a < 0 ? r : i[a][1];
      }
      function gm(n) {
        return Na(this.__data__, n) > -1;
      }
      function pm(n, i) {
        var a = this.__data__, c = Na(a, n);
        return c < 0 ? (++this.size, a.push([n, i])) : a[c][1] = i, this;
      }
      kn.prototype.clear = cm, kn.prototype.delete = dm, kn.prototype.get = hm, kn.prototype.has = gm, kn.prototype.set = pm;
      function Fn(n) {
        var i = -1, a = n == null ? 0 : n.length;
        for (this.clear(); ++i < a; ) {
          var c = n[i];
          this.set(c[0], c[1]);
        }
      }
      function bm() {
        this.size = 0, this.__data__ = {
          hash: new Di(),
          map: new (is || kn)(),
          string: new Di()
        };
      }
      function _m(n) {
        var i = Va(this, n).delete(n);
        return this.size -= i ? 1 : 0, i;
      }
      function ym(n) {
        return Va(this, n).get(n);
      }
      function wm(n) {
        return Va(this, n).has(n);
      }
      function mm(n, i) {
        var a = Va(this, n), c = a.size;
        return a.set(n, i), this.size += a.size == c ? 0 : 1, this;
      }
      Fn.prototype.clear = bm, Fn.prototype.delete = _m, Fn.prototype.get = ym, Fn.prototype.has = wm, Fn.prototype.set = mm;
      function ji(n) {
        var i = -1, a = n == null ? 0 : n.length;
        for (this.__data__ = new Fn(); ++i < a; )
          this.add(n[i]);
      }
      function Em(n) {
        return this.__data__.set(n, l), this;
      }
      function vm(n) {
        return this.__data__.has(n);
      }
      ji.prototype.add = ji.prototype.push = Em, ji.prototype.has = vm;
      function en(n) {
        var i = this.__data__ = new kn(n);
        this.size = i.size;
      }
      function Sm() {
        this.__data__ = new kn(), this.size = 0;
      }
      function Rm(n) {
        var i = this.__data__, a = i.delete(n);
        return this.size = i.size, a;
      }
      function Am(n) {
        return this.__data__.get(n);
      }
      function Tm(n) {
        return this.__data__.has(n);
      }
      function Im(n, i) {
        var a = this.__data__;
        if (a instanceof kn) {
          var c = a.__data__;
          if (!is || c.length < s - 1)
            return c.push([n, i]), this.size = ++a.size, this;
          a = this.__data__ = new Fn(c);
        }
        return a.set(n, i), this.size = a.size, this;
      }
      en.prototype.clear = Sm, en.prototype.delete = Rm, en.prototype.get = Am, en.prototype.has = Tm, en.prototype.set = Im;
      function ch(n, i) {
        var a = Fe(n), c = !a && Wi(n), y = !a && !c && yi(n), L = !a && !c && !y && So(n), k = a || c || y || L, G = k ? $f(n.length, Dw) : [], Q = G.length;
        for (var ge in n)
          (i || ot.call(n, ge)) && !(k && // Safari 9 has enumerable `arguments.length` in strict mode.
          (ge == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          y && (ge == "offset" || ge == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          L && (ge == "buffer" || ge == "byteLength" || ge == "byteOffset") || // Skip index properties.
          Vn(ge, Q))) && G.push(ge);
        return G;
      }
      function dh(n) {
        var i = n.length;
        return i ? n[Xf(0, i - 1)] : r;
      }
      function Om(n, i) {
        return Ga(dr(n), Ui(i, 0, n.length));
      }
      function Cm(n) {
        return Ga(dr(n));
      }
      function Ff(n, i, a) {
        (a !== r && !tn(n[i], a) || a === r && !(i in n)) && Hn(n, i, a);
      }
      function us(n, i, a) {
        var c = n[i];
        (!(ot.call(n, i) && tn(c, a)) || a === r && !(i in n)) && Hn(n, i, a);
      }
      function Na(n, i) {
        for (var a = n.length; a--; )
          if (tn(n[a][0], i))
            return a;
        return -1;
      }
      function Lm(n, i, a, c) {
        return gi(n, function(y, L, k) {
          i(c, y, a(y), k);
        }), c;
      }
      function hh(n, i) {
        return n && wn(i, Ut(i), n);
      }
      function Pm(n, i) {
        return n && wn(i, gr(i), n);
      }
      function Hn(n, i, a) {
        i == "__proto__" && Ia ? Ia(n, i, {
          configurable: !0,
          enumerable: !0,
          value: a,
          writable: !0
        }) : n[i] = a;
      }
      function Hf(n, i) {
        for (var a = -1, c = i.length, y = ue(c), L = n == null; ++a < c; )
          y[a] = L ? r : vl(n, i[a]);
        return y;
      }
      function Ui(n, i, a) {
        return n === n && (a !== r && (n = n <= a ? n : a), i !== r && (n = n >= i ? n : i)), n;
      }
      function xr(n, i, a, c, y, L) {
        var k, G = i & w, Q = i & I, ge = i & A;
        if (a && (k = y ? a(n, c, y, L) : a(n)), k !== r)
          return k;
        if (!Et(n))
          return n;
        var pe = Fe(n);
        if (pe) {
          if (k = wE(n), !G)
            return dr(n, k);
        } else {
          var we = Yt(n), Ae = we == g || we == _;
          if (yi(n))
            return Dh(n, G);
          if (we == oe || we == be || Ae && !y) {
            if (k = Q || Ae ? {} : rg(n), !G)
              return Q ? uE(n, Pm(k, n)) : aE(n, hh(k, n));
          } else {
            if (!it[we])
              return y ? n : {};
            k = mE(n, we, G);
          }
        }
        L || (L = new en());
        var Pe = L.get(n);
        if (Pe)
          return Pe;
        L.set(n, k), Pg(n) ? n.forEach(function(xe) {
          k.add(xr(xe, i, a, xe, n, L));
        }) : Cg(n) && n.forEach(function(xe, ze) {
          k.set(ze, xr(xe, i, a, ze, n, L));
        });
        var Me = ge ? Q ? ul : al : Q ? gr : Ut, qe = pe ? r : Me(n);
        return Nr(qe || n, function(xe, ze) {
          qe && (ze = xe, xe = n[ze]), us(k, ze, xr(xe, i, a, ze, n, L));
        }), k;
      }
      function Bm(n) {
        var i = Ut(n);
        return function(a) {
          return gh(a, n, i);
        };
      }
      function gh(n, i, a) {
        var c = a.length;
        if (n == null)
          return !c;
        for (n = lt(n); c--; ) {
          var y = a[c], L = i[y], k = n[y];
          if (k === r && !(y in n) || !L(k))
            return !1;
        }
        return !0;
      }
      function ph(n, i, a) {
        if (typeof n != "function")
          throw new $r(f);
        return ps(function() {
          n.apply(r, a);
        }, i);
      }
      function fs(n, i, a, c) {
        var y = -1, L = ba, k = !0, G = n.length, Q = [], ge = i.length;
        if (!G)
          return Q;
        a && (i = mt(i, vr(a))), c ? (L = Of, k = !1) : i.length >= s && (L = rs, k = !1, i = new ji(i));
        e:
          for (; ++y < G; ) {
            var pe = n[y], we = a == null ? pe : a(pe);
            if (pe = c || pe !== 0 ? pe : 0, k && we === we) {
              for (var Ae = ge; Ae--; )
                if (i[Ae] === we)
                  continue e;
              Q.push(pe);
            } else L(i, we, c) || Q.push(pe);
          }
        return Q;
      }
      var gi = Hh(yn), bh = Hh(qf, !0);
      function Nm(n, i) {
        var a = !0;
        return gi(n, function(c, y, L) {
          return a = !!i(c, y, L), a;
        }), a;
      }
      function $a(n, i, a) {
        for (var c = -1, y = n.length; ++c < y; ) {
          var L = n[c], k = i(L);
          if (k != null && (G === r ? k === k && !Rr(k) : a(k, G)))
            var G = k, Q = L;
        }
        return Q;
      }
      function $m(n, i, a, c) {
        var y = n.length;
        for (a = We(a), a < 0 && (a = -a > y ? 0 : y + a), c = c === r || c > y ? y : We(c), c < 0 && (c += y), c = a > c ? 0 : Ng(c); a < c; )
          n[a++] = i;
        return n;
      }
      function _h(n, i) {
        var a = [];
        return gi(n, function(c, y, L) {
          i(c, y, L) && a.push(c);
        }), a;
      }
      function Wt(n, i, a, c, y) {
        var L = -1, k = n.length;
        for (a || (a = vE), y || (y = []); ++L < k; ) {
          var G = n[L];
          i > 0 && a(G) ? i > 1 ? Wt(G, i - 1, a, c, y) : ci(y, G) : c || (y[y.length] = G);
        }
        return y;
      }
      var Wf = Wh(), yh = Wh(!0);
      function yn(n, i) {
        return n && Wf(n, i, Ut);
      }
      function qf(n, i) {
        return n && yh(n, i, Ut);
      }
      function Ma(n, i) {
        return li(i, function(a) {
          return Gn(n[a]);
        });
      }
      function ki(n, i) {
        i = bi(i, n);
        for (var a = 0, c = i.length; n != null && a < c; )
          n = n[mn(i[a++])];
        return a && a == c ? n : r;
      }
      function wh(n, i, a) {
        var c = i(n);
        return Fe(n) ? c : ci(c, a(n));
      }
      function or(n) {
        return n == null ? n === r ? _t : ne : xi && xi in lt(n) ? bE(n) : CE(n);
      }
      function Vf(n, i) {
        return n > i;
      }
      function Mm(n, i) {
        return n != null && ot.call(n, i);
      }
      function xm(n, i) {
        return n != null && i in lt(n);
      }
      function Dm(n, i, a) {
        return n >= Jt(i, a) && n < xt(i, a);
      }
      function Gf(n, i, a) {
        for (var c = a ? Of : ba, y = n[0].length, L = n.length, k = L, G = ue(L), Q = 1 / 0, ge = []; k--; ) {
          var pe = n[k];
          k && i && (pe = mt(pe, vr(i))), Q = Jt(pe.length, Q), G[k] = !a && (i || y >= 120 && pe.length >= 120) ? new ji(k && pe) : r;
        }
        pe = n[0];
        var we = -1, Ae = G[0];
        e:
          for (; ++we < y && ge.length < Q; ) {
            var Pe = pe[we], Me = i ? i(Pe) : Pe;
            if (Pe = a || Pe !== 0 ? Pe : 0, !(Ae ? rs(Ae, Me) : c(ge, Me, a))) {
              for (k = L; --k; ) {
                var qe = G[k];
                if (!(qe ? rs(qe, Me) : c(n[k], Me, a)))
                  continue e;
              }
              Ae && Ae.push(Me), ge.push(Pe);
            }
          }
        return ge;
      }
      function jm(n, i, a, c) {
        return yn(n, function(y, L, k) {
          i(c, a(y), L, k);
        }), c;
      }
      function ls(n, i, a) {
        i = bi(i, n), n = sg(n, i);
        var c = n == null ? n : n[mn(jr(i))];
        return c == null ? r : Er(c, n, a);
      }
      function mh(n) {
        return At(n) && or(n) == be;
      }
      function Um(n) {
        return At(n) && or(n) == Xe;
      }
      function km(n) {
        return At(n) && or(n) == ie;
      }
      function cs(n, i, a, c, y) {
        return n === i ? !0 : n == null || i == null || !At(n) && !At(i) ? n !== n && i !== i : Fm(n, i, a, c, cs, y);
      }
      function Fm(n, i, a, c, y, L) {
        var k = Fe(n), G = Fe(i), Q = k ? R : Yt(n), ge = G ? R : Yt(i);
        Q = Q == be ? oe : Q, ge = ge == be ? oe : ge;
        var pe = Q == oe, we = ge == oe, Ae = Q == ge;
        if (Ae && yi(n)) {
          if (!yi(i))
            return !1;
          k = !0, pe = !1;
        }
        if (Ae && !pe)
          return L || (L = new en()), k || So(n) ? Qh(n, i, a, c, y, L) : gE(n, i, Q, a, c, y, L);
        if (!(a & x)) {
          var Pe = pe && ot.call(n, "__wrapped__"), Me = we && ot.call(i, "__wrapped__");
          if (Pe || Me) {
            var qe = Pe ? n.value() : n, xe = Me ? i.value() : i;
            return L || (L = new en()), y(qe, xe, a, c, L);
          }
        }
        return Ae ? (L || (L = new en()), pE(n, i, a, c, y, L)) : !1;
      }
      function Hm(n) {
        return At(n) && Yt(n) == E;
      }
      function zf(n, i, a, c) {
        var y = a.length, L = y, k = !c;
        if (n == null)
          return !L;
        for (n = lt(n); y--; ) {
          var G = a[y];
          if (k && G[2] ? G[1] !== n[G[0]] : !(G[0] in n))
            return !1;
        }
        for (; ++y < L; ) {
          G = a[y];
          var Q = G[0], ge = n[Q], pe = G[1];
          if (k && G[2]) {
            if (ge === r && !(Q in n))
              return !1;
          } else {
            var we = new en();
            if (c)
              var Ae = c(ge, pe, Q, n, i, we);
            if (!(Ae === r ? cs(pe, ge, x | v, c, we) : Ae))
              return !1;
          }
        }
        return !0;
      }
      function Eh(n) {
        if (!Et(n) || RE(n))
          return !1;
        var i = Gn(n) ? Hw : Ht;
        return i.test(Hi(n));
      }
      function Wm(n) {
        return At(n) && or(n) == Ce;
      }
      function qm(n) {
        return At(n) && Yt(n) == Ue;
      }
      function Vm(n) {
        return At(n) && Za(n.length) && !!ft[or(n)];
      }
      function vh(n) {
        return typeof n == "function" ? n : n == null ? pr : typeof n == "object" ? Fe(n) ? Ah(n[0], n[1]) : Rh(n) : qg(n);
      }
      function Kf(n) {
        if (!gs(n))
          return Kw(n);
        var i = [];
        for (var a in lt(n))
          ot.call(n, a) && a != "constructor" && i.push(a);
        return i;
      }
      function Gm(n) {
        if (!Et(n))
          return OE(n);
        var i = gs(n), a = [];
        for (var c in n)
          c == "constructor" && (i || !ot.call(n, c)) || a.push(c);
        return a;
      }
      function Jf(n, i) {
        return n < i;
      }
      function Sh(n, i) {
        var a = -1, c = hr(n) ? ue(n.length) : [];
        return gi(n, function(y, L, k) {
          c[++a] = i(y, L, k);
        }), c;
      }
      function Rh(n) {
        var i = ll(n);
        return i.length == 1 && i[0][2] ? ig(i[0][0], i[0][1]) : function(a) {
          return a === n || zf(a, n, i);
        };
      }
      function Ah(n, i) {
        return dl(n) && ng(i) ? ig(mn(n), i) : function(a) {
          var c = vl(a, n);
          return c === r && c === i ? Sl(a, n) : cs(i, c, x | v);
        };
      }
      function xa(n, i, a, c, y) {
        n !== i && Wf(i, function(L, k) {
          if (y || (y = new en()), Et(L))
            zm(n, i, k, a, xa, c, y);
          else {
            var G = c ? c(gl(n, k), L, k + "", n, i, y) : r;
            G === r && (G = L), Ff(n, k, G);
          }
        }, gr);
      }
      function zm(n, i, a, c, y, L, k) {
        var G = gl(n, a), Q = gl(i, a), ge = k.get(Q);
        if (ge) {
          Ff(n, a, ge);
          return;
        }
        var pe = L ? L(G, Q, a + "", n, i, k) : r, we = pe === r;
        if (we) {
          var Ae = Fe(Q), Pe = !Ae && yi(Q), Me = !Ae && !Pe && So(Q);
          pe = Q, Ae || Pe || Me ? Fe(G) ? pe = G : It(G) ? pe = dr(G) : Pe ? (we = !1, pe = Dh(Q, !0)) : Me ? (we = !1, pe = jh(Q, !0)) : pe = [] : bs(Q) || Wi(Q) ? (pe = G, Wi(G) ? pe = $g(G) : (!Et(G) || Gn(G)) && (pe = rg(Q))) : we = !1;
        }
        we && (k.set(Q, pe), y(pe, Q, c, L, k), k.delete(Q)), Ff(n, a, pe);
      }
      function Th(n, i) {
        var a = n.length;
        if (a)
          return i += i < 0 ? a : 0, Vn(i, a) ? n[i] : r;
      }
      function Ih(n, i, a) {
        i.length ? i = mt(i, function(L) {
          return Fe(L) ? function(k) {
            return ki(k, L.length === 1 ? L[0] : L);
          } : L;
        }) : i = [pr];
        var c = -1;
        i = mt(i, vr($e()));
        var y = Sh(n, function(L, k, G) {
          var Q = mt(i, function(ge) {
            return ge(L);
          });
          return { criteria: Q, index: ++c, value: L };
        });
        return mw(y, function(L, k) {
          return sE(L, k, a);
        });
      }
      function Km(n, i) {
        return Oh(n, i, function(a, c) {
          return Sl(n, c);
        });
      }
      function Oh(n, i, a) {
        for (var c = -1, y = i.length, L = {}; ++c < y; ) {
          var k = i[c], G = ki(n, k);
          a(G, k) && ds(L, bi(k, n), G);
        }
        return L;
      }
      function Jm(n) {
        return function(i) {
          return ki(i, n);
        };
      }
      function Yf(n, i, a, c) {
        var y = c ? ww : co, L = -1, k = i.length, G = n;
        for (n === i && (i = dr(i)), a && (G = mt(n, vr(a))); ++L < k; )
          for (var Q = 0, ge = i[L], pe = a ? a(ge) : ge; (Q = y(G, pe, Q, c)) > -1; )
            G !== n && Ta.call(G, Q, 1), Ta.call(n, Q, 1);
        return n;
      }
      function Ch(n, i) {
        for (var a = n ? i.length : 0, c = a - 1; a--; ) {
          var y = i[a];
          if (a == c || y !== L) {
            var L = y;
            Vn(y) ? Ta.call(n, y, 1) : el(n, y);
          }
        }
        return n;
      }
      function Xf(n, i) {
        return n + Ca(fh() * (i - n + 1));
      }
      function Ym(n, i, a, c) {
        for (var y = -1, L = xt(Oa((i - n) / (a || 1)), 0), k = ue(L); L--; )
          k[c ? L : ++y] = n, n += a;
        return k;
      }
      function Zf(n, i) {
        var a = "";
        if (!n || i < 1 || i > re)
          return a;
        do
          i % 2 && (a += n), i = Ca(i / 2), i && (n += n);
        while (i);
        return a;
      }
      function Ve(n, i) {
        return pl(og(n, i, pr), n + "");
      }
      function Xm(n) {
        return dh(Ro(n));
      }
      function Zm(n, i) {
        var a = Ro(n);
        return Ga(a, Ui(i, 0, a.length));
      }
      function ds(n, i, a, c) {
        if (!Et(n))
          return n;
        i = bi(i, n);
        for (var y = -1, L = i.length, k = L - 1, G = n; G != null && ++y < L; ) {
          var Q = mn(i[y]), ge = a;
          if (Q === "__proto__" || Q === "constructor" || Q === "prototype")
            return n;
          if (y != k) {
            var pe = G[Q];
            ge = c ? c(pe, Q, G) : r, ge === r && (ge = Et(pe) ? pe : Vn(i[y + 1]) ? [] : {});
          }
          us(G, Q, ge), G = G[Q];
        }
        return n;
      }
      var Lh = La ? function(n, i) {
        return La.set(n, i), n;
      } : pr, Qm = Ia ? function(n, i) {
        return Ia(n, "toString", {
          configurable: !0,
          enumerable: !1,
          value: Al(i),
          writable: !0
        });
      } : pr;
      function eE(n) {
        return Ga(Ro(n));
      }
      function Dr(n, i, a) {
        var c = -1, y = n.length;
        i < 0 && (i = -i > y ? 0 : y + i), a = a > y ? y : a, a < 0 && (a += y), y = i > a ? 0 : a - i >>> 0, i >>>= 0;
        for (var L = ue(y); ++c < y; )
          L[c] = n[c + i];
        return L;
      }
      function tE(n, i) {
        var a;
        return gi(n, function(c, y, L) {
          return a = i(c, y, L), !a;
        }), !!a;
      }
      function Da(n, i, a) {
        var c = 0, y = n == null ? c : n.length;
        if (typeof i == "number" && i === i && y <= te) {
          for (; c < y; ) {
            var L = c + y >>> 1, k = n[L];
            k !== null && !Rr(k) && (a ? k <= i : k < i) ? c = L + 1 : y = L;
          }
          return y;
        }
        return Qf(n, i, pr, a);
      }
      function Qf(n, i, a, c) {
        var y = 0, L = n == null ? 0 : n.length;
        if (L === 0)
          return 0;
        i = a(i);
        for (var k = i !== i, G = i === null, Q = Rr(i), ge = i === r; y < L; ) {
          var pe = Ca((y + L) / 2), we = a(n[pe]), Ae = we !== r, Pe = we === null, Me = we === we, qe = Rr(we);
          if (k)
            var xe = c || Me;
          else ge ? xe = Me && (c || Ae) : G ? xe = Me && Ae && (c || !Pe) : Q ? xe = Me && Ae && !Pe && (c || !qe) : Pe || qe ? xe = !1 : xe = c ? we <= i : we < i;
          xe ? y = pe + 1 : L = pe;
        }
        return Jt(L, de);
      }
      function Ph(n, i) {
        for (var a = -1, c = n.length, y = 0, L = []; ++a < c; ) {
          var k = n[a], G = i ? i(k) : k;
          if (!a || !tn(G, Q)) {
            var Q = G;
            L[y++] = k === 0 ? 0 : k;
          }
        }
        return L;
      }
      function Bh(n) {
        return typeof n == "number" ? n : Rr(n) ? z : +n;
      }
      function Sr(n) {
        if (typeof n == "string")
          return n;
        if (Fe(n))
          return mt(n, Sr) + "";
        if (Rr(n))
          return lh ? lh.call(n) : "";
        var i = n + "";
        return i == "0" && 1 / n == -1 / 0 ? "-0" : i;
      }
      function pi(n, i, a) {
        var c = -1, y = ba, L = n.length, k = !0, G = [], Q = G;
        if (a)
          k = !1, y = Of;
        else if (L >= s) {
          var ge = i ? null : dE(n);
          if (ge)
            return ya(ge);
          k = !1, y = rs, Q = new ji();
        } else
          Q = i ? [] : G;
        e:
          for (; ++c < L; ) {
            var pe = n[c], we = i ? i(pe) : pe;
            if (pe = a || pe !== 0 ? pe : 0, k && we === we) {
              for (var Ae = Q.length; Ae--; )
                if (Q[Ae] === we)
                  continue e;
              i && Q.push(we), G.push(pe);
            } else y(Q, we, a) || (Q !== G && Q.push(we), G.push(pe));
          }
        return G;
      }
      function el(n, i) {
        return i = bi(i, n), n = sg(n, i), n == null || delete n[mn(jr(i))];
      }
      function Nh(n, i, a, c) {
        return ds(n, i, a(ki(n, i)), c);
      }
      function ja(n, i, a, c) {
        for (var y = n.length, L = c ? y : -1; (c ? L-- : ++L < y) && i(n[L], L, n); )
          ;
        return a ? Dr(n, c ? 0 : L, c ? L + 1 : y) : Dr(n, c ? L + 1 : 0, c ? y : L);
      }
      function $h(n, i) {
        var a = n;
        return a instanceof Je && (a = a.value()), Cf(i, function(c, y) {
          return y.func.apply(y.thisArg, ci([c], y.args));
        }, a);
      }
      function tl(n, i, a) {
        var c = n.length;
        if (c < 2)
          return c ? pi(n[0]) : [];
        for (var y = -1, L = ue(c); ++y < c; )
          for (var k = n[y], G = -1; ++G < c; )
            G != y && (L[y] = fs(L[y] || k, n[G], i, a));
        return pi(Wt(L, 1), i, a);
      }
      function Mh(n, i, a) {
        for (var c = -1, y = n.length, L = i.length, k = {}; ++c < y; ) {
          var G = c < L ? i[c] : r;
          a(k, n[c], G);
        }
        return k;
      }
      function rl(n) {
        return It(n) ? n : [];
      }
      function nl(n) {
        return typeof n == "function" ? n : pr;
      }
      function bi(n, i) {
        return Fe(n) ? n : dl(n, i) ? [n] : lg(nt(n));
      }
      var rE = Ve;
      function _i(n, i, a) {
        var c = n.length;
        return a = a === r ? c : a, !i && a >= c ? n : Dr(n, i, a);
      }
      var xh = Ww || function(n) {
        return De.clearTimeout(n);
      };
      function Dh(n, i) {
        if (i)
          return n.slice();
        var a = n.length, c = ih ? ih(a) : new n.constructor(a);
        return n.copy(c), c;
      }
      function il(n) {
        var i = new n.constructor(n.byteLength);
        return new Ra(i).set(new Ra(n)), i;
      }
      function nE(n, i) {
        var a = i ? il(n.buffer) : n.buffer;
        return new n.constructor(a, n.byteOffset, n.byteLength);
      }
      function iE(n) {
        var i = new n.constructor(n.source, Pr.exec(n));
        return i.lastIndex = n.lastIndex, i;
      }
      function oE(n) {
        return as ? lt(as.call(n)) : {};
      }
      function jh(n, i) {
        var a = i ? il(n.buffer) : n.buffer;
        return new n.constructor(a, n.byteOffset, n.length);
      }
      function Uh(n, i) {
        if (n !== i) {
          var a = n !== r, c = n === null, y = n === n, L = Rr(n), k = i !== r, G = i === null, Q = i === i, ge = Rr(i);
          if (!G && !ge && !L && n > i || L && k && Q && !G && !ge || c && k && Q || !a && Q || !y)
            return 1;
          if (!c && !L && !ge && n < i || ge && a && y && !c && !L || G && a && y || !k && y || !Q)
            return -1;
        }
        return 0;
      }
      function sE(n, i, a) {
        for (var c = -1, y = n.criteria, L = i.criteria, k = y.length, G = a.length; ++c < k; ) {
          var Q = Uh(y[c], L[c]);
          if (Q) {
            if (c >= G)
              return Q;
            var ge = a[c];
            return Q * (ge == "desc" ? -1 : 1);
          }
        }
        return n.index - i.index;
      }
      function kh(n, i, a, c) {
        for (var y = -1, L = n.length, k = a.length, G = -1, Q = i.length, ge = xt(L - k, 0), pe = ue(Q + ge), we = !c; ++G < Q; )
          pe[G] = i[G];
        for (; ++y < k; )
          (we || y < L) && (pe[a[y]] = n[y]);
        for (; ge--; )
          pe[G++] = n[y++];
        return pe;
      }
      function Fh(n, i, a, c) {
        for (var y = -1, L = n.length, k = -1, G = a.length, Q = -1, ge = i.length, pe = xt(L - G, 0), we = ue(pe + ge), Ae = !c; ++y < pe; )
          we[y] = n[y];
        for (var Pe = y; ++Q < ge; )
          we[Pe + Q] = i[Q];
        for (; ++k < G; )
          (Ae || y < L) && (we[Pe + a[k]] = n[y++]);
        return we;
      }
      function dr(n, i) {
        var a = -1, c = n.length;
        for (i || (i = ue(c)); ++a < c; )
          i[a] = n[a];
        return i;
      }
      function wn(n, i, a, c) {
        var y = !a;
        a || (a = {});
        for (var L = -1, k = i.length; ++L < k; ) {
          var G = i[L], Q = c ? c(a[G], n[G], G, a, n) : r;
          Q === r && (Q = n[G]), y ? Hn(a, G, Q) : us(a, G, Q);
        }
        return a;
      }
      function aE(n, i) {
        return wn(n, cl(n), i);
      }
      function uE(n, i) {
        return wn(n, eg(n), i);
      }
      function Ua(n, i) {
        return function(a, c) {
          var y = Fe(a) ? hw : Lm, L = i ? i() : {};
          return y(a, n, $e(c, 2), L);
        };
      }
      function mo(n) {
        return Ve(function(i, a) {
          var c = -1, y = a.length, L = y > 1 ? a[y - 1] : r, k = y > 2 ? a[2] : r;
          for (L = n.length > 3 && typeof L == "function" ? (y--, L) : r, k && sr(a[0], a[1], k) && (L = y < 3 ? r : L, y = 1), i = lt(i); ++c < y; ) {
            var G = a[c];
            G && n(i, G, c, L);
          }
          return i;
        });
      }
      function Hh(n, i) {
        return function(a, c) {
          if (a == null)
            return a;
          if (!hr(a))
            return n(a, c);
          for (var y = a.length, L = i ? y : -1, k = lt(a); (i ? L-- : ++L < y) && c(k[L], L, k) !== !1; )
            ;
          return a;
        };
      }
      function Wh(n) {
        return function(i, a, c) {
          for (var y = -1, L = lt(i), k = c(i), G = k.length; G--; ) {
            var Q = k[n ? G : ++y];
            if (a(L[Q], Q, L) === !1)
              break;
          }
          return i;
        };
      }
      function fE(n, i, a) {
        var c = i & C, y = hs(n);
        function L() {
          var k = this && this !== De && this instanceof L ? y : n;
          return k.apply(c ? a : this, arguments);
        }
        return L;
      }
      function qh(n) {
        return function(i) {
          i = nt(i);
          var a = ho(i) ? Qr(i) : r, c = a ? a[0] : i.charAt(0), y = a ? _i(a, 1).join("") : i.slice(1);
          return c[n]() + y;
        };
      }
      function Eo(n) {
        return function(i) {
          return Cf(Hg(Fg(i).replace(ha, "")), n, "");
        };
      }
      function hs(n) {
        return function() {
          var i = arguments;
          switch (i.length) {
            case 0:
              return new n();
            case 1:
              return new n(i[0]);
            case 2:
              return new n(i[0], i[1]);
            case 3:
              return new n(i[0], i[1], i[2]);
            case 4:
              return new n(i[0], i[1], i[2], i[3]);
            case 5:
              return new n(i[0], i[1], i[2], i[3], i[4]);
            case 6:
              return new n(i[0], i[1], i[2], i[3], i[4], i[5]);
            case 7:
              return new n(i[0], i[1], i[2], i[3], i[4], i[5], i[6]);
          }
          var a = wo(n.prototype), c = n.apply(a, i);
          return Et(c) ? c : a;
        };
      }
      function lE(n, i, a) {
        var c = hs(n);
        function y() {
          for (var L = arguments.length, k = ue(L), G = L, Q = vo(y); G--; )
            k[G] = arguments[G];
          var ge = L < 3 && k[0] !== Q && k[L - 1] !== Q ? [] : di(k, Q);
          if (L -= ge.length, L < a)
            return Jh(
              n,
              i,
              ka,
              y.placeholder,
              r,
              k,
              ge,
              r,
              r,
              a - L
            );
          var pe = this && this !== De && this instanceof y ? c : n;
          return Er(pe, this, k);
        }
        return y;
      }
      function Vh(n) {
        return function(i, a, c) {
          var y = lt(i);
          if (!hr(i)) {
            var L = $e(a, 3);
            i = Ut(i), a = function(G) {
              return L(y[G], G, y);
            };
          }
          var k = n(i, a, c);
          return k > -1 ? y[L ? i[k] : k] : r;
        };
      }
      function Gh(n) {
        return qn(function(i) {
          var a = i.length, c = a, y = Mr.prototype.thru;
          for (n && i.reverse(); c--; ) {
            var L = i[c];
            if (typeof L != "function")
              throw new $r(f);
            if (y && !k && qa(L) == "wrapper")
              var k = new Mr([], !0);
          }
          for (c = k ? c : a; ++c < a; ) {
            L = i[c];
            var G = qa(L), Q = G == "wrapper" ? fl(L) : r;
            Q && hl(Q[0]) && Q[1] == (ce | S | j | ae) && !Q[4].length && Q[9] == 1 ? k = k[qa(Q[0])].apply(k, Q[3]) : k = L.length == 1 && hl(L) ? k[G]() : k.thru(L);
          }
          return function() {
            var ge = arguments, pe = ge[0];
            if (k && ge.length == 1 && Fe(pe))
              return k.plant(pe).value();
            for (var we = 0, Ae = a ? i[we].apply(this, ge) : pe; ++we < a; )
              Ae = i[we].call(this, Ae);
            return Ae;
          };
        });
      }
      function ka(n, i, a, c, y, L, k, G, Q, ge) {
        var pe = i & ce, we = i & C, Ae = i & B, Pe = i & (S | m), Me = i & ee, qe = Ae ? r : hs(n);
        function xe() {
          for (var ze = arguments.length, Ze = ue(ze), Ar = ze; Ar--; )
            Ze[Ar] = arguments[Ar];
          if (Pe)
            var ar = vo(xe), Tr = vw(Ze, ar);
          if (c && (Ze = kh(Ze, c, y, Pe)), L && (Ze = Fh(Ze, L, k, Pe)), ze -= Tr, Pe && ze < ge) {
            var Ot = di(Ze, ar);
            return Jh(
              n,
              i,
              ka,
              xe.placeholder,
              a,
              Ze,
              Ot,
              G,
              Q,
              ge - ze
            );
          }
          var rn = we ? a : this, Kn = Ae ? rn[n] : n;
          return ze = Ze.length, G ? Ze = LE(Ze, G) : Me && ze > 1 && Ze.reverse(), pe && Q < ze && (Ze.length = Q), this && this !== De && this instanceof xe && (Kn = qe || hs(Kn)), Kn.apply(rn, Ze);
        }
        return xe;
      }
      function zh(n, i) {
        return function(a, c) {
          return jm(a, n, i(c), {});
        };
      }
      function Fa(n, i) {
        return function(a, c) {
          var y;
          if (a === r && c === r)
            return i;
          if (a !== r && (y = a), c !== r) {
            if (y === r)
              return c;
            typeof a == "string" || typeof c == "string" ? (a = Sr(a), c = Sr(c)) : (a = Bh(a), c = Bh(c)), y = n(a, c);
          }
          return y;
        };
      }
      function ol(n) {
        return qn(function(i) {
          return i = mt(i, vr($e())), Ve(function(a) {
            var c = this;
            return n(i, function(y) {
              return Er(y, c, a);
            });
          });
        });
      }
      function Ha(n, i) {
        i = i === r ? " " : Sr(i);
        var a = i.length;
        if (a < 2)
          return a ? Zf(i, n) : i;
        var c = Zf(i, Oa(n / go(i)));
        return ho(i) ? _i(Qr(c), 0, n).join("") : c.slice(0, n);
      }
      function cE(n, i, a, c) {
        var y = i & C, L = hs(n);
        function k() {
          for (var G = -1, Q = arguments.length, ge = -1, pe = c.length, we = ue(pe + Q), Ae = this && this !== De && this instanceof k ? L : n; ++ge < pe; )
            we[ge] = c[ge];
          for (; Q--; )
            we[ge++] = arguments[++G];
          return Er(Ae, y ? a : this, we);
        }
        return k;
      }
      function Kh(n) {
        return function(i, a, c) {
          return c && typeof c != "number" && sr(i, a, c) && (a = c = r), i = zn(i), a === r ? (a = i, i = 0) : a = zn(a), c = c === r ? i < a ? 1 : -1 : zn(c), Ym(i, a, c, n);
        };
      }
      function Wa(n) {
        return function(i, a) {
          return typeof i == "string" && typeof a == "string" || (i = Ur(i), a = Ur(a)), n(i, a);
        };
      }
      function Jh(n, i, a, c, y, L, k, G, Q, ge) {
        var pe = i & S, we = pe ? k : r, Ae = pe ? r : k, Pe = pe ? L : r, Me = pe ? r : L;
        i |= pe ? j : Z, i &= ~(pe ? Z : j), i & P || (i &= -4);
        var qe = [
          n,
          i,
          y,
          Pe,
          we,
          Me,
          Ae,
          G,
          Q,
          ge
        ], xe = a.apply(r, qe);
        return hl(n) && ag(xe, qe), xe.placeholder = c, ug(xe, n, i);
      }
      function sl(n) {
        var i = Mt[n];
        return function(a, c) {
          if (a = Ur(a), c = c == null ? 0 : Jt(We(c), 292), c && uh(a)) {
            var y = (nt(a) + "e").split("e"), L = i(y[0] + "e" + (+y[1] + c));
            return y = (nt(L) + "e").split("e"), +(y[0] + "e" + (+y[1] - c));
          }
          return i(a);
        };
      }
      var dE = _o && 1 / ya(new _o([, -0]))[1] == V ? function(n) {
        return new _o(n);
      } : Ol;
      function Yh(n) {
        return function(i) {
          var a = Yt(i);
          return a == E ? xf(i) : a == Ue ? Cw(i) : Ew(i, n(i));
        };
      }
      function Wn(n, i, a, c, y, L, k, G) {
        var Q = i & B;
        if (!Q && typeof n != "function")
          throw new $r(f);
        var ge = c ? c.length : 0;
        if (ge || (i &= -97, c = y = r), k = k === r ? k : xt(We(k), 0), G = G === r ? G : We(G), ge -= y ? y.length : 0, i & Z) {
          var pe = c, we = y;
          c = y = r;
        }
        var Ae = Q ? r : fl(n), Pe = [
          n,
          i,
          a,
          c,
          y,
          pe,
          we,
          L,
          k,
          G
        ];
        if (Ae && IE(Pe, Ae), n = Pe[0], i = Pe[1], a = Pe[2], c = Pe[3], y = Pe[4], G = Pe[9] = Pe[9] === r ? Q ? 0 : n.length : xt(Pe[9] - ge, 0), !G && i & (S | m) && (i &= -25), !i || i == C)
          var Me = fE(n, i, a);
        else i == S || i == m ? Me = lE(n, i, G) : (i == j || i == (C | j)) && !y.length ? Me = cE(n, i, a, c) : Me = ka.apply(r, Pe);
        var qe = Ae ? Lh : ag;
        return ug(qe(Me, Pe), n, i);
      }
      function Xh(n, i, a, c) {
        return n === r || tn(n, bo[a]) && !ot.call(c, a) ? i : n;
      }
      function Zh(n, i, a, c, y, L) {
        return Et(n) && Et(i) && (L.set(i, n), xa(n, i, r, Zh, L), L.delete(i)), n;
      }
      function hE(n) {
        return bs(n) ? r : n;
      }
      function Qh(n, i, a, c, y, L) {
        var k = a & x, G = n.length, Q = i.length;
        if (G != Q && !(k && Q > G))
          return !1;
        var ge = L.get(n), pe = L.get(i);
        if (ge && pe)
          return ge == i && pe == n;
        var we = -1, Ae = !0, Pe = a & v ? new ji() : r;
        for (L.set(n, i), L.set(i, n); ++we < G; ) {
          var Me = n[we], qe = i[we];
          if (c)
            var xe = k ? c(qe, Me, we, i, n, L) : c(Me, qe, we, n, i, L);
          if (xe !== r) {
            if (xe)
              continue;
            Ae = !1;
            break;
          }
          if (Pe) {
            if (!Lf(i, function(ze, Ze) {
              if (!rs(Pe, Ze) && (Me === ze || y(Me, ze, a, c, L)))
                return Pe.push(Ze);
            })) {
              Ae = !1;
              break;
            }
          } else if (!(Me === qe || y(Me, qe, a, c, L))) {
            Ae = !1;
            break;
          }
        }
        return L.delete(n), L.delete(i), Ae;
      }
      function gE(n, i, a, c, y, L, k) {
        switch (a) {
          case Ge:
            if (n.byteLength != i.byteLength || n.byteOffset != i.byteOffset)
              return !1;
            n = n.buffer, i = i.buffer;
          case Xe:
            return !(n.byteLength != i.byteLength || !L(new Ra(n), new Ra(i)));
          case W:
          case ie:
          case K:
            return tn(+n, +i);
          case d:
            return n.name == i.name && n.message == i.message;
          case Ce:
          case Re:
            return n == i + "";
          case E:
            var G = xf;
          case Ue:
            var Q = c & x;
            if (G || (G = ya), n.size != i.size && !Q)
              return !1;
            var ge = k.get(n);
            if (ge)
              return ge == i;
            c |= v, k.set(n, i);
            var pe = Qh(G(n), G(i), c, y, L, k);
            return k.delete(n), pe;
          case He:
            if (as)
              return as.call(n) == as.call(i);
        }
        return !1;
      }
      function pE(n, i, a, c, y, L) {
        var k = a & x, G = al(n), Q = G.length, ge = al(i), pe = ge.length;
        if (Q != pe && !k)
          return !1;
        for (var we = Q; we--; ) {
          var Ae = G[we];
          if (!(k ? Ae in i : ot.call(i, Ae)))
            return !1;
        }
        var Pe = L.get(n), Me = L.get(i);
        if (Pe && Me)
          return Pe == i && Me == n;
        var qe = !0;
        L.set(n, i), L.set(i, n);
        for (var xe = k; ++we < Q; ) {
          Ae = G[we];
          var ze = n[Ae], Ze = i[Ae];
          if (c)
            var Ar = k ? c(Ze, ze, Ae, i, n, L) : c(ze, Ze, Ae, n, i, L);
          if (!(Ar === r ? ze === Ze || y(ze, Ze, a, c, L) : Ar)) {
            qe = !1;
            break;
          }
          xe || (xe = Ae == "constructor");
        }
        if (qe && !xe) {
          var ar = n.constructor, Tr = i.constructor;
          ar != Tr && "constructor" in n && "constructor" in i && !(typeof ar == "function" && ar instanceof ar && typeof Tr == "function" && Tr instanceof Tr) && (qe = !1);
        }
        return L.delete(n), L.delete(i), qe;
      }
      function qn(n) {
        return pl(og(n, r, gg), n + "");
      }
      function al(n) {
        return wh(n, Ut, cl);
      }
      function ul(n) {
        return wh(n, gr, eg);
      }
      var fl = La ? function(n) {
        return La.get(n);
      } : Ol;
      function qa(n) {
        for (var i = n.name + "", a = yo[i], c = ot.call(yo, i) ? a.length : 0; c--; ) {
          var y = a[c], L = y.func;
          if (L == null || L == n)
            return y.name;
        }
        return i;
      }
      function vo(n) {
        var i = ot.call(T, "placeholder") ? T : n;
        return i.placeholder;
      }
      function $e() {
        var n = T.iteratee || Tl;
        return n = n === Tl ? vh : n, arguments.length ? n(arguments[0], arguments[1]) : n;
      }
      function Va(n, i) {
        var a = n.__data__;
        return SE(i) ? a[typeof i == "string" ? "string" : "hash"] : a.map;
      }
      function ll(n) {
        for (var i = Ut(n), a = i.length; a--; ) {
          var c = i[a], y = n[c];
          i[a] = [c, y, ng(y)];
        }
        return i;
      }
      function Fi(n, i) {
        var a = Tw(n, i);
        return Eh(a) ? a : r;
      }
      function bE(n) {
        var i = ot.call(n, xi), a = n[xi];
        try {
          n[xi] = r;
          var c = !0;
        } catch {
        }
        var y = va.call(n);
        return c && (i ? n[xi] = a : delete n[xi]), y;
      }
      var cl = jf ? function(n) {
        return n == null ? [] : (n = lt(n), li(jf(n), function(i) {
          return sh.call(n, i);
        }));
      } : Cl, eg = jf ? function(n) {
        for (var i = []; n; )
          ci(i, cl(n)), n = Aa(n);
        return i;
      } : Cl, Yt = or;
      (Uf && Yt(new Uf(new ArrayBuffer(1))) != Ge || is && Yt(new is()) != E || kf && Yt(kf.resolve()) != Ie || _o && Yt(new _o()) != Ue || os && Yt(new os()) != tt) && (Yt = function(n) {
        var i = or(n), a = i == oe ? n.constructor : r, c = a ? Hi(a) : "";
        if (c)
          switch (c) {
            case Zw:
              return Ge;
            case Qw:
              return E;
            case em:
              return Ie;
            case tm:
              return Ue;
            case rm:
              return tt;
          }
        return i;
      });
      function _E(n, i, a) {
        for (var c = -1, y = a.length; ++c < y; ) {
          var L = a[c], k = L.size;
          switch (L.type) {
            case "drop":
              n += k;
              break;
            case "dropRight":
              i -= k;
              break;
            case "take":
              i = Jt(i, n + k);
              break;
            case "takeRight":
              n = xt(n, i - k);
              break;
          }
        }
        return { start: n, end: i };
      }
      function yE(n) {
        var i = n.match(dn);
        return i ? i[1].split(Mn) : [];
      }
      function tg(n, i, a) {
        i = bi(i, n);
        for (var c = -1, y = i.length, L = !1; ++c < y; ) {
          var k = mn(i[c]);
          if (!(L = n != null && a(n, k)))
            break;
          n = n[k];
        }
        return L || ++c != y ? L : (y = n == null ? 0 : n.length, !!y && Za(y) && Vn(k, y) && (Fe(n) || Wi(n)));
      }
      function wE(n) {
        var i = n.length, a = new n.constructor(i);
        return i && typeof n[0] == "string" && ot.call(n, "index") && (a.index = n.index, a.input = n.input), a;
      }
      function rg(n) {
        return typeof n.constructor == "function" && !gs(n) ? wo(Aa(n)) : {};
      }
      function mE(n, i, a) {
        var c = n.constructor;
        switch (i) {
          case Xe:
            return il(n);
          case W:
          case ie:
            return new c(+n);
          case Ge:
            return nE(n, a);
          case jt:
          case Pt:
          case ut:
          case Nt:
          case lr:
          case tr:
          case Ft:
          case cr:
          case Jr:
            return jh(n, a);
          case E:
            return new c();
          case K:
          case Re:
            return new c(n);
          case Ce:
            return iE(n);
          case Ue:
            return new c();
          case He:
            return oE(n);
        }
      }
      function EE(n, i) {
        var a = i.length;
        if (!a)
          return n;
        var c = a - 1;
        return i[c] = (a > 1 ? "& " : "") + i[c], i = i.join(a > 2 ? ", " : " "), n.replace(Bt, `{
/* [wrapped with ` + i + `] */
`);
      }
      function vE(n) {
        return Fe(n) || Wi(n) || !!(ah && n && n[ah]);
      }
      function Vn(n, i) {
        var a = typeof n;
        return i = i ?? re, !!i && (a == "number" || a != "symbol" && Bi.test(n)) && n > -1 && n % 1 == 0 && n < i;
      }
      function sr(n, i, a) {
        if (!Et(a))
          return !1;
        var c = typeof i;
        return (c == "number" ? hr(a) && Vn(i, a.length) : c == "string" && i in a) ? tn(a[i], n) : !1;
      }
      function dl(n, i) {
        if (Fe(n))
          return !1;
        var a = typeof n;
        return a == "number" || a == "symbol" || a == "boolean" || n == null || Rr(n) ? !0 : Ee.test(n) || !D.test(n) || i != null && n in lt(i);
      }
      function SE(n) {
        var i = typeof n;
        return i == "string" || i == "number" || i == "symbol" || i == "boolean" ? n !== "__proto__" : n === null;
      }
      function hl(n) {
        var i = qa(n), a = T[i];
        if (typeof a != "function" || !(i in Je.prototype))
          return !1;
        if (n === a)
          return !0;
        var c = fl(a);
        return !!c && n === c[0];
      }
      function RE(n) {
        return !!nh && nh in n;
      }
      var AE = ma ? Gn : Ll;
      function gs(n) {
        var i = n && n.constructor, a = typeof i == "function" && i.prototype || bo;
        return n === a;
      }
      function ng(n) {
        return n === n && !Et(n);
      }
      function ig(n, i) {
        return function(a) {
          return a == null ? !1 : a[n] === i && (i !== r || n in lt(a));
        };
      }
      function TE(n) {
        var i = Ya(n, function(c) {
          return a.size === p && a.clear(), c;
        }), a = i.cache;
        return i;
      }
      function IE(n, i) {
        var a = n[1], c = i[1], y = a | c, L = y < (C | B | ce), k = c == ce && a == S || c == ce && a == ae && n[7].length <= i[8] || c == (ce | ae) && i[7].length <= i[8] && a == S;
        if (!(L || k))
          return n;
        c & C && (n[2] = i[2], y |= a & C ? 0 : P);
        var G = i[3];
        if (G) {
          var Q = n[3];
          n[3] = Q ? kh(Q, G, i[4]) : G, n[4] = Q ? di(n[3], b) : i[4];
        }
        return G = i[5], G && (Q = n[5], n[5] = Q ? Fh(Q, G, i[6]) : G, n[6] = Q ? di(n[5], b) : i[6]), G = i[7], G && (n[7] = G), c & ce && (n[8] = n[8] == null ? i[8] : Jt(n[8], i[8])), n[9] == null && (n[9] = i[9]), n[0] = i[0], n[1] = y, n;
      }
      function OE(n) {
        var i = [];
        if (n != null)
          for (var a in lt(n))
            i.push(a);
        return i;
      }
      function CE(n) {
        return va.call(n);
      }
      function og(n, i, a) {
        return i = xt(i === r ? n.length - 1 : i, 0), function() {
          for (var c = arguments, y = -1, L = xt(c.length - i, 0), k = ue(L); ++y < L; )
            k[y] = c[i + y];
          y = -1;
          for (var G = ue(i + 1); ++y < i; )
            G[y] = c[y];
          return G[i] = a(k), Er(n, this, G);
        };
      }
      function sg(n, i) {
        return i.length < 2 ? n : ki(n, Dr(i, 0, -1));
      }
      function LE(n, i) {
        for (var a = n.length, c = Jt(i.length, a), y = dr(n); c--; ) {
          var L = i[c];
          n[c] = Vn(L, a) ? y[L] : r;
        }
        return n;
      }
      function gl(n, i) {
        if (!(i === "constructor" && typeof n[i] == "function") && i != "__proto__")
          return n[i];
      }
      var ag = fg(Lh), ps = Vw || function(n, i) {
        return De.setTimeout(n, i);
      }, pl = fg(Qm);
      function ug(n, i, a) {
        var c = i + "";
        return pl(n, EE(c, PE(yE(c), a)));
      }
      function fg(n) {
        var i = 0, a = 0;
        return function() {
          var c = Jw(), y = U - (c - a);
          if (a = c, y > 0) {
            if (++i >= F)
              return arguments[0];
          } else
            i = 0;
          return n.apply(r, arguments);
        };
      }
      function Ga(n, i) {
        var a = -1, c = n.length, y = c - 1;
        for (i = i === r ? c : i; ++a < i; ) {
          var L = Xf(a, y), k = n[L];
          n[L] = n[a], n[a] = k;
        }
        return n.length = i, n;
      }
      var lg = TE(function(n) {
        var i = [];
        return n.charCodeAt(0) === 46 && i.push(""), n.replace(ve, function(a, c, y, L) {
          i.push(y ? L.replace(Zr, "$1") : c || a);
        }), i;
      });
      function mn(n) {
        if (typeof n == "string" || Rr(n))
          return n;
        var i = n + "";
        return i == "0" && 1 / n == -1 / 0 ? "-0" : i;
      }
      function Hi(n) {
        if (n != null) {
          try {
            return Ea.call(n);
          } catch {
          }
          try {
            return n + "";
          } catch {
          }
        }
        return "";
      }
      function PE(n, i) {
        return Nr(_e, function(a) {
          var c = "_." + a[0];
          i & a[1] && !ba(n, c) && n.push(c);
        }), n.sort();
      }
      function cg(n) {
        if (n instanceof Je)
          return n.clone();
        var i = new Mr(n.__wrapped__, n.__chain__);
        return i.__actions__ = dr(n.__actions__), i.__index__ = n.__index__, i.__values__ = n.__values__, i;
      }
      function BE(n, i, a) {
        (a ? sr(n, i, a) : i === r) ? i = 1 : i = xt(We(i), 0);
        var c = n == null ? 0 : n.length;
        if (!c || i < 1)
          return [];
        for (var y = 0, L = 0, k = ue(Oa(c / i)); y < c; )
          k[L++] = Dr(n, y, y += i);
        return k;
      }
      function NE(n) {
        for (var i = -1, a = n == null ? 0 : n.length, c = 0, y = []; ++i < a; ) {
          var L = n[i];
          L && (y[c++] = L);
        }
        return y;
      }
      function $E() {
        var n = arguments.length;
        if (!n)
          return [];
        for (var i = ue(n - 1), a = arguments[0], c = n; c--; )
          i[c - 1] = arguments[c];
        return ci(Fe(a) ? dr(a) : [a], Wt(i, 1));
      }
      var ME = Ve(function(n, i) {
        return It(n) ? fs(n, Wt(i, 1, It, !0)) : [];
      }), xE = Ve(function(n, i) {
        var a = jr(i);
        return It(a) && (a = r), It(n) ? fs(n, Wt(i, 1, It, !0), $e(a, 2)) : [];
      }), DE = Ve(function(n, i) {
        var a = jr(i);
        return It(a) && (a = r), It(n) ? fs(n, Wt(i, 1, It, !0), r, a) : [];
      });
      function jE(n, i, a) {
        var c = n == null ? 0 : n.length;
        return c ? (i = a || i === r ? 1 : We(i), Dr(n, i < 0 ? 0 : i, c)) : [];
      }
      function UE(n, i, a) {
        var c = n == null ? 0 : n.length;
        return c ? (i = a || i === r ? 1 : We(i), i = c - i, Dr(n, 0, i < 0 ? 0 : i)) : [];
      }
      function kE(n, i) {
        return n && n.length ? ja(n, $e(i, 3), !0, !0) : [];
      }
      function FE(n, i) {
        return n && n.length ? ja(n, $e(i, 3), !0) : [];
      }
      function HE(n, i, a, c) {
        var y = n == null ? 0 : n.length;
        return y ? (a && typeof a != "number" && sr(n, i, a) && (a = 0, c = y), $m(n, i, a, c)) : [];
      }
      function dg(n, i, a) {
        var c = n == null ? 0 : n.length;
        if (!c)
          return -1;
        var y = a == null ? 0 : We(a);
        return y < 0 && (y = xt(c + y, 0)), _a(n, $e(i, 3), y);
      }
      function hg(n, i, a) {
        var c = n == null ? 0 : n.length;
        if (!c)
          return -1;
        var y = c - 1;
        return a !== r && (y = We(a), y = a < 0 ? xt(c + y, 0) : Jt(y, c - 1)), _a(n, $e(i, 3), y, !0);
      }
      function gg(n) {
        var i = n == null ? 0 : n.length;
        return i ? Wt(n, 1) : [];
      }
      function WE(n) {
        var i = n == null ? 0 : n.length;
        return i ? Wt(n, V) : [];
      }
      function qE(n, i) {
        var a = n == null ? 0 : n.length;
        return a ? (i = i === r ? 1 : We(i), Wt(n, i)) : [];
      }
      function VE(n) {
        for (var i = -1, a = n == null ? 0 : n.length, c = {}; ++i < a; ) {
          var y = n[i];
          c[y[0]] = y[1];
        }
        return c;
      }
      function pg(n) {
        return n && n.length ? n[0] : r;
      }
      function GE(n, i, a) {
        var c = n == null ? 0 : n.length;
        if (!c)
          return -1;
        var y = a == null ? 0 : We(a);
        return y < 0 && (y = xt(c + y, 0)), co(n, i, y);
      }
      function zE(n) {
        var i = n == null ? 0 : n.length;
        return i ? Dr(n, 0, -1) : [];
      }
      var KE = Ve(function(n) {
        var i = mt(n, rl);
        return i.length && i[0] === n[0] ? Gf(i) : [];
      }), JE = Ve(function(n) {
        var i = jr(n), a = mt(n, rl);
        return i === jr(a) ? i = r : a.pop(), a.length && a[0] === n[0] ? Gf(a, $e(i, 2)) : [];
      }), YE = Ve(function(n) {
        var i = jr(n), a = mt(n, rl);
        return i = typeof i == "function" ? i : r, i && a.pop(), a.length && a[0] === n[0] ? Gf(a, r, i) : [];
      });
      function XE(n, i) {
        return n == null ? "" : zw.call(n, i);
      }
      function jr(n) {
        var i = n == null ? 0 : n.length;
        return i ? n[i - 1] : r;
      }
      function ZE(n, i, a) {
        var c = n == null ? 0 : n.length;
        if (!c)
          return -1;
        var y = c;
        return a !== r && (y = We(a), y = y < 0 ? xt(c + y, 0) : Jt(y, c - 1)), i === i ? Pw(n, i, y) : _a(n, Jd, y, !0);
      }
      function QE(n, i) {
        return n && n.length ? Th(n, We(i)) : r;
      }
      var ev = Ve(bg);
      function bg(n, i) {
        return n && n.length && i && i.length ? Yf(n, i) : n;
      }
      function tv(n, i, a) {
        return n && n.length && i && i.length ? Yf(n, i, $e(a, 2)) : n;
      }
      function rv(n, i, a) {
        return n && n.length && i && i.length ? Yf(n, i, r, a) : n;
      }
      var nv = qn(function(n, i) {
        var a = n == null ? 0 : n.length, c = Hf(n, i);
        return Ch(n, mt(i, function(y) {
          return Vn(y, a) ? +y : y;
        }).sort(Uh)), c;
      });
      function iv(n, i) {
        var a = [];
        if (!(n && n.length))
          return a;
        var c = -1, y = [], L = n.length;
        for (i = $e(i, 3); ++c < L; ) {
          var k = n[c];
          i(k, c, n) && (a.push(k), y.push(c));
        }
        return Ch(n, y), a;
      }
      function bl(n) {
        return n == null ? n : Xw.call(n);
      }
      function ov(n, i, a) {
        var c = n == null ? 0 : n.length;
        return c ? (a && typeof a != "number" && sr(n, i, a) ? (i = 0, a = c) : (i = i == null ? 0 : We(i), a = a === r ? c : We(a)), Dr(n, i, a)) : [];
      }
      function sv(n, i) {
        return Da(n, i);
      }
      function av(n, i, a) {
        return Qf(n, i, $e(a, 2));
      }
      function uv(n, i) {
        var a = n == null ? 0 : n.length;
        if (a) {
          var c = Da(n, i);
          if (c < a && tn(n[c], i))
            return c;
        }
        return -1;
      }
      function fv(n, i) {
        return Da(n, i, !0);
      }
      function lv(n, i, a) {
        return Qf(n, i, $e(a, 2), !0);
      }
      function cv(n, i) {
        var a = n == null ? 0 : n.length;
        if (a) {
          var c = Da(n, i, !0) - 1;
          if (tn(n[c], i))
            return c;
        }
        return -1;
      }
      function dv(n) {
        return n && n.length ? Ph(n) : [];
      }
      function hv(n, i) {
        return n && n.length ? Ph(n, $e(i, 2)) : [];
      }
      function gv(n) {
        var i = n == null ? 0 : n.length;
        return i ? Dr(n, 1, i) : [];
      }
      function pv(n, i, a) {
        return n && n.length ? (i = a || i === r ? 1 : We(i), Dr(n, 0, i < 0 ? 0 : i)) : [];
      }
      function bv(n, i, a) {
        var c = n == null ? 0 : n.length;
        return c ? (i = a || i === r ? 1 : We(i), i = c - i, Dr(n, i < 0 ? 0 : i, c)) : [];
      }
      function _v(n, i) {
        return n && n.length ? ja(n, $e(i, 3), !1, !0) : [];
      }
      function yv(n, i) {
        return n && n.length ? ja(n, $e(i, 3)) : [];
      }
      var wv = Ve(function(n) {
        return pi(Wt(n, 1, It, !0));
      }), mv = Ve(function(n) {
        var i = jr(n);
        return It(i) && (i = r), pi(Wt(n, 1, It, !0), $e(i, 2));
      }), Ev = Ve(function(n) {
        var i = jr(n);
        return i = typeof i == "function" ? i : r, pi(Wt(n, 1, It, !0), r, i);
      });
      function vv(n) {
        return n && n.length ? pi(n) : [];
      }
      function Sv(n, i) {
        return n && n.length ? pi(n, $e(i, 2)) : [];
      }
      function Rv(n, i) {
        return i = typeof i == "function" ? i : r, n && n.length ? pi(n, r, i) : [];
      }
      function _l(n) {
        if (!(n && n.length))
          return [];
        var i = 0;
        return n = li(n, function(a) {
          if (It(a))
            return i = xt(a.length, i), !0;
        }), $f(i, function(a) {
          return mt(n, Pf(a));
        });
      }
      function _g(n, i) {
        if (!(n && n.length))
          return [];
        var a = _l(n);
        return i == null ? a : mt(a, function(c) {
          return Er(i, r, c);
        });
      }
      var Av = Ve(function(n, i) {
        return It(n) ? fs(n, i) : [];
      }), Tv = Ve(function(n) {
        return tl(li(n, It));
      }), Iv = Ve(function(n) {
        var i = jr(n);
        return It(i) && (i = r), tl(li(n, It), $e(i, 2));
      }), Ov = Ve(function(n) {
        var i = jr(n);
        return i = typeof i == "function" ? i : r, tl(li(n, It), r, i);
      }), Cv = Ve(_l);
      function Lv(n, i) {
        return Mh(n || [], i || [], us);
      }
      function Pv(n, i) {
        return Mh(n || [], i || [], ds);
      }
      var Bv = Ve(function(n) {
        var i = n.length, a = i > 1 ? n[i - 1] : r;
        return a = typeof a == "function" ? (n.pop(), a) : r, _g(n, a);
      });
      function yg(n) {
        var i = T(n);
        return i.__chain__ = !0, i;
      }
      function Nv(n, i) {
        return i(n), n;
      }
      function za(n, i) {
        return i(n);
      }
      var $v = qn(function(n) {
        var i = n.length, a = i ? n[0] : 0, c = this.__wrapped__, y = function(L) {
          return Hf(L, n);
        };
        return i > 1 || this.__actions__.length || !(c instanceof Je) || !Vn(a) ? this.thru(y) : (c = c.slice(a, +a + (i ? 1 : 0)), c.__actions__.push({
          func: za,
          args: [y],
          thisArg: r
        }), new Mr(c, this.__chain__).thru(function(L) {
          return i && !L.length && L.push(r), L;
        }));
      });
      function Mv() {
        return yg(this);
      }
      function xv() {
        return new Mr(this.value(), this.__chain__);
      }
      function Dv() {
        this.__values__ === r && (this.__values__ = Bg(this.value()));
        var n = this.__index__ >= this.__values__.length, i = n ? r : this.__values__[this.__index__++];
        return { done: n, value: i };
      }
      function jv() {
        return this;
      }
      function Uv(n) {
        for (var i, a = this; a instanceof Ba; ) {
          var c = cg(a);
          c.__index__ = 0, c.__values__ = r, i ? y.__wrapped__ = c : i = c;
          var y = c;
          a = a.__wrapped__;
        }
        return y.__wrapped__ = n, i;
      }
      function kv() {
        var n = this.__wrapped__;
        if (n instanceof Je) {
          var i = n;
          return this.__actions__.length && (i = new Je(this)), i = i.reverse(), i.__actions__.push({
            func: za,
            args: [bl],
            thisArg: r
          }), new Mr(i, this.__chain__);
        }
        return this.thru(bl);
      }
      function Fv() {
        return $h(this.__wrapped__, this.__actions__);
      }
      var Hv = Ua(function(n, i, a) {
        ot.call(n, a) ? ++n[a] : Hn(n, a, 1);
      });
      function Wv(n, i, a) {
        var c = Fe(n) ? zd : Nm;
        return a && sr(n, i, a) && (i = r), c(n, $e(i, 3));
      }
      function qv(n, i) {
        var a = Fe(n) ? li : _h;
        return a(n, $e(i, 3));
      }
      var Vv = Vh(dg), Gv = Vh(hg);
      function zv(n, i) {
        return Wt(Ka(n, i), 1);
      }
      function Kv(n, i) {
        return Wt(Ka(n, i), V);
      }
      function Jv(n, i, a) {
        return a = a === r ? 1 : We(a), Wt(Ka(n, i), a);
      }
      function wg(n, i) {
        var a = Fe(n) ? Nr : gi;
        return a(n, $e(i, 3));
      }
      function mg(n, i) {
        var a = Fe(n) ? gw : bh;
        return a(n, $e(i, 3));
      }
      var Yv = Ua(function(n, i, a) {
        ot.call(n, a) ? n[a].push(i) : Hn(n, a, [i]);
      });
      function Xv(n, i, a, c) {
        n = hr(n) ? n : Ro(n), a = a && !c ? We(a) : 0;
        var y = n.length;
        return a < 0 && (a = xt(y + a, 0)), Qa(n) ? a <= y && n.indexOf(i, a) > -1 : !!y && co(n, i, a) > -1;
      }
      var Zv = Ve(function(n, i, a) {
        var c = -1, y = typeof i == "function", L = hr(n) ? ue(n.length) : [];
        return gi(n, function(k) {
          L[++c] = y ? Er(i, k, a) : ls(k, i, a);
        }), L;
      }), Qv = Ua(function(n, i, a) {
        Hn(n, a, i);
      });
      function Ka(n, i) {
        var a = Fe(n) ? mt : Sh;
        return a(n, $e(i, 3));
      }
      function eS(n, i, a, c) {
        return n == null ? [] : (Fe(i) || (i = i == null ? [] : [i]), a = c ? r : a, Fe(a) || (a = a == null ? [] : [a]), Ih(n, i, a));
      }
      var tS = Ua(function(n, i, a) {
        n[a ? 0 : 1].push(i);
      }, function() {
        return [[], []];
      });
      function rS(n, i, a) {
        var c = Fe(n) ? Cf : Xd, y = arguments.length < 3;
        return c(n, $e(i, 4), a, y, gi);
      }
      function nS(n, i, a) {
        var c = Fe(n) ? pw : Xd, y = arguments.length < 3;
        return c(n, $e(i, 4), a, y, bh);
      }
      function iS(n, i) {
        var a = Fe(n) ? li : _h;
        return a(n, Xa($e(i, 3)));
      }
      function oS(n) {
        var i = Fe(n) ? dh : Xm;
        return i(n);
      }
      function sS(n, i, a) {
        (a ? sr(n, i, a) : i === r) ? i = 1 : i = We(i);
        var c = Fe(n) ? Om : Zm;
        return c(n, i);
      }
      function aS(n) {
        var i = Fe(n) ? Cm : eE;
        return i(n);
      }
      function uS(n) {
        if (n == null)
          return 0;
        if (hr(n))
          return Qa(n) ? go(n) : n.length;
        var i = Yt(n);
        return i == E || i == Ue ? n.size : Kf(n).length;
      }
      function fS(n, i, a) {
        var c = Fe(n) ? Lf : tE;
        return a && sr(n, i, a) && (i = r), c(n, $e(i, 3));
      }
      var lS = Ve(function(n, i) {
        if (n == null)
          return [];
        var a = i.length;
        return a > 1 && sr(n, i[0], i[1]) ? i = [] : a > 2 && sr(i[0], i[1], i[2]) && (i = [i[0]]), Ih(n, Wt(i, 1), []);
      }), Ja = qw || function() {
        return De.Date.now();
      };
      function cS(n, i) {
        if (typeof i != "function")
          throw new $r(f);
        return n = We(n), function() {
          if (--n < 1)
            return i.apply(this, arguments);
        };
      }
      function Eg(n, i, a) {
        return i = a ? r : i, i = n && i == null ? n.length : i, Wn(n, ce, r, r, r, r, i);
      }
      function vg(n, i) {
        var a;
        if (typeof i != "function")
          throw new $r(f);
        return n = We(n), function() {
          return --n > 0 && (a = i.apply(this, arguments)), n <= 1 && (i = r), a;
        };
      }
      var yl = Ve(function(n, i, a) {
        var c = C;
        if (a.length) {
          var y = di(a, vo(yl));
          c |= j;
        }
        return Wn(n, c, i, a, y);
      }), Sg = Ve(function(n, i, a) {
        var c = C | B;
        if (a.length) {
          var y = di(a, vo(Sg));
          c |= j;
        }
        return Wn(i, c, n, a, y);
      });
      function Rg(n, i, a) {
        i = a ? r : i;
        var c = Wn(n, S, r, r, r, r, r, i);
        return c.placeholder = Rg.placeholder, c;
      }
      function Ag(n, i, a) {
        i = a ? r : i;
        var c = Wn(n, m, r, r, r, r, r, i);
        return c.placeholder = Ag.placeholder, c;
      }
      function Tg(n, i, a) {
        var c, y, L, k, G, Q, ge = 0, pe = !1, we = !1, Ae = !0;
        if (typeof n != "function")
          throw new $r(f);
        i = Ur(i) || 0, Et(a) && (pe = !!a.leading, we = "maxWait" in a, L = we ? xt(Ur(a.maxWait) || 0, i) : L, Ae = "trailing" in a ? !!a.trailing : Ae);
        function Pe(Ot) {
          var rn = c, Kn = y;
          return c = y = r, ge = Ot, k = n.apply(Kn, rn), k;
        }
        function Me(Ot) {
          return ge = Ot, G = ps(ze, i), pe ? Pe(Ot) : k;
        }
        function qe(Ot) {
          var rn = Ot - Q, Kn = Ot - ge, Vg = i - rn;
          return we ? Jt(Vg, L - Kn) : Vg;
        }
        function xe(Ot) {
          var rn = Ot - Q, Kn = Ot - ge;
          return Q === r || rn >= i || rn < 0 || we && Kn >= L;
        }
        function ze() {
          var Ot = Ja();
          if (xe(Ot))
            return Ze(Ot);
          G = ps(ze, qe(Ot));
        }
        function Ze(Ot) {
          return G = r, Ae && c ? Pe(Ot) : (c = y = r, k);
        }
        function Ar() {
          G !== r && xh(G), ge = 0, c = Q = y = G = r;
        }
        function ar() {
          return G === r ? k : Ze(Ja());
        }
        function Tr() {
          var Ot = Ja(), rn = xe(Ot);
          if (c = arguments, y = this, Q = Ot, rn) {
            if (G === r)
              return Me(Q);
            if (we)
              return xh(G), G = ps(ze, i), Pe(Q);
          }
          return G === r && (G = ps(ze, i)), k;
        }
        return Tr.cancel = Ar, Tr.flush = ar, Tr;
      }
      var dS = Ve(function(n, i) {
        return ph(n, 1, i);
      }), hS = Ve(function(n, i, a) {
        return ph(n, Ur(i) || 0, a);
      });
      function gS(n) {
        return Wn(n, ee);
      }
      function Ya(n, i) {
        if (typeof n != "function" || i != null && typeof i != "function")
          throw new $r(f);
        var a = function() {
          var c = arguments, y = i ? i.apply(this, c) : c[0], L = a.cache;
          if (L.has(y))
            return L.get(y);
          var k = n.apply(this, c);
          return a.cache = L.set(y, k) || L, k;
        };
        return a.cache = new (Ya.Cache || Fn)(), a;
      }
      Ya.Cache = Fn;
      function Xa(n) {
        if (typeof n != "function")
          throw new $r(f);
        return function() {
          var i = arguments;
          switch (i.length) {
            case 0:
              return !n.call(this);
            case 1:
              return !n.call(this, i[0]);
            case 2:
              return !n.call(this, i[0], i[1]);
            case 3:
              return !n.call(this, i[0], i[1], i[2]);
          }
          return !n.apply(this, i);
        };
      }
      function pS(n) {
        return vg(2, n);
      }
      var bS = rE(function(n, i) {
        i = i.length == 1 && Fe(i[0]) ? mt(i[0], vr($e())) : mt(Wt(i, 1), vr($e()));
        var a = i.length;
        return Ve(function(c) {
          for (var y = -1, L = Jt(c.length, a); ++y < L; )
            c[y] = i[y].call(this, c[y]);
          return Er(n, this, c);
        });
      }), wl = Ve(function(n, i) {
        var a = di(i, vo(wl));
        return Wn(n, j, r, i, a);
      }), Ig = Ve(function(n, i) {
        var a = di(i, vo(Ig));
        return Wn(n, Z, r, i, a);
      }), _S = qn(function(n, i) {
        return Wn(n, ae, r, r, r, i);
      });
      function yS(n, i) {
        if (typeof n != "function")
          throw new $r(f);
        return i = i === r ? i : We(i), Ve(n, i);
      }
      function wS(n, i) {
        if (typeof n != "function")
          throw new $r(f);
        return i = i == null ? 0 : xt(We(i), 0), Ve(function(a) {
          var c = a[i], y = _i(a, 0, i);
          return c && ci(y, c), Er(n, this, y);
        });
      }
      function mS(n, i, a) {
        var c = !0, y = !0;
        if (typeof n != "function")
          throw new $r(f);
        return Et(a) && (c = "leading" in a ? !!a.leading : c, y = "trailing" in a ? !!a.trailing : y), Tg(n, i, {
          leading: c,
          maxWait: i,
          trailing: y
        });
      }
      function ES(n) {
        return Eg(n, 1);
      }
      function vS(n, i) {
        return wl(nl(i), n);
      }
      function SS() {
        if (!arguments.length)
          return [];
        var n = arguments[0];
        return Fe(n) ? n : [n];
      }
      function RS(n) {
        return xr(n, A);
      }
      function AS(n, i) {
        return i = typeof i == "function" ? i : r, xr(n, A, i);
      }
      function TS(n) {
        return xr(n, w | A);
      }
      function IS(n, i) {
        return i = typeof i == "function" ? i : r, xr(n, w | A, i);
      }
      function OS(n, i) {
        return i == null || gh(n, i, Ut(i));
      }
      function tn(n, i) {
        return n === i || n !== n && i !== i;
      }
      var CS = Wa(Vf), LS = Wa(function(n, i) {
        return n >= i;
      }), Wi = mh(/* @__PURE__ */ function() {
        return arguments;
      }()) ? mh : function(n) {
        return At(n) && ot.call(n, "callee") && !sh.call(n, "callee");
      }, Fe = ue.isArray, PS = lo ? vr(lo) : Um;
      function hr(n) {
        return n != null && Za(n.length) && !Gn(n);
      }
      function It(n) {
        return At(n) && hr(n);
      }
      function BS(n) {
        return n === !0 || n === !1 || At(n) && or(n) == W;
      }
      var yi = Gw || Ll, NS = ts ? vr(ts) : km;
      function $S(n) {
        return At(n) && n.nodeType === 1 && !bs(n);
      }
      function MS(n) {
        if (n == null)
          return !0;
        if (hr(n) && (Fe(n) || typeof n == "string" || typeof n.splice == "function" || yi(n) || So(n) || Wi(n)))
          return !n.length;
        var i = Yt(n);
        if (i == E || i == Ue)
          return !n.size;
        if (gs(n))
          return !Kf(n).length;
        for (var a in n)
          if (ot.call(n, a))
            return !1;
        return !0;
      }
      function xS(n, i) {
        return cs(n, i);
      }
      function DS(n, i, a) {
        a = typeof a == "function" ? a : r;
        var c = a ? a(n, i) : r;
        return c === r ? cs(n, i, r, a) : !!c;
      }
      function ml(n) {
        if (!At(n))
          return !1;
        var i = or(n);
        return i == d || i == ye || typeof n.message == "string" && typeof n.name == "string" && !bs(n);
      }
      function jS(n) {
        return typeof n == "number" && uh(n);
      }
      function Gn(n) {
        if (!Et(n))
          return !1;
        var i = or(n);
        return i == g || i == _ || i == O || i == Be;
      }
      function Og(n) {
        return typeof n == "number" && n == We(n);
      }
      function Za(n) {
        return typeof n == "number" && n > -1 && n % 1 == 0 && n <= re;
      }
      function Et(n) {
        var i = typeof n;
        return n != null && (i == "object" || i == "function");
      }
      function At(n) {
        return n != null && typeof n == "object";
      }
      var Cg = Wd ? vr(Wd) : Hm;
      function US(n, i) {
        return n === i || zf(n, i, ll(i));
      }
      function kS(n, i, a) {
        return a = typeof a == "function" ? a : r, zf(n, i, ll(i), a);
      }
      function FS(n) {
        return Lg(n) && n != +n;
      }
      function HS(n) {
        if (AE(n))
          throw new ke(u);
        return Eh(n);
      }
      function WS(n) {
        return n === null;
      }
      function qS(n) {
        return n == null;
      }
      function Lg(n) {
        return typeof n == "number" || At(n) && or(n) == K;
      }
      function bs(n) {
        if (!At(n) || or(n) != oe)
          return !1;
        var i = Aa(n);
        if (i === null)
          return !0;
        var a = ot.call(i, "constructor") && i.constructor;
        return typeof a == "function" && a instanceof a && Ea.call(a) == kw;
      }
      var El = qd ? vr(qd) : Wm;
      function VS(n) {
        return Og(n) && n >= -9007199254740991 && n <= re;
      }
      var Pg = Vd ? vr(Vd) : qm;
      function Qa(n) {
        return typeof n == "string" || !Fe(n) && At(n) && or(n) == Re;
      }
      function Rr(n) {
        return typeof n == "symbol" || At(n) && or(n) == He;
      }
      var So = Gd ? vr(Gd) : Vm;
      function GS(n) {
        return n === r;
      }
      function zS(n) {
        return At(n) && Yt(n) == tt;
      }
      function KS(n) {
        return At(n) && or(n) == yt;
      }
      var JS = Wa(Jf), YS = Wa(function(n, i) {
        return n <= i;
      });
      function Bg(n) {
        if (!n)
          return [];
        if (hr(n))
          return Qa(n) ? Qr(n) : dr(n);
        if (ns && n[ns])
          return Ow(n[ns]());
        var i = Yt(n), a = i == E ? xf : i == Ue ? ya : Ro;
        return a(n);
      }
      function zn(n) {
        if (!n)
          return n === 0 ? n : 0;
        if (n = Ur(n), n === V || n === -1 / 0) {
          var i = n < 0 ? -1 : 1;
          return i * H;
        }
        return n === n ? n : 0;
      }
      function We(n) {
        var i = zn(n), a = i % 1;
        return i === i ? a ? i - a : i : 0;
      }
      function Ng(n) {
        return n ? Ui(We(n), 0, se) : 0;
      }
      function Ur(n) {
        if (typeof n == "number")
          return n;
        if (Rr(n))
          return z;
        if (Et(n)) {
          var i = typeof n.valueOf == "function" ? n.valueOf() : n;
          n = Et(i) ? i + "" : i;
        }
        if (typeof n != "string")
          return n === 0 ? n : +n;
        n = Zd(n);
        var a = ir.test(n);
        return a || Pi.test(n) ? Ke(n.slice(2), a ? 2 : 8) : mr.test(n) ? z : +n;
      }
      function $g(n) {
        return wn(n, gr(n));
      }
      function XS(n) {
        return n ? Ui(We(n), -9007199254740991, re) : n === 0 ? n : 0;
      }
      function nt(n) {
        return n == null ? "" : Sr(n);
      }
      var ZS = mo(function(n, i) {
        if (gs(i) || hr(i)) {
          wn(i, Ut(i), n);
          return;
        }
        for (var a in i)
          ot.call(i, a) && us(n, a, i[a]);
      }), Mg = mo(function(n, i) {
        wn(i, gr(i), n);
      }), eu = mo(function(n, i, a, c) {
        wn(i, gr(i), n, c);
      }), QS = mo(function(n, i, a, c) {
        wn(i, Ut(i), n, c);
      }), eR = qn(Hf);
      function tR(n, i) {
        var a = wo(n);
        return i == null ? a : hh(a, i);
      }
      var rR = Ve(function(n, i) {
        n = lt(n);
        var a = -1, c = i.length, y = c > 2 ? i[2] : r;
        for (y && sr(i[0], i[1], y) && (c = 1); ++a < c; )
          for (var L = i[a], k = gr(L), G = -1, Q = k.length; ++G < Q; ) {
            var ge = k[G], pe = n[ge];
            (pe === r || tn(pe, bo[ge]) && !ot.call(n, ge)) && (n[ge] = L[ge]);
          }
        return n;
      }), nR = Ve(function(n) {
        return n.push(r, Zh), Er(xg, r, n);
      });
      function iR(n, i) {
        return Kd(n, $e(i, 3), yn);
      }
      function oR(n, i) {
        return Kd(n, $e(i, 3), qf);
      }
      function sR(n, i) {
        return n == null ? n : Wf(n, $e(i, 3), gr);
      }
      function aR(n, i) {
        return n == null ? n : yh(n, $e(i, 3), gr);
      }
      function uR(n, i) {
        return n && yn(n, $e(i, 3));
      }
      function fR(n, i) {
        return n && qf(n, $e(i, 3));
      }
      function lR(n) {
        return n == null ? [] : Ma(n, Ut(n));
      }
      function cR(n) {
        return n == null ? [] : Ma(n, gr(n));
      }
      function vl(n, i, a) {
        var c = n == null ? r : ki(n, i);
        return c === r ? a : c;
      }
      function dR(n, i) {
        return n != null && tg(n, i, Mm);
      }
      function Sl(n, i) {
        return n != null && tg(n, i, xm);
      }
      var hR = zh(function(n, i, a) {
        i != null && typeof i.toString != "function" && (i = va.call(i)), n[i] = a;
      }, Al(pr)), gR = zh(function(n, i, a) {
        i != null && typeof i.toString != "function" && (i = va.call(i)), ot.call(n, i) ? n[i].push(a) : n[i] = [a];
      }, $e), pR = Ve(ls);
      function Ut(n) {
        return hr(n) ? ch(n) : Kf(n);
      }
      function gr(n) {
        return hr(n) ? ch(n, !0) : Gm(n);
      }
      function bR(n, i) {
        var a = {};
        return i = $e(i, 3), yn(n, function(c, y, L) {
          Hn(a, i(c, y, L), c);
        }), a;
      }
      function _R(n, i) {
        var a = {};
        return i = $e(i, 3), yn(n, function(c, y, L) {
          Hn(a, y, i(c, y, L));
        }), a;
      }
      var yR = mo(function(n, i, a) {
        xa(n, i, a);
      }), xg = mo(function(n, i, a, c) {
        xa(n, i, a, c);
      }), wR = qn(function(n, i) {
        var a = {};
        if (n == null)
          return a;
        var c = !1;
        i = mt(i, function(L) {
          return L = bi(L, n), c || (c = L.length > 1), L;
        }), wn(n, ul(n), a), c && (a = xr(a, w | I | A, hE));
        for (var y = i.length; y--; )
          el(a, i[y]);
        return a;
      });
      function mR(n, i) {
        return Dg(n, Xa($e(i)));
      }
      var ER = qn(function(n, i) {
        return n == null ? {} : Km(n, i);
      });
      function Dg(n, i) {
        if (n == null)
          return {};
        var a = mt(ul(n), function(c) {
          return [c];
        });
        return i = $e(i), Oh(n, a, function(c, y) {
          return i(c, y[0]);
        });
      }
      function vR(n, i, a) {
        i = bi(i, n);
        var c = -1, y = i.length;
        for (y || (y = 1, n = r); ++c < y; ) {
          var L = n == null ? r : n[mn(i[c])];
          L === r && (c = y, L = a), n = Gn(L) ? L.call(n) : L;
        }
        return n;
      }
      function SR(n, i, a) {
        return n == null ? n : ds(n, i, a);
      }
      function RR(n, i, a, c) {
        return c = typeof c == "function" ? c : r, n == null ? n : ds(n, i, a, c);
      }
      var jg = Yh(Ut), Ug = Yh(gr);
      function AR(n, i, a) {
        var c = Fe(n), y = c || yi(n) || So(n);
        if (i = $e(i, 4), a == null) {
          var L = n && n.constructor;
          y ? a = c ? new L() : [] : Et(n) ? a = Gn(L) ? wo(Aa(n)) : {} : a = {};
        }
        return (y ? Nr : yn)(n, function(k, G, Q) {
          return i(a, k, G, Q);
        }), a;
      }
      function TR(n, i) {
        return n == null ? !0 : el(n, i);
      }
      function IR(n, i, a) {
        return n == null ? n : Nh(n, i, nl(a));
      }
      function OR(n, i, a, c) {
        return c = typeof c == "function" ? c : r, n == null ? n : Nh(n, i, nl(a), c);
      }
      function Ro(n) {
        return n == null ? [] : Mf(n, Ut(n));
      }
      function CR(n) {
        return n == null ? [] : Mf(n, gr(n));
      }
      function LR(n, i, a) {
        return a === r && (a = i, i = r), a !== r && (a = Ur(a), a = a === a ? a : 0), i !== r && (i = Ur(i), i = i === i ? i : 0), Ui(Ur(n), i, a);
      }
      function PR(n, i, a) {
        return i = zn(i), a === r ? (a = i, i = 0) : a = zn(a), n = Ur(n), Dm(n, i, a);
      }
      function BR(n, i, a) {
        if (a && typeof a != "boolean" && sr(n, i, a) && (i = a = r), a === r && (typeof i == "boolean" ? (a = i, i = r) : typeof n == "boolean" && (a = n, n = r)), n === r && i === r ? (n = 0, i = 1) : (n = zn(n), i === r ? (i = n, n = 0) : i = zn(i)), n > i) {
          var c = n;
          n = i, i = c;
        }
        if (a || n % 1 || i % 1) {
          var y = fh();
          return Jt(n + y * (i - n + Le("1e-" + ((y + "").length - 1))), i);
        }
        return Xf(n, i);
      }
      var NR = Eo(function(n, i, a) {
        return i = i.toLowerCase(), n + (a ? kg(i) : i);
      });
      function kg(n) {
        return Rl(nt(n).toLowerCase());
      }
      function Fg(n) {
        return n = nt(n), n && n.replace(xn, Sw).replace(Dn, "");
      }
      function $R(n, i, a) {
        n = nt(n), i = Sr(i);
        var c = n.length;
        a = a === r ? c : Ui(We(a), 0, c);
        var y = a;
        return a -= i.length, a >= 0 && n.slice(a, y) == i;
      }
      function MR(n) {
        return n = nt(n), n && $n.test(n) ? n.replace(Lr, Rw) : n;
      }
      function xR(n) {
        return n = nt(n), n && wt.test(n) ? n.replace(Te, "\\$&") : n;
      }
      var DR = Eo(function(n, i, a) {
        return n + (a ? "-" : "") + i.toLowerCase();
      }), jR = Eo(function(n, i, a) {
        return n + (a ? " " : "") + i.toLowerCase();
      }), UR = qh("toLowerCase");
      function kR(n, i, a) {
        n = nt(n), i = We(i);
        var c = i ? go(n) : 0;
        if (!i || c >= i)
          return n;
        var y = (i - c) / 2;
        return Ha(Ca(y), a) + n + Ha(Oa(y), a);
      }
      function FR(n, i, a) {
        n = nt(n), i = We(i);
        var c = i ? go(n) : 0;
        return i && c < i ? n + Ha(i - c, a) : n;
      }
      function HR(n, i, a) {
        n = nt(n), i = We(i);
        var c = i ? go(n) : 0;
        return i && c < i ? Ha(i - c, a) + n : n;
      }
      function WR(n, i, a) {
        return a || i == null ? i = 0 : i && (i = +i), Yw(nt(n).replace(Rt, ""), i || 0);
      }
      function qR(n, i, a) {
        return (a ? sr(n, i, a) : i === r) ? i = 1 : i = We(i), Zf(nt(n), i);
      }
      function VR() {
        var n = arguments, i = nt(n[0]);
        return n.length < 3 ? i : i.replace(n[1], n[2]);
      }
      var GR = Eo(function(n, i, a) {
        return n + (a ? "_" : "") + i.toLowerCase();
      });
      function zR(n, i, a) {
        return a && typeof a != "number" && sr(n, i, a) && (i = a = r), a = a === r ? se : a >>> 0, a ? (n = nt(n), n && (typeof i == "string" || i != null && !El(i)) && (i = Sr(i), !i && ho(n)) ? _i(Qr(n), 0, a) : n.split(i, a)) : [];
      }
      var KR = Eo(function(n, i, a) {
        return n + (a ? " " : "") + Rl(i);
      });
      function JR(n, i, a) {
        return n = nt(n), a = a == null ? 0 : Ui(We(a), 0, n.length), i = Sr(i), n.slice(a, a + i.length) == i;
      }
      function YR(n, i, a) {
        var c = T.templateSettings;
        a && sr(n, i, a) && (i = r), n = nt(n), i = eu({}, i, c, Xh);
        var y = eu({}, i.imports, c.imports, Xh), L = Ut(y), k = Mf(y, L), G, Q, ge = 0, pe = i.interpolate || pn, we = "__p += '", Ae = Df(
          (i.escape || pn).source + "|" + pe.source + "|" + (pe === N ? Gt : pn).source + "|" + (i.evaluate || pn).source + "|$",
          "g"
        ), Pe = "//# sourceURL=" + (ot.call(i, "sourceURL") ? (i.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Tf + "]") + `
`;
        n.replace(Ae, function(xe, ze, Ze, Ar, ar, Tr) {
          return Ze || (Ze = Ar), we += n.slice(ge, Tr).replace(bn, Aw), ze && (G = !0, we += `' +
__e(` + ze + `) +
'`), ar && (Q = !0, we += `';
` + ar + `;
__p += '`), Ze && (we += `' +
((__t = (` + Ze + `)) == null ? '' : __t) +
'`), ge = Tr + xe.length, xe;
        }), we += `';
`;
        var Me = ot.call(i, "variable") && i.variable;
        if (!Me)
          we = `with (obj) {
` + we + `
}
`;
        else if (gn.test(Me))
          throw new ke(h);
        we = (Q ? we.replace(Yr, "") : we).replace(un, "$1").replace(fn, "$1;"), we = "function(" + (Me || "obj") + `) {
` + (Me ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (G ? ", __e = _.escape" : "") + (Q ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + we + `return __p
}`;
        var qe = Wg(function() {
          return et(L, Pe + "return " + we).apply(r, k);
        });
        if (qe.source = we, ml(qe))
          throw qe;
        return qe;
      }
      function XR(n) {
        return nt(n).toLowerCase();
      }
      function ZR(n) {
        return nt(n).toUpperCase();
      }
      function QR(n, i, a) {
        if (n = nt(n), n && (a || i === r))
          return Zd(n);
        if (!n || !(i = Sr(i)))
          return n;
        var c = Qr(n), y = Qr(i), L = Qd(c, y), k = eh(c, y) + 1;
        return _i(c, L, k).join("");
      }
      function e1(n, i, a) {
        if (n = nt(n), n && (a || i === r))
          return n.slice(0, rh(n) + 1);
        if (!n || !(i = Sr(i)))
          return n;
        var c = Qr(n), y = eh(c, Qr(i)) + 1;
        return _i(c, 0, y).join("");
      }
      function t1(n, i, a) {
        if (n = nt(n), n && (a || i === r))
          return n.replace(Rt, "");
        if (!n || !(i = Sr(i)))
          return n;
        var c = Qr(n), y = Qd(c, Qr(i));
        return _i(c, y).join("");
      }
      function r1(n, i) {
        var a = Se, c = me;
        if (Et(i)) {
          var y = "separator" in i ? i.separator : y;
          a = "length" in i ? We(i.length) : a, c = "omission" in i ? Sr(i.omission) : c;
        }
        n = nt(n);
        var L = n.length;
        if (ho(n)) {
          var k = Qr(n);
          L = k.length;
        }
        if (a >= L)
          return n;
        var G = a - go(c);
        if (G < 1)
          return c;
        var Q = k ? _i(k, 0, G).join("") : n.slice(0, G);
        if (y === r)
          return Q + c;
        if (k && (G += Q.length - G), El(y)) {
          if (n.slice(G).search(y)) {
            var ge, pe = Q;
            for (y.global || (y = Df(y.source, nt(Pr.exec(y)) + "g")), y.lastIndex = 0; ge = y.exec(pe); )
              var we = ge.index;
            Q = Q.slice(0, we === r ? G : we);
          }
        } else if (n.indexOf(Sr(y), G) != G) {
          var Ae = Q.lastIndexOf(y);
          Ae > -1 && (Q = Q.slice(0, Ae));
        }
        return Q + c;
      }
      function n1(n) {
        return n = nt(n), n && nr.test(n) ? n.replace(rr, Bw) : n;
      }
      var i1 = Eo(function(n, i, a) {
        return n + (a ? " " : "") + i.toUpperCase();
      }), Rl = qh("toUpperCase");
      function Hg(n, i, a) {
        return n = nt(n), i = a ? r : i, i === r ? Iw(n) ? Mw(n) : yw(n) : n.match(i) || [];
      }
      var Wg = Ve(function(n, i) {
        try {
          return Er(n, r, i);
        } catch (a) {
          return ml(a) ? a : new ke(a);
        }
      }), o1 = qn(function(n, i) {
        return Nr(i, function(a) {
          a = mn(a), Hn(n, a, yl(n[a], n));
        }), n;
      });
      function s1(n) {
        var i = n == null ? 0 : n.length, a = $e();
        return n = i ? mt(n, function(c) {
          if (typeof c[1] != "function")
            throw new $r(f);
          return [a(c[0]), c[1]];
        }) : [], Ve(function(c) {
          for (var y = -1; ++y < i; ) {
            var L = n[y];
            if (Er(L[0], this, c))
              return Er(L[1], this, c);
          }
        });
      }
      function a1(n) {
        return Bm(xr(n, w));
      }
      function Al(n) {
        return function() {
          return n;
        };
      }
      function u1(n, i) {
        return n == null || n !== n ? i : n;
      }
      var f1 = Gh(), l1 = Gh(!0);
      function pr(n) {
        return n;
      }
      function Tl(n) {
        return vh(typeof n == "function" ? n : xr(n, w));
      }
      function c1(n) {
        return Rh(xr(n, w));
      }
      function d1(n, i) {
        return Ah(n, xr(i, w));
      }
      var h1 = Ve(function(n, i) {
        return function(a) {
          return ls(a, n, i);
        };
      }), g1 = Ve(function(n, i) {
        return function(a) {
          return ls(n, a, i);
        };
      });
      function Il(n, i, a) {
        var c = Ut(i), y = Ma(i, c);
        a == null && !(Et(i) && (y.length || !c.length)) && (a = i, i = n, n = this, y = Ma(i, Ut(i)));
        var L = !(Et(a) && "chain" in a) || !!a.chain, k = Gn(n);
        return Nr(y, function(G) {
          var Q = i[G];
          n[G] = Q, k && (n.prototype[G] = function() {
            var ge = this.__chain__;
            if (L || ge) {
              var pe = n(this.__wrapped__), we = pe.__actions__ = dr(this.__actions__);
              return we.push({ func: Q, args: arguments, thisArg: n }), pe.__chain__ = ge, pe;
            }
            return Q.apply(n, ci([this.value()], arguments));
          });
        }), n;
      }
      function p1() {
        return De._ === this && (De._ = Fw), this;
      }
      function Ol() {
      }
      function b1(n) {
        return n = We(n), Ve(function(i) {
          return Th(i, n);
        });
      }
      var _1 = ol(mt), y1 = ol(zd), w1 = ol(Lf);
      function qg(n) {
        return dl(n) ? Pf(mn(n)) : Jm(n);
      }
      function m1(n) {
        return function(i) {
          return n == null ? r : ki(n, i);
        };
      }
      var E1 = Kh(), v1 = Kh(!0);
      function Cl() {
        return [];
      }
      function Ll() {
        return !1;
      }
      function S1() {
        return {};
      }
      function R1() {
        return "";
      }
      function A1() {
        return !0;
      }
      function T1(n, i) {
        if (n = We(n), n < 1 || n > re)
          return [];
        var a = se, c = Jt(n, se);
        i = $e(i), n -= se;
        for (var y = $f(c, i); ++a < n; )
          i(a);
        return y;
      }
      function I1(n) {
        return Fe(n) ? mt(n, mn) : Rr(n) ? [n] : dr(lg(nt(n)));
      }
      function O1(n) {
        var i = ++Uw;
        return nt(n) + i;
      }
      var C1 = Fa(function(n, i) {
        return n + i;
      }, 0), L1 = sl("ceil"), P1 = Fa(function(n, i) {
        return n / i;
      }, 1), B1 = sl("floor");
      function N1(n) {
        return n && n.length ? $a(n, pr, Vf) : r;
      }
      function $1(n, i) {
        return n && n.length ? $a(n, $e(i, 2), Vf) : r;
      }
      function M1(n) {
        return Yd(n, pr);
      }
      function x1(n, i) {
        return Yd(n, $e(i, 2));
      }
      function D1(n) {
        return n && n.length ? $a(n, pr, Jf) : r;
      }
      function j1(n, i) {
        return n && n.length ? $a(n, $e(i, 2), Jf) : r;
      }
      var U1 = Fa(function(n, i) {
        return n * i;
      }, 1), k1 = sl("round"), F1 = Fa(function(n, i) {
        return n - i;
      }, 0);
      function H1(n) {
        return n && n.length ? Nf(n, pr) : 0;
      }
      function W1(n, i) {
        return n && n.length ? Nf(n, $e(i, 2)) : 0;
      }
      return T.after = cS, T.ary = Eg, T.assign = ZS, T.assignIn = Mg, T.assignInWith = eu, T.assignWith = QS, T.at = eR, T.before = vg, T.bind = yl, T.bindAll = o1, T.bindKey = Sg, T.castArray = SS, T.chain = yg, T.chunk = BE, T.compact = NE, T.concat = $E, T.cond = s1, T.conforms = a1, T.constant = Al, T.countBy = Hv, T.create = tR, T.curry = Rg, T.curryRight = Ag, T.debounce = Tg, T.defaults = rR, T.defaultsDeep = nR, T.defer = dS, T.delay = hS, T.difference = ME, T.differenceBy = xE, T.differenceWith = DE, T.drop = jE, T.dropRight = UE, T.dropRightWhile = kE, T.dropWhile = FE, T.fill = HE, T.filter = qv, T.flatMap = zv, T.flatMapDeep = Kv, T.flatMapDepth = Jv, T.flatten = gg, T.flattenDeep = WE, T.flattenDepth = qE, T.flip = gS, T.flow = f1, T.flowRight = l1, T.fromPairs = VE, T.functions = lR, T.functionsIn = cR, T.groupBy = Yv, T.initial = zE, T.intersection = KE, T.intersectionBy = JE, T.intersectionWith = YE, T.invert = hR, T.invertBy = gR, T.invokeMap = Zv, T.iteratee = Tl, T.keyBy = Qv, T.keys = Ut, T.keysIn = gr, T.map = Ka, T.mapKeys = bR, T.mapValues = _R, T.matches = c1, T.matchesProperty = d1, T.memoize = Ya, T.merge = yR, T.mergeWith = xg, T.method = h1, T.methodOf = g1, T.mixin = Il, T.negate = Xa, T.nthArg = b1, T.omit = wR, T.omitBy = mR, T.once = pS, T.orderBy = eS, T.over = _1, T.overArgs = bS, T.overEvery = y1, T.overSome = w1, T.partial = wl, T.partialRight = Ig, T.partition = tS, T.pick = ER, T.pickBy = Dg, T.property = qg, T.propertyOf = m1, T.pull = ev, T.pullAll = bg, T.pullAllBy = tv, T.pullAllWith = rv, T.pullAt = nv, T.range = E1, T.rangeRight = v1, T.rearg = _S, T.reject = iS, T.remove = iv, T.rest = yS, T.reverse = bl, T.sampleSize = sS, T.set = SR, T.setWith = RR, T.shuffle = aS, T.slice = ov, T.sortBy = lS, T.sortedUniq = dv, T.sortedUniqBy = hv, T.split = zR, T.spread = wS, T.tail = gv, T.take = pv, T.takeRight = bv, T.takeRightWhile = _v, T.takeWhile = yv, T.tap = Nv, T.throttle = mS, T.thru = za, T.toArray = Bg, T.toPairs = jg, T.toPairsIn = Ug, T.toPath = I1, T.toPlainObject = $g, T.transform = AR, T.unary = ES, T.union = wv, T.unionBy = mv, T.unionWith = Ev, T.uniq = vv, T.uniqBy = Sv, T.uniqWith = Rv, T.unset = TR, T.unzip = _l, T.unzipWith = _g, T.update = IR, T.updateWith = OR, T.values = Ro, T.valuesIn = CR, T.without = Av, T.words = Hg, T.wrap = vS, T.xor = Tv, T.xorBy = Iv, T.xorWith = Ov, T.zip = Cv, T.zipObject = Lv, T.zipObjectDeep = Pv, T.zipWith = Bv, T.entries = jg, T.entriesIn = Ug, T.extend = Mg, T.extendWith = eu, Il(T, T), T.add = C1, T.attempt = Wg, T.camelCase = NR, T.capitalize = kg, T.ceil = L1, T.clamp = LR, T.clone = RS, T.cloneDeep = TS, T.cloneDeepWith = IS, T.cloneWith = AS, T.conformsTo = OS, T.deburr = Fg, T.defaultTo = u1, T.divide = P1, T.endsWith = $R, T.eq = tn, T.escape = MR, T.escapeRegExp = xR, T.every = Wv, T.find = Vv, T.findIndex = dg, T.findKey = iR, T.findLast = Gv, T.findLastIndex = hg, T.findLastKey = oR, T.floor = B1, T.forEach = wg, T.forEachRight = mg, T.forIn = sR, T.forInRight = aR, T.forOwn = uR, T.forOwnRight = fR, T.get = vl, T.gt = CS, T.gte = LS, T.has = dR, T.hasIn = Sl, T.head = pg, T.identity = pr, T.includes = Xv, T.indexOf = GE, T.inRange = PR, T.invoke = pR, T.isArguments = Wi, T.isArray = Fe, T.isArrayBuffer = PS, T.isArrayLike = hr, T.isArrayLikeObject = It, T.isBoolean = BS, T.isBuffer = yi, T.isDate = NS, T.isElement = $S, T.isEmpty = MS, T.isEqual = xS, T.isEqualWith = DS, T.isError = ml, T.isFinite = jS, T.isFunction = Gn, T.isInteger = Og, T.isLength = Za, T.isMap = Cg, T.isMatch = US, T.isMatchWith = kS, T.isNaN = FS, T.isNative = HS, T.isNil = qS, T.isNull = WS, T.isNumber = Lg, T.isObject = Et, T.isObjectLike = At, T.isPlainObject = bs, T.isRegExp = El, T.isSafeInteger = VS, T.isSet = Pg, T.isString = Qa, T.isSymbol = Rr, T.isTypedArray = So, T.isUndefined = GS, T.isWeakMap = zS, T.isWeakSet = KS, T.join = XE, T.kebabCase = DR, T.last = jr, T.lastIndexOf = ZE, T.lowerCase = jR, T.lowerFirst = UR, T.lt = JS, T.lte = YS, T.max = N1, T.maxBy = $1, T.mean = M1, T.meanBy = x1, T.min = D1, T.minBy = j1, T.stubArray = Cl, T.stubFalse = Ll, T.stubObject = S1, T.stubString = R1, T.stubTrue = A1, T.multiply = U1, T.nth = QE, T.noConflict = p1, T.noop = Ol, T.now = Ja, T.pad = kR, T.padEnd = FR, T.padStart = HR, T.parseInt = WR, T.random = BR, T.reduce = rS, T.reduceRight = nS, T.repeat = qR, T.replace = VR, T.result = vR, T.round = k1, T.runInContext = X, T.sample = oS, T.size = uS, T.snakeCase = GR, T.some = fS, T.sortedIndex = sv, T.sortedIndexBy = av, T.sortedIndexOf = uv, T.sortedLastIndex = fv, T.sortedLastIndexBy = lv, T.sortedLastIndexOf = cv, T.startCase = KR, T.startsWith = JR, T.subtract = F1, T.sum = H1, T.sumBy = W1, T.template = YR, T.times = T1, T.toFinite = zn, T.toInteger = We, T.toLength = Ng, T.toLower = XR, T.toNumber = Ur, T.toSafeInteger = XS, T.toString = nt, T.toUpper = ZR, T.trim = QR, T.trimEnd = e1, T.trimStart = t1, T.truncate = r1, T.unescape = n1, T.uniqueId = O1, T.upperCase = i1, T.upperFirst = Rl, T.each = wg, T.eachRight = mg, T.first = pg, Il(T, function() {
        var n = {};
        return yn(T, function(i, a) {
          ot.call(T.prototype, a) || (n[a] = i);
        }), n;
      }(), { chain: !1 }), T.VERSION = o, Nr(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(n) {
        T[n].placeholder = T;
      }), Nr(["drop", "take"], function(n, i) {
        Je.prototype[n] = function(a) {
          a = a === r ? 1 : xt(We(a), 0);
          var c = this.__filtered__ && !i ? new Je(this) : this.clone();
          return c.__filtered__ ? c.__takeCount__ = Jt(a, c.__takeCount__) : c.__views__.push({
            size: Jt(a, se),
            type: n + (c.__dir__ < 0 ? "Right" : "")
          }), c;
        }, Je.prototype[n + "Right"] = function(a) {
          return this.reverse()[n](a).reverse();
        };
      }), Nr(["filter", "map", "takeWhile"], function(n, i) {
        var a = i + 1, c = a == $ || a == J;
        Je.prototype[n] = function(y) {
          var L = this.clone();
          return L.__iteratees__.push({
            iteratee: $e(y, 3),
            type: a
          }), L.__filtered__ = L.__filtered__ || c, L;
        };
      }), Nr(["head", "last"], function(n, i) {
        var a = "take" + (i ? "Right" : "");
        Je.prototype[n] = function() {
          return this[a](1).value()[0];
        };
      }), Nr(["initial", "tail"], function(n, i) {
        var a = "drop" + (i ? "" : "Right");
        Je.prototype[n] = function() {
          return this.__filtered__ ? new Je(this) : this[a](1);
        };
      }), Je.prototype.compact = function() {
        return this.filter(pr);
      }, Je.prototype.find = function(n) {
        return this.filter(n).head();
      }, Je.prototype.findLast = function(n) {
        return this.reverse().find(n);
      }, Je.prototype.invokeMap = Ve(function(n, i) {
        return typeof n == "function" ? new Je(this) : this.map(function(a) {
          return ls(a, n, i);
        });
      }), Je.prototype.reject = function(n) {
        return this.filter(Xa($e(n)));
      }, Je.prototype.slice = function(n, i) {
        n = We(n);
        var a = this;
        return a.__filtered__ && (n > 0 || i < 0) ? new Je(a) : (n < 0 ? a = a.takeRight(-n) : n && (a = a.drop(n)), i !== r && (i = We(i), a = i < 0 ? a.dropRight(-i) : a.take(i - n)), a);
      }, Je.prototype.takeRightWhile = function(n) {
        return this.reverse().takeWhile(n).reverse();
      }, Je.prototype.toArray = function() {
        return this.take(se);
      }, yn(Je.prototype, function(n, i) {
        var a = /^(?:filter|find|map|reject)|While$/.test(i), c = /^(?:head|last)$/.test(i), y = T[c ? "take" + (i == "last" ? "Right" : "") : i], L = c || /^find/.test(i);
        y && (T.prototype[i] = function() {
          var k = this.__wrapped__, G = c ? [1] : arguments, Q = k instanceof Je, ge = G[0], pe = Q || Fe(k), we = function(ze) {
            var Ze = y.apply(T, ci([ze], G));
            return c && Ae ? Ze[0] : Ze;
          };
          pe && a && typeof ge == "function" && ge.length != 1 && (Q = pe = !1);
          var Ae = this.__chain__, Pe = !!this.__actions__.length, Me = L && !Ae, qe = Q && !Pe;
          if (!L && pe) {
            k = qe ? k : new Je(this);
            var xe = n.apply(k, G);
            return xe.__actions__.push({ func: za, args: [we], thisArg: r }), new Mr(xe, Ae);
          }
          return Me && qe ? n.apply(this, G) : (xe = this.thru(we), Me ? c ? xe.value()[0] : xe.value() : xe);
        });
      }), Nr(["pop", "push", "shift", "sort", "splice", "unshift"], function(n) {
        var i = wa[n], a = /^(?:push|sort|unshift)$/.test(n) ? "tap" : "thru", c = /^(?:pop|shift)$/.test(n);
        T.prototype[n] = function() {
          var y = arguments;
          if (c && !this.__chain__) {
            var L = this.value();
            return i.apply(Fe(L) ? L : [], y);
          }
          return this[a](function(k) {
            return i.apply(Fe(k) ? k : [], y);
          });
        };
      }), yn(Je.prototype, function(n, i) {
        var a = T[i];
        if (a) {
          var c = a.name + "";
          ot.call(yo, c) || (yo[c] = []), yo[c].push({ name: i, func: a });
        }
      }), yo[ka(r, B).name] = [{
        name: "wrapper",
        func: r
      }], Je.prototype.clone = nm, Je.prototype.reverse = im, Je.prototype.value = om, T.prototype.at = $v, T.prototype.chain = Mv, T.prototype.commit = xv, T.prototype.next = Dv, T.prototype.plant = Uv, T.prototype.reverse = kv, T.prototype.toJSON = T.prototype.valueOf = T.prototype.value = Fv, T.prototype.first = T.prototype.head, ns && (T.prototype[ns] = jv), T;
    }, po = xw();
    $t ? (($t.exports = po)._ = po, at._ = po) : De._ = po;
  }).call(Ye);
})(Cu, Cu.exports);
Cu.exports;
NA();
const Ss = {
  IFRAME_STATUS: "iframe_status",
  // Tell embed to create the window
  CREATE_WINDOW: "create_window",
  // Tell embed to close the window
  CLOSE_WINDOW: "close_window",
  USER_LOGGED_IN: "user_logged_in",
  USER_LOGGED_OUT: "user_logged_out"
}, Sn = {
  LOGOUT: "logout",
  WALLET_INSTANCE_ID: "wallet_instance_id",
  USER_INFO: "user_info",
  SET_PROVIDER: "set_provider",
  TOPUP: "topup",
  IFRAME_STATUS: "iframe_status",
  // embed has opened the window as requested
  OPENED_WINDOW: "opened_window",
  // user has closed the window from embed's side
  CLOSED_WINDOW: "closed_window",
  GET_PROVIDER_STATE: "get_provider_state",
  LOGIN_WITH_PRIVATE_KEY: "login_with_private_key"
}, EB = {
  GET_PROVIDER_STATE: "wallet_get_provider_state"
}, dc = {
  ACCOUNTS_CHANGED: "wallet_accounts_changed",
  CHAIN_CHANGED: "wallet_chain_changed",
  UNLOCK_STATE_CHANGED: "wallet_unlock_state_changed"
};
function vB(e) {
  return function(r, o, s) {
    s((u) => {
      o.error && Iu.warn(`Error in RPC response:
`, o), !r.isTorusInternal && (Iu.info(`RPC (${e.origin}):`, r, "->", o), u());
    });
  };
}
var Ib;
(function(e) {
  e.approved = "approved", e.cancelled = "cancelled", e.confirmed = "confirmed", e.failed = "failed", e.finalized = "finalized", e.processed = "processed", e.rejected = "rejected", e.signed = "signed", e.submitted = "submitted", e.unapproved = "unapproved", e.dropped = "dropped", e.expired = "expired";
})(Ib || (Ib = {}));
var zc = { exports: {} }, X0 = Pn.EventEmitter, hc, Ob;
function SB() {
  if (Ob) return hc;
  Ob = 1;
  function e(x, v) {
    var C = Object.keys(x);
    if (Object.getOwnPropertySymbols) {
      var B = Object.getOwnPropertySymbols(x);
      v && (B = B.filter(function(P) {
        return Object.getOwnPropertyDescriptor(x, P).enumerable;
      })), C.push.apply(C, B);
    }
    return C;
  }
  function t(x) {
    for (var v = 1; v < arguments.length; v++) {
      var C = arguments[v] != null ? arguments[v] : {};
      v % 2 ? e(Object(C), !0).forEach(function(B) {
        r(x, B, C[B]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(x, Object.getOwnPropertyDescriptors(C)) : e(Object(C)).forEach(function(B) {
        Object.defineProperty(x, B, Object.getOwnPropertyDescriptor(C, B));
      });
    }
    return x;
  }
  function r(x, v, C) {
    return v = f(v), v in x ? Object.defineProperty(x, v, { value: C, enumerable: !0, configurable: !0, writable: !0 }) : x[v] = C, x;
  }
  function o(x, v) {
    if (!(x instanceof v))
      throw new TypeError("Cannot call a class as a function");
  }
  function s(x, v) {
    for (var C = 0; C < v.length; C++) {
      var B = v[C];
      B.enumerable = B.enumerable || !1, B.configurable = !0, "value" in B && (B.writable = !0), Object.defineProperty(x, f(B.key), B);
    }
  }
  function u(x, v, C) {
    return v && s(x.prototype, v), Object.defineProperty(x, "prototype", { writable: !1 }), x;
  }
  function f(x) {
    var v = h(x, "string");
    return typeof v == "symbol" ? v : String(v);
  }
  function h(x, v) {
    if (typeof x != "object" || x === null) return x;
    var C = x[Symbol.toPrimitive];
    if (C !== void 0) {
      var B = C.call(x, v);
      if (typeof B != "object") return B;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(x);
  }
  var l = _r, p = l.Buffer, b = ks, w = b.inspect, I = w && w.custom || "inspect";
  function A(x, v, C) {
    p.prototype.copy.call(x, v, C);
  }
  return hc = /* @__PURE__ */ function() {
    function x() {
      o(this, x), this.head = null, this.tail = null, this.length = 0;
    }
    return u(x, [{
      key: "push",
      value: function(C) {
        var B = {
          data: C,
          next: null
        };
        this.length > 0 ? this.tail.next = B : this.head = B, this.tail = B, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(C) {
        var B = {
          data: C,
          next: this.head
        };
        this.length === 0 && (this.tail = B), this.head = B, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var C = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, C;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(C) {
        if (this.length === 0) return "";
        for (var B = this.head, P = "" + B.data; B = B.next; ) P += C + B.data;
        return P;
      }
    }, {
      key: "concat",
      value: function(C) {
        if (this.length === 0) return p.alloc(0);
        for (var B = p.allocUnsafe(C >>> 0), P = this.head, S = 0; P; )
          A(P.data, B, S), S += P.data.length, P = P.next;
        return B;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(C, B) {
        var P;
        return C < this.head.data.length ? (P = this.head.data.slice(0, C), this.head.data = this.head.data.slice(C)) : C === this.head.data.length ? P = this.shift() : P = B ? this._getString(C) : this._getBuffer(C), P;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(C) {
        var B = this.head, P = 1, S = B.data;
        for (C -= S.length; B = B.next; ) {
          var m = B.data, j = C > m.length ? m.length : C;
          if (j === m.length ? S += m : S += m.slice(0, C), C -= j, C === 0) {
            j === m.length ? (++P, B.next ? this.head = B.next : this.head = this.tail = null) : (this.head = B, B.data = m.slice(j));
            break;
          }
          ++P;
        }
        return this.length -= P, S;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(C) {
        var B = p.allocUnsafe(C), P = this.head, S = 1;
        for (P.data.copy(B), C -= P.data.length; P = P.next; ) {
          var m = P.data, j = C > m.length ? m.length : C;
          if (m.copy(B, B.length - C, 0, j), C -= j, C === 0) {
            j === m.length ? (++S, P.next ? this.head = P.next : this.head = this.tail = null) : (this.head = P, P.data = m.slice(j));
            break;
          }
          ++S;
        }
        return this.length -= S, B;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: I,
      value: function(C, B) {
        return w(this, t(t({}, B), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), x;
  }(), hc;
}
function RB(e, t) {
  var r = this, o = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
  return o || s ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, le.process.nextTick(Kc, this, e)) : le.process.nextTick(Kc, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(u) {
    !t && u ? r._writableState ? r._writableState.errorEmitted ? le.process.nextTick(_u, r) : (r._writableState.errorEmitted = !0, le.process.nextTick(Cb, r, u)) : le.process.nextTick(Cb, r, u) : t ? (le.process.nextTick(_u, r), t(u)) : le.process.nextTick(_u, r);
  }), this);
}
function Cb(e, t) {
  Kc(e, t), _u(e);
}
function _u(e) {
  e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
}
function AB() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function Kc(e, t) {
  e.emit("error", t);
}
function TB(e, t) {
  var r = e._readableState, o = e._writableState;
  r && r.autoDestroy || o && o.autoDestroy ? e.destroy(t) : e.emit("error", t);
}
var Z0 = {
  destroy: RB,
  undestroy: AB,
  errorOrDestroy: TB
}, so = {};
function IB(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
var Q0 = {};
function Kr(e, t, r) {
  r || (r = Error);
  function o(u, f, h) {
    return typeof t == "string" ? t : t(u, f, h);
  }
  var s = /* @__PURE__ */ function(u) {
    IB(f, u);
    function f(h, l, p) {
      return u.call(this, o(h, l, p)) || this;
    }
    return f;
  }(r);
  s.prototype.name = r.name, s.prototype.code = e, Q0[e] = s;
}
function Lb(e, t) {
  if (Array.isArray(e)) {
    var r = e.length;
    return e = e.map(function(o) {
      return String(o);
    }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
  } else
    return "of ".concat(t, " ").concat(String(e));
}
function OB(e, t, r) {
  return e.substr(0, t.length) === t;
}
function CB(e, t, r) {
  return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
}
function LB(e, t, r) {
  return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
}
Kr("ERR_INVALID_OPT_VALUE", function(e, t) {
  return 'The value "' + t + '" is invalid for option "' + e + '"';
}, TypeError);
Kr("ERR_INVALID_ARG_TYPE", function(e, t, r) {
  var o;
  typeof t == "string" && OB(t, "not ") ? (o = "must not be", t = t.replace(/^not /, "")) : o = "must be";
  var s;
  if (CB(e, " argument"))
    s = "The ".concat(e, " ").concat(o, " ").concat(Lb(t, "type"));
  else {
    var u = LB(e, ".") ? "property" : "argument";
    s = 'The "'.concat(e, '" ').concat(u, " ").concat(o, " ").concat(Lb(t, "type"));
  }
  return s += ". Received type ".concat(typeof r), s;
}, TypeError);
Kr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
Kr("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
  return "The " + e + " method is not implemented";
});
Kr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
Kr("ERR_STREAM_DESTROYED", function(e) {
  return "Cannot call " + e + " after a stream was destroyed";
});
Kr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
Kr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
Kr("ERR_STREAM_WRITE_AFTER_END", "write after end");
Kr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Kr("ERR_UNKNOWN_ENCODING", function(e) {
  return "Unknown encoding: " + e;
}, TypeError);
Kr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
so.codes = Q0;
var PB = so.codes.ERR_INVALID_OPT_VALUE;
function BB(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function NB(e, t, r, o) {
  var s = BB(t, o, r);
  if (s != null) {
    if (!(isFinite(s) && Math.floor(s) === s) || s < 0) {
      var u = o ? r : "highWaterMark";
      throw new PB(u, s);
    }
    return Math.floor(s);
  }
  return e.objectMode ? 16 : 16 * 1024;
}
var ew = {
  getHighWaterMark: NB
}, gc, Pb;
function tw() {
  if (Pb) return gc;
  Pb = 1, gc = ae;
  function e(R) {
    var O = this;
    this.next = null, this.entry = null, this.finish = function() {
      be(O, R);
    };
  }
  var t;
  ae.WritableState = Z;
  var r = {
    deprecate: Zb()
  }, o = X0, s = _r.Buffer, u = (typeof Ye < "u" ? Ye : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function f(R) {
    return s.from(R);
  }
  function h(R) {
    return s.isBuffer(R) || R instanceof u;
  }
  var l = Z0, p = ew, b = p.getHighWaterMark, w = so.codes, I = w.ERR_INVALID_ARG_TYPE, A = w.ERR_METHOD_NOT_IMPLEMENTED, x = w.ERR_MULTIPLE_CALLBACK, v = w.ERR_STREAM_CANNOT_PIPE, C = w.ERR_STREAM_DESTROYED, B = w.ERR_STREAM_NULL_VALUES, P = w.ERR_STREAM_WRITE_AFTER_END, S = w.ERR_UNKNOWN_ENCODING, m = l.errorOrDestroy;
  Bn(ae, o);
  function j() {
  }
  function Z(R, O, W) {
    t = t || Fo(), R = R || {}, typeof W != "boolean" && (W = O instanceof t), this.objectMode = !!R.objectMode, W && (this.objectMode = this.objectMode || !!R.writableObjectMode), this.highWaterMark = b(this, R, "writableHighWaterMark", W), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ie = R.decodeStrings === !1;
    this.decodeStrings = !ie, this.defaultEncoding = R.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ye) {
      J(O, ye);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = R.emitClose !== !1, this.autoDestroy = !!R.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  Z.prototype.getBuffer = function() {
    for (var O = this.bufferedRequest, W = []; O; )
      W.push(O), O = O.next;
    return W;
  }, function() {
    try {
      Object.defineProperty(Z.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ce;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ce = Function.prototype[Symbol.hasInstance], Object.defineProperty(ae, Symbol.hasInstance, {
    value: function(O) {
      return ce.call(this, O) ? !0 : this !== ae ? !1 : O && O._writableState instanceof Z;
    }
  })) : ce = function(O) {
    return O instanceof this;
  };
  function ae(R) {
    t = t || Fo();
    var O = this instanceof t;
    if (!O && !ce.call(ae, this)) return new ae(R);
    this._writableState = new Z(R, this, O), this.writable = !0, R && (typeof R.write == "function" && (this._write = R.write), typeof R.writev == "function" && (this._writev = R.writev), typeof R.destroy == "function" && (this._destroy = R.destroy), typeof R.final == "function" && (this._final = R.final)), o.call(this);
  }
  ae.prototype.pipe = function() {
    m(this, new v());
  };
  function ee(R, O) {
    var W = new P();
    m(R, W), le.process.nextTick(O, W);
  }
  function Se(R, O, W, ie) {
    var ye;
    return W === null ? ye = new B() : typeof W != "string" && !O.objectMode && (ye = new I("chunk", ["string", "Buffer"], W)), ye ? (m(R, ye), le.process.nextTick(ie, ye), !1) : !0;
  }
  ae.prototype.write = function(R, O, W) {
    var ie = this._writableState, ye = !1, d = !ie.objectMode && h(R);
    return d && !s.isBuffer(R) && (R = f(R)), typeof O == "function" && (W = O, O = null), d ? O = "buffer" : O || (O = ie.defaultEncoding), typeof W != "function" && (W = j), ie.ending ? ee(this, W) : (d || Se(this, ie, R, W)) && (ie.pendingcb++, ye = F(this, ie, d, R, O, W)), ye;
  }, ae.prototype.cork = function() {
    this._writableState.corked++;
  }, ae.prototype.uncork = function() {
    var R = this._writableState;
    R.corked && (R.corked--, !R.writing && !R.corked && !R.bufferProcessing && R.bufferedRequest && H(this, R));
  }, ae.prototype.setDefaultEncoding = function(O) {
    if (typeof O == "string" && (O = O.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((O + "").toLowerCase()) > -1)) throw new S(O);
    return this._writableState.defaultEncoding = O, this;
  }, Object.defineProperty(ae.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function me(R, O, W) {
    return !R.objectMode && R.decodeStrings !== !1 && typeof O == "string" && (O = s.from(O, W)), O;
  }
  Object.defineProperty(ae.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function F(R, O, W, ie, ye, d) {
    if (!W) {
      var g = me(O, ie, ye);
      ie !== g && (W = !0, ye = "buffer", ie = g);
    }
    var _ = O.objectMode ? 1 : ie.length;
    O.length += _;
    var E = O.length < O.highWaterMark;
    if (E || (O.needDrain = !0), O.writing || O.corked) {
      var K = O.lastBufferedRequest;
      O.lastBufferedRequest = {
        chunk: ie,
        encoding: ye,
        isBuf: W,
        callback: d,
        next: null
      }, K ? K.next = O.lastBufferedRequest : O.bufferedRequest = O.lastBufferedRequest, O.bufferedRequestCount += 1;
    } else
      U(R, O, !1, _, ie, ye, d);
    return E;
  }
  function U(R, O, W, ie, ye, d, g) {
    O.writelen = ie, O.writecb = g, O.writing = !0, O.sync = !0, O.destroyed ? O.onwrite(new C("write")) : W ? R._writev(ye, O.onwrite) : R._write(ye, d, O.onwrite), O.sync = !1;
  }
  function $(R, O, W, ie, ye) {
    --O.pendingcb, W ? (le.process.nextTick(ye, ie), le.process.nextTick(te, R, O), R._writableState.errorEmitted = !0, m(R, ie)) : (ye(ie), R._writableState.errorEmitted = !0, m(R, ie), te(R, O));
  }
  function q(R) {
    R.writing = !1, R.writecb = null, R.length -= R.writelen, R.writelen = 0;
  }
  function J(R, O) {
    var W = R._writableState, ie = W.sync, ye = W.writecb;
    if (typeof ye != "function") throw new x();
    if (q(W), O) $(R, W, ie, O, ye);
    else {
      var d = z(W) || R.destroyed;
      !d && !W.corked && !W.bufferProcessing && W.bufferedRequest && H(R, W), ie ? le.process.nextTick(V, R, W, d, ye) : V(R, W, d, ye);
    }
  }
  function V(R, O, W, ie) {
    W || re(R, O), O.pendingcb--, ie(), te(R, O);
  }
  function re(R, O) {
    O.length === 0 && O.needDrain && (O.needDrain = !1, R.emit("drain"));
  }
  function H(R, O) {
    O.bufferProcessing = !0;
    var W = O.bufferedRequest;
    if (R._writev && W && W.next) {
      var ie = O.bufferedRequestCount, ye = new Array(ie), d = O.corkedRequestsFree;
      d.entry = W;
      for (var g = 0, _ = !0; W; )
        ye[g] = W, W.isBuf || (_ = !1), W = W.next, g += 1;
      ye.allBuffers = _, U(R, O, !0, O.length, ye, "", d.finish), O.pendingcb++, O.lastBufferedRequest = null, d.next ? (O.corkedRequestsFree = d.next, d.next = null) : O.corkedRequestsFree = new e(O), O.bufferedRequestCount = 0;
    } else {
      for (; W; ) {
        var E = W.chunk, K = W.encoding, ne = W.callback, oe = O.objectMode ? 1 : E.length;
        if (U(R, O, !1, oe, E, K, ne), W = W.next, O.bufferedRequestCount--, O.writing)
          break;
      }
      W === null && (O.lastBufferedRequest = null);
    }
    O.bufferedRequest = W, O.bufferProcessing = !1;
  }
  ae.prototype._write = function(R, O, W) {
    W(new A("_write()"));
  }, ae.prototype._writev = null, ae.prototype.end = function(R, O, W) {
    var ie = this._writableState;
    return typeof R == "function" ? (W = R, R = null, O = null) : typeof O == "function" && (W = O, O = null), R != null && this.write(R, O), ie.corked && (ie.corked = 1, this.uncork()), ie.ending || _e(this, ie, W), this;
  }, Object.defineProperty(ae.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function z(R) {
    return R.ending && R.length === 0 && R.bufferedRequest === null && !R.finished && !R.writing;
  }
  function se(R, O) {
    R._final(function(W) {
      O.pendingcb--, W && m(R, W), O.prefinished = !0, R.emit("prefinish"), te(R, O);
    });
  }
  function de(R, O) {
    !O.prefinished && !O.finalCalled && (typeof R._final == "function" && !O.destroyed ? (O.pendingcb++, O.finalCalled = !0, le.process.nextTick(se, R, O)) : (O.prefinished = !0, R.emit("prefinish")));
  }
  function te(R, O) {
    var W = z(O);
    if (W && (de(R, O), O.pendingcb === 0 && (O.finished = !0, R.emit("finish"), O.autoDestroy))) {
      var ie = R._readableState;
      (!ie || ie.autoDestroy && ie.endEmitted) && R.destroy();
    }
    return W;
  }
  function _e(R, O, W) {
    O.ending = !0, te(R, O), W && (O.finished ? le.process.nextTick(W) : R.once("finish", W)), O.ended = !0, R.writable = !1;
  }
  function be(R, O, W) {
    var ie = R.entry;
    for (R.entry = null; ie; ) {
      var ye = ie.callback;
      O.pendingcb--, ye(W), ie = ie.next;
    }
    O.corkedRequestsFree.next = R;
  }
  return Object.defineProperty(ae.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(O) {
      this._writableState && (this._writableState.destroyed = O);
    }
  }), ae.prototype.destroy = l.destroy, ae.prototype._undestroy = l.undestroy, ae.prototype._destroy = function(R, O) {
    O(R);
  }, gc;
}
var pc, Bb;
function Fo() {
  if (Bb) return pc;
  Bb = 1;
  var e = Object.keys || function(p) {
    var b = [];
    for (var w in p) b.push(w);
    return b;
  };
  pc = f;
  var t = nw(), r = tw();
  Bn(f, t);
  for (var o = e(r.prototype), s = 0; s < o.length; s++) {
    var u = o[s];
    f.prototype[u] || (f.prototype[u] = r.prototype[u]);
  }
  function f(p) {
    if (!(this instanceof f)) return new f(p);
    t.call(this, p), r.call(this, p), this.allowHalfOpen = !0, p && (p.readable === !1 && (this.readable = !1), p.writable === !1 && (this.writable = !1), p.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", h)));
  }
  Object.defineProperty(f.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(f.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(f.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function h() {
    this._writableState.ended || le.process.nextTick(l, this);
  }
  function l(p) {
    p.end();
  }
  return Object.defineProperty(f.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(b) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = b, this._writableState.destroyed = b);
    }
  }), pc;
}
var Nb = so.codes.ERR_STREAM_PREMATURE_CLOSE;
function $B(e) {
  var t = !1;
  return function() {
    if (!t) {
      t = !0;
      for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++)
        o[s] = arguments[s];
      e.apply(this, o);
    }
  };
}
function MB() {
}
function xB(e) {
  return e.setHeader && typeof e.abort == "function";
}
function rw(e, t, r) {
  if (typeof t == "function") return rw(e, null, t);
  t || (t = {}), r = $B(r || MB);
  var o = t.readable || t.readable !== !1 && e.readable, s = t.writable || t.writable !== !1 && e.writable, u = function() {
    e.writable || h();
  }, f = e._writableState && e._writableState.finished, h = function() {
    s = !1, f = !0, o || r.call(e);
  }, l = e._readableState && e._readableState.endEmitted, p = function() {
    o = !1, l = !0, s || r.call(e);
  }, b = function(x) {
    r.call(e, x);
  }, w = function() {
    var x;
    if (o && !l)
      return (!e._readableState || !e._readableState.ended) && (x = new Nb()), r.call(e, x);
    if (s && !f)
      return (!e._writableState || !e._writableState.ended) && (x = new Nb()), r.call(e, x);
  }, I = function() {
    e.req.on("finish", h);
  };
  return xB(e) ? (e.on("complete", h), e.on("abort", w), e.req ? I() : e.on("request", I)) : s && !e._writableState && (e.on("end", u), e.on("close", u)), e.on("end", p), e.on("finish", h), t.error !== !1 && e.on("error", b), e.on("close", w), function() {
    e.removeListener("complete", h), e.removeListener("abort", w), e.removeListener("request", I), e.req && e.req.removeListener("finish", h), e.removeListener("end", u), e.removeListener("close", u), e.removeListener("finish", h), e.removeListener("end", p), e.removeListener("error", b), e.removeListener("close", w);
  };
}
var jd = rw, bc, $b;
function DB() {
  if ($b) return bc;
  $b = 1;
  var e;
  function t(S, m, j) {
    return m = r(m), m in S ? Object.defineProperty(S, m, { value: j, enumerable: !0, configurable: !0, writable: !0 }) : S[m] = j, S;
  }
  function r(S) {
    var m = o(S, "string");
    return typeof m == "symbol" ? m : String(m);
  }
  function o(S, m) {
    if (typeof S != "object" || S === null) return S;
    var j = S[Symbol.toPrimitive];
    if (j !== void 0) {
      var Z = j.call(S, m);
      if (typeof Z != "object") return Z;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (m === "string" ? String : Number)(S);
  }
  var s = jd, u = Symbol("lastResolve"), f = Symbol("lastReject"), h = Symbol("error"), l = Symbol("ended"), p = Symbol("lastPromise"), b = Symbol("handlePromise"), w = Symbol("stream");
  function I(S, m) {
    return {
      value: S,
      done: m
    };
  }
  function A(S) {
    var m = S[u];
    if (m !== null) {
      var j = S[w].read();
      j !== null && (S[p] = null, S[u] = null, S[f] = null, m(I(j, !1)));
    }
  }
  function x(S) {
    le.process.nextTick(A, S);
  }
  function v(S, m) {
    return function(j, Z) {
      S.then(function() {
        if (m[l]) {
          j(I(void 0, !0));
          return;
        }
        m[b](j, Z);
      }, Z);
    };
  }
  var C = Object.getPrototypeOf(function() {
  }), B = Object.setPrototypeOf((e = {
    get stream() {
      return this[w];
    },
    next: function() {
      var m = this, j = this[h];
      if (j !== null)
        return Promise.reject(j);
      if (this[l])
        return Promise.resolve(I(void 0, !0));
      if (this[w].destroyed)
        return new Promise(function(ee, Se) {
          le.process.nextTick(function() {
            m[h] ? Se(m[h]) : ee(I(void 0, !0));
          });
        });
      var Z = this[p], ce;
      if (Z)
        ce = new Promise(v(Z, this));
      else {
        var ae = this[w].read();
        if (ae !== null)
          return Promise.resolve(I(ae, !1));
        ce = new Promise(this[b]);
      }
      return this[p] = ce, ce;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var m = this;
    return new Promise(function(j, Z) {
      m[w].destroy(null, function(ce) {
        if (ce) {
          Z(ce);
          return;
        }
        j(I(void 0, !0));
      });
    });
  }), e), C), P = function(m) {
    var j, Z = Object.create(B, (j = {}, t(j, w, {
      value: m,
      writable: !0
    }), t(j, u, {
      value: null,
      writable: !0
    }), t(j, f, {
      value: null,
      writable: !0
    }), t(j, h, {
      value: null,
      writable: !0
    }), t(j, l, {
      value: m._readableState.endEmitted,
      writable: !0
    }), t(j, b, {
      value: function(ae, ee) {
        var Se = Z[w].read();
        Se ? (Z[p] = null, Z[u] = null, Z[f] = null, ae(I(Se, !1))) : (Z[u] = ae, Z[f] = ee);
      },
      writable: !0
    }), j));
    return Z[p] = null, s(m, function(ce) {
      if (ce && ce.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var ae = Z[f];
        ae !== null && (Z[p] = null, Z[u] = null, Z[f] = null, ae(ce)), Z[h] = ce;
        return;
      }
      var ee = Z[u];
      ee !== null && (Z[p] = null, Z[u] = null, Z[f] = null, ee(I(void 0, !0))), Z[l] = !0;
    }), m.on("readable", x.bind(null, Z)), Z;
  };
  return bc = P, bc;
}
var _c, Mb;
function jB() {
  return Mb || (Mb = 1, _c = function() {
    throw new Error("Readable.from is not available in the browser");
  }), _c;
}
var yc, xb;
function nw() {
  if (xb) return yc;
  xb = 1, yc = ee;
  var e;
  ee.ReadableState = ae, Pn.EventEmitter;
  var t = function(g, _) {
    return g.listeners(_).length;
  }, r = X0, o = _r.Buffer, s = (typeof Ye < "u" ? Ye : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function u(d) {
    return o.from(d);
  }
  function f(d) {
    return o.isBuffer(d) || d instanceof s;
  }
  var h = ks, l;
  h && h.debuglog ? l = h.debuglog("stream") : l = function() {
  };
  var p = SB(), b = Z0, w = ew, I = w.getHighWaterMark, A = so.codes, x = A.ERR_INVALID_ARG_TYPE, v = A.ERR_STREAM_PUSH_AFTER_EOF, C = A.ERR_METHOD_NOT_IMPLEMENTED, B = A.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, P, S, m;
  Bn(ee, r);
  var j = b.errorOrDestroy, Z = ["error", "close", "destroy", "pause", "resume"];
  function ce(d, g, _) {
    if (typeof d.prependListener == "function") return d.prependListener(g, _);
    !d._events || !d._events[g] ? d.on(g, _) : Array.isArray(d._events[g]) ? d._events[g].unshift(_) : d._events[g] = [_, d._events[g]];
  }
  function ae(d, g, _) {
    e = e || Fo(), d = d || {}, typeof _ != "boolean" && (_ = g instanceof e), this.objectMode = !!d.objectMode, _ && (this.objectMode = this.objectMode || !!d.readableObjectMode), this.highWaterMark = I(this, d, "readableHighWaterMark", _), this.buffer = new p(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = d.emitClose !== !1, this.autoDestroy = !!d.autoDestroy, this.destroyed = !1, this.defaultEncoding = d.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, d.encoding && (P || (P = Ls().StringDecoder), this.decoder = new P(d.encoding), this.encoding = d.encoding);
  }
  function ee(d) {
    if (e = e || Fo(), !(this instanceof ee)) return new ee(d);
    var g = this instanceof e;
    this._readableState = new ae(d, this, g), this.readable = !0, d && (typeof d.read == "function" && (this._read = d.read), typeof d.destroy == "function" && (this._destroy = d.destroy)), r.call(this);
  }
  Object.defineProperty(ee.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(g) {
      this._readableState && (this._readableState.destroyed = g);
    }
  }), ee.prototype.destroy = b.destroy, ee.prototype._undestroy = b.undestroy, ee.prototype._destroy = function(d, g) {
    g(d);
  }, ee.prototype.push = function(d, g) {
    var _ = this._readableState, E;
    return _.objectMode ? E = !0 : typeof d == "string" && (g = g || _.defaultEncoding, g !== _.encoding && (d = o.from(d, g), g = ""), E = !0), Se(this, d, g, !1, E);
  }, ee.prototype.unshift = function(d) {
    return Se(this, d, null, !0, !1);
  };
  function Se(d, g, _, E, K) {
    l("readableAddChunk", g);
    var ne = d._readableState;
    if (g === null)
      ne.reading = !1, J(d, ne);
    else {
      var oe;
      if (K || (oe = F(ne, g)), oe)
        j(d, oe);
      else if (ne.objectMode || g && g.length > 0)
        if (typeof g != "string" && !ne.objectMode && Object.getPrototypeOf(g) !== o.prototype && (g = u(g)), E)
          ne.endEmitted ? j(d, new B()) : me(d, ne, g, !0);
        else if (ne.ended)
          j(d, new v());
        else {
          if (ne.destroyed)
            return !1;
          ne.reading = !1, ne.decoder && !_ ? (g = ne.decoder.write(g), ne.objectMode || g.length !== 0 ? me(d, ne, g, !1) : H(d, ne)) : me(d, ne, g, !1);
        }
      else E || (ne.reading = !1, H(d, ne));
    }
    return !ne.ended && (ne.length < ne.highWaterMark || ne.length === 0);
  }
  function me(d, g, _, E) {
    g.flowing && g.length === 0 && !g.sync ? (g.awaitDrain = 0, d.emit("data", _)) : (g.length += g.objectMode ? 1 : _.length, E ? g.buffer.unshift(_) : g.buffer.push(_), g.needReadable && V(d)), H(d, g);
  }
  function F(d, g) {
    var _;
    return !f(g) && typeof g != "string" && g !== void 0 && !d.objectMode && (_ = new x("chunk", ["string", "Buffer", "Uint8Array"], g)), _;
  }
  ee.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ee.prototype.setEncoding = function(d) {
    P || (P = Ls().StringDecoder);
    var g = new P(d);
    this._readableState.decoder = g, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var _ = this._readableState.buffer.head, E = ""; _ !== null; )
      E += g.write(_.data), _ = _.next;
    return this._readableState.buffer.clear(), E !== "" && this._readableState.buffer.push(E), this._readableState.length = E.length, this;
  };
  var U = 1073741824;
  function $(d) {
    return d >= U ? d = U : (d--, d |= d >>> 1, d |= d >>> 2, d |= d >>> 4, d |= d >>> 8, d |= d >>> 16, d++), d;
  }
  function q(d, g) {
    return d <= 0 || g.length === 0 && g.ended ? 0 : g.objectMode ? 1 : d !== d ? g.flowing && g.length ? g.buffer.head.data.length : g.length : (d > g.highWaterMark && (g.highWaterMark = $(d)), d <= g.length ? d : g.ended ? g.length : (g.needReadable = !0, 0));
  }
  ee.prototype.read = function(d) {
    l("read", d), d = parseInt(d, 10);
    var g = this._readableState, _ = d;
    if (d !== 0 && (g.emittedReadable = !1), d === 0 && g.needReadable && ((g.highWaterMark !== 0 ? g.length >= g.highWaterMark : g.length > 0) || g.ended))
      return l("read: emitReadable", g.length, g.ended), g.length === 0 && g.ended ? W(this) : V(this), null;
    if (d = q(d, g), d === 0 && g.ended)
      return g.length === 0 && W(this), null;
    var E = g.needReadable;
    l("need readable", E), (g.length === 0 || g.length - d < g.highWaterMark) && (E = !0, l("length less than watermark", E)), g.ended || g.reading ? (E = !1, l("reading or ended", E)) : E && (l("do read"), g.reading = !0, g.sync = !0, g.length === 0 && (g.needReadable = !0), this._read(g.highWaterMark), g.sync = !1, g.reading || (d = q(_, g)));
    var K;
    return d > 0 ? K = O(d, g) : K = null, K === null ? (g.needReadable = g.length <= g.highWaterMark, d = 0) : (g.length -= d, g.awaitDrain = 0), g.length === 0 && (g.ended || (g.needReadable = !0), _ !== d && g.ended && W(this)), K !== null && this.emit("data", K), K;
  };
  function J(d, g) {
    if (l("onEofChunk"), !g.ended) {
      if (g.decoder) {
        var _ = g.decoder.end();
        _ && _.length && (g.buffer.push(_), g.length += g.objectMode ? 1 : _.length);
      }
      g.ended = !0, g.sync ? V(d) : (g.needReadable = !1, g.emittedReadable || (g.emittedReadable = !0, re(d)));
    }
  }
  function V(d) {
    var g = d._readableState;
    l("emitReadable", g.needReadable, g.emittedReadable), g.needReadable = !1, g.emittedReadable || (l("emitReadable", g.flowing), g.emittedReadable = !0, le.process.nextTick(re, d));
  }
  function re(d) {
    var g = d._readableState;
    l("emitReadable_", g.destroyed, g.length, g.ended), !g.destroyed && (g.length || g.ended) && (d.emit("readable"), g.emittedReadable = !1), g.needReadable = !g.flowing && !g.ended && g.length <= g.highWaterMark, R(d);
  }
  function H(d, g) {
    g.readingMore || (g.readingMore = !0, le.process.nextTick(z, d, g));
  }
  function z(d, g) {
    for (; !g.reading && !g.ended && (g.length < g.highWaterMark || g.flowing && g.length === 0); ) {
      var _ = g.length;
      if (l("maybeReadMore read 0"), d.read(0), _ === g.length)
        break;
    }
    g.readingMore = !1;
  }
  ee.prototype._read = function(d) {
    j(this, new C("_read()"));
  }, ee.prototype.pipe = function(d, g) {
    var _ = this, E = this._readableState;
    switch (E.pipesCount) {
      case 0:
        E.pipes = d;
        break;
      case 1:
        E.pipes = [E.pipes, d];
        break;
      default:
        E.pipes.push(d);
        break;
    }
    E.pipesCount += 1, l("pipe count=%d opts=%j", E.pipesCount, g);
    var K = (!g || g.end !== !1) && d !== le.process.stdout && d !== le.process.stderr, ne = K ? Ie : yt;
    E.endEmitted ? le.process.nextTick(ne) : _.once("end", ne), d.on("unpipe", oe);
    function oe(Xe, Ge) {
      l("onunpipe"), Xe === _ && Ge && Ge.hasUnpiped === !1 && (Ge.hasUnpiped = !0, Ue());
    }
    function Ie() {
      l("onend"), d.end();
    }
    var Be = se(_);
    d.on("drain", Be);
    var Ce = !1;
    function Ue() {
      l("cleanup"), d.removeListener("close", _t), d.removeListener("finish", tt), d.removeListener("drain", Be), d.removeListener("error", He), d.removeListener("unpipe", oe), _.removeListener("end", Ie), _.removeListener("end", yt), _.removeListener("data", Re), Ce = !0, E.awaitDrain && (!d._writableState || d._writableState.needDrain) && Be();
    }
    _.on("data", Re);
    function Re(Xe) {
      l("ondata");
      var Ge = d.write(Xe);
      l("dest.write", Ge), Ge === !1 && ((E.pipesCount === 1 && E.pipes === d || E.pipesCount > 1 && ye(E.pipes, d) !== -1) && !Ce && (l("false write response, pause", E.awaitDrain), E.awaitDrain++), _.pause());
    }
    function He(Xe) {
      l("onerror", Xe), yt(), d.removeListener("error", He), t(d, "error") === 0 && j(d, Xe);
    }
    ce(d, "error", He);
    function _t() {
      d.removeListener("finish", tt), yt();
    }
    d.once("close", _t);
    function tt() {
      l("onfinish"), d.removeListener("close", _t), yt();
    }
    d.once("finish", tt);
    function yt() {
      l("unpipe"), _.unpipe(d);
    }
    return d.emit("pipe", _), E.flowing || (l("pipe resume"), _.resume()), d;
  };
  function se(d) {
    return function() {
      var _ = d._readableState;
      l("pipeOnDrain", _.awaitDrain), _.awaitDrain && _.awaitDrain--, _.awaitDrain === 0 && t(d, "data") && (_.flowing = !0, R(d));
    };
  }
  ee.prototype.unpipe = function(d) {
    var g = this._readableState, _ = {
      hasUnpiped: !1
    };
    if (g.pipesCount === 0) return this;
    if (g.pipesCount === 1)
      return d && d !== g.pipes ? this : (d || (d = g.pipes), g.pipes = null, g.pipesCount = 0, g.flowing = !1, d && d.emit("unpipe", this, _), this);
    if (!d) {
      var E = g.pipes, K = g.pipesCount;
      g.pipes = null, g.pipesCount = 0, g.flowing = !1;
      for (var ne = 0; ne < K; ne++) E[ne].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var oe = ye(g.pipes, d);
    return oe === -1 ? this : (g.pipes.splice(oe, 1), g.pipesCount -= 1, g.pipesCount === 1 && (g.pipes = g.pipes[0]), d.emit("unpipe", this, _), this);
  }, ee.prototype.on = function(d, g) {
    var _ = r.prototype.on.call(this, d, g), E = this._readableState;
    return d === "data" ? (E.readableListening = this.listenerCount("readable") > 0, E.flowing !== !1 && this.resume()) : d === "readable" && !E.endEmitted && !E.readableListening && (E.readableListening = E.needReadable = !0, E.flowing = !1, E.emittedReadable = !1, l("on readable", E.length, E.reading), E.length ? V(this) : E.reading || le.process.nextTick(te, this)), _;
  }, ee.prototype.addListener = ee.prototype.on, ee.prototype.removeListener = function(d, g) {
    var _ = r.prototype.removeListener.call(this, d, g);
    return d === "readable" && le.process.nextTick(de, this), _;
  }, ee.prototype.removeAllListeners = function(d) {
    var g = r.prototype.removeAllListeners.apply(this, arguments);
    return (d === "readable" || d === void 0) && le.process.nextTick(de, this), g;
  };
  function de(d) {
    var g = d._readableState;
    g.readableListening = d.listenerCount("readable") > 0, g.resumeScheduled && !g.paused ? g.flowing = !0 : d.listenerCount("data") > 0 && d.resume();
  }
  function te(d) {
    l("readable nexttick read 0"), d.read(0);
  }
  ee.prototype.resume = function() {
    var d = this._readableState;
    return d.flowing || (l("resume"), d.flowing = !d.readableListening, _e(this, d)), d.paused = !1, this;
  };
  function _e(d, g) {
    g.resumeScheduled || (g.resumeScheduled = !0, le.process.nextTick(be, d, g));
  }
  function be(d, g) {
    l("resume", g.reading), g.reading || d.read(0), g.resumeScheduled = !1, d.emit("resume"), R(d), g.flowing && !g.reading && d.read(0);
  }
  ee.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function R(d) {
    var g = d._readableState;
    for (l("flow", g.flowing); g.flowing && d.read() !== null; ) ;
  }
  ee.prototype.wrap = function(d) {
    var g = this, _ = this._readableState, E = !1;
    d.on("end", function() {
      if (l("wrapped end"), _.decoder && !_.ended) {
        var oe = _.decoder.end();
        oe && oe.length && g.push(oe);
      }
      g.push(null);
    }), d.on("data", function(oe) {
      if (l("wrapped data"), _.decoder && (oe = _.decoder.write(oe)), !(_.objectMode && oe == null) && !(!_.objectMode && (!oe || !oe.length))) {
        var Ie = g.push(oe);
        Ie || (E = !0, d.pause());
      }
    });
    for (var K in d)
      this[K] === void 0 && typeof d[K] == "function" && (this[K] = /* @__PURE__ */ function(Ie) {
        return function() {
          return d[Ie].apply(d, arguments);
        };
      }(K));
    for (var ne = 0; ne < Z.length; ne++)
      d.on(Z[ne], this.emit.bind(this, Z[ne]));
    return this._read = function(oe) {
      l("wrapped _read", oe), E && (E = !1, d.resume());
    }, this;
  }, typeof Symbol == "function" && (ee.prototype[Symbol.asyncIterator] = function() {
    return S === void 0 && (S = DB()), S(this);
  }), Object.defineProperty(ee.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(ee.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(ee.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(g) {
      this._readableState && (this._readableState.flowing = g);
    }
  }), ee._fromList = O, Object.defineProperty(ee.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function O(d, g) {
    if (g.length === 0) return null;
    var _;
    return g.objectMode ? _ = g.buffer.shift() : !d || d >= g.length ? (g.decoder ? _ = g.buffer.join("") : g.buffer.length === 1 ? _ = g.buffer.first() : _ = g.buffer.concat(g.length), g.buffer.clear()) : _ = g.buffer.consume(d, g.decoder), _;
  }
  function W(d) {
    var g = d._readableState;
    l("endReadable", g.endEmitted), g.endEmitted || (g.ended = !0, le.process.nextTick(ie, g, d));
  }
  function ie(d, g) {
    if (l("endReadableNT", d.endEmitted, d.length), !d.endEmitted && d.length === 0 && (d.endEmitted = !0, g.readable = !1, g.emit("end"), d.autoDestroy)) {
      var _ = g._writableState;
      (!_ || _.autoDestroy && _.finished) && g.destroy();
    }
  }
  typeof Symbol == "function" && (ee.from = function(d, g) {
    return m === void 0 && (m = jB()), m(ee, d, g);
  });
  function ye(d, g) {
    for (var _ = 0, E = d.length; _ < E; _++)
      if (d[_] === g) return _;
    return -1;
  }
  return yc;
}
var iw = ni, hf = so.codes, UB = hf.ERR_METHOD_NOT_IMPLEMENTED, kB = hf.ERR_MULTIPLE_CALLBACK, FB = hf.ERR_TRANSFORM_ALREADY_TRANSFORMING, HB = hf.ERR_TRANSFORM_WITH_LENGTH_0, gf = Fo();
Bn(ni, gf);
function WB(e, t) {
  var r = this._transformState;
  r.transforming = !1;
  var o = r.writecb;
  if (o === null)
    return this.emit("error", new kB());
  r.writechunk = null, r.writecb = null, t != null && this.push(t), o(e);
  var s = this._readableState;
  s.reading = !1, (s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
}
function ni(e) {
  if (!(this instanceof ni)) return new ni(e);
  gf.call(this, e), this._transformState = {
    afterTransform: WB.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", qB);
}
function qB() {
  var e = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
    Db(e, t, r);
  }) : Db(this, null, null);
}
ni.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, gf.prototype.push.call(this, e, t);
};
ni.prototype._transform = function(e, t, r) {
  r(new UB("_transform()"));
};
ni.prototype._write = function(e, t, r) {
  var o = this._transformState;
  if (o.writecb = r, o.writechunk = e, o.writeencoding = t, !o.transforming) {
    var s = this._readableState;
    (o.needTransform || s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
  }
};
ni.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
ni.prototype._destroy = function(e, t) {
  gf.prototype._destroy.call(this, e, function(r) {
    t(r);
  });
};
function Db(e, t, r) {
  if (t) return e.emit("error", t);
  if (r != null && e.push(r), e._writableState.length) throw new HB();
  if (e._transformState.transforming) throw new FB();
  return e.push(null);
}
var VB = Us, ow = iw;
Bn(Us, ow);
function Us(e) {
  if (!(this instanceof Us)) return new Us(e);
  ow.call(this, e);
}
Us.prototype._transform = function(e, t, r) {
  r(null, e);
};
var wc;
function GB(e) {
  var t = !1;
  return function() {
    t || (t = !0, e.apply(void 0, arguments));
  };
}
var sw = so.codes, zB = sw.ERR_MISSING_ARGS, KB = sw.ERR_STREAM_DESTROYED;
function jb(e) {
  if (e) throw e;
}
function JB(e) {
  return e.setHeader && typeof e.abort == "function";
}
function YB(e, t, r, o) {
  o = GB(o);
  var s = !1;
  e.on("close", function() {
    s = !0;
  }), wc === void 0 && (wc = jd), wc(e, {
    readable: t,
    writable: r
  }, function(f) {
    if (f) return o(f);
    s = !0, o();
  });
  var u = !1;
  return function(f) {
    if (!s && !u) {
      if (u = !0, JB(e)) return e.abort();
      if (typeof e.destroy == "function") return e.destroy();
      o(f || new KB("pipe"));
    }
  };
}
function Ub(e) {
  e();
}
function XB(e, t) {
  return e.pipe(t);
}
function ZB(e) {
  return !e.length || typeof e[e.length - 1] != "function" ? jb : e.pop();
}
function QB() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var o = ZB(t);
  if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
    throw new zB("streams");
  var s, u = t.map(function(f, h) {
    var l = h < t.length - 1, p = h > 0;
    return YB(f, l, p, function(b) {
      s || (s = b), b && u.forEach(Ub), !l && (u.forEach(Ub), o(s));
    });
  });
  return t.reduce(XB);
}
var eN = QB;
(function(e, t) {
  t = e.exports = nw(), t.Stream = t, t.Readable = t, t.Writable = tw(), t.Duplex = Fo(), t.Transform = iw, t.PassThrough = VB, t.finished = jd, t.pipeline = eN;
})(zc, zc.exports);
var pf = zc.exports, tN = Y1();
const rN = /* @__PURE__ */ Oi(tN);
var nN = { exports: {} }, Ud = {}, kd = {};
Object.defineProperty(kd, "__esModule", { value: !0 });
function iN(e) {
  var t = 4, r = e.length, o = r % t;
  if (!o)
    return e;
  var s = r, u = t - o, f = r + u, h = le.Buffer.alloc(f);
  for (h.write(e); u--; )
    h.write("=", s++);
  return h.toString();
}
kd.default = iN;
Object.defineProperty(Ud, "__esModule", { value: !0 });
var oN = kd;
function aw(e, t) {
  return t === void 0 && (t = "utf8"), le.Buffer.isBuffer(e) ? Jc(e.toString("base64")) : Jc(le.Buffer.from(e, t).toString("base64"));
}
function sN(e, t) {
  return t === void 0 && (t = "utf8"), le.Buffer.from(Fd(e), "base64").toString(t);
}
function Fd(e) {
  return e = e.toString(), oN.default(e).replace(/\-/g, "+").replace(/_/g, "/");
}
function Jc(e) {
  return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function aN(e) {
  return le.Buffer.from(Fd(e), "base64");
}
var Go = aw;
Go.encode = aw;
Go.decode = sN;
Go.toBase64 = Fd;
Go.fromBase64 = Jc;
Go.toBuffer = aN;
Ud.default = Go;
(function(e) {
  e.exports = Ud.default, e.exports.default = e.exports;
})(nN);
const uN = () => rN(32).toString("hex");
function lu() {
}
const kb = "SYN", mc = "ACK", Fb = "BRK";
class Hb extends pf.Duplex {
  constructor(t) {
    let {
      name: r,
      target: o,
      targetWindow: s = window,
      targetOrigin: u = "*"
    } = t;
    if (super({
      objectMode: !0
    }), Ne(this, "_init", void 0), Ne(this, "_haveSyn", void 0), Ne(this, "_name", void 0), Ne(this, "_target", void 0), Ne(this, "_targetWindow", void 0), Ne(this, "_targetOrigin", void 0), Ne(this, "_onMessage", void 0), Ne(this, "_synIntervalId", void 0), !r || !o)
      throw new Error("Invalid input.");
    this._init = !1, this._haveSyn = !1, this._name = r, this._target = o, this._targetWindow = s, this._targetOrigin = u, this._onMessage = this.onMessage.bind(this), this._synIntervalId = null, window.addEventListener("message", this._onMessage, !1), this._handShake();
  }
  _break() {
    this.cork(), this._write(Fb, null, lu), this._haveSyn = !1, this._init = !1;
  }
  _handShake() {
    this._write(kb, null, lu), this.cork();
  }
  _onData(t) {
    if (!this._init)
      t === kb ? (this._haveSyn = !0, this._write(mc, null, lu)) : t === mc && (this._init = !0, this._haveSyn || this._write(mc, null, lu), this.uncork());
    else if (t === Fb)
      this._break();
    else
      try {
        this.push(t);
      } catch (r) {
        this.emit("error", r);
      }
  }
  _postMessage(t) {
    const r = this._targetOrigin;
    this._targetWindow.postMessage({
      target: this._target,
      data: t
    }, r);
  }
  onMessage(t) {
    const r = t.data;
    this._targetOrigin !== "*" && t.origin !== this._targetOrigin || t.source !== this._targetWindow || typeof r != "object" || r.target !== this._name || !r.data || this._onData(r.data);
  }
  _read() {
  }
  _write(t, r, o) {
    this._postMessage(t), o();
  }
  _destroy() {
    window.removeEventListener("message", this._onMessage, !1);
  }
}
function Wb(e, t, r) {
  try {
    Reflect.apply(e, t, r);
  } catch (o) {
    setTimeout(() => {
      throw o;
    });
  }
}
function fN(e) {
  const t = e.length, r = new Array(t);
  for (let o = 0; o < t; o += 1)
    r[o] = e[o];
  return r;
}
class bf extends Pn.EventEmitter {
  emit(t) {
    let r = t === "error";
    const o = this._events;
    if (o !== void 0)
      r = r && o.error === void 0;
    else if (!r)
      return !1;
    for (var s = arguments.length, u = new Array(s > 1 ? s - 1 : 0), f = 1; f < s; f++)
      u[f - 1] = arguments[f];
    if (r) {
      let l;
      if (u.length > 0 && ([l] = u), l instanceof Error)
        throw l;
      const p = new Error(`Unhandled error.${l ? ` (${l.message})` : ""}`);
      throw p.context = l, p;
    }
    const h = o[t];
    if (h === void 0)
      return !1;
    if (typeof h == "function")
      Wb(h, this, u);
    else {
      const l = h.length, p = fN(h);
      for (let b = 0; b < l; b += 1)
        Wb(p[b], this, u);
    }
    return !0;
  }
}
class Rs extends Error {
  constructor(t) {
    let {
      code: r,
      message: o,
      data: s
    } = t;
    if (!Number.isInteger(r))
      throw new Error("code must be an integer");
    if (!o || typeof o != "string")
      throw new Error("message must be string");
    super(o), Ne(this, "code", void 0), Ne(this, "data", void 0), this.code = r, s !== void 0 && (this.data = s);
  }
  toString() {
    return UA({
      code: this.code,
      message: this.message,
      data: this.data,
      stack: this.stack
    });
  }
}
const Yc = function(e, t) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  return (o, s) => {
    o || s.error ? t(o || s.error) : !r || Array.isArray(s) ? e(s) : e(s.result);
  };
};
function lN() {
  const e = {};
  function t() {
    return !1;
  }
  const r = new bf();
  function o(l) {
    const p = e[l.id];
    if (!p)
      throw new Error(`StreamMiddleware - Unknown response id "${l.id}"`);
    delete e[l.id], Object.assign(p.res, l), setTimeout(p.end);
  }
  function s(l) {
    r.emit("notification", l);
  }
  function u(l, p, b) {
    let w;
    try {
      !l.id ? s(l) : o(l);
    } catch (I) {
      w = I;
    }
    b(w);
  }
  const f = new pf.Duplex({
    objectMode: !0,
    read: t,
    write: u
  });
  return {
    events: r,
    middleware: (l, p, b, w) => {
      f.push(l), e[l.id] = {
        req: l,
        res: p,
        next: b,
        end: w
      };
    },
    stream: f
  };
}
function cN() {
  return (e, t, r, o) => {
    const s = e.id, u = uN();
    e.id = u, t.id = u, r((f) => {
      e.id = s, t.id = s, f();
    });
  };
}
function qb(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(s) {
      return Object.getOwnPropertyDescriptor(e, s).enumerable;
    })), r.push.apply(r, o);
  }
  return r;
}
function dN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qb(Object(r), !0).forEach(function(o) {
      Ne(e, o, r[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : qb(Object(r)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(r, o));
    });
  }
  return e;
}
class Zn extends bf {
  constructor() {
    super(), Ne(this, "_middleware", void 0), this._middleware = [];
  }
  /**
   * Serially executes the given stack of middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * a boolean indicating whether the request was completed, and an array of
   * middleware-defined return handlers.
   */
  static async _runAllMiddleware(t, r, o) {
    const s = [];
    let u = null, f = !1;
    for (const h of o)
      if ([u, f] = await Zn._runMiddleware(t, r, h, s), f)
        break;
    return [u, f, s.reverse()];
  }
  /**
   * Runs an individual middleware.
   *
   * @returns An array of any error encountered during middleware exection,
   * and a boolean indicating whether the request should end.
   */
  static _runMiddleware(t, r, o, s) {
    return new Promise((u) => {
      const f = (l) => {
        const p = l || r.error;
        p && (r.error = sn.serializeError(p)), u([p, !0]);
      }, h = (l) => {
        r.error ? f(r.error) : (l && (typeof l != "function" && f(new Rs({
          code: -32603,
          message: "JRPCEngine: 'next' return handlers must be functions"
        })), s.push(l)), u([null, !1]));
      };
      try {
        o(t, r, h, f);
      } catch (l) {
        f(l);
      }
    });
  }
  /**
   * Serially executes array of return handlers. The request and response are
   * assumed to be in their scope.
   */
  static async _runReturnHandlers(t) {
    for (const r of t)
      await new Promise((o, s) => {
        r((u) => u ? s(u) : o());
      });
  }
  /**
   * Throws an error if the response has neither a result nor an error, or if
   * the "isComplete" flag is falsy.
   */
  static _checkForCompletion(t, r, o) {
    if (!("result" in r) && !("error" in r))
      throw new Rs({
        code: -32603,
        message: "Response has no error or result for request"
      });
    if (!o)
      throw new Rs({
        code: -32603,
        message: "Nothing ended request"
      });
  }
  /**
   * Add a middleware function to the engine's middleware stack.
   *
   * @param middleware - The middleware function to add.
   */
  push(t) {
    this._middleware.push(t);
  }
  handle(t, r) {
    if (r && typeof r != "function")
      throw new Error('"callback" must be a function if provided.');
    return Array.isArray(t) ? r ? this._handleBatch(t, r) : this._handleBatch(t) : r ? this._handle(t, r) : this._promiseHandle(t);
  }
  /**
   * Returns this engine as a middleware function that can be pushed to other
   * engines.
   *
   * @returns This engine as a middleware function.
   */
  asMiddleware() {
    return async (t, r, o, s) => {
      try {
        const [u, f, h] = await Zn._runAllMiddleware(t, r, this._middleware);
        return f ? (await Zn._runReturnHandlers(h), s(u)) : o(async (l) => {
          try {
            await Zn._runReturnHandlers(h);
          } catch (p) {
            return l(p);
          }
          return l();
        });
      } catch (u) {
        return s(u);
      }
    };
  }
  async _handleBatch(t, r) {
    try {
      const o = await Promise.all(
        // 1. Begin executing each request in the order received
        t.map(this._promiseHandle.bind(this))
      );
      return r ? r(null, o) : o;
    } catch (o) {
      if (r)
        return r(o);
      throw o;
    }
  }
  /**
   * A promise-wrapped _handle.
   */
  _promiseHandle(t) {
    return new Promise((r) => {
      this._handle(t, (o, s) => {
        r(s);
      });
    });
  }
  /**
   * Ensures that the request object is valid, processes it, and passes any
   * error and the response object to the given callback.
   *
   * Does not reject.
   */
  async _handle(t, r) {
    if (!t || Array.isArray(t) || typeof t != "object") {
      const f = new Rs({
        code: -32603,
        message: "request must be plain object"
      });
      return r(f, {
        id: void 0,
        jsonrpc: "2.0",
        error: f
      });
    }
    if (typeof t.method != "string") {
      const f = new Rs({
        code: -32603,
        message: "method must be string"
      });
      return r(f, {
        id: t.id,
        jsonrpc: "2.0",
        error: f
      });
    }
    const o = dN({}, t), s = {
      id: o.id,
      jsonrpc: o.jsonrpc
    };
    let u = null;
    try {
      await this._processRequest(o, s);
    } catch (f) {
      u = f;
    }
    return u && (delete s.result, s.error || (s.error = sn.serializeError(u))), r(u, s);
  }
  /**
   * For the given request and response, runs all middleware and their return
   * handlers, if any, and ensures that internal request processing semantics
   * are satisfied.
   */
  async _processRequest(t, r) {
    const [o, s, u] = await Zn._runAllMiddleware(t, r, this._middleware);
    if (Zn._checkForCompletion(t, r, s), await Zn._runReturnHandlers(u), o)
      throw o;
  }
}
class hN extends pf.Duplex {
  constructor(t) {
    let {
      parent: r,
      name: o
    } = t;
    super({
      objectMode: !0
    }), Ne(this, "_parent", void 0), Ne(this, "_name", void 0), this._parent = r, this._name = o;
  }
  /**
   * Explicitly sets read operations to a no-op.
   */
  _read() {
  }
  /**
   * Called when data should be written to this writable stream.
   *
   * @param chunk - Arbitrary object to write
   * @param encoding - Encoding to use when writing payload
   * @param callback - Called when writing is complete or an error occurs
   */
  _write(t, r, o) {
    this._parent.push({
      name: this._name,
      data: t
    }), o();
  }
}
function Vb(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(s) {
      return Object.getOwnPropertyDescriptor(e, s).enumerable;
    })), r.push.apply(r, o);
  }
  return r;
}
function Gb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Vb(Object(r), !0).forEach(function(o) {
      Ne(e, o, r[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Vb(Object(r)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(r, o));
    });
  }
  return e;
}
const zb = Symbol("IGNORE_SUBSTREAM");
class gN extends pf.Duplex {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(Gb(Gb({}, t), {}, {
      objectMode: !0
    })), Ne(this, "_substreams", void 0), Ne(this, "getStream", void 0), this._substreams = {};
  }
  createStream(t) {
    if (!t)
      throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[t])
      throw new Error(`ObjectMultiplex - Substream for name "${t}" already exists`);
    const r = new hN({
      parent: this,
      name: t
    });
    return this._substreams[t] = r, pN(this, (o) => r.destroy(o || void 0)), r;
  }
  // ignore streams (dont display orphaned data warning)
  ignoreStream(t) {
    if (!t)
      throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[t])
      throw new Error(`ObjectMultiplex - Substream for name "${t}" already exists`);
    this._substreams[t] = zb;
  }
  _read() {
  }
  _write(t, r, o) {
    const {
      name: s,
      data: u
    } = t;
    if (!s)
      return window.console.warn(`ObjectMultiplex - malformed chunk without name "${t}"`), o();
    const f = this._substreams[s];
    return f ? (f !== zb && f.push(u), o()) : (window.console.warn(`ObjectMultiplex - orphaned data for stream "${s}"`), o());
  }
}
function pN(e, t) {
  const r = EL(t);
  db(e, {
    readable: !1
  }, r), db(e, {
    writable: !1
  }, r);
}
const Cn = (e) => e !== null && typeof e == "object" && typeof e.pipe == "function";
Cn.writable = (e) => Cn(e) && e.writable !== !1 && typeof e._write == "function" && typeof e._writableState == "object";
Cn.readable = (e) => Cn(e) && e.readable !== !1 && typeof e._read == "function" && typeof e._readableState == "object";
Cn.duplex = (e) => Cn.writable(e) && Cn.readable(e);
Cn.transform = (e) => Cn.duplex(e) && typeof e._transform == "function";
var bN = Cn, _N = function e(t, r) {
  if (t === r) return !0;
  if (t && r && typeof t == "object" && typeof r == "object") {
    if (t.constructor !== r.constructor) return !1;
    var o, s, u;
    if (Array.isArray(t)) {
      if (o = t.length, o != r.length) return !1;
      for (s = o; s-- !== 0; )
        if (!e(t[s], r[s])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === r.toString();
    if (u = Object.keys(t), o = u.length, o !== Object.keys(r).length) return !1;
    for (s = o; s-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, u[s])) return !1;
    for (s = o; s-- !== 0; ) {
      var f = u[s];
      if (!e(t[f], r[f])) return !1;
    }
    return !0;
  }
  return t !== t && r !== r;
};
const yN = /* @__PURE__ */ Oi(_N);
var wN = "0.3.4", In = {
  errors: {
    disconnected: () => "Torus: Lost connection to Torus.",
    permanentlyDisconnected: () => "Torus: Disconnected from iframe. Page reload required.",
    unsupportedSync: (e) => `Torus: The Torus Ethereum provider does not support synchronous methods like ${e} without a callback parameter.`,
    invalidDuplexStream: () => "Must provide a Node.js-style duplex stream.",
    invalidOptions: (e) => `Invalid options. Received: { maxEventListeners: ${e}}`,
    invalidRequestArgs: () => "Expected a single, non-array, object argument.",
    invalidRequestMethod: () => "'args.method' must be a non-empty string.",
    invalidRequestParams: () => "'args.params' must be an object or array if provided.",
    invalidLoggerObject: () => "'args.logger' must be an object if provided.",
    invalidLoggerMethod: (e) => `'args.logger' must include required method '${e}'.`
  },
  info: {
    connected: (e) => `Torus: Connected to chain with ID "${e}".`
  }
};
const mN = {
  PRODUCTION: "production"
}, Ts = {
  BOTTOM_LEFT: "bottom-left",
  TOP_LEFT: "top-left",
  BOTTOM_RIGHT: "bottom-right",
  TOP_RIGHT: "top-right"
}, EN = {
  en: {
    embed: {
      continue: "Continue",
      actionRequired: "Authorization required",
      pendingAction: "Click continue to proceed with your request in a popup",
      cookiesRequired: "Cookies Required",
      enableCookies: "Please enable cookies in your browser preferences to access Torus",
      clickHere: "More Info"
    }
  },
  de: {
    embed: {
      continue: "Fortsetzen",
      actionRequired: "Autorisierung erforderlich",
      pendingAction: "Klicken Sie in einem Popup auf Weiter, um mit Ihrer Anfrage fortzufahren",
      cookiesRequired: "Cookies bentigt",
      enableCookies: "Bitte aktivieren Sie Cookies in Ihren Browsereinstellungen, um auf Torus zuzugreifen",
      clickHere: "Mehr Info"
    }
  },
  ja: {
    embed: {
      continue: "",
      actionRequired: "",
      pendingAction: "",
      cookiesRequired: "",
      enableCookies: "TorusCookie",
      clickHere: ""
    }
  },
  ko: {
    embed: {
      continue: "",
      actionRequired: " ",
      pendingAction: "    .",
      cookiesRequired: " ",
      enableCookies: "     Torus .",
      clickHere: "  "
    }
  },
  zh: {
    embed: {
      continue: "",
      actionRequired: "",
      pendingAction: "",
      cookiesRequired: "Cookie",
      enableCookies: "cookieTorus",
      clickHere: ""
    }
  }
};
var Hd = {
  translations: EN,
  localStorageKeyPrefix: "torus-"
}, ct = Iu.getLogger("solana-embed");
function vN() {
  return (e, t, r) => {
    (typeof e.method != "string" || !e.method) && (t.error = sn.ethErrors.rpc.invalidRequest({
      message: "The request 'method' must be a non-empty string.",
      data: e
    })), r((o) => {
      const {
        error: s
      } = t;
      return s && ct.error(`Torus - RPC Error: ${s.message}`, s), o();
    });
  };
}
function SN(e, t, r) {
  let o = `Torus: Lost connection to "${e}".`;
  t != null && t.stack && (o += `
${t.stack}`), ct.warn(o), r && r.listenerCount("error") > 0 && r.emit("error", o);
}
const cu = () => Math.random().toString(36).slice(2), uw = async (e) => {
  let t, r;
  switch (e) {
    case "testing":
      t = "https://solana-testing.tor.us", r = "debug";
      break;
    case "development":
      t = "http://localhost:8080", r = "debug";
      break;
    default:
      t = "https://solana.tor.us", r = "error";
      break;
  }
  return {
    torusUrl: t,
    logLevel: r
  };
}, RN = () => {
  let e = window.navigator.language || "en-US";
  const t = e.split("-");
  return e = Object.prototype.hasOwnProperty.call(Hd.translations, t[0]) ? t[0] : "en", e;
}, AN = {
  height: 660,
  width: 375
}, TN = {
  height: 740,
  width: 1315
}, IN = {
  height: 700,
  width: 1200
}, fw = {
  height: 600,
  width: 400
};
function ON(e) {
  let t;
  try {
    t = window[e];
    const r = "__storage_test__";
    return t.setItem(r, r), t.removeItem(r), !0;
  } catch (r) {
    return r && // everything except Firefox
    (r.code === 22 || // Firefox
    r.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    r.name === "QuotaExceededError" || // Firefox
    r.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    t && t.length !== 0;
  }
}
function Cs(e) {
  let {
    width: t,
    height: r
  } = e;
  const o = window.screenLeft !== void 0 ? window.screenLeft : window.screenX, s = window.screenTop !== void 0 ? window.screenTop : window.screenY, u = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width, f = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height, h = 1, l = Math.abs((u - t) / 2 / h + o), p = Math.abs((f - r) / 2 / h + s);
  return `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${r / h},width=${t / h},top=${p},left=${l}`;
}
class lw extends bf {
  /**
   * Indicating that this provider is a Torus provider.
   */
  constructor(t, r) {
    let {
      maxEventListeners: o = 100,
      jsonRpcStreamName: s = "provider"
    } = r;
    if (super(), Ne(this, "isTorus", void 0), Ne(this, "_rpcEngine", void 0), Ne(this, "jsonRpcConnectionEvents", void 0), Ne(this, "_state", void 0), !bN.duplex(t))
      throw new Error(In.errors.invalidDuplexStream());
    this.isTorus = !0, this.setMaxListeners(o), this._handleConnect = this._handleConnect.bind(this), this._handleDisconnect = this._handleDisconnect.bind(this), this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this), this._rpcRequest = this._rpcRequest.bind(this), this._initializeState = this._initializeState.bind(this), this.request = this.request.bind(this), this.sendAsync = this.sendAsync.bind(this);
    const u = new gN();
    gb(t, u, t, this._handleStreamDisconnect.bind(this, "Torus")), u.ignoreStream("phishing");
    const f = lN();
    gb(f.stream, u.createStream(s), f.stream, this._handleStreamDisconnect.bind(this, "Torus RpcProvider"));
    const h = new Zn();
    h.push(cN()), h.push(vN()), h.push(vB({
      origin: location.origin
    })), h.push(f.middleware), this._rpcEngine = h, this.jsonRpcConnectionEvents = f.events;
  }
  /**
   * Submits an RPC request for the given method, with the given params.
   * Resolves with the result of the method call, or rejects on error.
   */
  async request(t) {
    if (!t || typeof t != "object" || Array.isArray(t))
      throw sn.ethErrors.rpc.invalidRequest({
        message: In.errors.invalidRequestArgs(),
        data: t
      });
    const {
      method: r,
      params: o
    } = t;
    if (typeof r != "string" || r.length === 0)
      throw sn.ethErrors.rpc.invalidRequest({
        message: In.errors.invalidRequestMethod(),
        data: t
      });
    if (o !== void 0 && !Array.isArray(o) && (typeof o != "object" || o === null))
      throw sn.ethErrors.rpc.invalidRequest({
        message: In.errors.invalidRequestParams(),
        data: t
      });
    return new Promise((s, u) => {
      this._rpcRequest({
        method: r,
        params: o
      }, Yc(s, u));
    });
  }
  /**
   * Submits an RPC request per the given JSON-RPC request object.
   */
  send(t, r) {
    this._rpcRequest(t, r);
  }
  /**
   * Submits an RPC request per the given JSON-RPC request object.
   */
  sendAsync(t) {
    return new Promise((r, o) => {
      this._rpcRequest(t, Yc(r, o));
    });
  }
  /**
   * Called when connection is lost to critical streams.
   *
   * emits TorusInpageProvider#disconnect
   */
  _handleStreamDisconnect(t, r) {
    SN(t, r, this), this._handleDisconnect(!1, r ? r.message : void 0);
  }
}
const CN = function(e, t, r) {
  for (var o = arguments.length, s = new Array(o > 3 ? o - 3 : 0), u = 3; u < o; u++)
    s[u - 3] = arguments[u];
  const f = () => {
    r(...s), e.removeEventListener(t, f);
  };
  e.addEventListener(t, f);
};
async function cw() {
  return new Promise((e) => {
    document.readyState !== "loading" ? e() : CN(document, "DOMContentLoaded", e);
  });
}
const Bo = (e) => {
  const t = window.document.createElement("template"), r = e.trim();
  return t.innerHTML = r, t.content.firstChild;
};
function du(e) {
  return e.version === void 0;
}
class dw extends bf {
  constructor(t) {
    let {
      url: r,
      target: o,
      features: s
    } = t;
    super(), Ne(this, "url", void 0), Ne(this, "target", void 0), Ne(this, "features", void 0), Ne(this, "window", void 0), Ne(this, "windowTimer", void 0), Ne(this, "iClosedWindow", void 0), this.url = r, this.target = o || "_blank", this.features = s || Cs(IN), this.window = void 0, this.windowTimer = void 0, this.iClosedWindow = !1, this._setupTimer();
  }
  _setupTimer() {
    this.windowTimer = Number(setInterval(() => {
      this.window && this.window.closed && (clearInterval(this.windowTimer), this.iClosedWindow || this.emit("close"), this.iClosedWindow = !1, this.window = void 0), this.window === void 0 && clearInterval(this.windowTimer);
    }, 500));
  }
  open() {
    var t;
    return this.window = window.open(this.url.href, this.target, this.features), (t = this.window) != null && t.focus && this.window.focus(), Promise.resolve();
  }
  close() {
    this.iClosedWindow = !0, this.window && this.window.close();
  }
  redirect(t) {
    t ? window.location.replace(this.url.href) : window.location.href = this.url.href;
  }
}
function Kb(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(s) {
      return Object.getOwnPropertyDescriptor(e, s).enumerable;
    })), r.push.apply(r, o);
  }
  return r;
}
function LN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Kb(Object(r), !0).forEach(function(o) {
      Ne(e, o, r[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Kb(Object(r)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(r, o));
    });
  }
  return e;
}
class _f extends lw {
  constructor(t, r) {
    let {
      maxEventListeners: o = 100,
      jsonRpcStreamName: s = "provider"
    } = r;
    super(t, {
      maxEventListeners: o,
      jsonRpcStreamName: s
    }), Ne(this, "embedTranslations", void 0), Ne(this, "torusUrl", void 0), Ne(this, "dappStorageKey", void 0), Ne(this, "windowRefs", void 0), Ne(this, "tryWindowHandle", void 0), Ne(this, "torusAlertContainer", void 0), Ne(this, "torusIframe", void 0), this._state = LN({}, _f._defaultState), this.torusUrl = "", this.dappStorageKey = "";
    const u = Hd.translations[RN()];
    this.embedTranslations = u.embed, this.windowRefs = {}, this.on("connect", () => {
      this._state.isConnected = !0;
    });
    const f = (h) => {
      const {
        method: l,
        params: p
      } = h;
      if (l === Ss.IFRAME_STATUS) {
        const {
          isFullScreen: b,
          rid: w
        } = p;
        this._displayIframe({
          isFull: b,
          rid: w
        });
      } else if (l === Ss.CREATE_WINDOW) {
        const {
          windowId: b,
          url: w
        } = p;
        this._createPopupBlockAlert(b, w);
      } else if (l === Ss.CLOSE_WINDOW)
        this._handleCloseWindow(p);
      else if (l === Ss.USER_LOGGED_IN) {
        const {
          currentLoginProvider: b
        } = p;
        this._state.isLoggedIn = !0, this._state.currentLoginProvider = b;
      } else l === Ss.USER_LOGGED_OUT && (this._state.isLoggedIn = !1, this._state.currentLoginProvider = null, this._displayIframe());
    };
    this.jsonRpcConnectionEvents.on("notification", f);
  }
  get isLoggedIn() {
    return this._state.isLoggedIn;
  }
  get isIFrameFullScreen() {
    return this._state.isIFrameFullScreen;
  }
  /**
   * Returns whether the inPage provider is connected to Torus.
   */
  isConnected() {
    return this._state.isConnected;
  }
  async _initializeState(t) {
    try {
      const {
        torusUrl: r,
        dappStorageKey: o,
        torusAlertContainer: s,
        torusIframe: u
      } = t;
      this.torusUrl = r, this.dappStorageKey = o, this.torusAlertContainer = s, this.torusIframe = u, this.torusIframe.addEventListener("load", () => {
        this._state.isIFrameFullScreen || this._displayIframe();
      });
      const {
        currentLoginProvider: f,
        isLoggedIn: h
      } = await this.request({
        method: Sn.GET_PROVIDER_STATE,
        params: []
      });
      this._handleConnect(f, h);
    } catch (r) {
      ct.error("Torus: Failed to get initial state. Please report this bug.", r);
    } finally {
      ct.info("initialized communication state"), this._state.initialized = !0, this.emit("_initialized");
    }
  }
  _handleWindow(t) {
    let {
      url: r,
      target: o,
      features: s
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const u = new URL(r || `${this.torusUrl}/redirect?windowId=${t}`);
    this.dappStorageKey && (u.hash ? u.hash += `&dappStorageKey=${this.dappStorageKey}` : u.hash = `#dappStorageKey=${this.dappStorageKey}`);
    const f = new dw({
      url: u,
      target: o,
      features: s
    });
    if (f.open(), !f.window) {
      this._createPopupBlockAlert(t, u.href);
      return;
    }
    this.windowRefs[t] = f, this.request({
      method: Sn.OPENED_WINDOW,
      params: {
        windowId: t
      }
    }), f.once("close", () => {
      delete this.windowRefs[t], this.request({
        method: Sn.CLOSED_WINDOW,
        params: {
          windowId: t
        }
      });
    });
  }
  _displayIframe() {
    let {
      isFull: t = !1,
      rid: r = ""
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const o = {};
    if (t)
      o.display = "block", o.width = "100%", o.height = "100%", o.top = "0px", o.right = "0px", o.left = "0px", o.bottom = "0px";
    else
      switch (o.display = this._state.torusWidgetVisibility ? "block" : "none", o.height = "70px", o.width = "70px", this._state.buttonPosition) {
        case Ts.TOP_LEFT:
          o.top = "0px", o.left = "0px", o.right = "auto", o.bottom = "auto";
          break;
        case Ts.TOP_RIGHT:
          o.top = "0px", o.right = "0px", o.left = "auto", o.bottom = "auto";
          break;
        case Ts.BOTTOM_RIGHT:
          o.bottom = "0px", o.right = "0px", o.top = "auto", o.left = "auto";
          break;
        case Ts.BOTTOM_LEFT:
        default:
          o.bottom = "0px", o.left = "0px", o.top = "auto", o.right = "auto";
          break;
      }
    Object.assign(this.torusIframe.style, o), this._state.isIFrameFullScreen = t, this.request({
      method: Sn.IFRAME_STATUS,
      params: {
        isIFrameFullScreen: t,
        rid: r
      }
    });
  }
  hideTorusButton() {
    this._state.torusWidgetVisibility = !1, this._displayIframe();
  }
  showTorusButton() {
    this._state.torusWidgetVisibility = !0, this._displayIframe();
  }
  /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */
  _rpcRequest(t, r) {
    const o = r, s = t;
    Array.isArray(s) || s.jsonrpc || (s.jsonrpc = "2.0"), this.tryWindowHandle(s, o);
  }
  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param currentLoginProvider - The login Provider
   * emits TorusInpageProvider#connect
   */
  _handleConnect(t, r) {
    this._state.isConnected || (this._state.isConnected = !0, this.emit("connect", {
      currentLoginProvider: t,
      isLoggedIn: r
    }), ct.debug(In.info.connected(t)));
  }
  /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits TorusInpageProvider#disconnect
   */
  _handleDisconnect(t, r) {
    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !t) {
      this._state.isConnected = !1;
      let o;
      t ? (o = new sn.EthereumRpcError(
        1013,
        // Try again later
        r || In.errors.disconnected()
      ), ct.debug(o)) : (o = new sn.EthereumRpcError(
        1011,
        // Internal error
        r || In.errors.permanentlyDisconnected()
      ), ct.error(o), this._state.currentLoginProvider = null, this._state.isLoggedIn = !1, this._state.torusWidgetVisibility = !1, this._state.isIFrameFullScreen = !1, this._state.isPermanentlyDisconnected = !0), this.emit("disconnect", o);
    }
  }
  // Called if the iframe wants to close the window cause it is done processing the request
  _handleCloseWindow(t) {
    const {
      windowId: r
    } = t;
    this.windowRefs[r] && (this.windowRefs[r].close(), delete this.windowRefs[r]);
  }
  async _createPopupBlockAlert(t, r) {
    const o = this.getLogoUrl(), s = Bo(`<div id="torusAlert" class="torus-alert--v2"><div id="torusAlert__logo"><img src="${o}" /></div><div><h1 id="torusAlert__title">${this.embedTranslations.actionRequired}</h1><p id="torusAlert__desc">${this.embedTranslations.pendingAction}</p></div></div>`), u = Bo(`<div><a id="torusAlert__btn">${this.embedTranslations.continue}</a></div>`), f = Bo('<div id="torusAlert__btn-container"></div>');
    f.appendChild(u), s.appendChild(f);
    const h = () => {
      u.addEventListener("click", () => {
        this._handleWindow(t, {
          url: r,
          target: "_blank",
          features: Cs(fw)
        }), s.remove(), this.torusAlertContainer.children.length === 0 && (this.torusAlertContainer.style.display = "none");
      });
    }, l = () => {
      this.torusAlertContainer.appendChild(s);
    };
    await cw(), l(), h(), this.torusAlertContainer.style.display = "block";
  }
  getLogoUrl() {
    return `${this.torusUrl}/images/torus_icon-blue.svg`;
  }
}
Ne(_f, "_defaultState", {
  buttonPosition: "bottom-left",
  currentLoginProvider: null,
  isIFrameFullScreen: !1,
  hasEmittedConnection: !1,
  torusWidgetVisibility: !1,
  initialized: !1,
  isLoggedIn: !1,
  isPermanentlyDisconnected: !1,
  isConnected: !1
});
function Jb(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(s) {
      return Object.getOwnPropertyDescriptor(e, s).enumerable;
    })), r.push.apply(r, o);
  }
  return r;
}
function PN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Jb(Object(r), !0).forEach(function(o) {
      Ne(e, o, r[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Jb(Object(r)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(r, o));
    });
  }
  return e;
}
class yf extends lw {
  /**
   * The chain ID of the currently connected Solana chain.
   * See [chainId.network]{@link https://chainid.network} for more information.
   */
  /**
   * The user's currently selected Solana address.
   * If null, Torus is either locked or the user has not permitted any
   * addresses to be viewed.
   */
  constructor(t, r) {
    let {
      maxEventListeners: o = 100,
      jsonRpcStreamName: s = "provider"
    } = r;
    super(t, {
      maxEventListeners: o,
      jsonRpcStreamName: s
    }), Ne(this, "chainId", void 0), Ne(this, "selectedAddress", void 0), Ne(this, "tryWindowHandle", void 0), this._state = PN({}, yf._defaultState), this.selectedAddress = null, this.chainId = null, this._handleAccountsChanged = this._handleAccountsChanged.bind(this), this._handleChainChanged = this._handleChainChanged.bind(this), this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this), this.on("connect", () => {
      this._state.isConnected = !0;
    });
    const u = (f) => {
      const {
        method: h,
        params: l
      } = f;
      h === dc.ACCOUNTS_CHANGED ? this._handleAccountsChanged(l) : h === dc.UNLOCK_STATE_CHANGED ? this._handleUnlockStateChanged(l) : h === dc.CHAIN_CHANGED && this._handleChainChanged(l);
    };
    this.jsonRpcConnectionEvents.on("notification", u);
  }
  /**
   * Returns whether the inpage provider is connected to Torus.
   */
  isConnected() {
    return this._state.isConnected;
  }
  // Private Methods
  //= ===================
  /**
   * Constructor helper.
   * Populates initial state by calling 'wallet_getProviderState' and emits
   * necessary events.
   */
  async _initializeState() {
    try {
      const {
        accounts: t,
        chainId: r,
        isUnlocked: o
      } = await this.request({
        method: EB.GET_PROVIDER_STATE,
        params: []
      });
      this.emit("connect", {
        chainId: r
      }), this._handleChainChanged({
        chainId: r
      }), this._handleUnlockStateChanged({
        accounts: t,
        isUnlocked: o
      }), this._handleAccountsChanged(t);
    } catch (t) {
      ct.error("Torus: Failed to get initial state. Please report this bug.", t);
    } finally {
      ct.info("initialized provider state"), this._state.initialized = !0, this.emit("_initialized");
    }
  }
  /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */
  _rpcRequest(t, r) {
    let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, s = r;
    const u = t;
    if (!Array.isArray(u)) {
      if (u.jsonrpc || (u.jsonrpc = "2.0"), u.method === "solana_accounts" || u.method === "solana_requestAccounts")
        s = (f, h) => {
          this._handleAccountsChanged(h.result || [], u.method === "solana_accounts", o), r(f, h);
        };
      else if (u.method === "wallet_getProviderState") {
        this._rpcEngine.handle(t, s);
        return;
      }
    }
    this.tryWindowHandle(u, s);
  }
  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param chainId - The ID of the newly connected chain.
   * emits TorusInpageProvider#connect
   */
  _handleConnect(t) {
    this._state.isConnected || (this._state.isConnected = !0, this.emit("connect", {
      chainId: t
    }), ct.debug(In.info.connected(t)));
  }
  /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits TorusInpageProvider#disconnect
   */
  _handleDisconnect(t, r) {
    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !t) {
      this._state.isConnected = !1;
      let o;
      t ? (o = new sn.EthereumRpcError(
        1013,
        // Try again later
        r || In.errors.disconnected()
      ), ct.debug(o)) : (o = new sn.EthereumRpcError(
        1011,
        // Internal error
        r || In.errors.permanentlyDisconnected()
      ), ct.error(o), this.chainId = null, this._state.accounts = null, this.selectedAddress = null, this._state.isUnlocked = !1, this._state.isPermanentlyDisconnected = !0), this.emit("disconnect", o);
    }
  }
  /**
   * Called when accounts may have changed.
   */
  _handleAccountsChanged(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, s = t;
    Array.isArray(s) || (ct.error("Torus: Received non-array accounts parameter. Please report this bug.", s), s = []);
    for (const u of t)
      if (typeof u != "string") {
        ct.error("Torus: Received non-string account. Please report this bug.", t), s = [];
        break;
      }
    yN(this._state.accounts, s) || (r && Array.isArray(this._state.accounts) && this._state.accounts.length > 0 && !o && ct.error('Torus: "solana_accounts" unexpectedly updated accounts. Please report this bug.', s), this._state.accounts = s, this.emit("accountsChanged", s)), this.selectedAddress !== s[0] && (this.selectedAddress = s[0] || null);
  }
  /**
   * Upon receipt of a new chainId and networkVersion, emits corresponding
   * events and sets relevant public state.
   * Does nothing if neither the chainId nor the networkVersion are different
   * from existing values.
   *
   * emits TorusInpageProvider#chainChanged
   * @param networkInfo - An object with network info.
   */
  _handleChainChanged() {
    let {
      chainId: t
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!t) {
      ct.error("Torus: Received invalid network parameters. Please report this bug.", {
        chainId: t
      });
      return;
    }
    t === "loading" ? this._handleDisconnect(!0) : (this._handleConnect(t), t !== this.chainId && (this.chainId = t, this._state.initialized && this.emit("chainChanged", this.chainId)));
  }
  /**
   * Upon receipt of a new isUnlocked state, sets relevant public state.
   * Calls the accounts changed handler with the received accounts, or an empty
   * array.
   *
   * Does nothing if the received value is equal to the existing value.
   * There are no lock/unlock events.
   *
   * @param opts - Options bag.
   */
  _handleUnlockStateChanged() {
    let {
      accounts: t,
      isUnlocked: r
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (typeof r != "boolean") {
      ct.error("Torus: Received invalid isUnlocked parameter. Please report this bug.", {
        isUnlocked: r
      });
      return;
    }
    r !== this._state.isUnlocked && (this._state.isUnlocked = r, this._handleAccountsChanged(t || []));
  }
}
Ne(yf, "_defaultState", {
  accounts: null,
  isConnected: !1,
  isUnlocked: !1,
  initialized: !1,
  isPermanentlyDisconnected: !1,
  hasEmittedConnection: !1
});
function Yb(e) {
  return new Promise((t, r) => {
    try {
      const o = document.createElement("img");
      o.onload = () => t(!0), o.onerror = () => t(!1), o.src = e;
    } catch (o) {
      r(o);
    }
  });
}
const BN = (e) => {
  const {
    document: t
  } = e, r = t.querySelector('head > meta[property="og:site_name"]');
  if (r)
    return r.content;
  const o = t.querySelector('head > meta[name="title"]');
  return o ? o.content : t.title && t.title.length > 0 ? t.title : e.location.hostname;
};
async function NN(e) {
  try {
    const {
      document: t
    } = e;
    let r = t.querySelector('head > link[rel="shortcut icon"]');
    return r && await Yb(r.href) || (r = Array.from(t.querySelectorAll('head > link[rel="icon"]')).find((o) => !!o.href), r && await Yb(r.href)) ? r.href : "";
  } catch {
    return "";
  }
}
const $N = async () => ({
  name: BN(window),
  icon: await NN(window)
});
function Xb(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(s) {
      return Object.getOwnPropertyDescriptor(e, s).enumerable;
    })), r.push.apply(r, o);
  }
  return r;
}
function Ec(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Xb(Object(r), !0).forEach(function(o) {
      Ne(e, o, r[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Xb(Object(r)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(r, o));
    });
  }
  return e;
}
const MN = ["send_transaction", "sign_transaction", "sign_all_transactions", "sign_message", "connect"], xN = [Sn.SET_PROVIDER], DN = ON("localStorage");
(async function() {
  try {
    if (typeof document > "u") return;
    const t = document.createElement("link"), {
      torusUrl: r
    } = await uw("production");
    t.href = `${r}/frame`, t.crossOrigin = "anonymous", t.type = "text/html", t.rel = "prefetch", t.relList && t.relList.supports && t.relList.supports("prefetch") && document.head.appendChild(t);
  } catch (t) {
    ct.warn(t);
  }
})();
class n$ {
  constructor() {
    let {
      modalZIndex: t = 99999
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Ne(this, "isInitialized", void 0), Ne(this, "torusAlert", void 0), Ne(this, "modalZIndex", void 0), Ne(this, "alertZIndex", void 0), Ne(this, "requestedLoginProvider", void 0), Ne(this, "provider", void 0), Ne(this, "communicationProvider", void 0), Ne(this, "dappStorageKey", void 0), Ne(this, "isTopupHidden", !1), Ne(this, "torusAlertContainer", void 0), Ne(this, "torusUrl", void 0), Ne(this, "torusIframe", void 0), Ne(this, "styleLink", void 0), this.torusUrl = "", this.isInitialized = !1, this.requestedLoginProvider = null, this.modalZIndex = t, this.alertZIndex = t + 1e3, this.dappStorageKey = "";
  }
  get isLoggedIn() {
    return this.communicationProvider ? this.communicationProvider.isLoggedIn : !1;
  }
  async init() {
    let {
      buildEnv: t = mN.PRODUCTION,
      enableLogging: r = !1,
      network: o,
      showTorusButton: s = !1,
      useLocalStorage: u = !1,
      buttonPosition: f = Ts.BOTTOM_LEFT,
      apiKey: h = "torus-default",
      extraParams: l = {},
      whiteLabel: p
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this.isInitialized) throw new Error("Already initialized");
    const {
      torusUrl: b,
      logLevel: w
    } = await uw(t);
    ct.enableAll(), ct.info(b, "url loaded"), ct.info(`Solana Embed Version :${wN}`), this.torusUrl = b, ct.setDefaultLevel(w), r ? ct.enableAll() : ct.disableAll();
    const I = this.handleDappStorageKey(u), A = new URL(b);
    A.pathname.endsWith("/") ? A.pathname += "frame" : A.pathname += "/frame";
    const x = new URLSearchParams();
    I && x.append("dappStorageKey", I), x.append("origin", window.location.origin), A.hash = x.toString(), this.torusIframe = Bo(`<iframe
        id="torusIframe"
        class="torusIframe"
        src="${A.href}"
        style="display: none; position: fixed; top: 0; right: 0; width: 100%;
        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex.toString()}"
      ></iframe>`), this.torusAlertContainer = Bo(`<div id="torusAlertContainer" style="display:none; z-index: ${this.alertZIndex.toString()}"></div>`), this.styleLink = Bo(`<link href="${b}/css/widget.css" rel="stylesheet" type="text/css">`);
    const v = async () => new Promise((C, B) => {
      try {
        window.document.head.appendChild(this.styleLink), window.document.body.appendChild(this.torusIframe), window.document.body.appendChild(this.torusAlertContainer), this.torusIframe.addEventListener("load", async () => {
          const P = await $N();
          this.torusIframe.contentWindow.postMessage({
            buttonPosition: f,
            apiKey: h,
            network: o,
            dappMetadata: P,
            extraParams: l,
            whiteLabel: p
          }, A.origin), await this._setupWeb3({
            torusUrl: b
          }), s && this.showTorusButton(), p != null && p.topupHide ? this.isTopupHidden = p.topupHide : this.hideTorusButton(), this.isInitialized = !0, window.torus = this, C();
        });
      } catch (P) {
        B(P);
      }
    });
    await cw(), await v();
  }
  async login() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!this.isInitialized) throw new Error("Call init() first");
    try {
      this.requestedLoginProvider = t.loginProvider || null, this.requestedLoginProvider || this.communicationProvider._displayIframe({
        isFull: !0
      });
      const r = await new Promise((o, s) => {
        this.provider._rpcRequest({
          method: "solana_requestAccounts",
          params: [this.requestedLoginProvider, t.login_hint]
        }, Yc(o, s));
      });
      if (Array.isArray(r) && r.length > 0)
        return r;
      throw new Error("Login failed");
    } catch (r) {
      throw ct.error("login failed", r), r;
    } finally {
      this.communicationProvider.isIFrameFullScreen && this.communicationProvider._displayIframe();
    }
  }
  async loginWithPrivateKey(t) {
    if (!this.isInitialized) throw new Error("Call init() first");
    const {
      privateKey: r,
      userInfo: o
    } = t, {
      success: s
    } = await this.communicationProvider.request({
      method: "login_with_private_key",
      params: {
        privateKey: r,
        userInfo: o
      }
    });
    if (!s) throw new Error("Login Failed");
  }
  async logout() {
    if (!this.communicationProvider.isLoggedIn) throw new Error("Not logged in");
    await this.communicationProvider.request({
      method: Sn.LOGOUT,
      params: []
    }), this.requestedLoginProvider = null;
  }
  async cleanUp() {
    this.communicationProvider.isLoggedIn && await this.logout(), this.clearInit();
  }
  clearInit() {
    function t(r) {
      return r instanceof Element || r instanceof Document;
    }
    t(this.styleLink) && window.document.body.contains(this.styleLink) && (this.styleLink.remove(), this.styleLink = void 0), t(this.torusIframe) && window.document.body.contains(this.torusIframe) && (this.torusIframe.remove(), this.torusIframe = void 0), t(this.torusAlertContainer) && window.document.body.contains(this.torusAlertContainer) && (this.torusAlert = void 0, this.torusAlertContainer.remove(), this.torusAlertContainer = void 0), this.isInitialized = !1;
  }
  hideTorusButton() {
    this.communicationProvider.hideTorusButton();
  }
  showTorusButton() {
    this.communicationProvider.showTorusButton();
  }
  async setProvider(t) {
    await this.communicationProvider.request({
      method: Sn.SET_PROVIDER,
      params: Ec({}, t)
    });
  }
  async showWallet(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const o = await this.communicationProvider.request({
      method: Sn.WALLET_INSTANCE_ID,
      params: []
    }), s = t ? `/${t}` : "", u = new URL(`${this.torusUrl}/wallet${s}`);
    u.searchParams.append("instanceId", o), Object.keys(r).forEach((h) => {
      u.searchParams.append(h, r[h]);
    }), this.dappStorageKey && (u.hash = `#dappStorageKey=${this.dappStorageKey}`), new dw({
      url: u,
      features: Cs(TN)
    }).open();
  }
  async getUserInfo() {
    return await this.communicationProvider.request({
      method: Sn.USER_INFO,
      params: []
    });
  }
  async initiateTopup(t, r) {
    if (!this.isInitialized) throw new Error("Torus is not initialized");
    const o = cu();
    return this.communicationProvider._handleWindow(o), await this.communicationProvider.request({
      method: Sn.TOPUP,
      params: {
        provider: t,
        params: r,
        windowId: o
      }
    });
  }
  // Solana specific API
  async getAccounts() {
    return await this.provider.request({
      method: "getAccounts",
      params: []
    });
  }
  async sendTransaction(t) {
    const r = du(t), o = r ? t.serialize({
      requireAllSignatures: !1
    }).toString("hex") : le.Buffer.from(t.serialize()).toString("hex");
    return await this.provider.request({
      method: "send_transaction",
      params: {
        message: o,
        isLegacyTransaction: r
      }
    });
  }
  // support sendOptions
  async signAndSendTransaction(t, r) {
    const o = du(t), s = o ? t.serialize({
      requireAllSignatures: !1
    }).toString("hex") : le.Buffer.from(t.serialize()).toString("hex");
    return {
      signature: await this.provider.request({
        method: "send_transaction",
        params: {
          message: s,
          options: r,
          isLegacyTransaction: o
        }
      })
    };
  }
  async signTransaction(t) {
    const r = du(t), o = r ? t.serializeMessage().toString("hex") : le.Buffer.from(t.message.serialize()).toString("hex"), s = await this.provider.request({
      method: "sign_transaction",
      params: {
        message: o,
        messageOnly: !0,
        isLegacyTransaction: r
      }
    }), u = JSON.parse(s), f = {
      publicKey: new zg(u.publicKey),
      signature: le.Buffer.from(u.signature, "hex")
    };
    return t.addSignature(f.publicKey, f.signature), t;
  }
  async signAllTransactions(t) {
    let r;
    const o = t.map((f) => (r = du(f), r ? f.serializeMessage().toString("hex") : le.Buffer.from(f.message.serialize()).toString("hex"))), u = (await this.provider.request({
      method: "sign_all_transactions",
      params: {
        message: o,
        messageOnly: !0,
        isLegacyTransaction: r
      }
    })).map((f) => {
      const h = JSON.parse(f);
      return {
        publicKey: new zg(h.publicKey),
        signature: le.Buffer.from(h.signature, "hex")
      };
    });
    return t.forEach((f, h) => (f.addSignature(u[h].publicKey, u[h].signature), f)), t;
  }
  async signMessage(t) {
    return await this.provider.request({
      method: "sign_message",
      params: {
        data: t
      }
    });
  }
  async getGaslessPublicKey() {
    return await this.provider.request({
      method: "get_gasless_public_key",
      params: []
    });
  }
  // async connect(): Promise<boolean> {
  //   const response = (await this.provider.request({
  //     method: "connect",
  //     params: {},
  //   })) as boolean;
  //   return response;
  // }
  handleDappStorageKey(t) {
    const r = `${Hd.localStorageKeyPrefix}${window.location.hostname}`;
    let o = "";
    if (DN && t) {
      const s = window.localStorage.getItem(r);
      if (s) o = s;
      else {
        const u = `torus-app-${cu()}`;
        window.localStorage.setItem(r, u), o = u;
      }
    }
    return this.dappStorageKey = o, o;
  }
  async _setupWeb3(t) {
    ct.info("setupWeb3 running");
    const r = new Hb({
      name: "embed_torus",
      target: "iframe_torus",
      targetWindow: this.torusIframe.contentWindow
    }), o = new Hb({
      name: "embed_communication",
      target: "iframe_communication",
      targetWindow: this.torusIframe.contentWindow
    }), s = new yf(r, {}), u = new _f(o, {});
    s.tryWindowHandle = (p, b) => {
      const w = p;
      if (!Array.isArray(w) && MN.includes(w.method)) {
        if (!this.communicationProvider.isLoggedIn) throw new Error("User Not Logged In");
        const I = cu();
        u._handleWindow(I, {
          target: "_blank",
          features: Cs(fw)
        }), w.windowId = I;
      }
      s._rpcEngine.handle(w, b);
    }, u.tryWindowHandle = (p, b) => {
      const w = p;
      if (!Array.isArray(w) && xN.includes(w.method)) {
        const I = cu();
        u._handleWindow(I, {
          target: "_blank",
          features: Cs(AN)
          // todo: are these features generic for all
        }), w.params.windowId = I;
      }
      u._rpcEngine.handle(w, b);
    };
    const f = (p) => {
      const b = s[p], w = this;
      s[p] = function(A, x) {
        const {
          method: v,
          params: C = []
        } = A;
        if (v === "solana_requestAccounts") {
          if (!x) return w.login({
            loginProvider: C[0]
          });
          w.login({
            loginProvider: C[0]
          }).then((B) => x(null, B)).catch((B) => x(B));
        }
        return b.apply(this, [A, x]);
      };
    };
    f("request"), f("sendAsync"), f("send");
    const h = new Proxy(s, {
      // straight up lie that we deleted the property so that it doesn't
      // throw an error in strict mode
      deleteProperty: () => !0
    }), l = new Proxy(u, {
      // straight up lie that we deleted the property so that it doesn't
      // throw an error in strict mode
      deleteProperty: () => !0
    });
    this.provider = h, this.communicationProvider = l, await Promise.all([s._initializeState(), u._initializeState(Ec(Ec({}, t), {}, {
      dappStorageKey: this.dappStorageKey,
      torusAlertContainer: this.torusAlertContainer,
      torusIframe: this.torusIframe
    }))]), ct.debug("Torus - injected provider");
  }
}
export {
  Ts as BUTTON_POSITION,
  mN as TORUS_BUILD_ENV,
  yf as TorusInPageProvider,
  n$ as default
};
