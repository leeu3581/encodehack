var D = Object.defineProperty;
var G = (e) => {
  throw TypeError(e);
};
var O = (e, t, s) => t in e ? D(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s;
var l = (e, t, s) => O(e, typeof t != "symbol" ? t + "" : t, s), S = (e, t, s) => t.has(e) || G("Cannot " + s);
var h = (e, t, s) => (S(e, t, "read from private field"), s ? s.call(e) : t.get(e)), u = (e, t, s) => t.has(e) ? G("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, s), o = (e, t, s, i) => (S(e, t, "write to private field"), i ? i.call(e, s) : t.set(e, s), s);
var E = (e, t, s, i) => ({
  set _(r) {
    o(e, t, r, s);
  },
  get _() {
    return h(e, t, i);
  }
});
import { A as W, d as b, W as $, E as f, P as M, a as R, b as j, c as q, _ as z } from "./index-CGIqRhuR.mjs";
var a, c;
const w = class w extends W {
  /**
   *  Creates a new **NonceManager** to manage %%signer%%.
   */
  constructor(s) {
    super(s.provider);
    /**
     *  The Signer being managed.
     */
    l(this, "signer");
    u(this, a);
    u(this, c);
    b(this, { signer: s }), o(this, a, null), o(this, c, 0);
  }
  async getAddress() {
    return this.signer.getAddress();
  }
  connect(s) {
    return new w(this.signer.connect(s));
  }
  async getNonce(s) {
    if (s === "pending") {
      h(this, a) == null && o(this, a, super.getNonce("pending"));
      const i = h(this, c);
      return await h(this, a) + i;
    }
    return super.getNonce(s);
  }
  /**
   *  Manually increment the nonce. This may be useful when managng
   *  offline transactions.
   */
  increment() {
    E(this, c)._++;
  }
  /**
   *  Resets the nonce, causing the **NonceManager** to reload the current
   *  nonce from the blockchain on the next transaction.
   */
  reset() {
    o(this, c, 0), o(this, a, null);
  }
  async sendTransaction(s) {
    const i = this.getNonce("pending");
    return this.increment(), s = await this.signer.populateTransaction(s), s.nonce = await i, await this.signer.sendTransaction(s);
  }
  signTransaction(s) {
    return this.signer.signTransaction(s);
  }
  signMessage(s) {
    return this.signer.signMessage(s);
  }
  signTypedData(s, i, r) {
    return this.signer.signTypedData(s, i, r);
  }
};
a = new WeakMap(), c = new WeakMap();
let P = w;
async function H(e, t, s) {
  const i = typeof t == "string" ? new $(t, e) : t, r = (s == null ? void 0 : s.chain) ?? (await f.chainFromRpc(e))[1], n = new P(i);
  if (n.provider === null)
    try {
      n.connect(e);
    } catch (g) {
      console.error("Cannot connect to network for signer", g);
    }
  return new I(r, await i.getAddress(), n, s);
}
class I extends M {
  constructor(s, i, r, n) {
    super(s, i, r);
    l(this, "opts");
    this.opts = n;
  }
  chain() {
    return this._chain;
  }
  address() {
    return this._address;
  }
  async sign(s) {
    var v, y, C, T, x, A, F;
    const i = this.chain(), r = [];
    let n = 500000n, g = 100000000000n, m = 1500000000n, p = 100000000n;
    if (((v = this.opts) == null ? void 0 : v.overrides) === void 0 && i !== "Celo") {
      const d = await this._signer.provider.getFeeData();
      g = d.gasPrice ?? g, m = d.maxFeePerGas ?? m, p = d.maxPriorityFeePerGas ?? p;
    }
    ((y = this.opts) == null ? void 0 : y.gasLimit) !== void 0 && (n = this.opts.gasLimit), ((C = this.opts) == null ? void 0 : C.maxGasLimit) !== void 0 && (n = n > ((T = this.opts) == null ? void 0 : T.maxGasLimit) ? (x = this.opts) == null ? void 0 : x.maxGasLimit : n);
    const L = i === "Oasis" ? { gasLimit: n, gasPrice: g, type: 0 } : { gasLimit: n, maxFeePerGas: m, maxPriorityFeePerGas: p };
    for (const d of s) {
      const { transaction: N, description: _ } = d;
      (A = this.opts) != null && A.debug && console.log(`Signing: ${_} for ${this.address()}`);
      const B = {
        ...N,
        ...L,
        from: this.address(),
        nonce: await this._signer.getNonce(),
        // Override any existing values with those passed in the constructor
        ...(F = this.opts) == null ? void 0 : F.overrides
      };
      r.push(await this._signer.signTransaction(B));
    }
    return r;
  }
}
const Q = {
  Address: j,
  Platform: f,
  getSigner: H,
  protocols: {
    WormholeCore: () => import("./index-CGIqRhuR.mjs").then((e) => e.dF),
    TokenBridge: () => import("./index-Bfj3CEir.mjs"),
    PorticoBridge: () => import("./index-CrHXilI7.mjs"),
    CircleBridge: () => import("./index-BfNT53vo.mjs"),
    TBTCBridge: () => import("./index-Bo9Gy0wt.mjs")
  },
  getChain: (e, t, s) => new R(t, new f(e, q(e, z, {
    [t]: s
  })))
};
export {
  Q as default
};
