"use strict";var b=Object.defineProperty;var T=(g,s,t)=>s in g?b(g,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):g[s]=t;var o=(g,s,t)=>T(g,typeof s!="symbol"?s+"":s,t);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const a=require("./index-Cq7ztix4.js"),I=[["Testnet",{tokenMessengerState:"0x5252abd1137094ed1db3e0d75bc36abcd287aee4bc310f8e047727ef5682e7c2",messageTransmitterState:"0x98234bd0fa9ac12cc0a20a144a22e36d6a32f7e0a97baaeaf9c76cdc6d122d2e",usdcTreasury:"0x7170137d4a6431bf83351ac025baf462909bffe2877d87716374fb42b9629ebe"}],["Mainnet",{tokenMessengerState:"0x45993eecc0382f37419864992c12faee2238f5cfe22b98ad3bf455baf65c8a2f",messageTransmitterState:"0xf68268c3d9b1df3215f2439400c1c4ea08ac4ef4bb7d6f3ca6a2a239e17510af",usdcTreasury:"0x57d6725e7a8b49a7b2a612f6bd66ab5f39fc95332ca48be421c3229d514a6de7"}]],k=a.constMap(I,[0,1]);class l{constructor(s,t,r,e){o(this,"network");o(this,"chain");o(this,"provider");o(this,"contracts");o(this,"usdcId");o(this,"usdcTreasuryId");o(this,"tokenMessengerId");o(this,"tokenMessengerStateId");o(this,"messageTransmitterId");o(this,"messageTransmitterStateId");var u,m,h,f;if(this.network=s,this.chain=t,this.provider=r,this.contracts=e,s==="Devnet")throw new Error("CircleBridge not supported on Devnet");const n=a.usdcContract.get(this.network,this.chain);if(!n)throw new Error(`No USDC contract configured for network=${this.network} chain=${this.chain}`);const{tokenMessengerState:c,messageTransmitterState:i,usdcTreasury:d}=k(s);if(!((u=e.cctp)!=null&&u.tokenMessenger))throw new Error(`Circle Token Messenger contract for domain ${t} not found`);if(!((m=e.cctp)!=null&&m.messageTransmitter))throw new Error(`Circle Message Transmitter contract for domain ${t} not found`);this.usdcId=n,this.usdcTreasuryId=d,this.tokenMessengerId=(h=e.cctp)==null?void 0:h.tokenMessenger,this.messageTransmitterId=(f=e.cctp)==null?void 0:f.messageTransmitter,this.tokenMessengerStateId=c,this.messageTransmitterStateId=i}async*transfer(s,t,r){const e=new a.Transaction$1,n=a.circleChainId.get(this.network,t.chain),[c,...i]=await a.SuiPlatform.getCoins(this.provider,s,this.usdcId);if(c===void 0)throw new Error("No USDC in wallet");const d=e.object(c.coinObjectId);i.length>0&&e.mergeCoins(d,i.map(m=>e.object(m.coinObjectId)));const[u]=e.splitCoins(d,[r]);e.moveCall({target:`${this.tokenMessengerId}::deposit_for_burn::deposit_for_burn`,arguments:[u,e.pure.u32(n),e.pure.address(t.address.toUniversalAddress().toString()),e.object(this.tokenMessengerStateId),e.object(this.messageTransmitterStateId),e.object("0x403"),e.object(this.usdcTreasuryId)],typeArguments:[this.usdcId]}),yield this.createUnsignedTx(e,"Sui.CircleBridge.Transfer")}async isTransferCompleted(s){const t=new a.Transaction$1;t.moveCall({target:`${this.messageTransmitterId}::state::is_nonce_used`,arguments:[t.object(this.messageTransmitterStateId),t.pure.u32(s.sourceDomain),t.pure.u64(s.nonce)]});const r=await this.provider.devInspectTransactionBlock({sender:"0x0000000000000000000000000000000000000000000000000000000000000000",transactionBlock:t});try{return!!r.results[0].returnValues[0][0][0]}catch(e){return console.error(`Error reading if nonce was used: ${e}`),!1}}async*redeem(s,t,r){const e=new a.Transaction$1,[n]=e.moveCall({target:`${this.messageTransmitterId}::receive_message::receive_message`,arguments:[e.pure.vector("u8",a.CircleBridge.serialize(t)),e.pure.vector("u8",a.hex.decode(r)),e.object(this.messageTransmitterStateId)]});if(!n)throw new Error("Failed to produce receipt");const[c]=e.moveCall({target:`${this.tokenMessengerId}::handle_receive_message::handle_receive_message`,arguments:[n,e.object(this.tokenMessengerStateId),e.object("0x403"),e.object(this.usdcTreasuryId)],typeArguments:[this.usdcId]});if(!c)throw new Error("Failed to produce stamp receipt ticket with burn message");const[i]=e.moveCall({target:`${this.tokenMessengerId}::handle_receive_message::deconstruct_stamp_receipt_ticket_with_burn_message`,arguments:[c]});if(!i)throw new Error("Failed to produce stamp receipt ticket");const[d]=e.moveCall({target:`${this.messageTransmitterId}::receive_message::stamp_receipt`,arguments:[i,e.object(this.messageTransmitterStateId)],typeArguments:[`${this.tokenMessengerId}::message_transmitter_authenticator::MessageTransmitterAuthenticator`]});if(!d)throw new Error("Failed to produce stamped receipt");e.moveCall({target:`${this.messageTransmitterId}::receive_message::complete_receive_message`,arguments:[d,e.object(this.messageTransmitterStateId)]}),yield this.createUnsignedTx(e,"Sui.CircleBridge.Redeem")}async parseTransactionDetails(s){var p;const t=await this.provider.waitForTransaction({digest:s,options:{showEvents:!0,showEffects:!0,showInput:!0}});if(!t)throw new Error("Transaction not found");if(!t.events)throw new Error("Transaction events not found");const r=(p=t.events)==null?void 0:p.find(w=>w.type.includes("send_message::MessageSent"));if(!r)throw new Error("No MessageSent event found");const e=new Uint8Array((r==null?void 0:r.parsedJson).message),[n,c]=a.CircleBridge.deserialize(e),{payload:i}=n,d=i.messageSender,u=i.mintRecipient,m=a.toCircleChain(this.network,n.sourceDomain),h=a.toCircleChain(this.network,n.destinationDomain),f={chain:m,address:i.burnToken};return{from:{chain:m,address:d},to:{chain:h,address:u},token:f,amount:i.amount,message:n,id:{hash:c}}}static async fromRpc(s,t){const[r,e]=await a.SuiPlatform.chainFromRpc(s),n=t[e];if(n.network!==r)throw new Error(`Network mismatch: ${n.network} != ${r}`);return new l(r,e,s,n.contracts)}createUnsignedTx(s,t,r=!1){return new a.SuiUnsignedTransaction(s,this.network,this.chain,t,r)}}a.registerProtocol("Sui","CircleBridge",l);exports.SuiCircleBridge=l;
