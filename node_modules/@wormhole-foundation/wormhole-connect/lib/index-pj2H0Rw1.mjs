var k = Object.defineProperty;
var v = (u, s, t) => s in u ? k(u, s, { enumerable: !0, configurable: !0, writable: !0, value: t }) : u[s] = t;
var i = (u, s, t) => v(u, typeof s != "symbol" ? s + "" : s, t);
import { cn as C, bs as S, cw as f, bq as _, I as w, br as b, r as y, bt as T, cJ as M, bf as x } from "./index-CGIqRhuR.mjs";
const j = [
  [
    "Testnet",
    {
      tokenMessengerState: "0x5252abd1137094ed1db3e0d75bc36abcd287aee4bc310f8e047727ef5682e7c2",
      messageTransmitterState: "0x98234bd0fa9ac12cc0a20a144a22e36d6a32f7e0a97baaeaf9c76cdc6d122d2e",
      usdcTreasury: "0x7170137d4a6431bf83351ac025baf462909bffe2877d87716374fb42b9629ebe"
    }
  ],
  [
    "Mainnet",
    {
      tokenMessengerState: "0x45993eecc0382f37419864992c12faee2238f5cfe22b98ad3bf455baf65c8a2f",
      messageTransmitterState: "0xf68268c3d9b1df3215f2439400c1c4ea08ac4ef4bb7d6f3ca6a2a239e17510af",
      usdcTreasury: "0x57d6725e7a8b49a7b2a612f6bd66ab5f39fc95332ca48be421c3229d514a6de7"
    }
  ]
], E = C(j, [0, 1]);
class p {
  constructor(s, t, r, e) {
    i(this, "network");
    i(this, "chain");
    i(this, "provider");
    i(this, "contracts");
    i(this, "usdcId");
    i(this, "usdcTreasuryId");
    i(this, "tokenMessengerId");
    i(this, "tokenMessengerStateId");
    i(this, "messageTransmitterId");
    i(this, "messageTransmitterStateId");
    var m, d, g, h;
    if (this.network = s, this.chain = t, this.provider = r, this.contracts = e, s === "Devnet")
      throw new Error("CircleBridge not supported on Devnet");
    const n = S.get(this.network, this.chain);
    if (!n)
      throw new Error(`No USDC contract configured for network=${this.network} chain=${this.chain}`);
    const { tokenMessengerState: o, messageTransmitterState: a, usdcTreasury: c } = E(s);
    if (!((m = e.cctp) != null && m.tokenMessenger))
      throw new Error(`Circle Token Messenger contract for domain ${t} not found`);
    if (!((d = e.cctp) != null && d.messageTransmitter))
      throw new Error(`Circle Message Transmitter contract for domain ${t} not found`);
    this.usdcId = n, this.usdcTreasuryId = c, this.tokenMessengerId = (g = e.cctp) == null ? void 0 : g.tokenMessenger, this.messageTransmitterId = (h = e.cctp) == null ? void 0 : h.messageTransmitter, this.tokenMessengerStateId = o, this.messageTransmitterStateId = a;
  }
  async *transfer(s, t, r) {
    const e = new f(), n = _.get(this.network, t.chain), [o, ...a] = await w.getCoins(this.provider, s, this.usdcId);
    if (o === void 0)
      throw new Error("No USDC in wallet");
    const c = e.object(o.coinObjectId);
    a.length > 0 && e.mergeCoins(c, a.map((d) => e.object(d.coinObjectId)));
    const [m] = e.splitCoins(c, [r]);
    e.moveCall({
      target: `${this.tokenMessengerId}::deposit_for_burn::deposit_for_burn`,
      arguments: [
        m,
        e.pure.u32(n),
        // destination_domain
        e.pure.address(t.address.toUniversalAddress().toString()),
        // mint_recipient
        e.object(this.tokenMessengerStateId),
        // token_messenger_minter state
        e.object(this.messageTransmitterStateId),
        // message_transmitter state
        e.object("0x403"),
        // deny_list id, fixed address
        e.object(this.usdcTreasuryId)
        // treasury object Treasury<USDC>
      ],
      typeArguments: [this.usdcId]
    }), yield this.createUnsignedTx(e, "Sui.CircleBridge.Transfer");
  }
  async isTransferCompleted(s) {
    const t = new f();
    t.moveCall({
      target: `${this.messageTransmitterId}::state::is_nonce_used`,
      arguments: [
        t.object(this.messageTransmitterStateId),
        t.pure.u32(s.sourceDomain),
        t.pure.u64(s.nonce)
      ]
    });
    const r = await this.provider.devInspectTransactionBlock({
      sender: "0x0000000000000000000000000000000000000000000000000000000000000000",
      transactionBlock: t
    });
    try {
      return !!r.results[0].returnValues[0][0][0];
    } catch (e) {
      return console.error(`Error reading if nonce was used: ${e}`), !1;
    }
  }
  async *redeem(s, t, r) {
    const e = new f(), [n] = e.moveCall({
      target: `${this.messageTransmitterId}::receive_message::receive_message`,
      arguments: [
        e.pure.vector("u8", b.serialize(t)),
        e.pure.vector("u8", y.decode(r)),
        e.object(this.messageTransmitterStateId)
        // message_transmitter state
      ]
    });
    if (!n)
      throw new Error("Failed to produce receipt");
    const [o] = e.moveCall({
      target: `${this.tokenMessengerId}::handle_receive_message::handle_receive_message`,
      arguments: [
        n,
        // Receipt object returned from receive_message call
        e.object(this.tokenMessengerStateId),
        // token_messenger_minter state
        e.object("0x403"),
        // deny list, fixed address
        e.object(this.usdcTreasuryId)
        // usdc treasury object Treasury<T>
      ],
      typeArguments: [this.usdcId]
    });
    if (!o)
      throw new Error("Failed to produce stamp receipt ticket with burn message");
    const [a] = e.moveCall({
      target: `${this.tokenMessengerId}::handle_receive_message::deconstruct_stamp_receipt_ticket_with_burn_message`,
      arguments: [o]
    });
    if (!a)
      throw new Error("Failed to produce stamp receipt ticket");
    const [c] = e.moveCall({
      target: `${this.messageTransmitterId}::receive_message::stamp_receipt`,
      arguments: [
        a,
        // Receipt ticket returned from deconstruct_stamp_receipt_ticket_with_burn_message call
        e.object(this.messageTransmitterStateId)
        // message_transmitter state
      ],
      typeArguments: [
        `${this.tokenMessengerId}::message_transmitter_authenticator::MessageTransmitterAuthenticator`
      ]
    });
    if (!c)
      throw new Error("Failed to produce stamped receipt");
    e.moveCall({
      target: `${this.messageTransmitterId}::receive_message::complete_receive_message`,
      arguments: [
        c,
        // Stamped receipt object returned from handle_receive_message call
        e.object(this.messageTransmitterStateId)
        // message_transmitter state
      ]
    }), yield this.createUnsignedTx(e, "Sui.CircleBridge.Redeem");
  }
  async parseTransactionDetails(s) {
    var l;
    const t = await this.provider.waitForTransaction({
      digest: s,
      options: { showEvents: !0, showEffects: !0, showInput: !0 }
    });
    if (!t)
      throw new Error("Transaction not found");
    if (!t.events)
      throw new Error("Transaction events not found");
    const r = (l = t.events) == null ? void 0 : l.find((I) => I.type.includes("send_message::MessageSent"));
    if (!r)
      throw new Error("No MessageSent event found");
    const e = new Uint8Array((r == null ? void 0 : r.parsedJson).message), [n, o] = b.deserialize(e), { payload: a } = n, c = a.messageSender, m = a.mintRecipient, d = T(this.network, n.sourceDomain), g = T(this.network, n.destinationDomain), h = { chain: d, address: a.burnToken };
    return {
      from: { chain: d, address: c },
      to: { chain: g, address: m },
      token: h,
      amount: a.amount,
      message: n,
      id: { hash: o }
    };
  }
  static async fromRpc(s, t) {
    const [r, e] = await w.chainFromRpc(s), n = t[e];
    if (n.network !== r)
      throw new Error(`Network mismatch: ${n.network} != ${r}`);
    return new p(r, e, s, n.contracts);
  }
  createUnsignedTx(s, t, r = !1) {
    return new M(s, this.network, this.chain, t, r);
  }
}
x("Sui", "CircleBridge", p);
export {
  p as SuiCircleBridge
};
