var j = Object.defineProperty;
var Y = (r, e, t) => e in r ? j(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var w = (r, e, t) => Y(r, typeof e != "symbol" ? e + "" : e, t);
import { s as S, t as m, u as x, v as J, w as X, x as Q, y as N, z as R, B as ee, D as W, F as M, G as te, H as d, I, J as re, K as ne, c as se, L as ie } from "./index-CGIqRhuR.mjs";
import { m as oe } from "./index-CGBpqVZc.mjs";
var E = {};
Object.defineProperty(E, "__esModule", { value: !0 });
E.bech32m = b = E.bech32 = void 0;
const K = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", z = {};
for (let r = 0; r < K.length; r++) {
  const e = K.charAt(r);
  z[e] = r;
}
function y(r) {
  const e = r >> 25;
  return (r & 33554431) << 5 ^ -(e >> 0 & 1) & 996825010 ^ -(e >> 1 & 1) & 642813549 ^ -(e >> 2 & 1) & 513874426 ^ -(e >> 3 & 1) & 1027748829 ^ -(e >> 4 & 1) & 705979059;
}
function T(r) {
  let e = 1;
  for (let t = 0; t < r.length; ++t) {
    const n = r.charCodeAt(t);
    if (n < 33 || n > 126)
      return "Invalid prefix (" + r + ")";
    e = y(e) ^ n >> 5;
  }
  e = y(e);
  for (let t = 0; t < r.length; ++t) {
    const n = r.charCodeAt(t);
    e = y(e) ^ n & 31;
  }
  return e;
}
function k(r, e, t, n) {
  let i = 0, o = 0;
  const s = (1 << t) - 1, c = [];
  for (let a = 0; a < r.length; ++a)
    for (i = i << e | r[a], o += e; o >= t; )
      o -= t, c.push(i >> o & s);
  if (n)
    o > 0 && c.push(i << t - o & s);
  else {
    if (o >= e)
      return "Excess padding";
    if (i << t - o & s)
      return "Non-zero padding";
  }
  return c;
}
function ce(r) {
  return k(r, 8, 5, !0);
}
function ae(r) {
  const e = k(r, 5, 8, !1);
  if (Array.isArray(e))
    return e;
}
function ue(r) {
  const e = k(r, 5, 8, !1);
  if (Array.isArray(e))
    return e;
  throw new Error(e);
}
function F(r) {
  let e;
  r === "bech32" ? e = 1 : e = 734539939;
  function t(s, c, a) {
    if (a = a || 90, s.length + 7 + c.length > a)
      throw new TypeError("Exceeds length limit");
    s = s.toLowerCase();
    let l = T(s);
    if (typeof l == "string")
      throw new Error(l);
    let f = s + "1";
    for (let u = 0; u < c.length; ++u) {
      const h = c[u];
      if (h >> 5)
        throw new Error("Non 5-bit word");
      l = y(l) ^ h, f += K.charAt(h);
    }
    for (let u = 0; u < 6; ++u)
      l = y(l);
    l ^= e;
    for (let u = 0; u < 6; ++u) {
      const h = l >> (5 - u) * 5 & 31;
      f += K.charAt(h);
    }
    return f;
  }
  function n(s, c) {
    if (c = c || 90, s.length < 8)
      return s + " too short";
    if (s.length > c)
      return "Exceeds length limit";
    const a = s.toLowerCase(), l = s.toUpperCase();
    if (s !== a && s !== l)
      return "Mixed-case string " + s;
    s = a;
    const f = s.lastIndexOf("1");
    if (f === -1)
      return "No separator character for " + s;
    if (f === 0)
      return "Missing prefix for " + s;
    const u = s.slice(0, f), h = s.slice(f + 1);
    if (h.length < 6)
      return "Data too short";
    let p = T(u);
    if (typeof p == "string")
      return p;
    const D = [];
    for (let v = 0; v < h.length; ++v) {
      const C = h.charAt(v), _ = z[C];
      if (_ === void 0)
        return "Unknown character " + C;
      p = y(p) ^ _, !(v + 6 >= h.length) && D.push(_);
    }
    return p !== e ? "Invalid checksum for " + s : { prefix: u, words: D };
  }
  function i(s, c) {
    const a = n(s, c);
    if (typeof a == "object")
      return a;
  }
  function o(s, c) {
    const a = n(s, c);
    if (typeof a == "object")
      return a;
    throw new Error(a);
  }
  return {
    decodeUnsafe: i,
    decode: o,
    encode: t,
    toWords: ce,
    fromWordsUnsafe: ae,
    fromWords: ue
  };
}
var b = E.bech32 = F("bech32");
E.bech32m = F("bech32m");
function O(r, e) {
  return S.IntentMessage(S.fixedArray(e.length, S.u8())).serialize({
    intent: {
      scope: { [r]: !0 },
      version: { V0: !0 },
      appId: { Sui: !0 }
    },
    value: e
  }).toBytes();
}
const B = {
  ED25519: 0,
  Secp256k1: 1,
  Secp256r1: 2,
  MultiSig: 3,
  ZkLogin: 5,
  Passkey: 6
}, le = {
  ED25519: 32,
  Secp256k1: 33,
  Secp256r1: 33
}, V = {
  0: "ED25519",
  1: "Secp256k1",
  2: "Secp256r1",
  3: "MultiSig",
  5: "ZkLogin",
  6: "Passkey"
};
function $(r, e) {
  if (r === e) return !0;
  if (r.length !== e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (r[t] !== e[t])
      return !1;
  return !0;
}
class he {
  /**
   * Checks if two public keys are equal
   */
  equals(e) {
    return $(this.toRawBytes(), e.toRawBytes());
  }
  /**
   * Return the base-64 representation of the public key
   */
  toBase64() {
    return m(this.toRawBytes());
  }
  toString() {
    throw new Error(
      "`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead."
    );
  }
  /**
   * Return the Sui representation of the public key encoded in
   * base-64. A Sui public key is formed by the concatenation
   * of the scheme flag with the raw bytes of the public key
   */
  toSuiPublicKey() {
    const e = this.toSuiBytes();
    return m(e);
  }
  verifyWithIntent(e, t, n) {
    const i = O(n, e), o = x(i, { dkLen: 32 });
    return this.verify(o, t);
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(e, t) {
    return this.verifyWithIntent(
      S.vector(S.u8()).serialize(e).toBytes(),
      t,
      "PersonalMessage"
    );
  }
  /**
   * Verifies that the signature is valid for for the provided Transaction
   */
  verifyTransaction(e, t) {
    return this.verifyWithIntent(e, t, "TransactionData");
  }
  /**
   * Verifies that the public key is associated with the provided address
   */
  verifyAddress(e) {
    return this.toSuiAddress() === e;
  }
  /**
   * Returns the bytes representation of the public key
   * prefixed with the signature scheme flag
   */
  toSuiBytes() {
    const e = this.toRawBytes(), t = new Uint8Array(e.length + 1);
    return t.set([this.flag()]), t.set(e, 1), t;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  toSuiAddress() {
    return J(
      X(x(this.toSuiBytes(), { dkLen: 32 })).slice(0, Q * 2)
    );
  }
}
function de(r) {
  const e = N(r), t = V[e[0]];
  switch (t) {
    case "ED25519":
    case "Secp256k1":
    case "Secp256r1":
      const n = le[t], i = e.slice(1, e.length - n), o = e.slice(1 + i.length);
      return {
        serializedSignature: r,
        signatureScheme: t,
        signature: i,
        publicKey: o,
        bytes: e
      };
    default:
      throw new Error("Unsupported signature scheme");
  }
}
function fe({
  signature: r,
  signatureScheme: e,
  publicKey: t
}) {
  if (!t)
    throw new Error("`publicKey` is required");
  const n = t.toRawBytes(), i = new Uint8Array(1 + r.length + n.length);
  return i.set([B[e]]), i.set(r, 1), i.set(n, 1 + r.length), m(i);
}
const A = 32, G = "suiprivkey";
class ge {
  /**
   * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,
   * it ensures that a signed message is tied to a specific purpose and domain separator is provided
   */
  async signWithIntent(e, t) {
    const n = O(t, e), i = x(n, { dkLen: 32 });
    return {
      signature: fe({
        signature: await this.sign(i),
        signatureScheme: this.getKeyScheme(),
        publicKey: this.getPublicKey()
      }),
      bytes: m(e)
    };
  }
  /**
   * Signs provided transaction by calling `signWithIntent()` with a `TransactionData` provided as intent scope
   */
  async signTransaction(e) {
    return this.signWithIntent(e, "TransactionData");
  }
  /**
   * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope
   */
  async signPersonalMessage(e) {
    const { signature: t } = await this.signWithIntent(
      R.vector(R.u8()).serialize(e).toBytes(),
      "PersonalMessage"
    );
    return {
      bytes: m(e),
      signature: t
    };
  }
  toSuiAddress() {
    return this.getPublicKey().toSuiAddress();
  }
}
class ye extends ge {
}
function pe(r) {
  const { prefix: e, words: t } = b.decode(r);
  if (e !== G)
    throw new Error("invalid private key prefix");
  const n = new Uint8Array(b.fromWords(t)), i = n.slice(1);
  return {
    schema: V[n[0]],
    secretKey: i
  };
}
function we(r, e) {
  if (r.length !== A)
    throw new Error("Invalid bytes length");
  const t = B[e], n = new Uint8Array(r.length + 1);
  return n.set([t]), n.set(r, 1), b.encode(G, b.toWords(n));
}
function U(r) {
  return !!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(r);
}
function Se(r) {
  return oe(r, "");
}
function me(r) {
  return ee(Se(r));
}
const Ee = "ed25519 seed", be = 2147483648, ve = new RegExp("^m(\\/[0-9]+')+$"), q = (r) => r.replace("'", ""), Ae = (r) => {
  const t = W.create(M, Ee).update(te(r)).digest(), n = t.slice(0, 32), i = t.slice(32);
  return {
    key: n,
    chainCode: i
  };
}, Ke = ({ key: r, chainCode: e }, t) => {
  const n = new ArrayBuffer(4);
  new DataView(n).setUint32(0, t);
  const o = new Uint8Array(1 + r.length + n.byteLength);
  o.set(new Uint8Array(1).fill(0)), o.set(r, 1), o.set(new Uint8Array(n, 0, n.byteLength), r.length + 1);
  const s = W.create(M, e).update(o).digest(), c = s.slice(0, 32), a = s.slice(32);
  return {
    key: c,
    chainCode: a
  };
}, _e = (r) => ve.test(r) ? !r.split("/").slice(1).map(q).some(
  isNaN
  /* ts T_T*/
) : !1, L = (r, e, t = be) => {
  if (!_e(r))
    throw new Error("Invalid derivation path");
  const { key: n, chainCode: i } = Ae(e);
  return r.split("/").slice(1).map(q).map((s) => parseInt(s, 10)).reduce((s, c) => Ke(s, c + t), {
    key: n,
    chainCode: i
  });
}, P = 32;
class Z extends he {
  /**
   * Create a new Ed25519PublicKey object
   * @param value ed25519 public key as buffer or base-64 encoded string
   */
  constructor(e) {
    if (super(), typeof e == "string" ? this.data = N(e) : e instanceof Uint8Array ? this.data = e : this.data = Uint8Array.from(e), this.data.length !== P)
      throw new Error(
        `Invalid public key input. Expected ${P} bytes, got ${this.data.length}`
      );
  }
  /**
   * Checks if two Ed25519 public keys are equal
   */
  equals(e) {
    return super.equals(e);
  }
  /**
   * Return the byte array representation of the Ed25519 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  flag() {
    return B.ED25519;
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(e, t) {
    let n;
    if (typeof t == "string") {
      const i = de(t);
      if (i.signatureScheme !== "ED25519")
        throw new Error("Invalid signature scheme");
      if (!$(this.toRawBytes(), i.publicKey))
        throw new Error("Signature does not match public key");
      n = i.signature;
    } else
      n = t;
    return d.verify(n, e, this.toRawBytes());
  }
}
Z.SIZE = P;
const H = "m/44'/784'/0'/0'/0'";
class g extends ye {
  /**
   * Create a new Ed25519 keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param keypair Ed25519 keypair
   */
  constructor(e) {
    if (super(), e)
      this.keypair = {
        publicKey: e.publicKey,
        secretKey: e.secretKey.slice(0, 32)
      };
    else {
      const t = d.utils.randomPrivateKey();
      this.keypair = {
        publicKey: d.getPublicKey(t),
        secretKey: t
      };
    }
  }
  /**
   * Get the key scheme of the keypair ED25519
   */
  getKeyScheme() {
    return "ED25519";
  }
  /**
   * Generate a new random Ed25519 keypair
   */
  static generate() {
    const e = d.utils.randomPrivateKey();
    return new g({
      publicKey: d.getPublicKey(e),
      secretKey: e
    });
  }
  /**
   * Create a Ed25519 keypair from a raw secret key byte array, also known as seed.
   * This is NOT the private scalar which is result of hashing and bit clamping of
   * the raw secret key.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key as a byte array or Bech32 secret key string
   * @param options: skip secret key validation
   */
  static fromSecretKey(e, t) {
    if (typeof e == "string") {
      const o = pe(e);
      if (o.schema !== "ED25519")
        throw new Error(`Expected a ED25519 keypair, got ${o.schema}`);
      return this.fromSecretKey(o.secretKey, t);
    }
    const n = e.length;
    if (n !== A)
      throw new Error(
        `Wrong secretKey size. Expected ${A} bytes, got ${n}.`
      );
    const i = {
      publicKey: d.getPublicKey(e),
      secretKey: e
    };
    if (!t || !t.skipValidation) {
      const s = new TextEncoder().encode("sui validation"), c = d.sign(s, e);
      if (!d.verify(c, s, i.publicKey))
        throw new Error("provided secretKey is invalid");
    }
    return new g(i);
  }
  /**
   * The public key for this Ed25519 keypair
   */
  getPublicKey() {
    return new Z(this.keypair.publicKey);
  }
  /**
   * The Bech32 secret key string for this Ed25519 keypair
   */
  getSecretKey() {
    return we(
      this.keypair.secretKey.slice(0, A),
      this.getKeyScheme()
    );
  }
  /**
   * Return the signature for the provided data using Ed25519.
   */
  async sign(e) {
    return d.sign(e, this.keypair.secretKey);
  }
  /**
   * Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized
   * and validated against the english wordlist.
   *
   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
   */
  static deriveKeypair(e, t) {
    if (t == null && (t = H), !U(t))
      throw new Error("Invalid derivation path");
    const { key: n } = L(t, me(e));
    return g.fromSecretKey(n);
  }
  /**
   * Derive Ed25519 keypair from mnemonicSeed and path.
   *
   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
   */
  static deriveKeypairFromSeed(e, t) {
    if (t == null && (t = H), !U(t))
      throw new Error("Invalid derivation path");
    const { key: n } = L(t, e);
    return g.fromSecretKey(n);
  }
}
async function xe(r, e) {
  const [, t] = await I.chainFromRpc(r);
  return new Ie(t, r, g.deriveKeypair(e, "m/44'/784'/0'/0'/0'"));
}
class Ie {
  constructor(e, t, n, i) {
    w(this, "_chain");
    w(this, "_client");
    w(this, "_signer");
    w(this, "_debug");
    this._chain = e, this._client = t, this._signer = n, this._debug = i;
  }
  chain() {
    return this._chain;
  }
  address() {
    return this._signer.toSuiAddress();
  }
  async signAndSend(e) {
    const t = [];
    for (const n of e) {
      const { description: i, transaction: o } = n;
      this._debug && console.log(`Signing ${i} for ${this.address()}`);
      try {
        const s = await this._client.signAndExecuteTransaction({
          transaction: o,
          signer: this._signer
        });
        t.push(s.digest);
      } catch (s) {
        throw s;
      }
    }
    return t;
  }
}
const De = {
  Address: ne,
  Platform: I,
  getSigner: xe,
  protocols: {
    WormholeCore: () => import("./index-D4ZaKfyX.mjs"),
    TokenBridge: () => import("./index-YnxPKgPu.mjs"),
    CircleBridge: () => import("./index-pj2H0Rw1.mjs")
  },
  getChain: (r, e, t) => new re(e, new I(r, se(r, ie, { [e]: t })))
};
export {
  De as default
};
