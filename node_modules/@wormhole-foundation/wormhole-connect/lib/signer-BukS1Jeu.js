"use strict";var k=Object.defineProperty;var B=(i,t,e)=>t in i?k(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var f=(i,t,e)=>B(i,typeof t!="symbol"?t+"":t,e);const a=require("./index-Cq7ztix4.js"),y=.5,F=1,b=1,E=1e8,T=5,x=25e4;async function I(i,t,e){const[n,r]=await a.SolanaPlatform.chainFromRpc(i),s=typeof t=="string"?a.Keypair.fromSecretKey(a.b58.decode(t)):t;if(e!=null&&e.priorityFee&&e.priorityFee.percentile&&e.priorityFee.percentile>1)throw new Error("priorityFeePercentile must be a number between 0 and 1");return new R(i,r,s,(e==null?void 0:e.debug)??!1,(e==null?void 0:e.priorityFee)??{},(e==null?void 0:e.retries)??T,e==null?void 0:e.sendOpts)}class R{constructor(t,e,n,r=!1,s,c=T,d){f(this,"_rpc");f(this,"_chain");f(this,"_keypair");f(this,"_debug");f(this,"_priorityFee");f(this,"_maxResubmits");f(this,"_sendOpts");this._rpc=t,this._chain=e,this._keypair=n,this._debug=r,this._priorityFee=s,this._maxResubmits=c,this._sendOpts=d,this._sendOpts=this._sendOpts??{preflightCommitment:this._rpc.commitment}}chain(){return this._chain}address(){return this._keypair.publicKey.toBase58()}retryable(t){var n;if(t instanceof a.TransactionExpiredBlockheightExceededError)return!0;if(!(t instanceof a.SendTransactionError)||!t.message.includes("Transaction simulation failed"))return!1;if(t.message.includes("Blockhash not found"))return!0;const e=(n=t.logs)==null?void 0:n.find(r=>r.startsWith("Program log: Error: "));return e?!!(e.includes("Not enough bytes")||e.includes("Unexpected length of input")):!1}async signAndSend(t){var d;let{blockhash:e,lastValidBlockHeight:n}=await a.SolanaPlatform.latestBlock(this._rpc);const r=[];for(const l of t){const{description:g,transaction:{transaction:o,signers:u}}=l;this._debug&&console.log(`Signing: ${g} for ${this.address()}`);let h;(d=this._priorityFee)!=null&&d.percentile&&this._priorityFee.percentile>0&&(h=await M(this._rpc,o,this._priorityFee.percentile,this._priorityFee.percentileMultiple,this._priorityFee.min,this._priorityFee.max)),this._debug&&A(o);for(let m=0;m<this._maxResubmits;m++)try{if(a.isVersionedTransaction(o)){if(h&&m===0){const _=a.TransactionMessage.decompile(o.message);_.instructions.push(...h),o.message=_.compileToV0Message()}o.message.recentBlockhash=e,o.sign([this._keypair,...u??[]])}else h&&m===0&&o.add(...h),o.recentBlockhash=e,o.lastValidBlockHeight=n,o.partialSign(this._keypair,...u??[]);this._debug&&console.log("Submitting transactions ");const{signature:p}=await a.SolanaPlatform.sendTxWithRetry(this._rpc,o.serialize(),this._sendOpts);r.push(p);break}catch(p){if(m===this._maxResubmits-1||!this.retryable(p))throw p;this._debug&&console.log(`Failed to send transaction on attempt ${m}, retrying: `,p);const{blockhash:_,lastValidBlockHeight:S}=await a.SolanaPlatform.latestBlock(this._rpc);n=S,e=_}}this._debug&&console.log("Waiting for confirmation for: ",r);const c=(await Promise.all(r.map(async l=>{try{return await this._rpc.confirmTransaction({signature:l,blockhash:e,lastValidBlockHeight:n},this._rpc.commitment)}catch(g){throw console.error("Failed to confirm transaction: ",g),g}}))).filter(l=>l.value.err).map(l=>l.value.err);if(c.length>0)throw new Error(`Failed to confirm transaction: ${c}`);return r}}function A(i){if(a.isVersionedTransaction(i)){console.log(i.signatures);const t=i.message,e=t.getAccountKeys();t.compiledInstructions.forEach(n=>{console.log("Program",e.get(n.programIdIndex).toBase58()),console.log("Data: ",a.hex.encode(n.data)),console.log("Keys: ",n.accountKeyIndexes.map(r=>[r,e.get(r).toBase58()]))})}else console.log(i.signatures),console.log(i.feePayer),i.instructions.forEach(t=>{console.log("Program",t.programId.toBase58()),console.log("Data: ",t.data.toString("hex")),console.log("Keys: ",t.keys.map(e=>[e,e.pubkey.toBase58()]))})}async function M(i,t,e=y,n=F,r=b,s=E){const[c,d]=await Promise.all([L(i,t),P(i,t,e,n,r,s)]);return[a.ComputeBudgetProgram.setComputeUnitLimit({units:c}),a.ComputeBudgetProgram.setComputeUnitPrice({microLamports:d})]}async function L(i,t){var n;let e=x;try{const r=await(a.isVersionedTransaction(t),i.simulateTransaction(t));r.value.err&&console.error(`Error simulating Solana transaction: ${r.value.err}`),(n=r==null?void 0:r.value)!=null&&n.unitsConsumed&&(e=Math.round(r.value.unitsConsumed*1.2))}catch(r){console.error(`Failed to calculate compute unit limit for Solana transaction: ${r}`)}return e}async function w(i,t){if(a.isVersionedTransaction(t)){const e=(await Promise.all(t.message.addressTableLookups.map(s=>i.getAddressLookupTable(s.accountKey)))).map(s=>s.value).filter(s=>s!==null),n=t.message,r=n.getAccountKeys({addressLookupTableAccounts:e??void 0});return n.compiledInstructions.flatMap(s=>s.accountKeyIndexes).map(s=>n.isAccountWritable(s)?r.get(s):null).filter(Boolean)}else return t.instructions.flatMap(e=>e.keys).map(e=>e.isWritable?e.pubkey:null).filter(Boolean)}async function P(i,t,e=y,n=F,r=b,s=E){let c=r;const d=await w(i,t);try{const l=await i.getRecentPrioritizationFees({lockedWritableAccounts:d});if(l){const g=l.map(u=>u.prioritizationFee).sort((u,h)=>u-h),o=Math.ceil(g.length*e);if(g.length>o){let u=g[o];n>0&&(u*=n),c=Math.max(c,u)}}}catch(l){console.error("Error fetching Solana recent fees",l)}return Math.min(Math.max(c,r),s)}async function U(i,t,e=y,n=F,r=b,s=E){const c=e*1e4;if(c<1||c>1e4)throw new Error("percentile must be between 0.0001 and 1");const d=i._rpcRequest,g=[await w(i,t),{percentile:c}],o=await d("getRecentPrioritizationFees",g);if(o.error)throw new Error(o.error);const u=o.result.map(m=>m.prioritizationFee);if(u.length===0)return r;const h=Math.floor(a.median(u)*(n>0?n:1));return a.bound(h,r,s)}exports.determinePriorityFee=P;exports.determinePriorityFeeTritonOne=U;exports.getSolanaSignAndSendSigner=I;
