"use strict";var _=Object.defineProperty;var G=s=>{throw TypeError(s)};var D=(s,i,e)=>i in s?_(s,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[i]=e;var f=(s,i,e)=>D(s,typeof i!="symbol"?i+"":i,e),q=(s,i,e)=>i.has(s)||G("Cannot "+e);var l=(s,i,e)=>(q(s,i,"read from private field"),e?e.call(s):i.get(s)),p=(s,i,e)=>i.has(s)?G("Cannot add the same private member more than once"):i instanceof WeakSet?i.add(s):i.set(s,e),c=(s,i,e,t)=>(q(s,i,"write to private field"),t?t.call(s,e):i.set(s,e),e);var A=(s,i,e,t)=>({set _(a){c(s,i,a,e)},get _(){return l(s,i,t)}});Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const r=require("./index-Cq7ztix4.js");var o,g;const v=class v extends r.AbstractSigner{constructor(e){super(e.provider);f(this,"signer");p(this,o);p(this,g);r.defineProperties(this,{signer:e}),c(this,o,null),c(this,g,0)}async getAddress(){return this.signer.getAddress()}connect(e){return new v(this.signer.connect(e))}async getNonce(e){if(e==="pending"){l(this,o)==null&&c(this,o,super.getNonce("pending"));const t=l(this,g);return await l(this,o)+t}return super.getNonce(e)}increment(){A(this,g)._++}reset(){c(this,g,0),c(this,o,null)}async sendTransaction(e){const t=this.getNonce("pending");return this.increment(),e=await this.signer.populateTransaction(e),e.nonce=await t,await this.signer.sendTransaction(e)}signTransaction(e){return this.signer.signTransaction(e)}signMessage(e){return this.signer.signMessage(e)}signTypedData(e,t,a){return this.signer.signTypedData(e,t,a)}};o=new WeakMap,g=new WeakMap;let P=v;async function O(s,i,e){const t=typeof i=="string"?new r.Wallet(i,s):i,a=(e==null?void 0:e.chain)??(await r.EvmPlatform.chainFromRpc(s))[1],n=new P(t);if(n.provider===null)try{n.connect(s)}catch(d){console.error("Cannot connect to network for signer",d)}return new b(a,await t.getAddress(),n,e)}class b extends r.PlatformNativeSigner{constructor(e,t,a,n){super(e,t,a);f(this,"opts");this.opts=n}chain(){return this._chain}address(){return this._address}async sign(e){var w,y,T,C,x,S,E;const t=this.chain(),a=[];let n=500000n,d=100000000000n,m=1500000000n,u=100000000n;if(((w=this.opts)==null?void 0:w.overrides)===void 0&&t!=="Celo"){const h=await this._signer.provider.getFeeData();d=h.gasPrice??d,m=h.maxFeePerGas??m,u=h.maxPriorityFeePerGas??u}((y=this.opts)==null?void 0:y.gasLimit)!==void 0&&(n=this.opts.gasLimit),((T=this.opts)==null?void 0:T.maxGasLimit)!==void 0&&(n=n>((C=this.opts)==null?void 0:C.maxGasLimit)?(x=this.opts)==null?void 0:x.maxGasLimit:n);const F=t==="Oasis"?{gasLimit:n,gasPrice:d,type:0}:{gasLimit:n,maxFeePerGas:m,maxPriorityFeePerGas:u};for(const h of e){const{transaction:L,description:N}=h;(S=this.opts)!=null&&S.debug&&console.log(`Signing: ${N} for ${this.address()}`);const B={...L,...F,from:this.address(),nonce:await this._signer.getNonce(),...(E=this.opts)==null?void 0:E.overrides};a.push(await this._signer.signTransaction(B))}return a}}const $={Address:r.EvmAddress,Platform:r.EvmPlatform,getSigner:O,protocols:{WormholeCore:()=>Promise.resolve().then(()=>require("./index-Cq7ztix4.js")).then(s=>s.index$1),TokenBridge:()=>Promise.resolve().then(()=>require("./index-BRAjbwxR.js")),PorticoBridge:()=>Promise.resolve().then(()=>require("./index-DZuIxiYZ.js")),CircleBridge:()=>Promise.resolve().then(()=>require("./index-F1y8fDnw.js")),TBTCBridge:()=>Promise.resolve().then(()=>require("./index-8EJVgSN2.js"))},getChain:(s,i,e)=>new r.EvmChain(i,new r.EvmPlatform(s,r.applyChainsConfigConfigOverrides(s,r._platform,{[i]:e})))};exports.default=$;
