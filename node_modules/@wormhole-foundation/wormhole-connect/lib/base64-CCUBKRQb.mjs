import { O as x } from "./index-CGIqRhuR.mjs";
const s = typeof x.Buffer == "function", h = typeof TextDecoder == "function" ? new TextDecoder() : void 0, c = typeof TextEncoder == "function" ? new TextEncoder() : void 0, C = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", d = Array.prototype.slice.call(C), l = ((t) => {
  let e = {};
  return t.forEach((o, n) => e[o] = n), e;
})(d), m = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, r = String.fromCharCode.bind(String), A = typeof Uint8Array.from == "function" ? Uint8Array.from.bind(Uint8Array) : (t) => new Uint8Array(Array.prototype.slice.call(t, 0)), _ = (t) => t.replace(/=/g, "").replace(/[+\/]/g, (e) => e == "+" ? "-" : "_"), p = (t) => t.replace(/[^A-Za-z0-9\+\/]/g, ""), F = (t) => {
  let e, o, n, f, a = "";
  const i = t.length % 3;
  for (let u = 0; u < t.length; ) {
    if ((o = t.charCodeAt(u++)) > 255 || (n = t.charCodeAt(u++)) > 255 || (f = t.charCodeAt(u++)) > 255)
      throw new TypeError("invalid character found");
    e = o << 16 | n << 8 | f, a += d[e >> 18 & 63] + d[e >> 12 & 63] + d[e >> 6 & 63] + d[e & 63];
  }
  return i ? a.slice(0, i - 3) + "===".substring(i) : a;
}, g = typeof btoa == "function" ? (t) => btoa(t) : s ? (t) => x.Buffer.from(t, "binary").toString("base64") : F, B = s ? (t) => x.Buffer.from(t).toString("base64") : (t) => {
  let o = [];
  for (let n = 0, f = t.length; n < f; n += 4096)
    o.push(r.apply(null, t.subarray(n, n + 4096)));
  return g(o.join(""));
}, D = (t) => {
  if (t.length < 2) {
    var e = t.charCodeAt(0);
    return e < 128 ? t : e < 2048 ? r(192 | e >>> 6) + r(128 | e & 63) : r(224 | e >>> 12 & 15) + r(128 | e >>> 6 & 63) + r(128 | e & 63);
  } else {
    var e = 65536 + (t.charCodeAt(0) - 55296) * 1024 + (t.charCodeAt(1) - 56320);
    return r(240 | e >>> 18 & 7) + r(128 | e >>> 12 & 63) + r(128 | e >>> 6 & 63) + r(128 | e & 63);
  }
}, U = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, w = (t) => t.replace(U, D), b = s ? (t) => x.Buffer.from(t, "utf8").toString("base64") : c ? (t) => B(c.encode(t)) : (t) => g(w(t)), E = (t, e = !1) => e ? _(b(t)) : b(t), j = (t) => E(t, !0), S = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, T = (t) => {
  switch (t.length) {
    case 4:
      var e = (7 & t.charCodeAt(0)) << 18 | (63 & t.charCodeAt(1)) << 12 | (63 & t.charCodeAt(2)) << 6 | 63 & t.charCodeAt(3), o = e - 65536;
      return r((o >>> 10) + 55296) + r((o & 1023) + 56320);
    case 3:
      return r((15 & t.charCodeAt(0)) << 12 | (63 & t.charCodeAt(1)) << 6 | 63 & t.charCodeAt(2));
    default:
      return r((31 & t.charCodeAt(0)) << 6 | 63 & t.charCodeAt(1));
  }
}, v = (t) => t.replace(S, T), z = (t) => {
  if (t = t.replace(/\s+/g, ""), !m.test(t))
    throw new TypeError("malformed base64.");
  t += "==".slice(2 - (t.length & 3));
  let e, o = "", n, f;
  for (let a = 0; a < t.length; )
    e = l[t.charAt(a++)] << 18 | l[t.charAt(a++)] << 12 | (n = l[t.charAt(a++)]) << 6 | (f = l[t.charAt(a++)]), o += n === 64 ? r(e >> 16 & 255) : f === 64 ? r(e >> 16 & 255, e >> 8 & 255) : r(e >> 16 & 255, e >> 8 & 255, e & 255);
  return o;
}, y = typeof atob == "function" ? (t) => atob(p(t)) : s ? (t) => x.Buffer.from(t, "base64").toString("binary") : z, Z = s ? (t) => A(x.Buffer.from(t, "base64")) : (t) => A(y(t).split("").map((e) => e.charCodeAt(0))), I = s ? (t) => x.Buffer.from(t, "base64").toString("utf8") : h ? (t) => h.decode(Z(t)) : (t) => v(y(t)), P = (t) => p(t.replace(/[-_]/g, (e) => e == "-" ? "+" : "/")), k = (t) => I(P(t));
export {
  k as d,
  j as e
};
