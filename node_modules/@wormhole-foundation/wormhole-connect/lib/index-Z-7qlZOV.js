"use strict";var $=Object.defineProperty;var U=(k,r,t)=>r in k?$(k,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):k[r]=t;var w=(k,r,t)=>U(k,typeof r!="symbol"?r+"":r,t);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const e=require("./index-Cq7ztix4.js");require("./index-BbtasVJX.js");const B=async(k,r,t)=>{var l,n,o;if(!e.isValidSuiType(t))throw new Error(`Invalid Sui type: ${t}`);const c=await e.getObjectFields(k,r);if(!c)throw new Error(`Unable to fetch object fields from token bridge state. Object ID: ${r}`);const i=(n=(l=c.token_registry.fields)==null?void 0:l.id)==null?void 0:n.id;if(!i)throw new Error("Unable to fetch token registry object ID");const a=e.getPackageIdFromType((o=c.token_registry)==null?void 0:o.type);if(!a)throw new Error("Unable to fetch token registry package ID");return k.getDynamicFieldObject({parentId:i,name:{type:`${a}::token_registry::Key<${t}>`,value:{dummy_field:!1}}})},_=async(k,r,t,c)=>{var s,f,p,y;const i=await e.getObjectFields(k,r);if(!i)throw new Error("Unable to fetch object fields from token bridge state");const a=(f=(s=i.token_registry)==null?void 0:s.fields)==null?void 0:f.coin_types,l=(y=(p=a==null?void 0:a.fields)==null?void 0:p.id)==null?void 0:y.id;if(!l)throw new Error("Unable to fetch coin types");const n=e.getTableKeyType(a==null?void 0:a.type);if(!n)throw new Error("Unable to get key type");const o=await k.getDynamicFieldObject({parentId:l,name:{type:n,value:{addr:[...t],chain:c}}});if(o.error){if(o.error.code==="dynamicFieldNotFound")return null;throw new Error(`Unexpected getDynamicFieldObject response ${o.error}`)}const g=e.getFieldsFromObjectResponse(o);if(!g)return null;if(!e.isMoveStructObject(g))throw new Error("What?");return"value"in g?e.trimSuiType(g.value):null};class S{constructor(r,t,c,i){w(this,"network");w(this,"chain");w(this,"provider");w(this,"contracts");w(this,"coreBridgeObjectId");w(this,"tokenBridgeObjectId");w(this,"chainId");this.network=r,this.chain=t,this.provider=c,this.contracts=i,this.chainId=e.networkChainToNativeChainId.get(r,t);const a=this.contracts.tokenBridge;if(!a)throw new Error(`Wormhole Token Bridge contract for domain ${t} not found`);const l=this.contracts.coreBridge;if(!l)throw new Error(`Wormhole Token Bridge contract for domain ${t} not found`);this.tokenBridgeObjectId=a,this.coreBridgeObjectId=l}static async fromRpc(r,t){const[c,i]=await e.SuiPlatform.chainFromRpc(r),a=t[i];if(a.network!==c)throw new Error(`Network mismatch: ${a.network} != ${c}`);return new S(c,i,r,a.contracts)}async isWrappedAsset(r){try{return await this.getOriginalAsset(r),!0}catch{return!1}}async getOriginalAsset(r){let t=r.getCoinType();if(!e.isValidSuiType(t))throw new Error(`Invalid Sui type: ${t}`);const c=await B(this.provider,this.tokenBridgeObjectId,t),i=e.getFieldsFromObjectResponse(c);if(!i)throw e.ErrNotWrapped(t);if(!e.isMoveStructObject(i))throw new Error("Expected fields to be a MoveStruct");if(!("value"in i))throw new Error("Expected a `value` key in fields of MoveStruct");const a=i.value;if(!e.isMoveStructStruct(a))throw new Error("Expected fields to be a MoveStruct");const l=e.trimSuiType(a.type);if(t=e.trimSuiType(t),l.includes(`wrapped_asset::WrappedAsset<${t}>`)){const n=a.fields.info;if(!e.isMoveStructStruct(n))throw new Error("Expected fields to be a MoveStruct");const o=n.fields.token_address;if(!e.isMoveStructStruct(o))throw new Error("Expected fields to be a MoveStruct");if(!e.isMoveStructObject(o.fields))throw new Error("Expected address data to be a MoveObject");if(!("value"in o.fields))throw new Error("Expected a `value` key in fields of MoveStruct");const g=o.fields.value;if(!e.isMoveStructStruct(g))throw new Error("Expected fields to be a MoveStruct");const s=new Uint8Array(g.fields.data);return{chain:e.toChain(Number(n.fields.token_chain)),address:new e.UniversalAddress(s)}}throw e.ErrNotWrapped(t)}async getTokenUniversalAddress(r){let t=r.getCoinType();if(!e.isValidSuiType(t))throw new Error(`Invalid Sui type: ${t}`);const c=await B(this.provider,this.tokenBridgeObjectId,t),i=e.getFieldsFromObjectResponse(c);if(!i)throw new Error(`Token of type ${t} has not been registered with the token bridge. Has it been attested?`);if(!e.isMoveStructObject(i))throw new Error("Expected fields to be a MoveStruct");if(!("value"in i))throw new Error("Expected a `value` key in fields of MoveStruct");const a=i.value;if(!e.isMoveStructStruct(a))throw new Error("Expected fields to be a MoveStruct");const l=e.trimSuiType(a.type);if(t=e.trimSuiType(t),l.includes(`native_asset::NativeAsset<${t}>`)){const n=a.fields.token_address;if(!e.isMoveStructStruct(n))throw new Error("Expected fields to be a MoveStruct");if(!("value"in n.fields))throw new Error("Expected a `value` key in fields of MoveStruct");const o=n.fields.value;if(!e.isMoveStructStruct(o))throw new Error("Expected fields to be a MoveStruct");const g=new Uint8Array(o.fields.data);return new e.UniversalAddress(g)}throw new Error(`Token of type ${t} is not a native asset`)}async getTokenNativeAddress(r,t){const c=await _(this.provider,this.tokenBridgeObjectId,t.toUint8Array(),e.toChainId(r));if(!c)throw new Error(`Token ${t.toString()} not found in token registry`);return new e.SuiAddress(c)}async hasWrappedAsset(r){try{return await this.getWrappedAsset(r),!0}catch{}return!1}async getWrappedAsset(r){if(e.isNative(r.address))throw new Error("Token Address required, 'native' literal not supported");const t=await _(this.provider,this.tokenBridgeObjectId,r.address.toUniversalAddress().toUint8Array(),e.toChainId(r.chain));if(!t)throw e.ErrNotWrapped(e.canonicalAddress(r));return e.toNative(this.chain,t)}async isTransferCompleted(r){var n,o,g,s,f,p,y,m;const t=await e.getObjectFields(this.provider,this.tokenBridgeObjectId);if(!t)throw new Error("Unable to fetch object fields from token bridge state");const c=(o=(n=t.consumed_vaas)==null?void 0:n.fields)==null?void 0:o.hashes,i=e.getTableKeyType((s=(g=c==null?void 0:c.fields)==null?void 0:g.items)==null?void 0:s.type);if(!i)throw new Error("Unable to get key type");const a=(m=(y=(p=(f=c==null?void 0:c.fields)==null?void 0:f.items)==null?void 0:p.fields)==null?void 0:y.id)==null?void 0:m.id;if(!a)throw new Error("Unable to fetch consumed VAAs table");const l=await this.provider.getDynamicFieldObject({parentId:a,name:{type:i,value:{data:[...e.keccak_256(r.hash)]}}});if(!l.error)return!0;if(l.error.code==="dynamicFieldNotFound")return!1;throw new Error(`Unexpected getDynamicFieldObject response ${l.error}`)}async*createAttestation(r){const t=0n,i=r.toString(),a=await this.provider.getCoinMetadata({coinType:i});if(a===null||a.id===null)throw new Error(`Coin metadata ID for type ${i} not found`);const[l,n]=await this.getPackageIds(),o=new e.Transaction$1,[g]=o.splitCoins(o.gas,[o.pure.u64(t)]),[s]=o.moveCall({target:`${n}::attest_token::attest_token`,arguments:[o.object(this.tokenBridgeObjectId),o.object(a.id),o.pure.u32(0)],typeArguments:[i]});o.moveCall({target:`${l}::publish_message::publish_message`,arguments:[o.object(this.coreBridgeObjectId),g,s,o.object(e.SUI_CLOCK_OBJECT_ID)]}),yield this.createUnsignedTx(o,"Sui.TokenBridge.CreateAttestation")}async*submitAttestation(r,t){const[c,i]=await this.getPackageIds(),a=t.toString(),l=Math.min(r.payload.decimals,8),n=await this.getCoinBuildOutput(c,i,l),o=await e.publishPackage(n,a);yield this.createUnsignedTx(o,"Sui.TokenBridge.PrepareCreateWrapped");let g="",s="",f="",p="",y="",m=!1;for(;!m;){await new Promise(h=>setTimeout(h,500));const I=await this.provider.queryTransactionBlocks({filter:{FromAddress:a},options:{showObjectChanges:!0},limit:3});for(const h of I.data)if("objectChanges"in h){for(const u of h.objectChanges)e.isSuiPublishEvent(u)&&u.packageId!==void 0?g=u.packageId:e.isSuiCreateEvent(u)&&u.objectType.includes("WrappedAssetSetup")?(s=u.objectId,y=u.objectType.split(", ")[1].replace(">","")):e.isSuiCreateEvent(u)&&u.objectType.includes("UpgradeCap")?f=u.objectId:e.isSuiCreateEvent(u)&&u.objectType.includes("CoinMetadata")&&(p=u.objectId);if(g!==""&&s!==""&&f!==""&&p!==""){m=!0;break}else g="",s="",f="",p=""}}const b=e.getCoinTypeFromPackageId(g),d=new e.Transaction$1,[j]=d.moveCall({target:`${c}::vaa::parse_and_verify`,arguments:[d.object(this.coreBridgeObjectId),d.pure.vector("u8",e.serialize(r)),d.object(e.SUI_CLOCK_OBJECT_ID)]}),[T]=d.moveCall({target:`${i}::vaa::verify_only_once`,arguments:[d.object(this.tokenBridgeObjectId),j]});d.moveCall({target:`${i}::create_wrapped::complete_registration`,arguments:[d.object(this.tokenBridgeObjectId),d.object(p),d.object(s),d.object(f),T],typeArguments:[b,y]}),yield this.createUnsignedTx(d,"Sui.TokenBridge.SubmitAttestation")}async*transfer(r,t,c,i,a){const l=0n,n=0n,g=r.toString(),s=(e.isNative(c)?e.SUI_TYPE_ARG:c).toString(),f=await e.SuiPlatform.getCoins(this.provider,r,s),[p,...y]=f.filter(h=>e.isSameType(h.coinType,s));if(p===void 0)throw new Error(`Coins array doesn't contain any coins of type ${s}`);const[m,b]=await this.getPackageIds(),d=new e.Transaction$1,[j]=(()=>{if(s===e.SUI_TYPE_ARG)return d.splitCoins(d.gas,[d.pure.u64(i)]);{const h=d.object(p.coinObjectId);return y.length&&d.mergeCoins(h,y.map(u=>d.object(u.coinObjectId))),d.splitCoins(h,[d.pure.u64(i)])}})(),[T]=d.splitCoins(d.gas,[d.pure.u64(l)]),[I]=d.moveCall({target:`${b}::state::verified_asset`,arguments:[d.object(this.tokenBridgeObjectId)],typeArguments:[s]});if(a){if(!g)throw new Error("senderAddress is required for transfer with payload");let h=!1;const u=await(async()=>{const O=await e.getOldestEmitterCapObjectId(this.provider,m,g);if(O!==null)return d.object(O);{const[P]=d.moveCall({target:`${m}::emitter::new`,arguments:[d.object(this.coreBridgeObjectId)]});return h=!0,P}})(),[v,A]=d.moveCall({target:`${b}::transfer_tokens_with_payload::prepare_transfer`,arguments:[u,I,j,d.pure.u16(e.toChainId(t.chain)),d.pure.vector("u8",t.address.toUint8Array()),d.pure.vector("u8",a),d.pure.u32(0)],typeArguments:[s]});d.moveCall({target:`${b}::coin_utils::return_nonzero`,arguments:[A],typeArguments:[s]});const[E]=d.moveCall({target:`${b}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[d.object(this.tokenBridgeObjectId),v],typeArguments:[s]});d.moveCall({target:`${m}::publish_message::publish_message`,arguments:[d.object(this.coreBridgeObjectId),T,E,d.object(e.SUI_CLOCK_OBJECT_ID)]}),h&&d.transferObjects([u],d.pure.address(g)),yield this.createUnsignedTx(d,"Sui.TokenBridge.TransferWithPayload")}else{const[h,u]=d.moveCall({target:`${b}::transfer_tokens::prepare_transfer`,arguments:[I,j,d.pure.u16(e.toChainId(t.chain)),d.pure.vector("u8",t.address.toUint8Array()),d.pure.u64(n),d.pure.u32(0)],typeArguments:[s]});d.moveCall({target:`${b}::coin_utils::return_nonzero`,arguments:[u],typeArguments:[s]});const[v]=d.moveCall({target:`${b}::transfer_tokens::transfer_tokens`,arguments:[d.object(this.tokenBridgeObjectId),h],typeArguments:[s]});d.moveCall({target:`${m}::publish_message::publish_message`,arguments:[d.object(this.coreBridgeObjectId),T,v,d.object(e.SUI_CLOCK_OBJECT_ID)]}),yield this.createUnsignedTx(d,"Sui.TokenBridge.Transfer")}}async*redeem(r,t,c=!0){const i=await _(this.provider,this.tokenBridgeObjectId,t.payload.token.address.toUint8Array(),e.toChainId(t.payload.token.chain));if(!i)throw new Error("Unable to fetch token coinType");const[a,l]=await this.getPackageIds(),n=new e.Transaction$1,[o]=n.moveCall({target:`${a}::vaa::parse_and_verify`,arguments:[n.object(this.coreBridgeObjectId),n.pure.vector("u8",e.serialize(t)),n.object(e.SUI_CLOCK_OBJECT_ID)]}),[g]=n.moveCall({target:`${l}::vaa::verify_only_once`,arguments:[n.object(this.tokenBridgeObjectId),o]}),[s]=n.moveCall({target:`${l}::complete_transfer::authorize_transfer`,arguments:[n.object(this.tokenBridgeObjectId),g],typeArguments:[i]}),[f]=n.moveCall({target:`${l}::complete_transfer::redeem_relayer_payout`,arguments:[s],typeArguments:[i]});n.moveCall({target:`${l}::coin_utils::return_nonzero`,arguments:[f],typeArguments:[i]}),yield this.createUnsignedTx(n,"Sui.TokenBridge.Redeem")}async getWrappedNative(){return e.toNative(this.chain,e.SUI_TYPE_ARG)}async getPackageIds(){return Promise.all([e.getPackageId(this.provider,this.coreBridgeObjectId),e.getPackageId(this.provider,this.tokenBridgeObjectId)])}async getCoinBuildOutput(r,t,c){var n;if(c>8)throw new Error("Decimals is capped at 8");const i=(n=await e.getOriginalPackageId(this.provider,this.tokenBridgeObjectId))==null?void 0:n.replace("0x","");if(!i)throw new Error(`Original token bridge package ID not found for object ID ${this.tokenBridgeObjectId}`);const a="a11ceb0b060000000901000a020a14031e1704350405392d07669f01088502600ae502050cea02160004010b010c0205020d000002000201020003030c020001000104020700000700010001090801010c020a050600030803040202000302010702080007080100020800080303090002070801010b020209000901010608010105010b0202080008030209000504434f494e095478436f6e7465787408565f5f305f325f3011577261707065644173736574536574757004636f696e0e6372656174655f777261707065640b64756d6d795f6669656c6404696e697414707265706172655f726567697374726174696f6e0f7075626c69635f7472616e736665720673656e646572087472616e736665720a74785f636f6e746578740f76657273696f6e5f636f6e74726f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002"+i+"00020106010000000001090b0031"+c.toString(16).padStart(2,"0")+"0a0138000b012e110238010200";return{modules:[e.b64.encode(e.hex.decode(a))],dependencies:["0x1","0x2",t,r].map(o=>e.normalizeSuiObjectId(o))}}createUnsignedTx(r,t,c=!1){return new e.SuiUnsignedTransaction(r,this.network,this.chain,t,c)}}class C{constructor(r,t,c,i){w(this,"network");w(this,"chain");w(this,"connection");w(this,"contracts");w(this,"tokenBridgeRelayerObjectId");w(this,"coreBridgeObjectId");w(this,"tokenBridgeObjectId");w(this,"fields");this.network=r,this.chain=t,this.connection=c,this.contracts=i;const{tokenBridge:a,tokenBridgeRelayer:l,coreBridge:n}=i;if(!a||!l||!n)throw new Error(`Some object IDs for ${t} Automatic Token Bridge not found`);this.tokenBridgeRelayerObjectId=l,this.tokenBridgeObjectId=a,this.coreBridgeObjectId=n}static async fromRpc(r,t){const[c,i]=await e.SuiPlatform.chainFromRpc(r),a=t[i];if(a.network!==c)throw new Error(`Network mismatch for chain ${i}: ${a.network} != ${c}`);return new C(c,i,r,a.contracts)}async*transfer(r,t,c,i,a){const n=new e.SuiAddress(e.isNative(c)?e.SuiPlatform.nativeTokenId(this.network,this.chain).address:c).getCoinType(),{coreBridge:o,tokenBridge:g}=await this.getPackageIds(),s=new e.Transaction$1,f=BigInt(0),[p]=s.splitCoins(s.gas,[s.pure.u64(f)]),[y]=await(async()=>{if(e.isNative(c))return s.splitCoins(s.gas,[s.pure.u64(i)]);{const T=await e.SuiPlatform.getCoins(this.connection,r,n),[I,...h]=T.filter(v=>v.coinType===n);if(I===void 0)throw new Error(`Coins array doesn't contain any coins of type ${n}`);const u=s.object(I.coinObjectId);return h.length&&s.mergeCoins(u,h.map(v=>s.object(v.coinObjectId))),s.splitCoins(u,[s.pure.u64(i)])}})(),[m]=s.moveCall({target:`${g}::state::verified_asset`,arguments:[s.object(this.tokenBridgeObjectId)],typeArguments:[n]}),b=await this.getPackageId(),[d]=s.moveCall({target:`${b}::transfer::transfer_tokens_with_relay`,arguments:[s.object(this.tokenBridgeRelayerObjectId),y,m,s.pure.u64(a??0n),s.pure.u16(e.toChainId(t.chain)),s.pure.address(e.hex.encode(t.address.toUint8Array(),!0)),s.pure.u32(123)],typeArguments:[n]}),[j]=s.moveCall({target:`${g}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[s.object(this.tokenBridgeObjectId),d],typeArguments:[n]});s.moveCall({target:`${o}::publish_message::publish_message`,arguments:[s.object(this.coreBridgeObjectId),p,j,s.object(e.SUI_CLOCK_OBJECT_ID)]}),yield this.createUnsignedTx(s,"AutomaticTokenBridge.transfer")}async*redeem(r,t){const{coreBridge:c,tokenBridge:i}=await this.getPackageIds(),{address:a,chain:l}=t.payload.token,n=await _(this.connection,this.tokenBridgeObjectId,a.toUniversalAddress().toUint8Array(),e.toChainId(l));if(!n)throw new Error("Unable to fetch token coinType");const o=new e.Transaction$1,[g]=o.moveCall({target:`${c}::vaa::parse_and_verify`,arguments:[o.object(this.coreBridgeObjectId),o.pure.vector("u8",e.serialize(t)),o.object(e.SUI_CLOCK_OBJECT_ID)]}),[s]=o.moveCall({target:`${i}::vaa::verify_only_once`,arguments:[o.object(this.tokenBridgeObjectId),g]}),[f]=o.moveCall({target:`${i}::complete_transfer_with_payload::authorize_transfer`,arguments:[o.object(this.tokenBridgeObjectId),s],typeArguments:[n]}),p=await this.getPackageId();o.moveCall({target:`${p}::redeem::complete_transfer`,arguments:[o.object(this.tokenBridgeRelayerObjectId),f],typeArguments:[n]}),yield this.createUnsignedTx(o,"AutomaticTokenBridge.redeem")}async getRelayerFee(r,t){const c=e.isNative(t)?e.SuiPlatform.nativeTokenId(this.network,this.chain):t,i=await this.getTokenInfo(c.toString());if(i===null)throw new Error("Unsupported token for relay");const a=await this.getFields(),l=await this.connection.getDynamicFieldObject({parentId:this.tokenBridgeRelayerObjectId,name:{type:"vector<u8>",value:Array.from(e.bytes.encode("relayer_fees"))}});if(!l.data||!l.data.content)throw l.error?new Error("Failed to get relayer fees: "+JSON.stringify(l.error)):new Error("Unable to compute relayer fee");const{content:n}=l.data;if(!e.isMoveStructStruct(n)||!e.isMoveStructId(n.fields.id))throw new Error("Unable to compute relayer fee");const o=await this.connection.getDynamicFieldObject({parentId:n.fields.id.id,name:{type:"u16",value:e.toChainId(r)}});if(!o.data||!o.data.content)throw o.error?new Error("Failed to get relayer fees: "+JSON.stringify(l.error)):new Error("Unable to compute relayer fee");const{content:g}=o.data;if(!e.isMoveStructStruct(g))throw new Error("Unable to compute relayer fee");const s=await e.SuiPlatform.getDecimals(this.chain,this.connection,t.toString()),f=i.swap_rate,p=a.relayer_fee_precision,y=a.swap_rate_precision,m=g.fields.value;return 10n**BigInt(s)*BigInt(m)*BigInt(y)/(BigInt(f)*BigInt(p))}async maxSwapAmount(r){var o,g;const c=(e.isNative(r)?e.SuiPlatform.nativeTokenId(this.network,this.chain):r).toString(),i=await this.connection.getCoinMetadata({coinType:c});if(!i)throw new Error("metadata is null");const a=await this.getPackageId(),l=new e.Transaction$1;l.moveCall({target:`${a}::redeem::calculate_max_swap_amount_in`,arguments:[l.object(this.tokenBridgeRelayerObjectId),l.pure.u8(i.decimals)],typeArguments:[c]});const n=await this.connection.devInspectTransactionBlock({transactionBlock:l,sender:e.hex.encode(new Uint8Array(32))});if(!n.results||n.results.length==0||!((o=n.results[0])!=null&&o.returnValues)||((g=n.results[0])==null?void 0:g.returnValues.length)!==1)throw Error("swap rate not set");return e.bignum.decode(new Uint8Array(n.results[0].returnValues[0][0].toReversed()))}async nativeTokenAmount(r,t){var g,s;const i=(e.isNative(r)?e.SuiPlatform.nativeTokenId(this.network,this.chain):r).toString(),a=await this.connection.getCoinMetadata({coinType:i});if(!a)throw new Error("metadata is null");const l=await this.getPackageId(),n=new e.Transaction$1;n.moveCall({target:`${l}::redeem::calculate_native_swap_amount_out`,arguments:[n.object(this.tokenBridgeRelayerObjectId),n.pure.u64(t),n.pure.u8(a.decimals)],typeArguments:[i]});const o=await this.connection.devInspectTransactionBlock({transactionBlock:n,sender:e.hex.encode(new Uint8Array(32))});if(!o.results||o.results.length==0||!((g=o.results[0])!=null&&g.returnValues)||((s=o.results[0])==null?void 0:s.returnValues.length)!==1)throw Error("swap rate not set");return e.bignum.decode(new Uint8Array(o.results[0].returnValues[0][0].toReversed()))}async getRegisteredTokens(){const t=(await this.getFields()).registered_tokens.fields.id.id;return(await this.connection.getDynamicFields({parentId:t})).data.map(a=>{const{address:l,module:n,name:o}=e.parseStructTag(a.objectType);return new e.SuiAddress([l,n,o].join(e.SUI_SEPARATOR))})}async isRegisteredToken(r){const t=new e.SuiAddress(e.isNative(r)?e.SuiPlatform.nativeTokenId(this.network,this.chain).address:r).unwrap();try{return await this.getTokenInfo(t)!==null}catch(c){console.error(c)}return!1}async getTokenInfo(r){var o;const t=await this.getFields(),i=new e.SuiAddress(t.registered_tokens.type).getPackageId(),a=t.registered_tokens.fields.id.id,l=new e.SuiAddress(r),n=e.isSameType(e.SUI_COIN,l.unwrap())?e.SUI_COIN:l.getCoinType();try{const g=await this.connection.getDynamicFieldObject({parentId:a,name:{type:`${i}::registered_tokens::Key<${n}>`,value:{dummy_field:!1}}});if(g.error)throw new Error("Failed to get token info: "+JSON.stringify(g.error));if(!g.data||!g.data.content)throw new Error("Failed to get token info: "+JSON.stringify(g));const{content:s}=g.data;return e.isMoveStructStruct(s)&&e.isMoveStructStruct(s.fields.value)?s.fields.value.fields:null}catch(g){if((g==null?void 0:g.code)===-32e3&&((o=g.message)!=null&&o.includes("RPC Error")))return console.error(g),null;throw g}}async getFields(){if(!this.fields){const r=await e.getObjectFields(this.connection,this.tokenBridgeRelayerObjectId);if(r===null)throw new Error("Failed to get fields from token bridge relayer state");this.fields=r}return this.fields}async getPackageId(){const r=await this.getFields();return new e.SuiAddress(r.registered_tokens.type).getPackageId()}async getPackageIds(){const[r,t]=await Promise.all([e.getPackageId(this.connection,this.coreBridgeObjectId),e.getPackageId(this.connection,this.tokenBridgeObjectId)]);return{coreBridge:r,tokenBridge:t}}createUnsignedTx(r,t,c=!1){return new e.SuiUnsignedTransaction(r,this.network,this.chain,t,c)}}e.registerProtocol("Sui","TokenBridge",S);e.registerProtocol("Sui","AutomaticTokenBridge",C);exports.SuiAutomaticTokenBridge=C;exports.SuiTokenBridge=S;exports.getTokenCoinType=_;exports.getTokenFromTokenRegistry=B;
