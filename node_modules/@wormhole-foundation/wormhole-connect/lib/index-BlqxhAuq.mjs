import { b as vo, a as _o, d as xo, e as Eo, f as Fo, g as So, h as Ao, i as Bo, j as Io, k as Oo, c as To } from "./index-Dmzj0s48.mjs";
import { O as ge, Q as Tn, cS as Co, as as me } from "./index-CGIqRhuR.mjs";
function Cn(e = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(e) : new Uint8Array(e);
}
function jf(e, t) {
  t || (t = e.reduce((i, o) => i + o.length, 0));
  const r = Cn(t);
  let n = 0;
  for (const i of e)
    r.set(i, n), n += i.length;
  return r;
}
const kr = {
  ...Oo,
  ...Io,
  ...Bo,
  ...Ao,
  ...So,
  ...Fo,
  ...Eo,
  ...xo,
  ..._o,
  ...vo
};
function Rn(e, t, r, n) {
  return {
    name: e,
    prefix: t,
    encoder: {
      name: e,
      prefix: t,
      encode: r
    },
    decoder: { decode: n }
  };
}
const Jr = Rn("utf8", "u", (e) => "u" + new TextDecoder("utf8").decode(e), (e) => new TextEncoder().encode(e.substring(1))), er = Rn("ascii", "a", (e) => {
  let t = "a";
  for (let r = 0; r < e.length; r++)
    t += String.fromCharCode(e[r]);
  return t;
}, (e) => {
  e = e.substring(1);
  const t = Cn(e.length);
  for (let r = 0; r < e.length; r++)
    t[r] = e.charCodeAt(r);
  return t;
}), Ln = {
  utf8: Jr,
  "utf-8": Jr,
  hex: kr.base16,
  latin1: er,
  ascii: er,
  binary: er,
  ...kr
};
function zf(e, t = "utf8") {
  const r = Ln[t];
  if (!r)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(e, "utf8") : r.decoder.decode(`${r.prefix}${e}`);
}
function Uf(e, t = "utf8") {
  const r = Ln[t];
  if (!r)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString("utf8") : r.encoder.encode(e).substring(1);
}
var Zr = function(e, t, r) {
  if (r || arguments.length === 2) for (var n = 0, i = t.length, o; n < i; n++)
    (o || !(n in t)) && (o || (o = Array.prototype.slice.call(t, 0, n)), o[n] = t[n]);
  return e.concat(o || Array.prototype.slice.call(t));
}, Ro = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t, r, n) {
      this.name = t, this.version = r, this.os = n, this.type = "browser";
    }
    return e;
  }()
), Lo = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      this.version = t, this.type = "node", this.name = "node", this.os = ge.process.platform;
    }
    return e;
  }()
), Po = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t, r, n, i) {
      this.name = t, this.version = r, this.os = n, this.bot = i, this.type = "bot-device";
    }
    return e;
  }()
), No = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return e;
  }()
), jo = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return e;
  }()
), zo = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, Uo = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, Yr = 3, Do = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", zo]
], Xr = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function Df(e) {
  return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new jo() : typeof navigator < "u" ? $o(navigator.userAgent) : Ho();
}
function Mo(e) {
  return e !== "" && Do.reduce(function(t, r) {
    var n = r[0], i = r[1];
    if (t)
      return t;
    var o = i.exec(e);
    return !!o && [n, o];
  }, !1);
}
function $o(e) {
  var t = Mo(e);
  if (!t)
    return null;
  var r = t[0], n = t[1];
  if (r === "searchbot")
    return new No();
  var i = n[1] && n[1].split(".").join("_").split("_").slice(0, 3);
  i ? i.length < Yr && (i = Zr(Zr([], i, !0), Wo(Yr - i.length), !0)) : i = [];
  var o = i.join("."), f = Ko(e), d = Uo.exec(e);
  return d && d[1] ? new Po(r, o, f, d[1]) : new Ro(r, o, f);
}
function Ko(e) {
  for (var t = 0, r = Xr.length; t < r; t++) {
    var n = Xr[t], i = n[0], o = n[1], f = o.exec(e);
    if (f)
      return i;
  }
  return null;
}
function Ho() {
  var e = typeof ge.process < "u" && ge.process.version;
  return e ? new Lo(ge.process.version.slice(1)) : null;
}
function Wo(e) {
  for (var t = [], r = 0; r < e; r++)
    t.push("0");
  return t;
}
const Mf = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } }, Go = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, Vo = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, qo = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function ko(e, t) {
  if (e === "__proto__" || e === "constructor" && t && typeof t == "object" && "prototype" in t) {
    Jo(e);
    return;
  }
  return t;
}
function Jo(e) {
  console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`);
}
function At(e, t = {}) {
  if (typeof e != "string")
    return e;
  const r = e.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    e[0] === '"' && e.endsWith('"') && !e.includes("\\")
  )
    return r.slice(1, -1);
  if (r.length <= 9) {
    const n = r.toLowerCase();
    if (n === "true")
      return !0;
    if (n === "false")
      return !1;
    if (n === "undefined")
      return;
    if (n === "null")
      return null;
    if (n === "nan")
      return Number.NaN;
    if (n === "infinity")
      return Number.POSITIVE_INFINITY;
    if (n === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!qo.test(e)) {
    if (t.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return e;
  }
  try {
    if (Go.test(e) || Vo.test(e)) {
      if (t.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(e, ko);
    }
    return JSON.parse(e);
  } catch (n) {
    if (t.strict)
      throw n;
    return e;
  }
}
function Zo(e) {
  return !e || typeof e.then != "function" ? Promise.resolve(e) : e;
}
function Z(e, ...t) {
  try {
    return Zo(e(...t));
  } catch (r) {
    return Promise.reject(r);
  }
}
function Yo(e) {
  const t = typeof e;
  return e === null || t !== "object" && t !== "function";
}
function Xo(e) {
  const t = Object.getPrototypeOf(e);
  return !t || t.isPrototypeOf(Object);
}
function Rt(e) {
  if (Yo(e))
    return String(e);
  if (Xo(e) || Array.isArray(e))
    return JSON.stringify(e);
  if (typeof e.toJSON == "function")
    return Rt(e.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
const hr = "base64:";
function Qo(e) {
  return typeof e == "string" ? e : hr + rs(e);
}
function es(e) {
  return typeof e != "string" || !e.startsWith(hr) ? e : ts(e.slice(hr.length));
}
function ts(e) {
  return globalThis.Buffer ? ge.Buffer.from(e, "base64") : Uint8Array.from(
    globalThis.atob(e),
    (t) => t.codePointAt(0)
  );
}
function rs(e) {
  return globalThis.Buffer ? ge.Buffer.from(e).toString("base64") : globalThis.btoa(String.fromCodePoint(...e));
}
function ie(e) {
  var t;
  return e && ((t = e.split("?")[0]) == null ? void 0 : t.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function ns(...e) {
  return ie(e.join(":"));
}
function Bt(e) {
  return e = ie(e), e ? e + ":" : "";
}
const is = "memory", os = () => {
  const e = /* @__PURE__ */ new Map();
  return {
    name: is,
    getInstance: () => e,
    hasItem(t) {
      return e.has(t);
    },
    getItem(t) {
      return e.get(t) ?? null;
    },
    getItemRaw(t) {
      return e.get(t) ?? null;
    },
    setItem(t, r) {
      e.set(t, r);
    },
    setItemRaw(t, r) {
      e.set(t, r);
    },
    removeItem(t) {
      e.delete(t);
    },
    getKeys() {
      return [...e.keys()];
    },
    clear() {
      e.clear();
    },
    dispose() {
      e.clear();
    }
  };
};
function ss(e = {}) {
  const t = {
    mounts: { "": e.driver || os() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, r = (a) => {
    for (const u of t.mountpoints)
      if (a.startsWith(u))
        return {
          base: u,
          relativeKey: a.slice(u.length),
          driver: t.mounts[u]
        };
    return {
      base: "",
      relativeKey: a,
      driver: t.mounts[""]
    };
  }, n = (a, u) => t.mountpoints.filter(
    (h) => h.startsWith(a) || u && a.startsWith(h)
  ).map((h) => ({
    relativeBase: a.length > h.length ? a.slice(h.length) : void 0,
    mountpoint: h,
    driver: t.mounts[h]
  })), i = (a, u) => {
    if (t.watching) {
      u = ie(u);
      for (const h of t.watchListeners)
        h(a, u);
    }
  }, o = async () => {
    if (!t.watching) {
      t.watching = !0;
      for (const a in t.mounts)
        t.unwatch[a] = await Qr(
          t.mounts[a],
          i,
          a
        );
    }
  }, f = async () => {
    if (t.watching) {
      for (const a in t.unwatch)
        await t.unwatch[a]();
      t.unwatch = {}, t.watching = !1;
    }
  }, d = (a, u, h) => {
    const g = /* @__PURE__ */ new Map(), b = (p) => {
      let _ = g.get(p.base);
      return _ || (_ = {
        driver: p.driver,
        base: p.base,
        items: []
      }, g.set(p.base, _)), _;
    };
    for (const p of a) {
      const _ = typeof p == "string", O = ie(_ ? p : p.key), R = _ ? void 0 : p.value, T = _ || !p.options ? u : { ...u, ...p.options }, m = r(O);
      b(m).items.push({
        key: O,
        value: R,
        relativeKey: m.relativeKey,
        options: T
      });
    }
    return Promise.all([...g.values()].map((p) => h(p))).then(
      (p) => p.flat()
    );
  }, c = {
    // Item
    hasItem(a, u = {}) {
      a = ie(a);
      const { relativeKey: h, driver: g } = r(a);
      return Z(g.hasItem, h, u);
    },
    getItem(a, u = {}) {
      a = ie(a);
      const { relativeKey: h, driver: g } = r(a);
      return Z(g.getItem, h, u).then(
        (b) => At(b)
      );
    },
    getItems(a, u = {}) {
      return d(a, u, (h) => h.driver.getItems ? Z(
        h.driver.getItems,
        h.items.map((g) => ({
          key: g.relativeKey,
          options: g.options
        })),
        u
      ).then(
        (g) => g.map((b) => ({
          key: ns(h.base, b.key),
          value: At(b.value)
        }))
      ) : Promise.all(
        h.items.map((g) => Z(
          h.driver.getItem,
          g.relativeKey,
          g.options
        ).then((b) => ({
          key: g.key,
          value: At(b)
        })))
      ));
    },
    getItemRaw(a, u = {}) {
      a = ie(a);
      const { relativeKey: h, driver: g } = r(a);
      return g.getItemRaw ? Z(g.getItemRaw, h, u) : Z(g.getItem, h, u).then(
        (b) => es(b)
      );
    },
    async setItem(a, u, h = {}) {
      if (u === void 0)
        return c.removeItem(a);
      a = ie(a);
      const { relativeKey: g, driver: b } = r(a);
      b.setItem && (await Z(b.setItem, g, Rt(u), h), b.watch || i("update", a));
    },
    async setItems(a, u) {
      await d(a, u, async (h) => {
        if (h.driver.setItems)
          return Z(
            h.driver.setItems,
            h.items.map((g) => ({
              key: g.relativeKey,
              value: Rt(g.value),
              options: g.options
            })),
            u
          );
        h.driver.setItem && await Promise.all(
          h.items.map((g) => Z(
            h.driver.setItem,
            g.relativeKey,
            Rt(g.value),
            g.options
          ))
        );
      });
    },
    async setItemRaw(a, u, h = {}) {
      if (u === void 0)
        return c.removeItem(a, h);
      a = ie(a);
      const { relativeKey: g, driver: b } = r(a);
      if (b.setItemRaw)
        await Z(b.setItemRaw, g, u, h);
      else if (b.setItem)
        await Z(b.setItem, g, Qo(u), h);
      else
        return;
      b.watch || i("update", a);
    },
    async removeItem(a, u = {}) {
      typeof u == "boolean" && (u = { removeMeta: u }), a = ie(a);
      const { relativeKey: h, driver: g } = r(a);
      g.removeItem && (await Z(g.removeItem, h, u), (u.removeMeta || u.removeMata) && await Z(g.removeItem, h + "$", u), g.watch || i("remove", a));
    },
    // Meta
    async getMeta(a, u = {}) {
      typeof u == "boolean" && (u = { nativeOnly: u }), a = ie(a);
      const { relativeKey: h, driver: g } = r(a), b = /* @__PURE__ */ Object.create(null);
      if (g.getMeta && Object.assign(b, await Z(g.getMeta, h, u)), !u.nativeOnly) {
        const p = await Z(
          g.getItem,
          h + "$",
          u
        ).then((_) => At(_));
        p && typeof p == "object" && (typeof p.atime == "string" && (p.atime = new Date(p.atime)), typeof p.mtime == "string" && (p.mtime = new Date(p.mtime)), Object.assign(b, p));
      }
      return b;
    },
    setMeta(a, u, h = {}) {
      return this.setItem(a + "$", u, h);
    },
    removeMeta(a, u = {}) {
      return this.removeItem(a + "$", u);
    },
    // Keys
    async getKeys(a, u = {}) {
      a = Bt(a);
      const h = n(a, !0);
      let g = [];
      const b = [];
      for (const p of h) {
        const _ = await Z(
          p.driver.getKeys,
          p.relativeBase,
          u
        );
        for (const O of _) {
          const R = p.mountpoint + ie(O);
          g.some((T) => R.startsWith(T)) || b.push(R);
        }
        g = [
          p.mountpoint,
          ...g.filter((O) => !O.startsWith(p.mountpoint))
        ];
      }
      return a ? b.filter(
        (p) => p.startsWith(a) && p[p.length - 1] !== "$"
      ) : b.filter((p) => p[p.length - 1] !== "$");
    },
    // Utils
    async clear(a, u = {}) {
      a = Bt(a), await Promise.all(
        n(a, !1).map(async (h) => {
          if (h.driver.clear)
            return Z(h.driver.clear, h.relativeBase, u);
          if (h.driver.removeItem) {
            const g = await h.driver.getKeys(h.relativeBase || "", u);
            return Promise.all(
              g.map((b) => h.driver.removeItem(b, u))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(t.mounts).map((a) => en(a))
      );
    },
    async watch(a) {
      return await o(), t.watchListeners.push(a), async () => {
        t.watchListeners = t.watchListeners.filter(
          (u) => u !== a
        ), t.watchListeners.length === 0 && await f();
      };
    },
    async unwatch() {
      t.watchListeners = [], await f();
    },
    // Mount
    mount(a, u) {
      if (a = Bt(a), a && t.mounts[a])
        throw new Error(`already mounted at ${a}`);
      return a && (t.mountpoints.push(a), t.mountpoints.sort((h, g) => g.length - h.length)), t.mounts[a] = u, t.watching && Promise.resolve(Qr(u, i, a)).then((h) => {
        t.unwatch[a] = h;
      }).catch(console.error), c;
    },
    async unmount(a, u = !0) {
      var h, g;
      a = Bt(a), !(!a || !t.mounts[a]) && (t.watching && a in t.unwatch && ((g = (h = t.unwatch)[a]) == null || g.call(h), delete t.unwatch[a]), u && await en(t.mounts[a]), t.mountpoints = t.mountpoints.filter((b) => b !== a), delete t.mounts[a]);
    },
    getMount(a = "") {
      a = ie(a) + ":";
      const u = r(a);
      return {
        driver: u.driver,
        base: u.base
      };
    },
    getMounts(a = "", u = {}) {
      return a = ie(a), n(a, u.parents).map((g) => ({
        driver: g.driver,
        base: g.mountpoint
      }));
    },
    // Aliases
    keys: (a, u = {}) => c.getKeys(a, u),
    get: (a, u = {}) => c.getItem(a, u),
    set: (a, u, h = {}) => c.setItem(a, u, h),
    has: (a, u = {}) => c.hasItem(a, u),
    del: (a, u = {}) => c.removeItem(a, u),
    remove: (a, u = {}) => c.removeItem(a, u)
  };
  return c;
}
function Qr(e, t, r) {
  return e.watch ? e.watch((n, i) => t(n, r + i)) : () => {
  };
}
async function en(e) {
  typeof e.dispose == "function" && await Z(e.dispose);
}
function Me(e) {
  return new Promise((t, r) => {
    e.oncomplete = e.onsuccess = () => t(e.result), e.onabort = e.onerror = () => r(e.error);
  });
}
function Pn(e, t) {
  const r = indexedDB.open(e);
  r.onupgradeneeded = () => r.result.createObjectStore(t);
  const n = Me(r);
  return (i, o) => n.then((f) => o(f.transaction(t, i).objectStore(t)));
}
let tr;
function ut() {
  return tr || (tr = Pn("keyval-store", "keyval")), tr;
}
function tn(e, t = ut()) {
  return t("readonly", (r) => Me(r.get(e)));
}
function as(e, t, r = ut()) {
  return r("readwrite", (n) => (n.put(t, e), Me(n.transaction)));
}
function us(e, t = ut()) {
  return t("readwrite", (r) => (r.delete(e), Me(r.transaction)));
}
function cs(e = ut()) {
  return e("readwrite", (t) => (t.clear(), Me(t.transaction)));
}
function fs(e, t) {
  return e.openCursor().onsuccess = function() {
    this.result && (t(this.result), this.result.continue());
  }, Me(e.transaction);
}
function ls(e = ut()) {
  return e("readonly", (t) => {
    if (t.getAllKeys)
      return Me(t.getAllKeys());
    const r = [];
    return fs(t, (n) => r.push(n.key)).then(() => r);
  });
}
const hs = (e) => JSON.stringify(e, (t, r) => typeof r == "bigint" ? r.toString() + "n" : r), ds = (e) => {
  const t = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, r = e.replace(t, '$1"$2n"$3');
  return JSON.parse(r, (n, i) => typeof i == "string" && i.match(/^\d+n$/) ? BigInt(i.substring(0, i.length - 1)) : i);
};
function Nn(e) {
  if (typeof e != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof e}`);
  try {
    return ds(e);
  } catch {
    return e;
  }
}
function jn(e) {
  return typeof e == "string" ? e : hs(e) || "";
}
const gs = "idb-keyval";
var ps = (e = {}) => {
  const t = e.base && e.base.length > 0 ? `${e.base}:` : "", r = (i) => t + i;
  let n;
  return e.dbName && e.storeName && (n = Pn(e.dbName, e.storeName)), { name: gs, options: e, async hasItem(i) {
    return !(typeof await tn(r(i), n) > "u");
  }, async getItem(i) {
    return await tn(r(i), n) ?? null;
  }, setItem(i, o) {
    return as(r(i), o, n);
  }, removeItem(i) {
    return us(r(i), n);
  }, getKeys() {
    return ls(n);
  }, clear() {
    return cs(n);
  } };
};
const bs = "WALLET_CONNECT_V2_INDEXED_DB", ys = "keyvaluestorage";
let ws = class {
  constructor() {
    this.indexedDb = ss({ driver: ps({ dbName: bs, storeName: ys }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const r = await this.indexedDb.getItem(t);
    if (r !== null) return r;
  }
  async setItem(t, r) {
    await this.indexedDb.setItem(t, jn(r));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var rr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof ge.global < "u" ? ge.global : typeof self < "u" ? self : {}, Lt = { exports: {} };
(function() {
  let e;
  function t() {
  }
  e = t, e.prototype.getItem = function(r) {
    return this.hasOwnProperty(r) ? String(this[r]) : null;
  }, e.prototype.setItem = function(r, n) {
    this[r] = String(n);
  }, e.prototype.removeItem = function(r) {
    delete this[r];
  }, e.prototype.clear = function() {
    const r = this;
    Object.keys(r).forEach(function(n) {
      r[n] = void 0, delete r[n];
    });
  }, e.prototype.key = function(r) {
    return r = r || 0, Object.keys(this)[r];
  }, e.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof rr < "u" && rr.localStorage ? Lt.exports = rr.localStorage : typeof window < "u" && window.localStorage ? Lt.exports = window.localStorage : Lt.exports = new t();
})();
function ms(e) {
  var t;
  return [e[0], Nn((t = e[1]) != null ? t : "")];
}
let vs = class {
  constructor() {
    this.localStorage = Lt.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(ms);
  }
  async getItem(t) {
    const r = this.localStorage.getItem(t);
    if (r !== null) return Nn(r);
  }
  async setItem(t, r) {
    this.localStorage.setItem(t, jn(r));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
const _s = "wc_storage_version", rn = 1, xs = async (e, t, r) => {
  const n = _s, i = await t.getItem(n);
  if (i && i >= rn) {
    r(t);
    return;
  }
  const o = await e.getKeys();
  if (!o.length) {
    r(t);
    return;
  }
  const f = [];
  for (; o.length; ) {
    const d = o.shift();
    if (!d) continue;
    const c = d.toLowerCase();
    if (c.includes("wc@") || c.includes("walletconnect") || c.includes("wc_") || c.includes("wallet_connect")) {
      const a = await e.getItem(d);
      await t.setItem(d, a), f.push(d);
    }
  }
  await t.setItem(n, rn), r(t), Es(e, f);
}, Es = async (e, t) => {
  t.length && t.forEach(async (r) => {
    await e.removeItem(r);
  });
};
class Hf {
  constructor() {
    this.initialized = !1, this.setInitialized = (r) => {
      this.storage = r, this.initialized = !0;
    };
    const t = new vs();
    this.storage = t;
    try {
      const r = new ws();
      xs(t, r, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, r) {
    return await this.initialize(), this.storage.setItem(t, r);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const r = setInterval(() => {
        this.initialized && (clearInterval(r), t());
      }, 20);
    });
  }
}
class Wf {
}
function Fs(e) {
  try {
    return JSON.stringify(e);
  } catch {
    return '"[Circular]"';
  }
}
var Ss = As;
function As(e, t, r) {
  var n = r && r.stringify || Fs, i = 1;
  if (typeof e == "object" && e !== null) {
    var o = t.length + i;
    if (o === 1) return e;
    var f = new Array(o);
    f[0] = n(e);
    for (var d = 1; d < o; d++)
      f[d] = n(t[d]);
    return f.join(" ");
  }
  if (typeof e != "string")
    return e;
  var c = t.length;
  if (c === 0) return e;
  for (var a = "", u = 1 - i, h = -1, g = e && e.length || 0, b = 0; b < g; ) {
    if (e.charCodeAt(b) === 37 && b + 1 < g) {
      switch (h = h > -1 ? h : 0, e.charCodeAt(b + 1)) {
        case 100:
        case 102:
          if (u >= c || t[u] == null) break;
          h < b && (a += e.slice(h, b)), a += Number(t[u]), h = b + 2, b++;
          break;
        case 105:
          if (u >= c || t[u] == null) break;
          h < b && (a += e.slice(h, b)), a += Math.floor(Number(t[u])), h = b + 2, b++;
          break;
        case 79:
        case 111:
        case 106:
          if (u >= c || t[u] === void 0) break;
          h < b && (a += e.slice(h, b));
          var p = typeof t[u];
          if (p === "string") {
            a += "'" + t[u] + "'", h = b + 2, b++;
            break;
          }
          if (p === "function") {
            a += t[u].name || "<anonymous>", h = b + 2, b++;
            break;
          }
          a += n(t[u]), h = b + 2, b++;
          break;
        case 115:
          if (u >= c)
            break;
          h < b && (a += e.slice(h, b)), a += String(t[u]), h = b + 2, b++;
          break;
        case 37:
          h < b && (a += e.slice(h, b)), a += "%", h = b + 2, b++, u--;
          break;
      }
      ++u;
    }
    ++b;
  }
  return h === -1 ? e : (h < g && (a += e.slice(h)), a);
}
const nn = Ss;
var Ve = ve;
const ot = js().console || {}, Bs = {
  mapHttpRequest: It,
  mapHttpResponse: It,
  wrapRequestSerializer: nr,
  wrapResponseSerializer: nr,
  wrapErrorSerializer: nr,
  req: It,
  res: It,
  err: Rs
};
function Is(e, t) {
  return Array.isArray(e) ? e.filter(function(n) {
    return n !== "!stdSerializers.err";
  }) : e === !0 ? Object.keys(t) : !1;
}
function ve(e) {
  e = e || {}, e.browser = e.browser || {};
  const t = e.browser.transmit;
  if (t && typeof t.send != "function")
    throw Error("pino: transmit option must have a send function");
  const r = e.browser.write || ot;
  e.browser.write && (e.browser.asObject = !0);
  const n = e.serializers || {}, i = Is(e.browser.serialize, n);
  let o = e.browser.serialize;
  Array.isArray(e.browser.serialize) && e.browser.serialize.indexOf("!stdSerializers.err") > -1 && (o = !1);
  const f = ["error", "fatal", "warn", "info", "debug", "trace"];
  typeof r == "function" && (r.error = r.fatal = r.warn = r.info = r.debug = r.trace = r), e.enabled === !1 && (e.level = "silent");
  const d = e.level || "info", c = Object.create(r);
  c.log || (c.log = st), Object.defineProperty(c, "levelVal", {
    get: u
  }), Object.defineProperty(c, "level", {
    get: h,
    set: g
  });
  const a = {
    transmit: t,
    serialize: i,
    asObject: e.browser.asObject,
    levels: f,
    timestamp: Ls(e)
  };
  c.levels = ve.levels, c.level = d, c.setMaxListeners = c.getMaxListeners = c.emit = c.addListener = c.on = c.prependListener = c.once = c.prependOnceListener = c.removeListener = c.removeAllListeners = c.listeners = c.listenerCount = c.eventNames = c.write = c.flush = st, c.serializers = n, c._serialize = i, c._stdErrSerialize = o, c.child = b, t && (c._logEvent = dr());
  function u() {
    return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
  }
  function h() {
    return this._level;
  }
  function g(p) {
    if (p !== "silent" && !this.levels.values[p])
      throw Error("unknown level " + p);
    this._level = p, He(a, c, "error", "log"), He(a, c, "fatal", "error"), He(a, c, "warn", "error"), He(a, c, "info", "log"), He(a, c, "debug", "log"), He(a, c, "trace", "log");
  }
  function b(p, _) {
    if (!p)
      throw new Error("missing bindings for child Pino");
    _ = _ || {}, i && p.serializers && (_.serializers = p.serializers);
    const O = _.serializers;
    if (i && O) {
      var R = Object.assign({}, n, O), T = e.browser.serialize === !0 ? Object.keys(R) : i;
      delete p.serializers, Mt([p], T, R, this._stdErrSerialize);
    }
    function m(I) {
      this._childLevel = (I._childLevel | 0) + 1, this.error = We(I, p, "error"), this.fatal = We(I, p, "fatal"), this.warn = We(I, p, "warn"), this.info = We(I, p, "info"), this.debug = We(I, p, "debug"), this.trace = We(I, p, "trace"), R && (this.serializers = R, this._serialize = T), t && (this._logEvent = dr(
        [].concat(I._logEvent.bindings, p)
      ));
    }
    return m.prototype = this, new m(this);
  }
  return c;
}
ve.levels = {
  values: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },
  labels: {
    10: "trace",
    20: "debug",
    30: "info",
    40: "warn",
    50: "error",
    60: "fatal"
  }
};
ve.stdSerializers = Bs;
ve.stdTimeFunctions = Object.assign({}, { nullTime: zn, epochTime: Un, unixTime: Ps, isoTime: Ns });
function He(e, t, r, n) {
  const i = Object.getPrototypeOf(t);
  t[r] = t.levelVal > t.levels.values[r] ? st : i[r] ? i[r] : ot[r] || ot[n] || st, Os(e, t, r);
}
function Os(e, t, r) {
  !e.transmit && t[r] === st || (t[r] = /* @__PURE__ */ function(n) {
    return function() {
      const o = e.timestamp(), f = new Array(arguments.length), d = Object.getPrototypeOf && Object.getPrototypeOf(this) === ot ? ot : this;
      for (var c = 0; c < f.length; c++) f[c] = arguments[c];
      if (e.serialize && !e.asObject && Mt(f, this._serialize, this.serializers, this._stdErrSerialize), e.asObject ? n.call(d, Ts(this, r, f, o)) : n.apply(d, f), e.transmit) {
        const a = e.transmit.level || t.level, u = ve.levels.values[a], h = ve.levels.values[r];
        if (h < u) return;
        Cs(this, {
          ts: o,
          methodLevel: r,
          methodValue: h,
          transmitValue: ve.levels.values[e.transmit.level || t.level],
          send: e.transmit.send,
          val: t.levelVal
        }, f);
      }
    };
  }(t[r]));
}
function Ts(e, t, r, n) {
  e._serialize && Mt(r, e._serialize, e.serializers, e._stdErrSerialize);
  const i = r.slice();
  let o = i[0];
  const f = {};
  n && (f.time = n), f.level = ve.levels.values[t];
  let d = (e._childLevel | 0) + 1;
  if (d < 1 && (d = 1), o !== null && typeof o == "object") {
    for (; d-- && typeof i[0] == "object"; )
      Object.assign(f, i.shift());
    o = i.length ? nn(i.shift(), i) : void 0;
  } else typeof o == "string" && (o = nn(i.shift(), i));
  return o !== void 0 && (f.msg = o), f;
}
function Mt(e, t, r, n) {
  for (const i in e)
    if (n && e[i] instanceof Error)
      e[i] = ve.stdSerializers.err(e[i]);
    else if (typeof e[i] == "object" && !Array.isArray(e[i]))
      for (const o in e[i])
        t && t.indexOf(o) > -1 && o in r && (e[i][o] = r[o](e[i][o]));
}
function We(e, t, r) {
  return function() {
    const n = new Array(1 + arguments.length);
    n[0] = t;
    for (var i = 1; i < n.length; i++)
      n[i] = arguments[i - 1];
    return e[r].apply(this, n);
  };
}
function Cs(e, t, r) {
  const n = t.send, i = t.ts, o = t.methodLevel, f = t.methodValue, d = t.val, c = e._logEvent.bindings;
  Mt(
    r,
    e._serialize || Object.keys(e.serializers),
    e.serializers,
    e._stdErrSerialize === void 0 ? !0 : e._stdErrSerialize
  ), e._logEvent.ts = i, e._logEvent.messages = r.filter(function(a) {
    return c.indexOf(a) === -1;
  }), e._logEvent.level.label = o, e._logEvent.level.value = f, n(o, e._logEvent, d), e._logEvent = dr(c);
}
function dr(e) {
  return {
    ts: 0,
    messages: [],
    bindings: e || [],
    level: { label: "", value: 0 }
  };
}
function Rs(e) {
  const t = {
    type: e.constructor.name,
    msg: e.message,
    stack: e.stack
  };
  for (const r in e)
    t[r] === void 0 && (t[r] = e[r]);
  return t;
}
function Ls(e) {
  return typeof e.timestamp == "function" ? e.timestamp : e.timestamp === !1 ? zn : Un;
}
function It() {
  return {};
}
function nr(e) {
  return e;
}
function st() {
}
function zn() {
  return !1;
}
function Un() {
  return Date.now();
}
function Ps() {
  return Math.round(Date.now() / 1e3);
}
function Ns() {
  return new Date(Date.now()).toISOString();
}
function js() {
  function e(t) {
    return typeof t < "u" && t;
  }
  try {
    return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
      get: function() {
        return delete Object.prototype.globalThis, this.globalThis = this;
      },
      configurable: !0
    }), globalThis;
  } catch {
    return e(self) || e(window) || e(this) || {};
  }
}
const Dn = /* @__PURE__ */ Tn(Ve), zs = (e) => JSON.stringify(e, (t, r) => typeof r == "bigint" ? r.toString() + "n" : r);
function on(e) {
  return typeof e == "string" ? e : zs(e) || "";
}
const Us = { level: "info" }, ct = "custom_context", xr = 1e3 * 1024;
class Ds {
  constructor(t) {
    this.nodeValue = t, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
}
class sn {
  constructor(t) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = t, this.sizeInBytes = 0;
  }
  append(t) {
    const r = new Ds(t);
    if (r.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${t} with size ${r.size}`);
    for (; this.size + r.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = r), this.tail = r) : (this.head = r, this.tail = r), this.lengthInNodes++, this.sizeInBytes += r.size;
  }
  shift() {
    if (!this.head) return;
    const t = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= t.size;
  }
  toArray() {
    const t = [];
    let r = this.head;
    for (; r !== null; ) t.push(r.value), r = r.next;
    return t;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let t = this.head;
    return { next: () => {
      if (!t) return { done: !0, value: null };
      const r = t.value;
      return t = t.next, { done: !1, value: r };
    } };
  }
}
class Mn {
  constructor(t, r = xr) {
    this.level = t ?? "error", this.levelValue = Ve.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = r, this.logs = new sn(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(t, r) {
    r === Ve.levels.values.error ? console.error(t) : r === Ve.levels.values.warn ? console.warn(t) : r === Ve.levels.values.debug ? console.debug(t) : r === Ve.levels.values.trace ? console.trace(t) : console.log(t);
  }
  appendToLogs(t) {
    this.logs.append(on({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: t }));
    const r = typeof t == "string" ? JSON.parse(t).level : t.level;
    r >= this.levelValue && this.forwardToConsole(t, r);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new sn(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(t) {
    const r = this.getLogArray();
    return r.push(on({ extraMetadata: t })), new Blob(r, { type: "application/json" });
  }
}
class Ms {
  constructor(t, r = xr) {
    this.baseChunkLogger = new Mn(t, r);
  }
  write(t) {
    this.baseChunkLogger.appendToLogs(t);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(t) {
    return this.baseChunkLogger.logsToBlob(t);
  }
  downloadLogsBlobInBrowser(t) {
    const r = URL.createObjectURL(this.logsToBlob(t)), n = document.createElement("a");
    n.href = r, n.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(r);
  }
}
class $s {
  constructor(t, r = xr) {
    this.baseChunkLogger = new Mn(t, r);
  }
  write(t) {
    this.baseChunkLogger.appendToLogs(t);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(t) {
    return this.baseChunkLogger.logsToBlob(t);
  }
}
var Ks = Object.defineProperty, Hs = Object.defineProperties, Ws = Object.getOwnPropertyDescriptors, an = Object.getOwnPropertySymbols, Gs = Object.prototype.hasOwnProperty, Vs = Object.prototype.propertyIsEnumerable, un = (e, t, r) => t in e ? Ks(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Nt = (e, t) => {
  for (var r in t || (t = {})) Gs.call(t, r) && un(e, r, t[r]);
  if (an) for (var r of an(t)) Vs.call(t, r) && un(e, r, t[r]);
  return e;
}, jt = (e, t) => Hs(e, Ws(t));
function Gf(e) {
  return jt(Nt({}, e), { level: (e == null ? void 0 : e.level) || Us.level });
}
function qs(e, t = ct) {
  return e[t] || "";
}
function ks(e, t, r = ct) {
  return e[r] = t, e;
}
function Js(e, t = ct) {
  let r = "";
  return typeof e.bindings > "u" ? r = qs(e, t) : r = e.bindings().context || "", r;
}
function Zs(e, t, r = ct) {
  const n = Js(e, r);
  return n.trim() ? `${n}/${t}` : t;
}
function Vf(e, t, r = ct) {
  const n = Zs(e, t, r), i = e.child({ context: n });
  return ks(i, n, r);
}
function Ys(e) {
  var t, r;
  const n = new Ms((t = e.opts) == null ? void 0 : t.level, e.maxSizeInBytes);
  return { logger: Dn(jt(Nt({}, e.opts), { level: "trace", browser: jt(Nt({}, (r = e.opts) == null ? void 0 : r.browser), { write: (i) => n.write(i) }) })), chunkLoggerController: n };
}
function Xs(e) {
  var t;
  const r = new $s((t = e.opts) == null ? void 0 : t.level, e.maxSizeInBytes);
  return { logger: Dn(jt(Nt({}, e.opts), { level: "trace" }), r), chunkLoggerController: r };
}
function qf(e) {
  return typeof e.loggerOverride < "u" && typeof e.loggerOverride != "string" ? { logger: e.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? Ys(e) : Xs(e);
}
const Qs = (e) => JSON.stringify(e, (t, r) => typeof r == "bigint" ? r.toString() + "n" : r), ea = (e) => {
  const t = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, r = e.replace(t, '$1"$2n"$3');
  return JSON.parse(r, (n, i) => typeof i == "string" && i.match(/^\d+n$/) ? BigInt(i.substring(0, i.length - 1)) : i);
};
function ta(e) {
  if (typeof e != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof e}`);
  try {
    return ea(e);
  } catch {
    return e;
  }
}
function ra(e) {
  return typeof e == "string" ? e : Qs(e) || "";
}
function na(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function $n(e, ...t) {
  if (!na(e)) throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function cn(e, t = !0) {
  if (e.destroyed) throw new Error("Hash instance has been destroyed");
  if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function ia(e, t) {
  $n(e);
  const r = t.outputLen;
  if (e.length < r) throw new Error("digestInto() expects output buffer of length at least " + r);
}
const Ge = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ir = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
function oa(e) {
  if (typeof e != "string") throw new Error("utf8ToBytes expected string, got " + typeof e);
  return new Uint8Array(new TextEncoder().encode(e));
}
function Kn(e) {
  return typeof e == "string" && (e = oa(e)), $n(e), e;
}
class sa {
  clone() {
    return this._cloneInto();
  }
}
function aa(e) {
  const t = (n) => e().update(Kn(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function Hn(e = 32) {
  if (Ge && typeof Ge.getRandomValues == "function") return Ge.getRandomValues(new Uint8Array(e));
  if (Ge && typeof Ge.randomBytes == "function") return Ge.randomBytes(e);
  throw new Error("crypto.getRandomValues must be defined");
}
function ua(e, t, r, n) {
  if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
  const i = BigInt(32), o = BigInt(4294967295), f = Number(r >> i & o), d = Number(r & o), c = n ? 4 : 0, a = n ? 0 : 4;
  e.setUint32(t + c, f, n), e.setUint32(t + a, d, n);
}
class ca extends sa {
  constructor(t, r, n, i) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = ir(this.buffer);
  }
  update(t) {
    cn(this);
    const { view: r, buffer: n, blockLen: i } = this;
    t = Kn(t);
    const o = t.length;
    for (let f = 0; f < o; ) {
      const d = Math.min(i - this.pos, o - f);
      if (d === i) {
        const c = ir(t);
        for (; i <= o - f; f += i) this.process(c, f);
        continue;
      }
      n.set(t.subarray(f, f + d), this.pos), this.pos += d, f += d, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    cn(this), ia(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: o } = this;
    let { pos: f } = this;
    r[f++] = 128, this.buffer.subarray(f).fill(0), this.padOffset > i - f && (this.process(n, 0), f = 0);
    for (let h = f; h < i; h++) r[h] = 0;
    ua(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
    const d = ir(t), c = this.outputLen;
    if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const a = c / 4, u = this.get();
    if (a > u.length) throw new Error("_sha2: outputLen bigger than state");
    for (let h = 0; h < a; h++) d.setUint32(4 * h, u[h], o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: o, destroyed: f, pos: d } = this;
    return t.length = i, t.pos = d, t.finished = o, t.destroyed = f, i % r && t.buffer.set(n), t;
  }
}
const Ot = BigInt(2 ** 32 - 1), gr = BigInt(32);
function Wn(e, t = !1) {
  return t ? { h: Number(e & Ot), l: Number(e >> gr & Ot) } : { h: Number(e >> gr & Ot) | 0, l: Number(e & Ot) | 0 };
}
function fa(e, t = !1) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: o, l: f } = Wn(e[i], t);
    [r[i], n[i]] = [o, f];
  }
  return [r, n];
}
const la = (e, t) => BigInt(e >>> 0) << gr | BigInt(t >>> 0), ha = (e, t, r) => e >>> r, da = (e, t, r) => e << 32 - r | t >>> r, ga = (e, t, r) => e >>> r | t << 32 - r, pa = (e, t, r) => e << 32 - r | t >>> r, ba = (e, t, r) => e << 64 - r | t >>> r - 32, ya = (e, t, r) => e >>> r - 32 | t << 64 - r, wa = (e, t) => t, ma = (e, t) => e, va = (e, t, r) => e << r | t >>> 32 - r, _a = (e, t, r) => t << r | e >>> 32 - r, xa = (e, t, r) => t << r - 32 | e >>> 64 - r, Ea = (e, t, r) => e << r - 32 | t >>> 64 - r;
function Fa(e, t, r, n) {
  const i = (t >>> 0) + (n >>> 0);
  return { h: e + r + (i / 2 ** 32 | 0) | 0, l: i | 0 };
}
const Sa = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0), Aa = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0, Ba = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0), Ia = (e, t, r, n, i) => t + r + n + i + (e / 2 ** 32 | 0) | 0, Oa = (e, t, r, n, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0), Ta = (e, t, r, n, i, o) => t + r + n + i + o + (e / 2 ** 32 | 0) | 0, B = { fromBig: Wn, split: fa, toBig: la, shrSH: ha, shrSL: da, rotrSH: ga, rotrSL: pa, rotrBH: ba, rotrBL: ya, rotr32H: wa, rotr32L: ma, rotlSH: va, rotlSL: _a, rotlBH: xa, rotlBL: Ea, add: Fa, add3L: Sa, add3H: Aa, add4L: Ba, add4H: Ia, add5H: Ta, add5L: Oa }, [Ca, Ra] = B.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((e) => BigInt(e))), Ce = new Uint32Array(80), Re = new Uint32Array(80);
class La extends ca {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: t, Al: r, Bh: n, Bl: i, Ch: o, Cl: f, Dh: d, Dl: c, Eh: a, El: u, Fh: h, Fl: g, Gh: b, Gl: p, Hh: _, Hl: O } = this;
    return [t, r, n, i, o, f, d, c, a, u, h, g, b, p, _, O];
  }
  set(t, r, n, i, o, f, d, c, a, u, h, g, b, p, _, O) {
    this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = o | 0, this.Cl = f | 0, this.Dh = d | 0, this.Dl = c | 0, this.Eh = a | 0, this.El = u | 0, this.Fh = h | 0, this.Fl = g | 0, this.Gh = b | 0, this.Gl = p | 0, this.Hh = _ | 0, this.Hl = O | 0;
  }
  process(t, r) {
    for (let m = 0; m < 16; m++, r += 4) Ce[m] = t.getUint32(r), Re[m] = t.getUint32(r += 4);
    for (let m = 16; m < 80; m++) {
      const I = Ce[m - 15] | 0, z = Re[m - 15] | 0, K = B.rotrSH(I, z, 1) ^ B.rotrSH(I, z, 8) ^ B.shrSH(I, z, 7), W = B.rotrSL(I, z, 1) ^ B.rotrSL(I, z, 8) ^ B.shrSL(I, z, 7), U = Ce[m - 2] | 0, G = Re[m - 2] | 0, pe = B.rotrSH(U, G, 19) ^ B.rotrBH(U, G, 61) ^ B.shrSH(U, G, 6), be = B.rotrSL(U, G, 19) ^ B.rotrBL(U, G, 61) ^ B.shrSL(U, G, 6), ce = B.add4L(W, be, Re[m - 7], Re[m - 16]), Le = B.add4H(ce, K, pe, Ce[m - 7], Ce[m - 16]);
      Ce[m] = Le | 0, Re[m] = ce | 0;
    }
    let { Ah: n, Al: i, Bh: o, Bl: f, Ch: d, Cl: c, Dh: a, Dl: u, Eh: h, El: g, Fh: b, Fl: p, Gh: _, Gl: O, Hh: R, Hl: T } = this;
    for (let m = 0; m < 80; m++) {
      const I = B.rotrSH(h, g, 14) ^ B.rotrSH(h, g, 18) ^ B.rotrBH(h, g, 41), z = B.rotrSL(h, g, 14) ^ B.rotrSL(h, g, 18) ^ B.rotrBL(h, g, 41), K = h & b ^ ~h & _, W = g & p ^ ~g & O, U = B.add5L(T, z, W, Ra[m], Re[m]), G = B.add5H(U, R, I, K, Ca[m], Ce[m]), pe = U | 0, be = B.rotrSH(n, i, 28) ^ B.rotrBH(n, i, 34) ^ B.rotrBH(n, i, 39), ce = B.rotrSL(n, i, 28) ^ B.rotrBL(n, i, 34) ^ B.rotrBL(n, i, 39), Le = n & o ^ n & d ^ o & d, ke = i & f ^ i & c ^ f & c;
      R = _ | 0, T = O | 0, _ = b | 0, O = p | 0, b = h | 0, p = g | 0, { h, l: g } = B.add(a | 0, u | 0, G | 0, pe | 0), a = d | 0, u = c | 0, d = o | 0, c = f | 0, o = n | 0, f = i | 0;
      const E = B.add3L(pe, ce, ke);
      n = B.add3H(E, G, be, Le), i = E | 0;
    }
    ({ h: n, l: i } = B.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), { h: o, l: f } = B.add(this.Bh | 0, this.Bl | 0, o | 0, f | 0), { h: d, l: c } = B.add(this.Ch | 0, this.Cl | 0, d | 0, c | 0), { h: a, l: u } = B.add(this.Dh | 0, this.Dl | 0, a | 0, u | 0), { h, l: g } = B.add(this.Eh | 0, this.El | 0, h | 0, g | 0), { h: b, l: p } = B.add(this.Fh | 0, this.Fl | 0, b | 0, p | 0), { h: _, l: O } = B.add(this.Gh | 0, this.Gl | 0, _ | 0, O | 0), { h: R, l: T } = B.add(this.Hh | 0, this.Hl | 0, R | 0, T | 0), this.set(n, i, o, f, d, c, a, u, h, g, b, p, _, O, R, T);
  }
  roundClean() {
    Ce.fill(0), Re.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const Pa = aa(() => new La());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Er = BigInt(0), Gn = BigInt(1), Na = BigInt(2);
function Fr(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function Sr(e) {
  if (!Fr(e)) throw new Error("Uint8Array expected");
}
function or(e, t) {
  if (typeof t != "boolean") throw new Error(e + " boolean expected, got " + t);
}
const ja = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Ar(e) {
  Sr(e);
  let t = "";
  for (let r = 0; r < e.length; r++) t += ja[e[r]];
  return t;
}
function Vn(e) {
  if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
  return e === "" ? Er : BigInt("0x" + e);
}
const Ee = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function fn(e) {
  if (e >= Ee._0 && e <= Ee._9) return e - Ee._0;
  if (e >= Ee.A && e <= Ee.F) return e - (Ee.A - 10);
  if (e >= Ee.a && e <= Ee.f) return e - (Ee.a - 10);
}
function qn(e) {
  if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
  const t = e.length, r = t / 2;
  if (t % 2) throw new Error("hex string expected, got unpadded hex of length " + t);
  const n = new Uint8Array(r);
  for (let i = 0, o = 0; i < r; i++, o += 2) {
    const f = fn(e.charCodeAt(o)), d = fn(e.charCodeAt(o + 1));
    if (f === void 0 || d === void 0) {
      const c = e[o] + e[o + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + o);
    }
    n[i] = f * 16 + d;
  }
  return n;
}
function za(e) {
  return Vn(Ar(e));
}
function Pt(e) {
  return Sr(e), Vn(Ar(Uint8Array.from(e).reverse()));
}
function kn(e, t) {
  return qn(e.toString(16).padStart(t * 2, "0"));
}
function pr(e, t) {
  return kn(e, t).reverse();
}
function Fe(e, t, r) {
  let n;
  if (typeof t == "string") try {
    n = qn(t);
  } catch (o) {
    throw new Error(e + " must be hex string or Uint8Array, cause: " + o);
  }
  else if (Fr(t)) n = Uint8Array.from(t);
  else throw new Error(e + " must be hex string or Uint8Array");
  const i = n.length;
  if (typeof r == "number" && i !== r) throw new Error(e + " of length " + r + " expected, got " + i);
  return n;
}
function ln(...e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    Sr(i), t += i.length;
  }
  const r = new Uint8Array(t);
  for (let n = 0, i = 0; n < e.length; n++) {
    const o = e[n];
    r.set(o, i), i += o.length;
  }
  return r;
}
const sr = (e) => typeof e == "bigint" && Er <= e;
function Ua(e, t, r) {
  return sr(e) && sr(t) && sr(r) && t <= e && e < r;
}
function nt(e, t, r, n) {
  if (!Ua(t, r, n)) throw new Error("expected valid " + e + ": " + r + " <= n < " + n + ", got " + t);
}
function Da(e) {
  let t;
  for (t = 0; e > Er; e >>= Gn, t += 1) ;
  return t;
}
const Ma = (e) => (Na << BigInt(e - 1)) - Gn, $a = { bigint: (e) => typeof e == "bigint", function: (e) => typeof e == "function", boolean: (e) => typeof e == "boolean", string: (e) => typeof e == "string", stringOrUint8Array: (e) => typeof e == "string" || Fr(e), isSafeInteger: (e) => Number.isSafeInteger(e), array: (e) => Array.isArray(e), field: (e, t) => t.Fp.isValid(e), hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen) };
function Br(e, t, r = {}) {
  const n = (i, o, f) => {
    const d = $a[o];
    if (typeof d != "function") throw new Error("invalid validator function");
    const c = e[i];
    if (!(f && c === void 0) && !d(c, e)) throw new Error("param " + String(i) + " is invalid. Expected " + o + ", got " + c);
  };
  for (const [i, o] of Object.entries(t)) n(i, o, !1);
  for (const [i, o] of Object.entries(r)) n(i, o, !0);
  return e;
}
function hn(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, ...n) => {
    const i = t.get(r);
    if (i !== void 0) return i;
    const o = e(r, ...n);
    return t.set(r, o), o;
  };
}
const Y = BigInt(0), V = BigInt(1), De = BigInt(2), Ka = BigInt(3), br = BigInt(4), dn = BigInt(5), gn = BigInt(8);
function k(e, t) {
  const r = e % t;
  return r >= Y ? r : t + r;
}
function Ha(e, t, r) {
  if (t < Y) throw new Error("invalid exponent, negatives unsupported");
  if (r <= Y) throw new Error("invalid modulus");
  if (r === V) return Y;
  let n = V;
  for (; t > Y; ) t & V && (n = n * e % r), e = e * e % r, t >>= V;
  return n;
}
function we(e, t, r) {
  let n = e;
  for (; t-- > Y; ) n *= n, n %= r;
  return n;
}
function pn(e, t) {
  if (e === Y) throw new Error("invert: expected non-zero number");
  if (t <= Y) throw new Error("invert: expected positive modulus, got " + t);
  let r = k(e, t), n = t, i = Y, o = V;
  for (; r !== Y; ) {
    const f = n / r, d = n % r, c = i - o * f;
    n = r, r = d, i = o, o = c;
  }
  if (n !== V) throw new Error("invert: does not exist");
  return k(i, t);
}
function Wa(e) {
  const t = (e - V) / De;
  let r, n, i;
  for (r = e - V, n = 0; r % De === Y; r /= De, n++) ;
  for (i = De; i < e && Ha(i, t, e) !== e - V; i++) if (i > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (n === 1) {
    const f = (e + V) / br;
    return function(d, c) {
      const a = d.pow(c, f);
      if (!d.eql(d.sqr(a), c)) throw new Error("Cannot find square root");
      return a;
    };
  }
  const o = (r + V) / De;
  return function(f, d) {
    if (f.pow(d, t) === f.neg(f.ONE)) throw new Error("Cannot find square root");
    let c = n, a = f.pow(f.mul(f.ONE, i), r), u = f.pow(d, o), h = f.pow(d, r);
    for (; !f.eql(h, f.ONE); ) {
      if (f.eql(h, f.ZERO)) return f.ZERO;
      let g = 1;
      for (let p = f.sqr(h); g < c && !f.eql(p, f.ONE); g++) p = f.sqr(p);
      const b = f.pow(a, V << BigInt(c - g - 1));
      a = f.sqr(b), u = f.mul(u, b), h = f.mul(h, a), c = g;
    }
    return u;
  };
}
function Ga(e) {
  if (e % br === Ka) {
    const t = (e + V) / br;
    return function(r, n) {
      const i = r.pow(n, t);
      if (!r.eql(r.sqr(i), n)) throw new Error("Cannot find square root");
      return i;
    };
  }
  if (e % gn === dn) {
    const t = (e - dn) / gn;
    return function(r, n) {
      const i = r.mul(n, De), o = r.pow(i, t), f = r.mul(n, o), d = r.mul(r.mul(f, De), o), c = r.mul(f, r.sub(d, r.ONE));
      if (!r.eql(r.sqr(c), n)) throw new Error("Cannot find square root");
      return c;
    };
  }
  return Wa(e);
}
const Va = (e, t) => (k(e, t) & V) === V, qa = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function ka(e) {
  const t = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, r = qa.reduce((n, i) => (n[i] = "function", n), t);
  return Br(e, r);
}
function Ja(e, t, r) {
  if (r < Y) throw new Error("invalid exponent, negatives unsupported");
  if (r === Y) return e.ONE;
  if (r === V) return t;
  let n = e.ONE, i = t;
  for (; r > Y; ) r & V && (n = e.mul(n, i)), i = e.sqr(i), r >>= V;
  return n;
}
function Za(e, t) {
  const r = new Array(t.length), n = t.reduce((o, f, d) => e.is0(f) ? o : (r[d] = o, e.mul(o, f)), e.ONE), i = e.inv(n);
  return t.reduceRight((o, f, d) => e.is0(f) ? o : (r[d] = e.mul(o, r[d]), e.mul(o, f)), i), r;
}
function Jn(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
function Zn(e, t, r = !1, n = {}) {
  if (e <= Y) throw new Error("invalid field: expected ORDER > 0, got " + e);
  const { nBitLength: i, nByteLength: o } = Jn(e, t);
  if (o > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let f;
  const d = Object.freeze({ ORDER: e, isLE: r, BITS: i, BYTES: o, MASK: Ma(i), ZERO: Y, ONE: V, create: (c) => k(c, e), isValid: (c) => {
    if (typeof c != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c);
    return Y <= c && c < e;
  }, is0: (c) => c === Y, isOdd: (c) => (c & V) === V, neg: (c) => k(-c, e), eql: (c, a) => c === a, sqr: (c) => k(c * c, e), add: (c, a) => k(c + a, e), sub: (c, a) => k(c - a, e), mul: (c, a) => k(c * a, e), pow: (c, a) => Ja(d, c, a), div: (c, a) => k(c * pn(a, e), e), sqrN: (c) => c * c, addN: (c, a) => c + a, subN: (c, a) => c - a, mulN: (c, a) => c * a, inv: (c) => pn(c, e), sqrt: n.sqrt || ((c) => (f || (f = Ga(e)), f(d, c))), invertBatch: (c) => Za(d, c), cmov: (c, a, u) => u ? a : c, toBytes: (c) => r ? pr(c, o) : kn(c, o), fromBytes: (c) => {
    if (c.length !== o) throw new Error("Field.fromBytes: expected " + o + " bytes, got " + c.length);
    return r ? Pt(c) : za(c);
  } });
  return Object.freeze(d);
}
const bn = BigInt(0), Tt = BigInt(1);
function ar(e, t) {
  const r = t.negate();
  return e ? r : t;
}
function Yn(e, t) {
  if (!Number.isSafeInteger(e) || e <= 0 || e > t) throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function ur(e, t) {
  Yn(e, t);
  const r = Math.ceil(t / e) + 1, n = 2 ** (e - 1);
  return { windows: r, windowSize: n };
}
function Ya(e, t) {
  if (!Array.isArray(e)) throw new Error("array expected");
  e.forEach((r, n) => {
    if (!(r instanceof t)) throw new Error("invalid point at index " + n);
  });
}
function Xa(e, t) {
  if (!Array.isArray(e)) throw new Error("array of scalars expected");
  e.forEach((r, n) => {
    if (!t.isValid(r)) throw new Error("invalid scalar at index " + n);
  });
}
const cr = /* @__PURE__ */ new WeakMap(), Xn = /* @__PURE__ */ new WeakMap();
function fr(e) {
  return Xn.get(e) || 1;
}
function Qa(e, t) {
  return { constTimeNegate: ar, hasPrecomputes(r) {
    return fr(r) !== 1;
  }, unsafeLadder(r, n, i = e.ZERO) {
    let o = r;
    for (; n > bn; ) n & Tt && (i = i.add(o)), o = o.double(), n >>= Tt;
    return i;
  }, precomputeWindow(r, n) {
    const { windows: i, windowSize: o } = ur(n, t), f = [];
    let d = r, c = d;
    for (let a = 0; a < i; a++) {
      c = d, f.push(c);
      for (let u = 1; u < o; u++) c = c.add(d), f.push(c);
      d = c.double();
    }
    return f;
  }, wNAF(r, n, i) {
    const { windows: o, windowSize: f } = ur(r, t);
    let d = e.ZERO, c = e.BASE;
    const a = BigInt(2 ** r - 1), u = 2 ** r, h = BigInt(r);
    for (let g = 0; g < o; g++) {
      const b = g * f;
      let p = Number(i & a);
      i >>= h, p > f && (p -= u, i += Tt);
      const _ = b, O = b + Math.abs(p) - 1, R = g % 2 !== 0, T = p < 0;
      p === 0 ? c = c.add(ar(R, n[_])) : d = d.add(ar(T, n[O]));
    }
    return { p: d, f: c };
  }, wNAFUnsafe(r, n, i, o = e.ZERO) {
    const { windows: f, windowSize: d } = ur(r, t), c = BigInt(2 ** r - 1), a = 2 ** r, u = BigInt(r);
    for (let h = 0; h < f; h++) {
      const g = h * d;
      if (i === bn) break;
      let b = Number(i & c);
      if (i >>= u, b > d && (b -= a, i += Tt), b === 0) continue;
      let p = n[g + Math.abs(b) - 1];
      b < 0 && (p = p.negate()), o = o.add(p);
    }
    return o;
  }, getPrecomputes(r, n, i) {
    let o = cr.get(n);
    return o || (o = this.precomputeWindow(n, r), r !== 1 && cr.set(n, i(o))), o;
  }, wNAFCached(r, n, i) {
    const o = fr(r);
    return this.wNAF(o, this.getPrecomputes(o, r, i), n);
  }, wNAFCachedUnsafe(r, n, i, o) {
    const f = fr(r);
    return f === 1 ? this.unsafeLadder(r, n, o) : this.wNAFUnsafe(f, this.getPrecomputes(f, r, i), n, o);
  }, setWindowSize(r, n) {
    Yn(n, t), Xn.set(r, n), cr.delete(r);
  } };
}
function eu(e, t, r, n) {
  if (Ya(r, e), Xa(n, t), r.length !== n.length) throw new Error("arrays of points and scalars must have equal length");
  const i = e.ZERO, o = Da(BigInt(r.length)), f = o > 12 ? o - 3 : o > 4 ? o - 2 : o ? 2 : 1, d = (1 << f) - 1, c = new Array(d + 1).fill(i), a = Math.floor((t.BITS - 1) / f) * f;
  let u = i;
  for (let h = a; h >= 0; h -= f) {
    c.fill(i);
    for (let b = 0; b < n.length; b++) {
      const p = n[b], _ = Number(p >> BigInt(h) & BigInt(d));
      c[_] = c[_].add(r[b]);
    }
    let g = i;
    for (let b = c.length - 1, p = i; b > 0; b--) p = p.add(c[b]), g = g.add(p);
    if (u = u.add(g), h !== 0) for (let b = 0; b < f; b++) u = u.double();
  }
  return u;
}
function tu(e) {
  return ka(e.Fp), Br(e, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...Jn(e.n, e.nBitLength), ...e, p: e.Fp.ORDER });
}
const de = BigInt(0), ne = BigInt(1), Ct = BigInt(2), ru = BigInt(8), nu = { zip215: !0 };
function iu(e) {
  const t = tu(e);
  return Br(e, { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" }, { adjustScalarBytes: "function", domain: "function", uvRatio: "function", mapToCurve: "function" }), Object.freeze({ ...t });
}
function ou(e) {
  const t = iu(e), { Fp: r, n, prehash: i, hash: o, randomBytes: f, nByteLength: d, h: c } = t, a = Ct << BigInt(d * 8) - ne, u = r.create, h = Zn(t.n, t.nBitLength), g = t.uvRatio || ((E, w) => {
    try {
      return { isValid: !0, value: r.sqrt(E * r.inv(w)) };
    } catch {
      return { isValid: !1, value: de };
    }
  }), b = t.adjustScalarBytes || ((E) => E), p = t.domain || ((E, w, x) => {
    if (or("phflag", x), w.length || x) throw new Error("Contexts/pre-hash are not supported");
    return E;
  });
  function _(E, w) {
    nt("coordinate " + E, w, de, a);
  }
  function O(E) {
    if (!(E instanceof m)) throw new Error("ExtendedPoint expected");
  }
  const R = hn((E, w) => {
    const { ex: x, ey: F, ez: C } = E, L = E.is0();
    w == null && (w = L ? ru : r.inv(C));
    const P = u(x * w), D = u(F * w), N = u(C * w);
    if (L) return { x: de, y: ne };
    if (N !== ne) throw new Error("invZ was invalid");
    return { x: P, y: D };
  }), T = hn((E) => {
    const { a: w, d: x } = t;
    if (E.is0()) throw new Error("bad point: ZERO");
    const { ex: F, ey: C, ez: L, et: P } = E, D = u(F * F), N = u(C * C), M = u(L * L), S = u(M * M), X = u(D * w), fe = u(M * u(X + N)), q = u(S + u(x * u(D * N)));
    if (fe !== q) throw new Error("bad point: equation left != right (1)");
    const re = u(F * C), le = u(L * P);
    if (re !== le) throw new Error("bad point: equation left != right (2)");
    return !0;
  });
  class m {
    constructor(w, x, F, C) {
      this.ex = w, this.ey = x, this.ez = F, this.et = C, _("x", w), _("y", x), _("z", F), _("t", C), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(w) {
      if (w instanceof m) throw new Error("extended point not allowed");
      const { x, y: F } = w || {};
      return _("x", x), _("y", F), new m(x, F, ne, u(x * F));
    }
    static normalizeZ(w) {
      const x = r.invertBatch(w.map((F) => F.ez));
      return w.map((F, C) => F.toAffine(x[C])).map(m.fromAffine);
    }
    static msm(w, x) {
      return eu(m, h, w, x);
    }
    _setWindowSize(w) {
      K.setWindowSize(this, w);
    }
    assertValidity() {
      T(this);
    }
    equals(w) {
      O(w);
      const { ex: x, ey: F, ez: C } = this, { ex: L, ey: P, ez: D } = w, N = u(x * D), M = u(L * C), S = u(F * D), X = u(P * C);
      return N === M && S === X;
    }
    is0() {
      return this.equals(m.ZERO);
    }
    negate() {
      return new m(u(-this.ex), this.ey, this.ez, u(-this.et));
    }
    double() {
      const { a: w } = t, { ex: x, ey: F, ez: C } = this, L = u(x * x), P = u(F * F), D = u(Ct * u(C * C)), N = u(w * L), M = x + F, S = u(u(M * M) - L - P), X = N + P, fe = X - D, q = N - P, re = u(S * fe), le = u(X * q), ye = u(S * q), Be = u(fe * X);
      return new m(re, le, Be, ye);
    }
    add(w) {
      O(w);
      const { a: x, d: F } = t, { ex: C, ey: L, ez: P, et: D } = this, { ex: N, ey: M, ez: S, et: X } = w;
      if (x === BigInt(-1)) {
        const lt = u((L - C) * (M + N)), ht = u((L + C) * (M - N)), Ye = u(ht - lt);
        if (Ye === de) return this.double();
        const dt = u(P * Ct * X), gt = u(D * Ct * S), pt = gt + dt, bt = ht + lt, yt = gt - dt, $e = u(pt * Ye), Xe = u(bt * yt), wt = u(pt * yt), se = u(Ye * bt);
        return new m($e, Xe, se, wt);
      }
      const fe = u(C * N), q = u(L * M), re = u(D * F * X), le = u(P * S), ye = u((C + L) * (N + M) - fe - q), Be = le - re, Je = le + re, Ze = u(q - x * fe), Wt = u(ye * Be), Gt = u(Je * Ze), Vt = u(ye * Ze), qt = u(Be * Je);
      return new m(Wt, Gt, qt, Vt);
    }
    subtract(w) {
      return this.add(w.negate());
    }
    wNAF(w) {
      return K.wNAFCached(this, w, m.normalizeZ);
    }
    multiply(w) {
      const x = w;
      nt("scalar", x, ne, n);
      const { p: F, f: C } = this.wNAF(x);
      return m.normalizeZ([F, C])[0];
    }
    multiplyUnsafe(w, x = m.ZERO) {
      const F = w;
      return nt("scalar", F, de, n), F === de ? z : this.is0() || F === ne ? this : K.wNAFCachedUnsafe(this, F, m.normalizeZ, x);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(c).is0();
    }
    isTorsionFree() {
      return K.unsafeLadder(this, n).is0();
    }
    toAffine(w) {
      return R(this, w);
    }
    clearCofactor() {
      const { h: w } = t;
      return w === ne ? this : this.multiplyUnsafe(w);
    }
    static fromHex(w, x = !1) {
      const { d: F, a: C } = t, L = r.BYTES;
      w = Fe("pointHex", w, L), or("zip215", x);
      const P = w.slice(), D = w[L - 1];
      P[L - 1] = D & -129;
      const N = Pt(P), M = x ? a : r.ORDER;
      nt("pointHex.y", N, de, M);
      const S = u(N * N), X = u(S - ne), fe = u(F * S - C);
      let { isValid: q, value: re } = g(X, fe);
      if (!q) throw new Error("Point.fromHex: invalid y coordinate");
      const le = (re & ne) === ne, ye = (D & 128) !== 0;
      if (!x && re === de && ye) throw new Error("Point.fromHex: x=0 and x_0=1");
      return ye !== le && (re = u(-re)), m.fromAffine({ x: re, y: N });
    }
    static fromPrivateKey(w) {
      return G(w).point;
    }
    toRawBytes() {
      const { x: w, y: x } = this.toAffine(), F = pr(x, r.BYTES);
      return F[F.length - 1] |= w & ne ? 128 : 0, F;
    }
    toHex() {
      return Ar(this.toRawBytes());
    }
  }
  m.BASE = new m(t.Gx, t.Gy, ne, u(t.Gx * t.Gy)), m.ZERO = new m(de, ne, ne, de);
  const { BASE: I, ZERO: z } = m, K = Qa(m, d * 8);
  function W(E) {
    return k(E, n);
  }
  function U(E) {
    return W(Pt(E));
  }
  function G(E) {
    const w = r.BYTES;
    E = Fe("private key", E, w);
    const x = Fe("hashed private key", o(E), 2 * w), F = b(x.slice(0, w)), C = x.slice(w, 2 * w), L = U(F), P = I.multiply(L), D = P.toRawBytes();
    return { head: F, prefix: C, scalar: L, point: P, pointBytes: D };
  }
  function pe(E) {
    return G(E).pointBytes;
  }
  function be(E = new Uint8Array(), ...w) {
    const x = ln(...w);
    return U(o(p(x, Fe("context", E), !!i)));
  }
  function ce(E, w, x = {}) {
    E = Fe("message", E), i && (E = i(E));
    const { prefix: F, scalar: C, pointBytes: L } = G(w), P = be(x.context, F, E), D = I.multiply(P).toRawBytes(), N = be(x.context, D, L, E), M = W(P + N * C);
    nt("signature.s", M, de, n);
    const S = ln(D, pr(M, r.BYTES));
    return Fe("result", S, r.BYTES * 2);
  }
  const Le = nu;
  function ke(E, w, x, F = Le) {
    const { context: C, zip215: L } = F, P = r.BYTES;
    E = Fe("signature", E, 2 * P), w = Fe("message", w), x = Fe("publicKey", x, P), L !== void 0 && or("zip215", L), i && (w = i(w));
    const D = Pt(E.slice(P, 2 * P));
    let N, M, S;
    try {
      N = m.fromHex(x, L), M = m.fromHex(E.slice(0, P), L), S = I.multiplyUnsafe(D);
    } catch {
      return !1;
    }
    if (!L && N.isSmallOrder()) return !1;
    const X = be(C, M.toRawBytes(), N.toRawBytes(), w);
    return M.add(N.multiplyUnsafe(X)).subtract(S).clearCofactor().equals(m.ZERO);
  }
  return I._setWindowSize(8), { CURVE: t, getPublicKey: pe, sign: ce, verify: ke, ExtendedPoint: m, utils: { getExtendedPublicKey: G, randomPrivateKey: () => f(r.BYTES), precompute(E = 8, w = m.BASE) {
    return w._setWindowSize(E), w.multiply(BigInt(3)), w;
  } } };
}
BigInt(0), BigInt(1);
const Ir = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), yn = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const su = BigInt(1), wn = BigInt(2);
BigInt(3);
const au = BigInt(5), uu = BigInt(8);
function cu(e) {
  const t = BigInt(10), r = BigInt(20), n = BigInt(40), i = BigInt(80), o = Ir, f = e * e % o * e % o, d = we(f, wn, o) * f % o, c = we(d, su, o) * e % o, a = we(c, au, o) * c % o, u = we(a, t, o) * a % o, h = we(u, r, o) * u % o, g = we(h, n, o) * h % o, b = we(g, i, o) * g % o, p = we(b, i, o) * g % o, _ = we(p, t, o) * a % o;
  return { pow_p_5_8: we(_, wn, o) * e % o, b2: f };
}
function fu(e) {
  return e[0] &= 248, e[31] &= 127, e[31] |= 64, e;
}
function lu(e, t) {
  const r = Ir, n = k(t * t * t, r), i = k(n * n * t, r), o = cu(e * i).pow_p_5_8;
  let f = k(e * n * o, r);
  const d = k(t * f * f, r), c = f, a = k(f * yn, r), u = d === e, h = d === k(-e, r), g = d === k(-e * yn, r);
  return u && (f = c), (h || g) && (f = a), Va(f, r) && (f = k(-f, r)), { isValid: u || h, value: f };
}
const hu = Zn(Ir, void 0, !0), du = { a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), Fp: hu, n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), h: uu, Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"), hash: Pa, randomBytes: Hn, adjustScalarBytes: fu, uvRatio: lu }, Qn = ou(du), gu = "EdDSA", pu = "JWT", zt = ".", $t = "base64url", ei = "utf8", ti = "utf8", bu = ":", yu = "did", wu = "key", mn = "base58btc", mu = "z", vu = "K36", _u = 32;
function Or(e) {
  return globalThis.Buffer != null ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e;
}
function ri(e = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Or(globalThis.Buffer.allocUnsafe(e)) : new Uint8Array(e);
}
function ni(e, t) {
  t || (t = e.reduce((i, o) => i + o.length, 0));
  const r = ri(t);
  let n = 0;
  for (const i of e) r.set(i, n), n += i.length;
  return Or(r);
}
function xu(e, t) {
  if (e.length >= 255) throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++) r[n] = 255;
  for (var i = 0; i < e.length; i++) {
    var o = e.charAt(i), f = o.charCodeAt(0);
    if (r[f] !== 255) throw new TypeError(o + " is ambiguous");
    r[f] = i;
  }
  var d = e.length, c = e.charAt(0), a = Math.log(d) / Math.log(256), u = Math.log(256) / Math.log(d);
  function h(p) {
    if (p instanceof Uint8Array || (ArrayBuffer.isView(p) ? p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength) : Array.isArray(p) && (p = Uint8Array.from(p))), !(p instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (p.length === 0) return "";
    for (var _ = 0, O = 0, R = 0, T = p.length; R !== T && p[R] === 0; ) R++, _++;
    for (var m = (T - R) * u + 1 >>> 0, I = new Uint8Array(m); R !== T; ) {
      for (var z = p[R], K = 0, W = m - 1; (z !== 0 || K < O) && W !== -1; W--, K++) z += 256 * I[W] >>> 0, I[W] = z % d >>> 0, z = z / d >>> 0;
      if (z !== 0) throw new Error("Non-zero carry");
      O = K, R++;
    }
    for (var U = m - O; U !== m && I[U] === 0; ) U++;
    for (var G = c.repeat(_); U < m; ++U) G += e.charAt(I[U]);
    return G;
  }
  function g(p) {
    if (typeof p != "string") throw new TypeError("Expected String");
    if (p.length === 0) return new Uint8Array();
    var _ = 0;
    if (p[_] !== " ") {
      for (var O = 0, R = 0; p[_] === c; ) O++, _++;
      for (var T = (p.length - _) * a + 1 >>> 0, m = new Uint8Array(T); p[_]; ) {
        var I = r[p.charCodeAt(_)];
        if (I === 255) return;
        for (var z = 0, K = T - 1; (I !== 0 || z < R) && K !== -1; K--, z++) I += d * m[K] >>> 0, m[K] = I % 256 >>> 0, I = I / 256 >>> 0;
        if (I !== 0) throw new Error("Non-zero carry");
        R = z, _++;
      }
      if (p[_] !== " ") {
        for (var W = T - R; W !== T && m[W] === 0; ) W++;
        for (var U = new Uint8Array(O + (T - W)), G = O; W !== T; ) U[G++] = m[W++];
        return U;
      }
    }
  }
  function b(p) {
    var _ = g(p);
    if (_) return _;
    throw new Error(`Non-${t} character`);
  }
  return { encode: h, decodeUnsafe: g, decode: b };
}
var Eu = xu, Fu = Eu;
const ii = (e) => {
  if (e instanceof Uint8Array && e.constructor.name === "Uint8Array") return e;
  if (e instanceof ArrayBuffer) return new Uint8Array(e);
  if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
  throw new Error("Unknown type, must be binary type");
}, Su = (e) => new TextEncoder().encode(e), Au = (e) => new TextDecoder().decode(e);
class Bu {
  constructor(t, r, n) {
    this.name = t, this.prefix = r, this.baseEncode = n;
  }
  encode(t) {
    if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Iu {
  constructor(t, r, n) {
    if (this.name = t, this.prefix = r, r.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(t) {
    return oi(this, t);
  }
}
class Ou {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return oi(this, t);
  }
  decode(t) {
    const r = t[0], n = this.decoders[r];
    if (n) return n.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const oi = (e, t) => new Ou({ ...e.decoders || { [e.prefix]: e }, ...t.decoders || { [t.prefix]: t } });
class Tu {
  constructor(t, r, n, i) {
    this.name = t, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new Bu(t, r, n), this.decoder = new Iu(t, r, i);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
}
const Kt = ({ name: e, prefix: t, encode: r, decode: n }) => new Tu(e, t, r, n), ft = ({ prefix: e, name: t, alphabet: r }) => {
  const { encode: n, decode: i } = Fu(r, t);
  return Kt({ prefix: e, name: t, encode: n, decode: (o) => ii(i(o)) });
}, Cu = (e, t, r, n) => {
  const i = {};
  for (let u = 0; u < t.length; ++u) i[t[u]] = u;
  let o = e.length;
  for (; e[o - 1] === "="; ) --o;
  const f = new Uint8Array(o * r / 8 | 0);
  let d = 0, c = 0, a = 0;
  for (let u = 0; u < o; ++u) {
    const h = i[e[u]];
    if (h === void 0) throw new SyntaxError(`Non-${n} character`);
    c = c << r | h, d += r, d >= 8 && (d -= 8, f[a++] = 255 & c >> d);
  }
  if (d >= r || 255 & c << 8 - d) throw new SyntaxError("Unexpected end of data");
  return f;
}, Ru = (e, t, r) => {
  const n = t[t.length - 1] === "=", i = (1 << r) - 1;
  let o = "", f = 0, d = 0;
  for (let c = 0; c < e.length; ++c) for (d = d << 8 | e[c], f += 8; f > r; ) f -= r, o += t[i & d >> f];
  if (f && (o += t[i & d << r - f]), n) for (; o.length * r & 7; ) o += "=";
  return o;
}, ee = ({ name: e, prefix: t, bitsPerChar: r, alphabet: n }) => Kt({ prefix: t, name: e, encode(i) {
  return Ru(i, n, r);
}, decode(i) {
  return Cu(i, n, r, e);
} }), Lu = Kt({ prefix: "\0", name: "identity", encode: (e) => Au(e), decode: (e) => Su(e) });
var Pu = Object.freeze({ __proto__: null, identity: Lu });
const Nu = ee({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var ju = Object.freeze({ __proto__: null, base2: Nu });
const zu = ee({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Uu = Object.freeze({ __proto__: null, base8: zu });
const Du = ft({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Mu = Object.freeze({ __proto__: null, base10: Du });
const $u = ee({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), Ku = ee({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Hu = Object.freeze({ __proto__: null, base16: $u, base16upper: Ku });
const Wu = ee({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), Gu = ee({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), Vu = ee({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), qu = ee({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), ku = ee({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), Ju = ee({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), Zu = ee({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), Yu = ee({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), Xu = ee({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Qu = Object.freeze({ __proto__: null, base32: Wu, base32upper: Gu, base32pad: Vu, base32padupper: qu, base32hex: ku, base32hexupper: Ju, base32hexpad: Zu, base32hexpadupper: Yu, base32z: Xu });
const ec = ft({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), tc = ft({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var rc = Object.freeze({ __proto__: null, base36: ec, base36upper: tc });
const nc = ft({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), ic = ft({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var oc = Object.freeze({ __proto__: null, base58btc: nc, base58flickr: ic });
const sc = ee({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), ac = ee({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), uc = ee({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), cc = ee({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var fc = Object.freeze({ __proto__: null, base64: sc, base64pad: ac, base64url: uc, base64urlpad: cc });
const si = Array.from(""), lc = si.reduce((e, t, r) => (e[r] = t, e), []), hc = si.reduce((e, t, r) => (e[t.codePointAt(0)] = r, e), []);
function dc(e) {
  return e.reduce((t, r) => (t += lc[r], t), "");
}
function gc(e) {
  const t = [];
  for (const r of e) {
    const n = hc[r.codePointAt(0)];
    if (n === void 0) throw new Error(`Non-base256emoji character: ${r}`);
    t.push(n);
  }
  return new Uint8Array(t);
}
const pc = Kt({ prefix: "", name: "base256emoji", encode: dc, decode: gc });
var bc = Object.freeze({ __proto__: null, base256emoji: pc }), yc = ai, vn = 128, wc = -128, mc = Math.pow(2, 31);
function ai(e, t, r) {
  t = t || [], r = r || 0;
  for (var n = r; e >= mc; ) t[r++] = e & 255 | vn, e /= 128;
  for (; e & wc; ) t[r++] = e & 255 | vn, e >>>= 7;
  return t[r] = e | 0, ai.bytes = r - n + 1, t;
}
var vc = yr, _c = 128, _n = 127;
function yr(e, n) {
  var r = 0, n = n || 0, i = 0, o = n, f, d = e.length;
  do {
    if (o >= d) throw yr.bytes = 0, new RangeError("Could not decode varint");
    f = e[o++], r += i < 28 ? (f & _n) << i : (f & _n) * Math.pow(2, i), i += 7;
  } while (f >= _c);
  return yr.bytes = o - n, r;
}
var xc = Math.pow(2, 7), Ec = Math.pow(2, 14), Fc = Math.pow(2, 21), Sc = Math.pow(2, 28), Ac = Math.pow(2, 35), Bc = Math.pow(2, 42), Ic = Math.pow(2, 49), Oc = Math.pow(2, 56), Tc = Math.pow(2, 63), Cc = function(e) {
  return e < xc ? 1 : e < Ec ? 2 : e < Fc ? 3 : e < Sc ? 4 : e < Ac ? 5 : e < Bc ? 6 : e < Ic ? 7 : e < Oc ? 8 : e < Tc ? 9 : 10;
}, Rc = { encode: yc, decode: vc, encodingLength: Cc }, ui = Rc;
const xn = (e, t, r = 0) => (ui.encode(e, t, r), t), En = (e) => ui.encodingLength(e), wr = (e, t) => {
  const r = t.byteLength, n = En(e), i = n + En(r), o = new Uint8Array(i + r);
  return xn(e, o, 0), xn(r, o, n), o.set(t, i), new Lc(e, r, t, o);
};
class Lc {
  constructor(t, r, n, i) {
    this.code = t, this.size = r, this.digest = n, this.bytes = i;
  }
}
const ci = ({ name: e, code: t, encode: r }) => new Pc(e, t, r);
class Pc {
  constructor(t, r, n) {
    this.name = t, this.code = r, this.encode = n;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const r = this.encode(t);
      return r instanceof Uint8Array ? wr(this.code, r) : r.then((n) => wr(this.code, n));
    } else throw Error("Unknown type, must be binary type");
  }
}
const fi = (e) => async (t) => new Uint8Array(await crypto.subtle.digest(e, t)), Nc = ci({ name: "sha2-256", code: 18, encode: fi("SHA-256") }), jc = ci({ name: "sha2-512", code: 19, encode: fi("SHA-512") });
var zc = Object.freeze({ __proto__: null, sha256: Nc, sha512: jc });
const li = 0, Uc = "identity", hi = ii, Dc = (e) => wr(li, hi(e)), Mc = { code: li, name: Uc, encode: hi, digest: Dc };
var $c = Object.freeze({ __proto__: null, identity: Mc });
new TextEncoder(), new TextDecoder();
const Fn = { ...Pu, ...ju, ...Uu, ...Mu, ...Hu, ...Qu, ...rc, ...oc, ...fc, ...bc };
({ ...zc, ...$c });
function di(e, t, r, n) {
  return { name: e, prefix: t, encoder: { name: e, prefix: t, encode: r }, decoder: { decode: n } };
}
const Sn = di("utf8", "u", (e) => "u" + new TextDecoder("utf8").decode(e), (e) => new TextEncoder().encode(e.substring(1))), lr = di("ascii", "a", (e) => {
  let t = "a";
  for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
  return t;
}, (e) => {
  e = e.substring(1);
  const t = ri(e.length);
  for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);
  return t;
}), gi = { utf8: Sn, "utf-8": Sn, hex: Fn.base16, latin1: lr, ascii: lr, binary: lr, ...Fn };
function Ht(e, t = "utf8") {
  const r = gi[t];
  if (!r) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString("utf8") : r.encoder.encode(e).substring(1);
}
function qe(e, t = "utf8") {
  const r = gi[t];
  if (!r) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Or(globalThis.Buffer.from(e, "utf-8")) : r.decoder.decode(`${r.prefix}${e}`);
}
function An(e) {
  return ta(Ht(qe(e, $t), ei));
}
function Ut(e) {
  return Ht(qe(ra(e), ei), $t);
}
function Kc(e) {
  const t = qe(vu, mn), r = mu + Ht(ni([t, e]), mn);
  return [yu, wu, r].join(bu);
}
function Hc(e) {
  return Ht(e, $t);
}
function Wc(e) {
  return qe(e, $t);
}
function Gc(e) {
  return qe([Ut(e.header), Ut(e.payload)].join(zt), ti);
}
function Vc(e) {
  return [Ut(e.header), Ut(e.payload), Hc(e.signature)].join(zt);
}
function kf(e) {
  const t = e.split(zt), r = An(t[0]), n = An(t[1]), i = Wc(t[2]), o = qe(t.slice(0, 2).join(zt), ti);
  return { header: r, payload: n, signature: i, data: o };
}
function Jf(e = Hn(_u)) {
  const t = Qn.getPublicKey(e);
  return { secretKey: ni([e, t]), publicKey: t };
}
async function Zf(e, t, r, n, i = To.fromMiliseconds(Date.now())) {
  const o = { alg: gu, typ: pu }, f = Kc(n.publicKey), d = i + r, c = { iss: f, sub: e, aud: t, iat: i, exp: d }, a = Gc({ header: o, payload: c }), u = Qn.sign(a, n.secretKey.slice(0, 32));
  return Vc({ header: o, payload: c, signature: u });
}
const qc = "PARSE_ERROR", kc = "INVALID_REQUEST", Jc = "METHOD_NOT_FOUND", Zc = "INVALID_PARAMS", pi = "INTERNAL_ERROR", Tr = "SERVER_ERROR", Yc = [-32700, -32600, -32601, -32602, -32603], it = {
  [qc]: { code: -32700, message: "Parse error" },
  [kc]: { code: -32600, message: "Invalid Request" },
  [Jc]: { code: -32601, message: "Method not found" },
  [Zc]: { code: -32602, message: "Invalid params" },
  [pi]: { code: -32603, message: "Internal error" },
  [Tr]: { code: -32e3, message: "Server error" }
}, bi = Tr;
function Xc(e) {
  return Yc.includes(e);
}
function Bn(e) {
  return Object.keys(it).includes(e) ? it[e] : it[bi];
}
function Qc(e) {
  const t = Object.values(it).find((r) => r.code === e);
  return t || it[bi];
}
function Yf(e, t, r) {
  return e.message.includes("getaddrinfo ENOTFOUND") || e.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${r} RPC url at ${t}`) : e;
}
var ef = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var mr = function(e, t) {
  return mr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var i in n) n.hasOwnProperty(i) && (r[i] = n[i]);
  }, mr(e, t);
};
function tf(e, t) {
  mr(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var vr = function() {
  return vr = Object.assign || function(t) {
    for (var r, n = 1, i = arguments.length; n < i; n++) {
      r = arguments[n];
      for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (t[o] = r[o]);
    }
    return t;
  }, vr.apply(this, arguments);
};
function rf(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
      t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
}
function nf(e, t, r, n) {
  var i = arguments.length, o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n, f;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(e, t, r, n);
  else for (var d = e.length - 1; d >= 0; d--) (f = e[d]) && (o = (i < 3 ? f(o) : i > 3 ? f(t, r, o) : f(t, r)) || o);
  return i > 3 && o && Object.defineProperty(t, r, o), o;
}
function of(e, t) {
  return function(r, n) {
    t(r, n, e);
  };
}
function sf(e, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(e, t);
}
function af(e, t, r, n) {
  function i(o) {
    return o instanceof r ? o : new r(function(f) {
      f(o);
    });
  }
  return new (r || (r = Promise))(function(o, f) {
    function d(u) {
      try {
        a(n.next(u));
      } catch (h) {
        f(h);
      }
    }
    function c(u) {
      try {
        a(n.throw(u));
      } catch (h) {
        f(h);
      }
    }
    function a(u) {
      u.done ? o(u.value) : i(u.value).then(d, c);
    }
    a((n = n.apply(e, t || [])).next());
  });
}
function uf(e, t) {
  var r = { label: 0, sent: function() {
    if (o[0] & 1) throw o[1];
    return o[1];
  }, trys: [], ops: [] }, n, i, o, f;
  return f = { next: d(0), throw: d(1), return: d(2) }, typeof Symbol == "function" && (f[Symbol.iterator] = function() {
    return this;
  }), f;
  function d(a) {
    return function(u) {
      return c([a, u]);
    };
  }
  function c(a) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; r; ) try {
      if (n = 1, i && (o = a[0] & 2 ? i.return : a[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, a[1])).done) return o;
      switch (i = 0, o && (a = [a[0] & 2, o.value]), a[0]) {
        case 0:
        case 1:
          o = a;
          break;
        case 4:
          return r.label++, { value: a[1], done: !1 };
        case 5:
          r.label++, i = a[1], a = [0];
          continue;
        case 7:
          a = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (o = r.trys, !(o = o.length > 0 && o[o.length - 1]) && (a[0] === 6 || a[0] === 2)) {
            r = 0;
            continue;
          }
          if (a[0] === 3 && (!o || a[1] > o[0] && a[1] < o[3])) {
            r.label = a[1];
            break;
          }
          if (a[0] === 6 && r.label < o[1]) {
            r.label = o[1], o = a;
            break;
          }
          if (o && r.label < o[2]) {
            r.label = o[2], r.ops.push(a);
            break;
          }
          o[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      a = t.call(e, r);
    } catch (u) {
      a = [6, u], i = 0;
    } finally {
      n = o = 0;
    }
    if (a[0] & 5) throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
}
function cf(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
}
function ff(e, t) {
  for (var r in e) r !== "default" && !t.hasOwnProperty(r) && (t[r] = e[r]);
}
function _r(e) {
  var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0;
  if (r) return r.call(e);
  if (e && typeof e.length == "number") return {
    next: function() {
      return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e };
    }
  };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function yi(e, t) {
  var r = typeof Symbol == "function" && e[Symbol.iterator];
  if (!r) return e;
  var n = r.call(e), i, o = [], f;
  try {
    for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; ) o.push(i.value);
  } catch (d) {
    f = { error: d };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (f) throw f.error;
    }
  }
  return o;
}
function lf() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e = e.concat(yi(arguments[t]));
  return e;
}
function hf() {
  for (var e = 0, t = 0, r = arguments.length; t < r; t++) e += arguments[t].length;
  for (var n = Array(e), i = 0, t = 0; t < r; t++)
    for (var o = arguments[t], f = 0, d = o.length; f < d; f++, i++)
      n[i] = o[f];
  return n;
}
function at(e) {
  return this instanceof at ? (this.v = e, this) : new at(e);
}
function df(e, t, r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(e, t || []), i, o = [];
  return i = {}, f("next"), f("throw"), f("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function f(g) {
    n[g] && (i[g] = function(b) {
      return new Promise(function(p, _) {
        o.push([g, b, p, _]) > 1 || d(g, b);
      });
    });
  }
  function d(g, b) {
    try {
      c(n[g](b));
    } catch (p) {
      h(o[0][3], p);
    }
  }
  function c(g) {
    g.value instanceof at ? Promise.resolve(g.value.v).then(a, u) : h(o[0][2], g);
  }
  function a(g) {
    d("next", g);
  }
  function u(g) {
    d("throw", g);
  }
  function h(g, b) {
    g(b), o.shift(), o.length && d(o[0][0], o[0][1]);
  }
}
function gf(e) {
  var t, r;
  return t = {}, n("next"), n("throw", function(i) {
    throw i;
  }), n("return"), t[Symbol.iterator] = function() {
    return this;
  }, t;
  function n(i, o) {
    t[i] = e[i] ? function(f) {
      return (r = !r) ? { value: at(e[i](f)), done: i === "return" } : o ? o(f) : f;
    } : o;
  }
}
function pf(e) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator], r;
  return t ? t.call(e) : (e = typeof _r == "function" ? _r(e) : e[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function n(o) {
    r[o] = e[o] && function(f) {
      return new Promise(function(d, c) {
        f = e[o](f), i(d, c, f.done, f.value);
      });
    };
  }
  function i(o, f, d, c) {
    Promise.resolve(c).then(function(a) {
      o({ value: a, done: d });
    }, f);
  }
}
function bf(e, t) {
  return Object.defineProperty ? Object.defineProperty(e, "raw", { value: t }) : e.raw = t, e;
}
function yf(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
  return t.default = e, t;
}
function wf(e) {
  return e && e.__esModule ? e : { default: e };
}
function mf(e, t) {
  if (!t.has(e))
    throw new TypeError("attempted to get private field on non-instance");
  return t.get(e);
}
function vf(e, t, r) {
  if (!t.has(e))
    throw new TypeError("attempted to set private field on non-instance");
  return t.set(e, r), r;
}
const _f = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return vr;
  },
  __asyncDelegator: gf,
  __asyncGenerator: df,
  __asyncValues: pf,
  __await: at,
  __awaiter: af,
  __classPrivateFieldGet: mf,
  __classPrivateFieldSet: vf,
  __createBinding: cf,
  __decorate: nf,
  __exportStar: ff,
  __extends: tf,
  __generator: uf,
  __importDefault: wf,
  __importStar: yf,
  __makeTemplateObject: bf,
  __metadata: sf,
  __param: of,
  __read: yi,
  __rest: rf,
  __spread: lf,
  __spreadArrays: hf,
  __values: _r
}, Symbol.toStringTag, { value: "Module" })), xf = /* @__PURE__ */ Co(_f);
var Se = {}, In;
function Ef() {
  if (In) return Se;
  In = 1, Object.defineProperty(Se, "__esModule", { value: !0 }), Se.isBrowserCryptoAvailable = Se.getSubtleCrypto = Se.getBrowerCrypto = void 0;
  function e() {
    return (me === null || me === void 0 ? void 0 : me.crypto) || (me === null || me === void 0 ? void 0 : me.msCrypto) || {};
  }
  Se.getBrowerCrypto = e;
  function t() {
    const n = e();
    return n.subtle || n.webkitSubtle;
  }
  Se.getSubtleCrypto = t;
  function r() {
    return !!e() && !!t();
  }
  return Se.isBrowserCryptoAvailable = r, Se;
}
var Ae = {}, On;
function Ff() {
  if (On) return Ae;
  On = 1, Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.isBrowser = Ae.isNode = Ae.isReactNative = void 0;
  function e() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  Ae.isReactNative = e;
  function t() {
    return typeof ge.process < "u" && typeof ge.process.versions < "u" && typeof ge.process.versions.node < "u";
  }
  Ae.isNode = t;
  function r() {
    return !e() && !t();
  }
  return Ae.isBrowser = r, Ae;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  const t = xf;
  t.__exportStar(Ef(), e), t.__exportStar(Ff(), e);
})(ef);
function wi(e = 3) {
  const t = Date.now() * Math.pow(10, e), r = Math.floor(Math.random() * Math.pow(10, e));
  return t + r;
}
function Xf(e = 6) {
  return BigInt(wi(e));
}
function Qf(e, t, r) {
  return {
    id: r || wi(),
    jsonrpc: "2.0",
    method: e,
    params: t
  };
}
function el(e, t) {
  return {
    id: e,
    jsonrpc: "2.0",
    result: t
  };
}
function tl(e, t, r) {
  return {
    id: e,
    jsonrpc: "2.0",
    error: Sf(t)
  };
}
function Sf(e, t) {
  return typeof e > "u" ? Bn(pi) : (typeof e == "string" && (e = Object.assign(Object.assign({}, Bn(Tr)), { message: e })), Xc(e.code) && (e = Qc(e.code)), e);
}
class Af {
}
class Bf extends Af {
  constructor() {
    super();
  }
}
class rl extends Bf {
  constructor(t) {
    super();
  }
}
const If = "^https?:", Of = "^wss?:";
function Tf(e) {
  const t = e.match(new RegExp(/^\w+:/, "gi"));
  if (!(!t || !t.length))
    return t[0];
}
function mi(e, t) {
  const r = Tf(e);
  return typeof r > "u" ? !1 : new RegExp(t).test(r);
}
function nl(e) {
  return mi(e, If);
}
function il(e) {
  return mi(e, Of);
}
function ol(e) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(e);
}
function vi(e) {
  return typeof e == "object" && "id" in e && "jsonrpc" in e && e.jsonrpc === "2.0";
}
function sl(e) {
  return vi(e) && "method" in e;
}
function al(e) {
  return vi(e) && (Cf(e) || Rf(e));
}
function Cf(e) {
  return "result" in e;
}
function Rf(e) {
  return "error" in e;
}
var Dt = { exports: {} };
Dt.exports;
(function(e, t) {
  var r = 200, n = "__lodash_hash_undefined__", i = 1, o = 2, f = 9007199254740991, d = "[object Arguments]", c = "[object Array]", a = "[object AsyncFunction]", u = "[object Boolean]", h = "[object Date]", g = "[object Error]", b = "[object Function]", p = "[object GeneratorFunction]", _ = "[object Map]", O = "[object Number]", R = "[object Null]", T = "[object Object]", m = "[object Promise]", I = "[object Proxy]", z = "[object RegExp]", K = "[object Set]", W = "[object String]", U = "[object Symbol]", G = "[object Undefined]", pe = "[object WeakMap]", be = "[object ArrayBuffer]", ce = "[object DataView]", Le = "[object Float32Array]", ke = "[object Float64Array]", E = "[object Int8Array]", w = "[object Int16Array]", x = "[object Int32Array]", F = "[object Uint8Array]", C = "[object Uint8ClampedArray]", L = "[object Uint16Array]", P = "[object Uint32Array]", D = /[\\^$.*+?()[\]{}|]/g, N = /^\[object .+?Constructor\]$/, M = /^(?:0|[1-9]\d*)$/, S = {};
  S[Le] = S[ke] = S[E] = S[w] = S[x] = S[F] = S[C] = S[L] = S[P] = !0, S[d] = S[c] = S[be] = S[u] = S[ce] = S[h] = S[g] = S[b] = S[_] = S[O] = S[T] = S[z] = S[K] = S[W] = S[pe] = !1;
  var X = typeof me == "object" && me && me.Object === Object && me, fe = typeof self == "object" && self && self.Object === Object && self, q = X || fe || Function("return this")(), re = t && !t.nodeType && t, le = re && !0 && e && !e.nodeType && e, ye = le && le.exports === re, Be = ye && X.process, Je = function() {
    try {
      return Be && Be.binding && Be.binding("util");
    } catch {
    }
  }(), Ze = Je && Je.isTypedArray;
  function Wt(s, l) {
    for (var y = -1, v = s == null ? 0 : s.length, j = 0, A = []; ++y < v; ) {
      var H = s[y];
      l(H, y, s) && (A[j++] = H);
    }
    return A;
  }
  function Gt(s, l) {
    for (var y = -1, v = l.length, j = s.length; ++y < v; )
      s[j + y] = l[y];
    return s;
  }
  function Vt(s, l) {
    for (var y = -1, v = s == null ? 0 : s.length; ++y < v; )
      if (l(s[y], y, s))
        return !0;
    return !1;
  }
  function qt(s, l) {
    for (var y = -1, v = Array(s); ++y < s; )
      v[y] = l(y);
    return v;
  }
  function lt(s) {
    return function(l) {
      return s(l);
    };
  }
  function ht(s, l) {
    return s.has(l);
  }
  function Ye(s, l) {
    return s == null ? void 0 : s[l];
  }
  function dt(s) {
    var l = -1, y = Array(s.size);
    return s.forEach(function(v, j) {
      y[++l] = [j, v];
    }), y;
  }
  function gt(s, l) {
    return function(y) {
      return s(l(y));
    };
  }
  function pt(s) {
    var l = -1, y = Array(s.size);
    return s.forEach(function(v) {
      y[++l] = v;
    }), y;
  }
  var bt = Array.prototype, yt = Function.prototype, $e = Object.prototype, Xe = q["__core-js_shared__"], wt = yt.toString, se = $e.hasOwnProperty, Cr = function() {
    var s = /[^.]+$/.exec(Xe && Xe.keys && Xe.keys.IE_PROTO || "");
    return s ? "Symbol(src)_1." + s : "";
  }(), Rr = $e.toString, _i = RegExp(
    "^" + wt.call(se).replace(D, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Lr = ye ? q.Buffer : void 0, mt = q.Symbol, Pr = q.Uint8Array, Nr = $e.propertyIsEnumerable, xi = bt.splice, Pe = mt ? mt.toStringTag : void 0, jr = Object.getOwnPropertySymbols, Ei = Lr ? Lr.isBuffer : void 0, Fi = gt(Object.keys, Object), kt = Ke(q, "DataView"), Qe = Ke(q, "Map"), Jt = Ke(q, "Promise"), Zt = Ke(q, "Set"), Yt = Ke(q, "WeakMap"), et = Ke(Object, "create"), Si = ze(kt), Ai = ze(Qe), Bi = ze(Jt), Ii = ze(Zt), Oi = ze(Yt), zr = mt ? mt.prototype : void 0, Xt = zr ? zr.valueOf : void 0;
  function Ne(s) {
    var l = -1, y = s == null ? 0 : s.length;
    for (this.clear(); ++l < y; ) {
      var v = s[l];
      this.set(v[0], v[1]);
    }
  }
  function Ti() {
    this.__data__ = et ? et(null) : {}, this.size = 0;
  }
  function Ci(s) {
    var l = this.has(s) && delete this.__data__[s];
    return this.size -= l ? 1 : 0, l;
  }
  function Ri(s) {
    var l = this.__data__;
    if (et) {
      var y = l[s];
      return y === n ? void 0 : y;
    }
    return se.call(l, s) ? l[s] : void 0;
  }
  function Li(s) {
    var l = this.__data__;
    return et ? l[s] !== void 0 : se.call(l, s);
  }
  function Pi(s, l) {
    var y = this.__data__;
    return this.size += this.has(s) ? 0 : 1, y[s] = et && l === void 0 ? n : l, this;
  }
  Ne.prototype.clear = Ti, Ne.prototype.delete = Ci, Ne.prototype.get = Ri, Ne.prototype.has = Li, Ne.prototype.set = Pi;
  function _e(s) {
    var l = -1, y = s == null ? 0 : s.length;
    for (this.clear(); ++l < y; ) {
      var v = s[l];
      this.set(v[0], v[1]);
    }
  }
  function Ni() {
    this.__data__ = [], this.size = 0;
  }
  function ji(s) {
    var l = this.__data__, y = _t(l, s);
    if (y < 0)
      return !1;
    var v = l.length - 1;
    return y == v ? l.pop() : xi.call(l, y, 1), --this.size, !0;
  }
  function zi(s) {
    var l = this.__data__, y = _t(l, s);
    return y < 0 ? void 0 : l[y][1];
  }
  function Ui(s) {
    return _t(this.__data__, s) > -1;
  }
  function Di(s, l) {
    var y = this.__data__, v = _t(y, s);
    return v < 0 ? (++this.size, y.push([s, l])) : y[v][1] = l, this;
  }
  _e.prototype.clear = Ni, _e.prototype.delete = ji, _e.prototype.get = zi, _e.prototype.has = Ui, _e.prototype.set = Di;
  function je(s) {
    var l = -1, y = s == null ? 0 : s.length;
    for (this.clear(); ++l < y; ) {
      var v = s[l];
      this.set(v[0], v[1]);
    }
  }
  function Mi() {
    this.size = 0, this.__data__ = {
      hash: new Ne(),
      map: new (Qe || _e)(),
      string: new Ne()
    };
  }
  function $i(s) {
    var l = xt(this, s).delete(s);
    return this.size -= l ? 1 : 0, l;
  }
  function Ki(s) {
    return xt(this, s).get(s);
  }
  function Hi(s) {
    return xt(this, s).has(s);
  }
  function Wi(s, l) {
    var y = xt(this, s), v = y.size;
    return y.set(s, l), this.size += y.size == v ? 0 : 1, this;
  }
  je.prototype.clear = Mi, je.prototype.delete = $i, je.prototype.get = Ki, je.prototype.has = Hi, je.prototype.set = Wi;
  function vt(s) {
    var l = -1, y = s == null ? 0 : s.length;
    for (this.__data__ = new je(); ++l < y; )
      this.add(s[l]);
  }
  function Gi(s) {
    return this.__data__.set(s, n), this;
  }
  function Vi(s) {
    return this.__data__.has(s);
  }
  vt.prototype.add = vt.prototype.push = Gi, vt.prototype.has = Vi;
  function Ie(s) {
    var l = this.__data__ = new _e(s);
    this.size = l.size;
  }
  function qi() {
    this.__data__ = new _e(), this.size = 0;
  }
  function ki(s) {
    var l = this.__data__, y = l.delete(s);
    return this.size = l.size, y;
  }
  function Ji(s) {
    return this.__data__.get(s);
  }
  function Zi(s) {
    return this.__data__.has(s);
  }
  function Yi(s, l) {
    var y = this.__data__;
    if (y instanceof _e) {
      var v = y.__data__;
      if (!Qe || v.length < r - 1)
        return v.push([s, l]), this.size = ++y.size, this;
      y = this.__data__ = new je(v);
    }
    return y.set(s, l), this.size = y.size, this;
  }
  Ie.prototype.clear = qi, Ie.prototype.delete = ki, Ie.prototype.get = Ji, Ie.prototype.has = Zi, Ie.prototype.set = Yi;
  function Xi(s, l) {
    var y = Et(s), v = !y && go(s), j = !y && !v && Qt(s), A = !y && !v && !j && Vr(s), H = y || v || j || A, J = H ? qt(s.length, String) : [], Q = J.length;
    for (var $ in s)
      se.call(s, $) && !(H && // Safari 9 has enumerable `arguments.length` in strict mode.
      ($ == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      j && ($ == "offset" || $ == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      A && ($ == "buffer" || $ == "byteLength" || $ == "byteOffset") || // Skip index properties.
      uo($, Q))) && J.push($);
    return J;
  }
  function _t(s, l) {
    for (var y = s.length; y--; )
      if (Kr(s[y][0], l))
        return y;
    return -1;
  }
  function Qi(s, l, y) {
    var v = l(s);
    return Et(s) ? v : Gt(v, y(s));
  }
  function tt(s) {
    return s == null ? s === void 0 ? G : R : Pe && Pe in Object(s) ? so(s) : ho(s);
  }
  function Ur(s) {
    return rt(s) && tt(s) == d;
  }
  function Dr(s, l, y, v, j) {
    return s === l ? !0 : s == null || l == null || !rt(s) && !rt(l) ? s !== s && l !== l : eo(s, l, y, v, Dr, j);
  }
  function eo(s, l, y, v, j, A) {
    var H = Et(s), J = Et(l), Q = H ? c : Oe(s), $ = J ? c : Oe(l);
    Q = Q == d ? T : Q, $ = $ == d ? T : $;
    var oe = Q == T, he = $ == T, te = Q == $;
    if (te && Qt(s)) {
      if (!Qt(l))
        return !1;
      H = !0, oe = !1;
    }
    if (te && !oe)
      return A || (A = new Ie()), H || Vr(s) ? Mr(s, l, y, v, j, A) : io(s, l, Q, y, v, j, A);
    if (!(y & i)) {
      var ae = oe && se.call(s, "__wrapped__"), ue = he && se.call(l, "__wrapped__");
      if (ae || ue) {
        var Te = ae ? s.value() : s, xe = ue ? l.value() : l;
        return A || (A = new Ie()), j(Te, xe, y, v, A);
      }
    }
    return te ? (A || (A = new Ie()), oo(s, l, y, v, j, A)) : !1;
  }
  function to(s) {
    if (!Gr(s) || fo(s))
      return !1;
    var l = Hr(s) ? _i : N;
    return l.test(ze(s));
  }
  function ro(s) {
    return rt(s) && Wr(s.length) && !!S[tt(s)];
  }
  function no(s) {
    if (!lo(s))
      return Fi(s);
    var l = [];
    for (var y in Object(s))
      se.call(s, y) && y != "constructor" && l.push(y);
    return l;
  }
  function Mr(s, l, y, v, j, A) {
    var H = y & i, J = s.length, Q = l.length;
    if (J != Q && !(H && Q > J))
      return !1;
    var $ = A.get(s);
    if ($ && A.get(l))
      return $ == l;
    var oe = -1, he = !0, te = y & o ? new vt() : void 0;
    for (A.set(s, l), A.set(l, s); ++oe < J; ) {
      var ae = s[oe], ue = l[oe];
      if (v)
        var Te = H ? v(ue, ae, oe, l, s, A) : v(ae, ue, oe, s, l, A);
      if (Te !== void 0) {
        if (Te)
          continue;
        he = !1;
        break;
      }
      if (te) {
        if (!Vt(l, function(xe, Ue) {
          if (!ht(te, Ue) && (ae === xe || j(ae, xe, y, v, A)))
            return te.push(Ue);
        })) {
          he = !1;
          break;
        }
      } else if (!(ae === ue || j(ae, ue, y, v, A))) {
        he = !1;
        break;
      }
    }
    return A.delete(s), A.delete(l), he;
  }
  function io(s, l, y, v, j, A, H) {
    switch (y) {
      case ce:
        if (s.byteLength != l.byteLength || s.byteOffset != l.byteOffset)
          return !1;
        s = s.buffer, l = l.buffer;
      case be:
        return !(s.byteLength != l.byteLength || !A(new Pr(s), new Pr(l)));
      case u:
      case h:
      case O:
        return Kr(+s, +l);
      case g:
        return s.name == l.name && s.message == l.message;
      case z:
      case W:
        return s == l + "";
      case _:
        var J = dt;
      case K:
        var Q = v & i;
        if (J || (J = pt), s.size != l.size && !Q)
          return !1;
        var $ = H.get(s);
        if ($)
          return $ == l;
        v |= o, H.set(s, l);
        var oe = Mr(J(s), J(l), v, j, A, H);
        return H.delete(s), oe;
      case U:
        if (Xt)
          return Xt.call(s) == Xt.call(l);
    }
    return !1;
  }
  function oo(s, l, y, v, j, A) {
    var H = y & i, J = $r(s), Q = J.length, $ = $r(l), oe = $.length;
    if (Q != oe && !H)
      return !1;
    for (var he = Q; he--; ) {
      var te = J[he];
      if (!(H ? te in l : se.call(l, te)))
        return !1;
    }
    var ae = A.get(s);
    if (ae && A.get(l))
      return ae == l;
    var ue = !0;
    A.set(s, l), A.set(l, s);
    for (var Te = H; ++he < Q; ) {
      te = J[he];
      var xe = s[te], Ue = l[te];
      if (v)
        var qr = H ? v(Ue, xe, te, l, s, A) : v(xe, Ue, te, s, l, A);
      if (!(qr === void 0 ? xe === Ue || j(xe, Ue, y, v, A) : qr)) {
        ue = !1;
        break;
      }
      Te || (Te = te == "constructor");
    }
    if (ue && !Te) {
      var Ft = s.constructor, St = l.constructor;
      Ft != St && "constructor" in s && "constructor" in l && !(typeof Ft == "function" && Ft instanceof Ft && typeof St == "function" && St instanceof St) && (ue = !1);
    }
    return A.delete(s), A.delete(l), ue;
  }
  function $r(s) {
    return Qi(s, yo, ao);
  }
  function xt(s, l) {
    var y = s.__data__;
    return co(l) ? y[typeof l == "string" ? "string" : "hash"] : y.map;
  }
  function Ke(s, l) {
    var y = Ye(s, l);
    return to(y) ? y : void 0;
  }
  function so(s) {
    var l = se.call(s, Pe), y = s[Pe];
    try {
      s[Pe] = void 0;
      var v = !0;
    } catch {
    }
    var j = Rr.call(s);
    return v && (l ? s[Pe] = y : delete s[Pe]), j;
  }
  var ao = jr ? function(s) {
    return s == null ? [] : (s = Object(s), Wt(jr(s), function(l) {
      return Nr.call(s, l);
    }));
  } : wo, Oe = tt;
  (kt && Oe(new kt(new ArrayBuffer(1))) != ce || Qe && Oe(new Qe()) != _ || Jt && Oe(Jt.resolve()) != m || Zt && Oe(new Zt()) != K || Yt && Oe(new Yt()) != pe) && (Oe = function(s) {
    var l = tt(s), y = l == T ? s.constructor : void 0, v = y ? ze(y) : "";
    if (v)
      switch (v) {
        case Si:
          return ce;
        case Ai:
          return _;
        case Bi:
          return m;
        case Ii:
          return K;
        case Oi:
          return pe;
      }
    return l;
  });
  function uo(s, l) {
    return l = l ?? f, !!l && (typeof s == "number" || M.test(s)) && s > -1 && s % 1 == 0 && s < l;
  }
  function co(s) {
    var l = typeof s;
    return l == "string" || l == "number" || l == "symbol" || l == "boolean" ? s !== "__proto__" : s === null;
  }
  function fo(s) {
    return !!Cr && Cr in s;
  }
  function lo(s) {
    var l = s && s.constructor, y = typeof l == "function" && l.prototype || $e;
    return s === y;
  }
  function ho(s) {
    return Rr.call(s);
  }
  function ze(s) {
    if (s != null) {
      try {
        return wt.call(s);
      } catch {
      }
      try {
        return s + "";
      } catch {
      }
    }
    return "";
  }
  function Kr(s, l) {
    return s === l || s !== s && l !== l;
  }
  var go = Ur(/* @__PURE__ */ function() {
    return arguments;
  }()) ? Ur : function(s) {
    return rt(s) && se.call(s, "callee") && !Nr.call(s, "callee");
  }, Et = Array.isArray;
  function po(s) {
    return s != null && Wr(s.length) && !Hr(s);
  }
  var Qt = Ei || mo;
  function bo(s, l) {
    return Dr(s, l);
  }
  function Hr(s) {
    if (!Gr(s))
      return !1;
    var l = tt(s);
    return l == b || l == p || l == a || l == I;
  }
  function Wr(s) {
    return typeof s == "number" && s > -1 && s % 1 == 0 && s <= f;
  }
  function Gr(s) {
    var l = typeof s;
    return s != null && (l == "object" || l == "function");
  }
  function rt(s) {
    return s != null && typeof s == "object";
  }
  var Vr = Ze ? lt(Ze) : ro;
  function yo(s) {
    return po(s) ? Xi(s) : no(s);
  }
  function wo() {
    return [];
  }
  function mo() {
    return !1;
  }
  e.exports = bo;
})(Dt, Dt.exports);
var Lf = Dt.exports;
const ul = /* @__PURE__ */ Tn(Lf);
export {
  qf as A,
  Mf as C,
  Vf as E,
  Wf as I,
  Jf as P,
  Kc as Q,
  Dn as T,
  ul as _,
  Qf as a,
  al as b,
  jf as c,
  Df as d,
  il as e,
  zf as f,
  Xf as g,
  ef as h,
  Rf as i,
  ol as j,
  tl as k,
  Gf as l,
  Hf as m,
  Zf as n,
  sl as o,
  Yf as p,
  el as q,
  rl as r,
  Cf as s,
  Uf as t,
  wi as u,
  nl as v,
  kf as w,
  Js as y
};
