"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const e=require("./evm-Di8LC9_s.js");class y extends e.BaseError{constructor({callbackSelector:r,cause:t,data:c,extraData:i,sender:u,urls:a}){var d;super(t.shortMessage||"An error occurred while fetching for an offchain result.",{cause:t,metaMessages:[...t.metaMessages||[],(d=t.metaMessages)!=null&&d.length?"":[],"Offchain Gateway Call:",a&&["  Gateway URL(s):",...a.map(f=>`    ${e.getUrl(f)}`)],`  Sender: ${u}`,`  Data: ${c}`,`  Callback selector: ${r}`,`  Extra data: ${i}`].flat()}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupError"})}}class w extends e.BaseError{constructor({result:r,url:t}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${e.getUrl(t)}`,`Response: ${e.stringify(r)}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupResponseMalformedError"})}}class b extends e.BaseError{constructor({sender:r,to:t}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${t}`,`OffchainLookup sender address: ${r}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupSenderMismatchError"})}}function g(n,r){if(!e.isAddress(n))throw new e.InvalidAddressError({address:n});if(!e.isAddress(r))throw new e.InvalidAddressError({address:r});return n.toLowerCase()===r.toLowerCase()}const k="0x556f1830",p={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function E(n,{blockNumber:r,blockTag:t,data:c,to:i}){const{args:u}=e.decodeErrorResult({data:c,abi:[p]}),[a,d,f,s,o]=u;try{if(!g(i,a))throw new b({sender:a,to:i});const l=await h({data:f,sender:a,urls:d}),{data:m}=await e.call(n,{blockNumber:r,blockTag:t,data:e.concat([s,e.encodeAbiParameters([{type:"bytes"},{type:"bytes"}],[l,o])]),to:i});return m}catch(l){throw new y({callbackSelector:s,cause:l,data:c,extraData:o,sender:a,urls:d})}}async function h({data:n,sender:r,urls:t}){var i;let c=new Error("An unknown error occurred.");for(let u=0;u<t.length;u++){const a=t[u],d=a.includes("{data}")?"GET":"POST",f=d==="POST"?{data:n,sender:r}:void 0;try{const s=await fetch(a.replace("{sender}",r).replace("{data}",n),{body:JSON.stringify(f),method:d});let o;if((i=s.headers.get("Content-Type"))!=null&&i.startsWith("application/json")?o=(await s.json()).data:o=await s.text(),!s.ok){c=new e.HttpRequestError({body:f,details:o!=null&&o.error?e.stringify(o.error):s.statusText,headers:s.headers,status:s.status,url:a});continue}if(!e.isHex(o)){c=new w({result:o,url:a});continue}return o}catch(s){c=new e.HttpRequestError({body:f,details:s.message,url:a})}}throw c}exports.ccipFetch=h;exports.offchainLookup=E;exports.offchainLookupAbiItem=p;exports.offchainLookupSignature=k;
