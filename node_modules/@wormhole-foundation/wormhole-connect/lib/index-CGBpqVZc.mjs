import { aG as F, aQ as L, aR as g, aS as k, aT as I, D as T, F as D } from "./index-CGIqRhuR.mjs";
function P(n, t, e, s) {
  L(n);
  const i = g({ dkLen: 32, asyncTick: 10 }, s), { c: u, dkLen: a, asyncTick: o } = i;
  if (k(u), k(a), k(o), u < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const d = I(t), c = I(e), f = new Uint8Array(a), l = T.create(n, d), r = l._cloneInto().update(c);
  return { c: u, dkLen: a, asyncTick: o, DK: f, PRF: l, PRFSalt: r };
}
function R(n, t, e, s, i) {
  return n.destroy(), t.destroy(), s && s.destroy(), i.fill(0), e;
}
function S(n, t, e, s) {
  const { c: i, dkLen: u, DK: a, PRF: o, PRFSalt: d } = P(n, t, e, s);
  let c;
  const f = new Uint8Array(4), l = F(f), r = new Uint8Array(o.outputLen);
  for (let w = 1, p = 0; p < u; w++, p += o.outputLen) {
    const m = a.subarray(p, p + o.outputLen);
    l.setInt32(0, w, !1), (c = d._cloneInto(c)).update(f).digestInto(r), m.set(r.subarray(0, m.length));
    for (let h = 1; h < i; h++) {
      o._cloneInto(c).update(r).digestInto(r);
      for (let y = 0; y < m.length; y++)
        m[y] ^= r[y];
    }
  }
  return R(o, d, a, c, r);
}
/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
function b(n) {
  if (typeof n != "string")
    throw new TypeError("invalid mnemonic type: " + typeof n);
  return n.normalize("NFKD");
}
function K(n) {
  const t = b(n), e = t.split(" ");
  if (![12, 15, 18, 21, 24].includes(e.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: t, words: e };
}
const v = (n) => b("mnemonic" + n);
function E(n, t = "") {
  return S(D, K(n).nfkd, v(t), { c: 2048, dkLen: 64 });
}
export {
  E as m
};
