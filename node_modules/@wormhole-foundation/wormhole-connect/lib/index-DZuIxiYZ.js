"use strict";var S=Object.defineProperty;var P=(l,o,t)=>o in l?S(l,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[o]=t;var h=(l,o,t)=>P(l,typeof o!="symbol"?o+"":o,t);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const e=require("./index-Cq7ztix4.js"),U=require("./index-BRAjbwxR.js"),A=new e.Interface(["function start((bytes32,address,address,address,address,address,uint256,uint256,uint256,uint256)) returns (address,uint16,uint64)","function receiveMessageAndSwap(bytes)"]),q=new e.Interface(["function quoteExactInputSingle((address,address,uint256,uint24,uint160)) public view returns (uint256,uint160,uint32,uint256)"]),N="https://gfx.relayers.xlabs.xyz/api/v1/swap/quote";class R{static async quoteRelayer(o,t,r){var a;if(e.isNative(t)||e.isNative(r))throw new Error("how did you get here tho?");const n=e.hex.encode(t.toUniversalAddress().toUint8Array(),!1),s=e.hex.encode(r.toUniversalAddress().toUint8Array(),!1),i={targetChain:e.toChainId(o),sourceToken:n,targetToken:s};try{const c=await e.axios.post(N,i);return BigInt(c.data.fee)}catch(c){throw e.axios.isAxiosError(c)?new Error(`Error getting relayer fee: ${(a=c.response)==null?void 0:a.statusText}`):c}}}const m=100,E={ETH:[e.Wormhole.tokenId("Arbitrum","native"),e.Wormhole.tokenId("Base","native"),e.Wormhole.tokenId("Ethereum","native"),e.Wormhole.tokenId("Optimism","native")],WETH:[e.Wormhole.tokenId("Arbitrum","0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"),e.Wormhole.tokenId("Avalanche","0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB"),e.Wormhole.tokenId("Base","0x4200000000000000000000000000000000000006"),e.Wormhole.tokenId("Bsc","0x2170Ed0880ac9A755fd29B2688956BD959F933F8"),e.Wormhole.tokenId("Ethereum","0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"),e.Wormhole.tokenId("Optimism","0x4200000000000000000000000000000000000006"),e.Wormhole.tokenId("Polygon","0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619")],wstETH:[e.Wormhole.tokenId("Arbitrum","0x5979D7b546E38E414F7E9822514be443A4800529"),e.Wormhole.tokenId("Base","0xc1CBa3fCea344f92D9239c08C0568f6F2F0ee452"),e.Wormhole.tokenId("Ethereum","0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0"),e.Wormhole.tokenId("Optimism","0x1F32b1c2345538c0c6f582fCB022739c4A194Ebb"),e.Wormhole.tokenId("Polygon","0x03b54A6e9a984069379fae1a4fC4dBAE93B3bCCD")],USDT:[e.Wormhole.tokenId("Arbitrum","0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9"),e.Wormhole.tokenId("Avalanche","0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7"),e.Wormhole.tokenId("Base","0xfde4C96c8593536E31F229EA8f37b2ADa2699bb2"),e.Wormhole.tokenId("Bsc","0x55d398326f99059fF775485246999027B3197955"),e.Wormhole.tokenId("Ethereum","0xdAC17F958D2ee523a2206206994597C13D831ec7"),e.Wormhole.tokenId("Optimism","0x94b008aA00579c1307B0EF2c499aD98a8ce58e58"),e.Wormhole.tokenId("Polygon","0xc2132D05D31c914a87C6611C10748AEb04B58e8F"),e.Wormhole.tokenId("Celo","0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e")]};class p{constructor(o,t,r,n){h(this,"network");h(this,"chain");h(this,"provider");h(this,"contracts");h(this,"chainId");h(this,"core");h(this,"tokenBridge");if(this.network=o,this.chain=t,this.provider=r,this.contracts=n,!n.portico)throw new Error("Unsupported chain, no contract addresses for: "+t);this.core=new e.EvmWormholeCore(o,t,r,n),this.tokenBridge=new U.EvmTokenBridge(o,t,r,n),this.chainId=e.networkChainToNativeChainId.get(o,t)}static async fromRpc(o,t){const[r,n]=await e.EvmPlatform.chainFromRpc(o),s=t[n];if(s.network!==r)throw new Error(`Network mismatch: ${s.network} != ${r}`);return new p(r,n,o,s.contracts)}async*transfer(o,t,r,n,s,d,i){const{minAmountStart:a,minAmountFinish:c}=i.swapAmounts;if(a===0n)throw new Error("Invalid min swap amount");if(c===0n)throw new Error("Invalid min swap amount");const f=new e.EvmAddress(o).toString(),[u,g]=e.resolveWrappedToken(this.network,this.chain,r),[T,C]=e.resolveWrappedToken(this.network,t.chain,s),k=e.canonicalAddress(g),I=e.canonicalAddress(await this.getTransferrableToken(k)),b=e.canonicalAddress(t),v=e.canonicalAddress(C),F=new Date().valueOf()%2**4,B=e.PorticoBridge.serializeFlagSet({flags:{shouldWrapNative:u,shouldUnwrapNative:T},recipientChain:e.toChainId(t.chain),bridgeNonce:F,feeTierStart:m,feeTierFinish:m,padding:new Uint8Array(19)}),y=A.encodeFunctionData("start",[[B,k.toLowerCase(),I,v.toLowerCase(),b,d,n.toString(),a.toString(),c.toString(),i.relayerFee.toString()]]),x=this.getTokenGroup(g.address.toString()),w=this.getPorticoAddress(x);u||(yield*this.approve(k,f,n,w));const W=await this.core.getMessageFee(),D={to:w,data:y,value:W+(u?n:0n)};yield this.createUnsignedTransaction(e.addFrom(D,f),"PorticoBridge.Transfer")}async*redeem(o,t){const r=e.toChain(t.payload.payload.flagSet.recipientChain),n=t.payload.payload.finalTokenAddress.toNative(r).toString(),s=this.getTokenGroup(n),d=this.getPorticoAddress(s),a=await new e.Contract(d,A.fragments,this.provider).getFunction("receiveMessageAndSwap").populateTransaction(e.serialize(t)),c=new e.EvmAddress(o).toString();yield this.createUnsignedTransaction(e.addFrom(a,c),"PorticoBridge.Redeem")}async isTransferCompleted(o){return await this.tokenBridge.tokenBridge.isTransferCompleted(e.keccak256(o.hash))}async quoteSwap(o,t,r,n){const[,s]=e.resolveWrappedToken(this.network,this.chain,o),[,d]=e.resolveWrappedToken(this.network,this.chain,t),i=e.canonicalAddress(s),a=e.canonicalAddress(d);if(e.isEqualCaseInsensitive(i,a))return n;const c=this.getQuoterAddress(r);return(await new e.Contract(c,q.fragments,this.provider).getFunction("quoteExactInputSingle").staticCall([i,a,n,m,0]))[0]}async quoteRelay(o,t){return await R.quoteRelayer(this.chain,o,t)}async getTransferrableToken(o){const t=e.Wormhole.tokenId(this.chain,o),[,r]=e.resolveWrappedToken(this.network,this.chain,t);if(this.chain==="Ethereum")return r;const n=Object.values(E).find(i=>i.find(a=>a.chain===this.chain&&e.canonicalAddress(a)===e.canonicalAddress(r)));if(!n)throw new Error(`No token group found for ${o} on ${this.chain}`);const s=n.find(i=>i.chain==="Ethereum");if(!s)throw new Error(`No Ethereum origin token found for ${o} on ${this.chain}`);const d=await this.tokenBridge.getWrappedAsset(s);return e.Wormhole.tokenId(this.chain,d.toString())}supportedTokens(){const o=[];for(const[t,r]of Object.entries(E))for(const n of r)n.chain===this.chain&&o.push({group:t,token:n});return o}getTokenGroup(o){const r=this.supportedTokens().find(n=>e.canonicalAddress(n.token)===o);if(!r)throw new Error("Token not found");return r.group}async*approve(o,t,r,n){const s=e.EvmPlatform.getTokenImplementation(this.provider,o);if(await s.allowance(t,n)<r){const i=await s.approve.populateTransaction(n,r);yield this.createUnsignedTransaction(e.addFrom(i,t),"PorticoBridge.Approve")}}createUnsignedTransaction(o,t){return new e.EvmUnsignedTransaction(e.addChainId(o,this.chainId),this.network,this.chain,t,!1)}getPorticoAddress(o){const t=this.contracts.portico;return o==="USDT"&&t.porticoPancakeSwap||t.porticoUniswap}getQuoterAddress(o){const t=this.contracts.portico;return o==="USDT"&&t.pancakeSwapQuoterV2||t.uniswapQuoterV2}}e.registerProtocol(e._platform,"PorticoBridge",p);exports.EvmPorticoBridge=p;
