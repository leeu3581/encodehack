var T = Object.defineProperty;
var l = (i, t, e) => t in i ? T(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var r = (i, t, e) => l(i, typeof t != "symbol" ? t + "" : t, e);
import { bD as b, b4 as p, b3 as g, $ as y, b6 as m, E as d, b as h, b2 as f, b8 as o, ba as u, bd as k, be as v, bf as C, _ as A } from "./index-CGIqRhuR.mjs";
class c {
  constructor(t, e, a, n) {
    r(this, "network");
    r(this, "chain");
    r(this, "provider");
    r(this, "contracts");
    r(this, "chainId");
    r(this, "core");
    r(this, "gatewayAddress");
    r(this, "gateway");
    r(this, "tbtcTokenAddr");
    if (this.network = t, this.chain = e, this.provider = a, this.contracts = n, this.network !== "Mainnet")
      throw new Error("TBTC is only supported on Mainnet");
    if (!this.contracts.tbtc)
      throw new Error("TBTC contract address is required");
    const s = b.getNativeTbtcToken(this.chain);
    if (!s)
      throw new Error("Native tbtc token not found");
    this.chainId = p.get(t, e), this.core = new g(t, e, a, n), this.gatewayAddress = this.contracts.tbtc, this.gateway = new y(this.gatewayAddress, [
      "function sendTbtc(uint256 amount, uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) payable returns (uint64)",
      "function receiveTbtc(bytes calldata encodedVm)"
    ], a), this.tbtcTokenAddr = m(s);
  }
  static async fromRpc(t, e) {
    const [a, n] = await d.chainFromRpc(t), s = e[n];
    if (s.network !== a)
      throw new Error(`Network mismatch: ${s.network} != ${a}`);
    return new c(a, n, t, s.contracts);
  }
  async *transfer(t, e, a) {
    const n = new h(t).toString(), s = await this.gateway.sendTbtc.populateTransaction(a, f(e.chain), e.address.toUniversalAddress().toUint8Array(), 0n, 0n);
    s.value = await this.core.getMessageFee(), yield* this.approve(n, a, this.gatewayAddress), yield this.createUnsignedTransaction(o(s, n), "TBTCBridge.Send");
  }
  async *redeem(t, e) {
    if (e.payloadName !== "GatewayTransfer")
      throw new Error("Invalid VAA payload");
    const a = new h(t).toString(), n = await this.gateway.receiveTbtc.populateTransaction(u(e));
    yield this.createUnsignedTransaction(o(n, a), "TBTCBridge.Redeem");
  }
  async *approve(t, e, a) {
    const n = d.getTokenImplementation(this.provider, this.tbtcTokenAddr);
    if (await n.allowance(t, a) < e) {
      const w = await n.approve.populateTransaction(a, e);
      yield this.createUnsignedTransaction(o(w, t), "TBTC.Approve");
    }
  }
  createUnsignedTransaction(t, e) {
    return new k(v(t, this.chainId), this.network, this.chain, e, !1);
  }
}
C(A, "TBTCBridge", c);
export {
  c as EvmTBTCBridge
};
