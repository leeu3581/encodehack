var d = Object.defineProperty;
var h = (i, e, r) => e in i ? d(i, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : i[e] = r;
var o = (i, e, r) => h(i, typeof e != "symbol" ? e + "" : e, r);
import { b2 as m, I as w, cg as g, K as p, bf as u } from "./index-CGIqRhuR.mjs";
class c {
  constructor(e, r, t, n) {
    o(this, "network");
    o(this, "chain");
    o(this, "provider");
    o(this, "contracts");
    o(this, "chainId");
    o(this, "coreBridgePackageId");
    this.network = e, this.chain = r, this.provider = t, this.contracts = n, this.chainId = m(r);
    const s = n.coreBridge;
    if (!s)
      throw new Error(`CoreBridge contract Address for chain ${r} not found`);
    this.coreBridgePackageId = s;
  }
  getGuardianSet(e) {
    throw new Error("Method not implemented.");
  }
  getMessageFee() {
    throw new Error("Method not implemented.");
  }
  static async fromRpc(e, r) {
    const [t, n] = await w.chainFromRpc(e), s = r[n];
    if (s.network !== t)
      throw new Error(`Network mismatch: ${s.network} !== ${t}`);
    return new c(t, n, e, s.contracts);
  }
  async *verifyMessage(e, r) {
    throw new Error("Method not implemented.");
  }
  async *publishMessage(e, r) {
    throw new Error("Method not implemented.");
  }
  async parseTransaction(e) {
    return (await this.parseMessages(e)).map((t) => ({
      emitter: t.emitterAddress,
      sequence: t.sequence,
      chain: this.chain
    }));
  }
  async getGuardianSetIndex() {
    throw new Error("Method not implemented.");
  }
  async parseMessages(e) {
    var n;
    const t = (n = (await this.provider.getTransactionBlock({
      digest: e,
      options: { showEvents: !0, showEffects: !0, showInput: !0 }
    })).events) == null ? void 0 : n.filter((s) => s.type.endsWith("WormholeMessage"));
    if (!t || t.length == 0)
      throw new Error("WormholeMessage not found");
    return t.map((s) => {
      const a = s.parsedJson;
      return g("Uint8Array", {
        emitterChain: this.chain,
        emitterAddress: new p(a.sender).toUniversalAddress(),
        sequence: BigInt(a.sequence),
        guardianSet: 0,
        // TODO: need to implement guardian set idx
        timestamp: Number(a.timestamp),
        consistencyLevel: a.consistency_level,
        nonce: a.nonce,
        signatures: [],
        payload: new Uint8Array(a.payload)
      });
    });
  }
}
u("Sui", "WormholeCore", c);
export {
  c as SuiWormholeCore
};
