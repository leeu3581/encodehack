import { bJ as K, cX as Z } from "./index-CGIqRhuR.mjs";
const j = "logger/5.8.0";
let F = !1, k = !1;
const U = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let G = U.default, P = null;
function q() {
  try {
    const r = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((t) => {
      try {
        if ("test".normalize(t) !== "test")
          throw new Error("bad normalize");
      } catch {
        r.push(t);
      }
    }), r.length)
      throw new Error("missing " + r.join(", "));
    if ("é".normalize("NFD") !== "é")
      throw new Error("broken implementation");
  } catch (r) {
    return r.message;
  }
  return null;
}
const L = q();
var D;
(function(r) {
  r.DEBUG = "DEBUG", r.INFO = "INFO", r.WARNING = "WARNING", r.ERROR = "ERROR", r.OFF = "OFF";
})(D || (D = {}));
var E;
(function(r) {
  r.UNKNOWN_ERROR = "UNKNOWN_ERROR", r.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", r.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", r.NETWORK_ERROR = "NETWORK_ERROR", r.SERVER_ERROR = "SERVER_ERROR", r.TIMEOUT = "TIMEOUT", r.BUFFER_OVERRUN = "BUFFER_OVERRUN", r.NUMERIC_FAULT = "NUMERIC_FAULT", r.MISSING_NEW = "MISSING_NEW", r.INVALID_ARGUMENT = "INVALID_ARGUMENT", r.MISSING_ARGUMENT = "MISSING_ARGUMENT", r.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", r.CALL_EXCEPTION = "CALL_EXCEPTION", r.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", r.NONCE_EXPIRED = "NONCE_EXPIRED", r.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", r.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", r.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", r.ACTION_REJECTED = "ACTION_REJECTED";
})(E || (E = {}));
const B = "0123456789abcdef";
class o {
  constructor(t) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: t,
      writable: !1
    });
  }
  _log(t, e) {
    const n = t.toLowerCase();
    U[n] == null && this.throwArgumentError("invalid log level name", "logLevel", t), !(G > U[n]) && console.log.apply(console, e);
  }
  debug(...t) {
    this._log(o.levels.DEBUG, t);
  }
  info(...t) {
    this._log(o.levels.INFO, t);
  }
  warn(...t) {
    this._log(o.levels.WARNING, t);
  }
  makeError(t, e, n) {
    if (k)
      return this.makeError("censored error", e, {});
    e || (e = o.errors.UNKNOWN_ERROR), n || (n = {});
    const i = [];
    Object.keys(n).forEach((g) => {
      const p = n[g];
      try {
        if (p instanceof Uint8Array) {
          let S = "";
          for (let I = 0; I < p.length; I++)
            S += B[p[I] >> 4], S += B[p[I] & 15];
          i.push(g + "=Uint8Array(0x" + S + ")");
        } else
          i.push(g + "=" + JSON.stringify(p));
      } catch {
        i.push(g + "=" + JSON.stringify(n[g].toString()));
      }
    }), i.push(`code=${e}`), i.push(`version=${this.version}`);
    const N = t;
    let m = "";
    switch (e) {
      case E.NUMERIC_FAULT: {
        m = "NUMERIC_FAULT";
        const g = t;
        switch (g) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            m += "-" + g;
            break;
          case "negative-power":
          case "negative-width":
            m += "-unsupported";
            break;
          case "unbound-bitwise-result":
            m += "-unbound-result";
            break;
        }
        break;
      }
      case E.CALL_EXCEPTION:
      case E.INSUFFICIENT_FUNDS:
      case E.MISSING_NEW:
      case E.NONCE_EXPIRED:
      case E.REPLACEMENT_UNDERPRICED:
      case E.TRANSACTION_REPLACED:
      case E.UNPREDICTABLE_GAS_LIMIT:
        m = e;
        break;
    }
    m && (t += " [ See: https://links.ethers.org/v5-errors-" + m + " ]"), i.length && (t += " (" + i.join(", ") + ")");
    const R = new Error(t);
    return R.reason = N, R.code = e, Object.keys(n).forEach(function(g) {
      R[g] = n[g];
    }), R;
  }
  throwError(t, e, n) {
    throw this.makeError(t, e, n);
  }
  throwArgumentError(t, e, n) {
    return this.throwError(t, o.errors.INVALID_ARGUMENT, {
      argument: e,
      value: n
    });
  }
  assert(t, e, n, i) {
    t || this.throwError(e, n, i);
  }
  assertArgument(t, e, n, i) {
    t || this.throwArgumentError(e, n, i);
  }
  checkNormalize(t) {
    L && this.throwError("platform missing String.prototype.normalize", o.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: L
    });
  }
  checkSafeUint53(t, e) {
    typeof t == "number" && (e == null && (e = "value not safe"), (t < 0 || t >= 9007199254740991) && this.throwError(e, o.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: t
    }), t % 1 && this.throwError(e, o.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: t
    }));
  }
  checkArgumentCount(t, e, n) {
    n ? n = ": " + n : n = "", t < e && this.throwError("missing argument" + n, o.errors.MISSING_ARGUMENT, {
      count: t,
      expectedCount: e
    }), t > e && this.throwError("too many arguments" + n, o.errors.UNEXPECTED_ARGUMENT, {
      count: t,
      expectedCount: e
    });
  }
  checkNew(t, e) {
    (t === Object || t == null) && this.throwError("missing new", o.errors.MISSING_NEW, { name: e.name });
  }
  checkAbstract(t, e) {
    t === e ? this.throwError("cannot instantiate abstract class " + JSON.stringify(e.name) + " directly; use a sub-class", o.errors.UNSUPPORTED_OPERATION, { name: t.name, operation: "new" }) : (t === Object || t == null) && this.throwError("missing new", o.errors.MISSING_NEW, { name: e.name });
  }
  static globalLogger() {
    return P || (P = new o(j)), P;
  }
  static setCensorship(t, e) {
    if (!t && e && this.globalLogger().throwError("cannot permanently disable censorship", o.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), F) {
      if (!t)
        return;
      this.globalLogger().throwError("error censorship permanent", o.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    k = !!t, F = !!e;
  }
  static setLogLevel(t) {
    const e = U[t.toLowerCase()];
    if (e == null) {
      o.globalLogger().warn("invalid log level - " + t);
      return;
    }
    G = e;
  }
  static from(t) {
    return new o(t);
  }
}
o.errors = E;
o.levels = D;
const Q = "bytes/5.8.0", f = new o(Q);
function W(r) {
  return !!r.toHexString;
}
function y(r) {
  return r.slice || (r.slice = function() {
    const t = Array.prototype.slice.call(arguments);
    return y(new Uint8Array(Array.prototype.slice.apply(r, t)));
  }), r;
}
function Y(r) {
  return a(r) && !(r.length % 2) || T(r);
}
function z(r) {
  return typeof r == "number" && r == r && r % 1 === 0;
}
function T(r) {
  if (r == null)
    return !1;
  if (r.constructor === Uint8Array)
    return !0;
  if (typeof r == "string" || !z(r.length) || r.length < 0)
    return !1;
  for (let t = 0; t < r.length; t++) {
    const e = r[t];
    if (!z(e) || e < 0 || e >= 256)
      return !1;
  }
  return !0;
}
function A(r, t) {
  if (t || (t = {}), typeof r == "number") {
    f.checkSafeUint53(r, "invalid arrayify value");
    const e = [];
    for (; r; )
      e.unshift(r & 255), r = parseInt(String(r / 256));
    return e.length === 0 && e.push(0), y(new Uint8Array(e));
  }
  if (t.allowMissingPrefix && typeof r == "string" && r.substring(0, 2) !== "0x" && (r = "0x" + r), W(r) && (r = r.toHexString()), a(r)) {
    let e = r.substring(2);
    e.length % 2 && (t.hexPad === "left" ? e = "0" + e : t.hexPad === "right" ? e += "0" : f.throwArgumentError("hex data is odd-length", "value", r));
    const n = [];
    for (let i = 0; i < e.length; i += 2)
      n.push(parseInt(e.substring(i, i + 2), 16));
    return y(new Uint8Array(n));
  }
  return T(r) ? y(new Uint8Array(r)) : f.throwArgumentError("invalid arrayify value", "value", r);
}
function Er(r) {
  const t = r.map((i) => A(i)), e = t.reduce((i, N) => i + N.length, 0), n = new Uint8Array(e);
  return t.reduce((i, N) => (n.set(N, i), i + N.length), 0), y(n);
}
function rr(r, t) {
  r = A(r), r.length > t && f.throwArgumentError("value out of range", "value", arguments[0]);
  const e = new Uint8Array(t);
  return e.set(r, t - r.length), y(e);
}
function a(r, t) {
  return !(typeof r != "string" || !r.match(/^0x[0-9A-Fa-f]*$/) || t && r.length !== 2 + 2 * t);
}
const O = "0123456789abcdef";
function c(r, t) {
  if (t || (t = {}), typeof r == "number") {
    f.checkSafeUint53(r, "invalid hexlify value");
    let e = "";
    for (; r; )
      e = O[r & 15] + e, r = Math.floor(r / 16);
    return e.length ? (e.length % 2 && (e = "0" + e), "0x" + e) : "0x00";
  }
  if (typeof r == "bigint")
    return r = r.toString(16), r.length % 2 ? "0x0" + r : "0x" + r;
  if (t.allowMissingPrefix && typeof r == "string" && r.substring(0, 2) !== "0x" && (r = "0x" + r), W(r))
    return r.toHexString();
  if (a(r))
    return r.length % 2 && (t.hexPad === "left" ? r = "0x0" + r.substring(2) : t.hexPad === "right" ? r += "0" : f.throwArgumentError("hex data is odd-length", "value", r)), r.toLowerCase();
  if (T(r)) {
    let e = "0x";
    for (let n = 0; n < r.length; n++) {
      let i = r[n];
      e += O[(i & 240) >> 4] + O[i & 15];
    }
    return e;
  }
  return f.throwArgumentError("invalid hexlify value", "value", r);
}
function mr(r) {
  if (typeof r != "string")
    r = c(r);
  else if (!a(r) || r.length % 2)
    return null;
  return (r.length - 2) / 2;
}
function Nr(r, t, e) {
  return typeof r != "string" ? r = c(r) : (!a(r) || r.length % 2) && f.throwArgumentError("invalid hexData", "value", r), t = 2 + 2 * t, e != null ? "0x" + r.substring(t, 2 + 2 * e) : "0x" + r.substring(t);
}
function wr(r) {
  let t = "0x";
  return r.forEach((e) => {
    t += c(e).substring(2);
  }), t;
}
function d(r, t) {
  for (typeof r != "string" ? r = c(r) : a(r) || f.throwArgumentError("invalid hex string", "value", r), r.length > 2 * t + 2 && f.throwArgumentError("value out of range", "value", arguments[1]); r.length < 2 * t + 2; )
    r = "0x0" + r.substring(2);
  return r;
}
function Ar(r) {
  const t = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (Y(r)) {
    let e = A(r);
    e.length === 64 ? (t.v = 27 + (e[32] >> 7), e[32] &= 127, t.r = c(e.slice(0, 32)), t.s = c(e.slice(32, 64))) : e.length === 65 ? (t.r = c(e.slice(0, 32)), t.s = c(e.slice(32, 64)), t.v = e[64]) : f.throwArgumentError("invalid signature string", "signature", r), t.v < 27 && (t.v === 0 || t.v === 1 ? t.v += 27 : f.throwArgumentError("signature invalid v byte", "signature", r)), t.recoveryParam = 1 - t.v % 2, t.recoveryParam && (e[32] |= 128), t._vs = c(e.slice(32, 64));
  } else {
    if (t.r = r.r, t.s = r.s, t.v = r.v, t.recoveryParam = r.recoveryParam, t._vs = r._vs, t._vs != null) {
      const i = rr(A(t._vs), 32);
      t._vs = c(i);
      const N = i[0] >= 128 ? 1 : 0;
      t.recoveryParam == null ? t.recoveryParam = N : t.recoveryParam !== N && f.throwArgumentError("signature recoveryParam mismatch _vs", "signature", r), i[0] &= 127;
      const m = c(i);
      t.s == null ? t.s = m : t.s !== m && f.throwArgumentError("signature v mismatch _vs", "signature", r);
    }
    if (t.recoveryParam == null)
      t.v == null ? f.throwArgumentError("signature missing v and recoveryParam", "signature", r) : t.v === 0 || t.v === 1 ? t.recoveryParam = t.v : t.recoveryParam = 1 - t.v % 2;
    else if (t.v == null)
      t.v = 27 + t.recoveryParam;
    else {
      const i = t.v === 0 || t.v === 1 ? t.v : 1 - t.v % 2;
      t.recoveryParam !== i && f.throwArgumentError("signature recoveryParam mismatch v", "signature", r);
    }
    t.r == null || !a(t.r) ? f.throwArgumentError("signature missing or invalid r", "signature", r) : t.r = d(t.r, 32), t.s == null || !a(t.s) ? f.throwArgumentError("signature missing or invalid s", "signature", r) : t.s = d(t.s, 32);
    const e = A(t.s);
    e[0] >= 128 && f.throwArgumentError("signature s out of range", "signature", r), t.recoveryParam && (e[0] |= 128);
    const n = c(e);
    t._vs && (a(t._vs) || f.throwArgumentError("signature invalid _vs", "signature", r), t._vs = d(t._vs, 32)), t._vs == null ? t._vs = n : t._vs !== n && f.throwArgumentError("signature _vs mismatch v and s", "signature", r);
  }
  return t.yParityAndS = t._vs, t.compact = t.r + t.yParityAndS.substring(2), t;
}
const tr = "bignumber/5.7.0";
var _ = K.BN;
const w = new o(tr), C = {}, er = 9007199254740991;
let $ = !1;
class h {
  constructor(t, e) {
    t !== C && w.throwError("cannot call constructor directly; use BigNumber.from", o.errors.UNSUPPORTED_OPERATION, {
      operation: "new (BigNumber)"
    }), this._hex = e, this._isBigNumber = !0, Object.freeze(this);
  }
  fromTwos(t) {
    return u(s(this).fromTwos(t));
  }
  toTwos(t) {
    return u(s(this).toTwos(t));
  }
  abs() {
    return this._hex[0] === "-" ? h.from(this._hex.substring(1)) : this;
  }
  add(t) {
    return u(s(this).add(s(t)));
  }
  sub(t) {
    return u(s(this).sub(s(t)));
  }
  div(t) {
    return h.from(t).isZero() && l("division-by-zero", "div"), u(s(this).div(s(t)));
  }
  mul(t) {
    return u(s(this).mul(s(t)));
  }
  mod(t) {
    const e = s(t);
    return e.isNeg() && l("division-by-zero", "mod"), u(s(this).umod(e));
  }
  pow(t) {
    const e = s(t);
    return e.isNeg() && l("negative-power", "pow"), u(s(this).pow(e));
  }
  and(t) {
    const e = s(t);
    return (this.isNegative() || e.isNeg()) && l("unbound-bitwise-result", "and"), u(s(this).and(e));
  }
  or(t) {
    const e = s(t);
    return (this.isNegative() || e.isNeg()) && l("unbound-bitwise-result", "or"), u(s(this).or(e));
  }
  xor(t) {
    const e = s(t);
    return (this.isNegative() || e.isNeg()) && l("unbound-bitwise-result", "xor"), u(s(this).xor(e));
  }
  mask(t) {
    return (this.isNegative() || t < 0) && l("negative-width", "mask"), u(s(this).maskn(t));
  }
  shl(t) {
    return (this.isNegative() || t < 0) && l("negative-width", "shl"), u(s(this).shln(t));
  }
  shr(t) {
    return (this.isNegative() || t < 0) && l("negative-width", "shr"), u(s(this).shrn(t));
  }
  eq(t) {
    return s(this).eq(s(t));
  }
  lt(t) {
    return s(this).lt(s(t));
  }
  lte(t) {
    return s(this).lte(s(t));
  }
  gt(t) {
    return s(this).gt(s(t));
  }
  gte(t) {
    return s(this).gte(s(t));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return s(this).isZero();
  }
  toNumber() {
    try {
      return s(this).toNumber();
    } catch {
      l("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return w.throwError("this platform does not support BigInt", o.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? $ || ($ = !0, w.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? w.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", o.errors.UNEXPECTED_ARGUMENT, {}) : w.throwError("BigNumber.toString does not accept parameters", o.errors.UNEXPECTED_ARGUMENT, {})), s(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(t) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(t) {
    if (t instanceof h)
      return t;
    if (typeof t == "string")
      return t.match(/^-?0x[0-9a-f]+$/i) ? new h(C, b(t)) : t.match(/^-?[0-9]+$/) ? new h(C, b(new _(t))) : w.throwArgumentError("invalid BigNumber string", "value", t);
    if (typeof t == "number")
      return t % 1 && l("underflow", "BigNumber.from", t), (t >= er || t <= -9007199254740991) && l("overflow", "BigNumber.from", t), h.from(String(t));
    const e = t;
    if (typeof e == "bigint")
      return h.from(e.toString());
    if (T(e))
      return h.from(c(e));
    if (e)
      if (e.toHexString) {
        const n = e.toHexString();
        if (typeof n == "string")
          return h.from(n);
      } else {
        let n = e._hex;
        if (n == null && e.type === "BigNumber" && (n = e.hex), typeof n == "string" && (a(n) || n[0] === "-" && a(n.substring(1))))
          return h.from(n);
      }
    return w.throwArgumentError("invalid BigNumber value", "value", t);
  }
  static isBigNumber(t) {
    return !!(t && t._isBigNumber);
  }
}
function b(r) {
  if (typeof r != "string")
    return b(r.toString(16));
  if (r[0] === "-")
    return r = r.substring(1), r[0] === "-" && w.throwArgumentError("invalid hex", "value", r), r = b(r), r === "0x00" ? r : "-" + r;
  if (r.substring(0, 2) !== "0x" && (r = "0x" + r), r === "0x")
    return "0x00";
  for (r.length % 2 && (r = "0x0" + r.substring(2)); r.length > 4 && r.substring(0, 4) === "0x00"; )
    r = "0x" + r.substring(4);
  return r;
}
function u(r) {
  return h.from(b(r));
}
function s(r) {
  const t = h.from(r).toHexString();
  return t[0] === "-" ? new _("-" + t.substring(3), 16) : new _(t.substring(2), 16);
}
function l(r, t, e) {
  const n = { fault: r, operation: t };
  return e != null && (n.value = e), w.throwError(r, o.errors.NUMERIC_FAULT, n);
}
function nr(r) {
  return new _(r, 36).toString(16);
}
const ir = "properties/5.7.0", V = new o(ir);
function sr(r, t, e) {
  Object.defineProperty(r, t, {
    enumerable: !0,
    value: e,
    writable: !1
  });
}
function yr(r, t) {
  for (let e = 0; e < 32; e++) {
    if (r[t])
      return r[t];
    if (!r.prototype || typeof r.prototype != "object")
      break;
    r = Object.getPrototypeOf(r.prototype).constructor;
  }
  return null;
}
const or = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 };
function J(r) {
  if (r == null || or[typeof r])
    return !0;
  if (Array.isArray(r) || typeof r == "object") {
    if (!Object.isFrozen(r))
      return !1;
    const t = Object.keys(r);
    for (let e = 0; e < t.length; e++) {
      let n = null;
      try {
        n = r[t[e]];
      } catch {
        continue;
      }
      if (!J(n))
        return !1;
    }
    return !0;
  }
  return V.throwArgumentError(`Cannot deepCopy ${typeof r}`, "object", r);
}
function fr(r) {
  if (J(r))
    return r;
  if (Array.isArray(r))
    return Object.freeze(r.map((t) => M(t)));
  if (typeof r == "object") {
    const t = {};
    for (const e in r) {
      const n = r[e];
      n !== void 0 && sr(t, e, M(n));
    }
    return t;
  }
  return V.throwArgumentError(`Cannot deepCopy ${typeof r}`, "object", r);
}
function M(r) {
  return fr(r);
}
class pr {
  constructor(t) {
    for (const e in t)
      this[e] = M(t[e]);
  }
}
function ur(r) {
  return "0x" + Z.keccak_256(A(r));
}
const hr = "address/5.7.0", x = new o(hr);
function X(r) {
  a(r, 20) || x.throwArgumentError("invalid address", "address", r), r = r.toLowerCase();
  const t = r.substring(2).split(""), e = new Uint8Array(40);
  for (let i = 0; i < 40; i++)
    e[i] = t[i].charCodeAt(0);
  const n = A(ur(e));
  for (let i = 0; i < 40; i += 2)
    n[i >> 1] >> 4 >= 8 && (t[i] = t[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (t[i + 1] = t[i + 1].toUpperCase());
  return "0x" + t.join("");
}
const cr = 9007199254740991;
function lr(r) {
  return Math.log10 ? Math.log10(r) : Math.log(r) / Math.LN10;
}
const v = {};
for (let r = 0; r < 10; r++)
  v[String(r)] = String(r);
for (let r = 0; r < 26; r++)
  v[String.fromCharCode(65 + r)] = String(10 + r);
const H = Math.floor(lr(cr));
function ar(r) {
  r = r.toUpperCase(), r = r.substring(4) + r.substring(0, 2) + "00";
  let t = r.split("").map((n) => v[n]).join("");
  for (; t.length >= H; ) {
    let n = t.substring(0, H);
    t = parseInt(n, 10) % 97 + t.substring(n.length);
  }
  let e = String(98 - parseInt(t, 10) % 97);
  for (; e.length < 2; )
    e = "0" + e;
  return e;
}
function xr(r) {
  let t = null;
  if (typeof r != "string" && x.throwArgumentError("invalid address", "address", r), r.match(/^(0x)?[0-9a-fA-F]{40}$/))
    r.substring(0, 2) !== "0x" && (r = "0x" + r), t = X(r), r.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && t !== r && x.throwArgumentError("bad address checksum", "address", r);
  else if (r.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (r.substring(2, 4) !== ar(r) && x.throwArgumentError("bad icap checksum", "address", r), t = nr(r.substring(4)); t.length < 40; )
      t = "0" + t;
    t = X("0x" + t);
  } else
    x.throwArgumentError("invalid address", "address", r);
  return t;
}
export {
  h as B,
  pr as D,
  o as L,
  A as a,
  wr as b,
  Er as c,
  sr as d,
  d as e,
  yr as f,
  xr as g,
  c as h,
  Nr as i,
  a as j,
  ur as k,
  mr as l,
  Ar as s
};
