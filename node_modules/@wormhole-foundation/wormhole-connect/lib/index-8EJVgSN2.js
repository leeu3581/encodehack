"use strict";var h=Object.defineProperty;var w=(o,t,e)=>t in o?h(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e;var s=(o,t,e)=>w(o,typeof t!="symbol"?t+"":t,e);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const n=require("./index-Cq7ztix4.js");class c{constructor(t,e,a,r){s(this,"network");s(this,"chain");s(this,"provider");s(this,"contracts");s(this,"chainId");s(this,"core");s(this,"gatewayAddress");s(this,"gateway");s(this,"tbtcTokenAddr");if(this.network=t,this.chain=e,this.provider=a,this.contracts=r,this.network!=="Mainnet")throw new Error("TBTC is only supported on Mainnet");if(!this.contracts.tbtc)throw new Error("TBTC contract address is required");const i=n.TBTCBridge.getNativeTbtcToken(this.chain);if(!i)throw new Error("Native tbtc token not found");this.chainId=n.networkChainToNativeChainId.get(t,e),this.core=new n.EvmWormholeCore(t,e,a,r),this.gatewayAddress=this.contracts.tbtc,this.gateway=new n.Contract(this.gatewayAddress,["function sendTbtc(uint256 amount, uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) payable returns (uint64)","function receiveTbtc(bytes calldata encodedVm)"],a),this.tbtcTokenAddr=n.canonicalAddress(i)}static async fromRpc(t,e){const[a,r]=await n.EvmPlatform.chainFromRpc(t),i=e[r];if(i.network!==a)throw new Error(`Network mismatch: ${i.network} != ${a}`);return new c(a,r,t,i.contracts)}async*transfer(t,e,a){const r=new n.EvmAddress(t).toString(),i=await this.gateway.sendTbtc.populateTransaction(a,n.toChainId(e.chain),e.address.toUniversalAddress().toUint8Array(),0n,0n);i.value=await this.core.getMessageFee(),yield*this.approve(r,a,this.gatewayAddress),yield this.createUnsignedTransaction(n.addFrom(i,r),"TBTCBridge.Send")}async*redeem(t,e){if(e.payloadName!=="GatewayTransfer")throw new Error("Invalid VAA payload");const a=new n.EvmAddress(t).toString(),r=await this.gateway.receiveTbtc.populateTransaction(n.serialize(e));yield this.createUnsignedTransaction(n.addFrom(r,a),"TBTCBridge.Redeem")}async*approve(t,e,a){const r=n.EvmPlatform.getTokenImplementation(this.provider,this.tbtcTokenAddr);if(await r.allowance(t,a)<e){const d=await r.approve.populateTransaction(a,e);yield this.createUnsignedTransaction(n.addFrom(d,t),"TBTC.Approve")}}createUnsignedTransaction(t,e){return new n.EvmUnsignedTransaction(n.addChainId(t,this.chainId),this.network,this.chain,e,!1)}}n.registerProtocol(n._platform,"TBTCBridge",c);exports.EvmTBTCBridge=c;
