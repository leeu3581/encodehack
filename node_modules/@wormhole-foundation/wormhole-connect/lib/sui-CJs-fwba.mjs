var zn = Object.defineProperty;
var On = (e, t, r) => t in e ? zn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var k = (e, t, r) => On(e, typeof t != "symbol" ? t + "" : t, r);
import { g as br } from "./wallets-B2tqS5lZ.mjs";
import { R as Bn } from "./util--bw7gFPs.mjs";
import { Q as Pn, O as Rn, as as tr, at as Un, u as Gn, T as Qn, X as rr, au as nr, U as Yn, a3 as _e } from "./index-CGIqRhuR.mjs";
function Wn(e) {
  return Uint8Array.from(atob(e), (t) => t.charCodeAt(0));
}
const dt = 8192;
function Lr(e) {
  if (e.length < dt)
    return btoa(String.fromCharCode(...e));
  let t = "";
  for (var r = 0; r < e.length; r += dt) {
    const n = e.slice(r, r + dt);
    t += String.fromCharCode(...n);
  }
  return btoa(t);
}
const Zn = 32;
function Vn(e, t = !1) {
  let r = e.toLowerCase();
  return !t && r.startsWith("0x") && (r = r.slice(2)), `0x${r.padStart(Zn * 2, "0")}`;
}
function Cr(e, t = !1) {
  return Vn(e, t);
}
BigInt(1e9);
Cr("0x6");
Cr("0x5");
let Fn = class extends TypeError {
  constructor(t, r) {
    let n;
    const { message: i, explanation: a, ...o } = t, { path: l } = t, c = l.length === 0 ? i : `At path: ${l.join(".")} -- ${i}`;
    super(a ?? c), a != null && (this.cause = c), Object.assign(this, o), this.name = this.constructor.name, this.failures = () => n ?? (n = [t, ...r()]);
  }
};
function Jn(e) {
  return Ee(e) && typeof e[Symbol.iterator] == "function";
}
function Ee(e) {
  return typeof e == "object" && e != null;
}
function be(e) {
  return typeof e == "symbol" ? e.toString() : typeof e == "string" ? JSON.stringify(e) : `${e}`;
}
function Hn(e) {
  const { done: t, value: r } = e.next();
  return t ? void 0 : r;
}
function Xn(e, t, r, n) {
  if (e === !0)
    return;
  e === !1 ? e = {} : typeof e == "string" && (e = { message: e });
  const { path: i, branch: a } = t, { type: o } = r, { refinement: l, message: c = `Expected a value of type \`${o}\`${l ? ` with refinement \`${l}\`` : ""}, but received: \`${be(n)}\`` } = e;
  return {
    value: n,
    type: o,
    refinement: l,
    key: i[i.length - 1],
    path: i,
    branch: a,
    ...e,
    message: c
  };
}
function* ir(e, t, r, n) {
  Jn(e) || (e = [e]);
  for (const i of e) {
    const a = Xn(i, t, r, n);
    a && (yield a);
  }
}
function* xt(e, t, r = {}) {
  const { path: n = [], branch: i = [e], coerce: a = !1, mask: o = !1 } = r, l = { path: n, branch: i };
  if (a && (e = t.coercer(e, l), o && t.type !== "type" && Ee(t.schema) && Ee(e) && !Array.isArray(e)))
    for (const g in e)
      t.schema[g] === void 0 && delete e[g];
  let c = "valid";
  for (const g of t.validator(e, l))
    g.explanation = r.message, c = "not_valid", yield [g, void 0];
  for (let [g, d, A] of t.entries(e, l)) {
    const j = xt(d, A, {
      path: g === void 0 ? n : [...n, g],
      branch: g === void 0 ? i : [...i, d],
      coerce: a,
      mask: o,
      message: r.message
    });
    for (const h of j)
      h[0] ? (c = h[0].refinement != null ? "not_refined" : "not_valid", yield [h[0], void 0]) : a && (d = h[1], g === void 0 ? e = d : e instanceof Map ? e.set(g, d) : e instanceof Set ? e.add(d) : Ee(e) && (d !== void 0 || g in e) && (e[g] = d));
  }
  if (c !== "not_valid")
    for (const g of t.refiner(e, l))
      g.explanation = r.message, c = "not_refined", yield [g, void 0];
  c === "valid" && (yield [void 0, e]);
}
let Re = class {
  constructor(t) {
    const { type: r, schema: n, validator: i, refiner: a, coercer: o = (c) => c, entries: l = function* () {
    } } = t;
    this.type = r, this.schema = n, this.entries = l, this.coercer = o, i ? this.validator = (c, g) => {
      const d = i(c, g);
      return ir(d, g, this, c);
    } : this.validator = () => [], a ? this.refiner = (c, g) => {
      const d = a(c, g);
      return ir(d, g, this, c);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(t, r) {
    return qn(t, this, r);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(t, r) {
    return Kn(t, this, r);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(t) {
    return $n(t, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(t, r) {
    return _n(t, this, r);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(t, r = {}) {
    return Xe(t, this, r);
  }
};
function qn(e, t, r) {
  const n = Xe(e, t, { message: r });
  if (n[0])
    throw n[0];
}
function Kn(e, t, r) {
  const n = Xe(e, t, { coerce: !0, message: r });
  if (n[0])
    throw n[0];
  return n[1];
}
function _n(e, t, r) {
  const n = Xe(e, t, { coerce: !0, mask: !0, message: r });
  if (n[0])
    throw n[0];
  return n[1];
}
function $n(e, t) {
  return !Xe(e, t)[0];
}
function Xe(e, t, r = {}) {
  const n = xt(e, t, r), i = Hn(n);
  return i[0] ? [new Fn(i[0], function* () {
    for (const o of n)
      o[0] && (yield o[0]);
  }), void 0] : [void 0, i[1]];
}
function kt(e, t) {
  return new Re({ type: e, schema: null, validator: t });
}
function sr(e) {
  return new Re({
    type: "array",
    schema: e,
    *entries(t) {
      if (e && Array.isArray(t))
        for (const [r, n] of t.entries())
          yield [r, n, e];
    },
    coercer(t) {
      return Array.isArray(t) ? t.slice() : t;
    },
    validator(t) {
      return Array.isArray(t) || `Expected an array value, but received: ${be(t)}`;
    }
  });
}
function ke() {
  return kt("boolean", (e) => typeof e == "boolean");
}
function $e(e) {
  const t = be(e), r = typeof e;
  return new Re({
    type: "literal",
    schema: r === "string" || r === "number" || r === "boolean" ? e : null,
    validator(n) {
      return n === e || `Expected the literal \`${t}\`, but received: ${be(n)}`;
    }
  });
}
function ei() {
  return kt("never", () => !1);
}
function Ue(e) {
  const t = e ? Object.keys(e) : [], r = ei();
  return new Re({
    type: "object",
    schema: e || null,
    *entries(n) {
      if (e && Ee(n)) {
        const i = new Set(Object.keys(n));
        for (const a of t)
          i.delete(a), yield [a, n[a], e[a]];
        for (const a of i)
          yield [a, n[a], r];
      }
    },
    validator(n) {
      return Ee(n) || `Expected an object, but received: ${be(n)}`;
    },
    coercer(n) {
      return Ee(n) ? { ...n } : n;
    }
  });
}
function re(e) {
  return new Re({
    ...e,
    validator: (t, r) => t === void 0 || e.validator(t, r),
    refiner: (t, r) => t === void 0 || e.refiner(t, r)
  });
}
function Y() {
  return kt("string", (e) => typeof e == "string" || `Expected a string, but received: ${be(e)}`);
}
function ti(e) {
  const t = e.map((r) => r.type).join(" | ");
  return new Re({
    type: "union",
    schema: null,
    coercer(r) {
      for (const n of e) {
        const [i, a] = n.validate(r, { coerce: !0 });
        if (!i)
          return a;
      }
      return r;
    },
    validator(r, n) {
      const i = [];
      for (const a of e) {
        const [...o] = xt(r, a, n), [l] = o;
        if (l[0])
          for (const [c] of o)
            c && i.push(c);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${t}\`, but received: ${be(r)}`,
        ...i
      ];
    }
  });
}
var ri = Object.defineProperty, ni = (e, t, r) => t in e ? ri(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, _ = (e, t, r) => (ni(e, typeof t != "symbol" ? t + "" : t, r), r), vr = (e, t, r) => {
  if (!t.has(e))
    throw TypeError("Cannot " + r);
}, q = (e, t, r) => (vr(e, t, "read from private field"), r ? r.call(e) : t.get(e)), ae = (e, t, r) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, r);
}, F = (e, t, r, n) => (vr(e, t, "write to private field"), t.set(e, r), r), zt = Ue({
  address: Y(),
  publicKey: Y(),
  chains: sr(Y()),
  features: sr(Y()),
  label: re(Y()),
  icon: re(Y())
});
function Ot(e) {
  return {
    address: e.address,
    publicKey: Lr(e.publicKey),
    features: [...e.features],
    chains: [...e.chains],
    label: e.label,
    icon: e.icon
  };
}
function ii(e) {
  return {
    address: e.address,
    publicKey: Wn(e.publicKey),
    chains: e.chains.map((t) => t),
    features: e.features.map((t) => t),
    label: e.label,
    icon: e.icon
  };
}
Ue({
  message: Y(),
  account: zt
});
function si(e) {
  return {
    message: Lr(e.message),
    account: Ot(e.account)
  };
}
Ue({
  transactionBlock: Y(),
  account: zt,
  chain: Y()
});
function ai(e) {
  return {
    transactionBlock: e.transactionBlock.serialize(),
    account: Ot(e.account),
    chain: e.chain
  };
}
var oi = Ue({
  showBalanceChanges: re(ke()),
  showEffects: re(ke()),
  showEvents: re(ke()),
  showInput: re(ke()),
  showObjectChanges: re(ke()),
  showRawInput: re(ke())
});
Ue({
  transactionBlock: Y(),
  account: zt,
  chain: Y(),
  requestType: re(Y()),
  options: re(oi)
});
function ci(e) {
  return {
    transactionBlock: e.transactionBlock.serialize(),
    account: Ot(e.account),
    chain: e.chain,
    requestType: e.requestType,
    options: e.options
  };
}
Ue({
  network: ti([$e("mainnet"), $e("testnet"), $e("devnet"), $e("localnet")]),
  url: Y()
});
const ui = "sui:devnet", li = "sui:testnet", gi = "sui:localnet", di = "sui:mainnet", Mi = [
  ui,
  li,
  gi,
  di
];
var Ai = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbDpzcGFjZT0icHJlc2VydmUiIGlkPSJMYXllcl8xIiB4PSIwIiB5PSIwIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAzMTguNiAzMTguNiI+CiAgPHN0eWxlPgogICAgLnN0MSwuc3Q2e2ZpbGw6I2U0NzYxYjtzdHJva2U6I2U0NzYxYjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmR9LnN0NntmaWxsOiNmNjg1MWI7c3Ryb2tlOiNmNjg1MWJ9CiAgPC9zdHlsZT4KICA8cGF0aCBmaWxsPSIjZTI3NjFiIiBzdHJva2U9IiNlMjc2MWIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0ibTI3NC4xIDM1LjUtOTkuNSA3My45TDE5MyA2NS44eiIvPgogIDxwYXRoIGQ9Im00NC40IDM1LjUgOTguNyA3NC42LTE3LjUtNDQuM3ptMTkzLjkgMTcxLjMtMjYuNSA0MC42IDU2LjcgMTUuNiAxNi4zLTU1LjN6bS0yMDQuNC45TDUwLjEgMjYzbDU2LjctMTUuNi0yNi41LTQwLjZ6IiBjbGFzcz0ic3QxIi8+CiAgPHBhdGggZD0ibTEwMy42IDEzOC4yLTE1LjggMjMuOSA1Ni4zIDIuNS0yLTYwLjV6bTExMS4zIDAtMzktMzQuOC0xLjMgNjEuMiA1Ni4yLTIuNXpNMTA2LjggMjQ3LjRsMzMuOC0xNi41LTI5LjItMjIuOHptNzEuMS0xNi41IDMzLjkgMTYuNS00LjctMzkuM3oiIGNsYXNzPSJzdDEiLz4KICA8cGF0aCBmaWxsPSIjZDdjMWIzIiBzdHJva2U9IiNkN2MxYjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0ibTIxMS44IDI0Ny40LTMzLjktMTYuNSAyLjcgMjIuMS0uMyA5LjN6bS0xMDUgMCAzMS41IDE0LjktLjItOS4zIDIuNS0yMi4xeiIvPgogIDxwYXRoIGZpbGw9IiMyMzM0NDciIHN0cm9rZT0iIzIzMzQ0NyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBkPSJtMTM4LjggMTkzLjUtMjguMi04LjMgMTkuOS05LjF6bTQwLjkgMCA4LjMtMTcuNCAyMCA5LjF6Ii8+CiAgPHBhdGggZmlsbD0iI2NkNjExNiIgc3Ryb2tlPSIjY2Q2MTE2IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGQ9Im0xMDYuOCAyNDcuNCA0LjgtNDAuNi0zMS4zLjl6TTIwNyAyMDYuOGw0LjggNDAuNiAyNi41LTM5Ljd6bTIzLjgtNDQuNy01Ni4yIDIuNSA1LjIgMjguOSA4LjMtMTcuNCAyMCA5LjF6bS0xMjAuMiAyMy4xIDIwLTkuMSA4LjIgMTcuNCA1LjMtMjguOS01Ni4zLTIuNXoiLz4KICA8cGF0aCBmaWxsPSIjZTQ3NTFmIiBzdHJva2U9IiNlNDc1MWYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0ibTg3LjggMTYyLjEgMjMuNiA0Ni0uOC0yMi45em0xMjAuMyAyMy4xLTEgMjIuOSAyMy43LTQ2em0tNjQtMjAuNi01LjMgMjguOSA2LjYgMzQuMSAxLjUtNDQuOXptMzAuNSAwLTIuNyAxOCAxLjIgNDUgNi43LTM0LjF6Ii8+CiAgPHBhdGggZD0ibTE3OS44IDE5My41LTYuNyAzNC4xIDQuOCAzLjMgMjkuMi0yMi44IDEtMjIuOXptLTY5LjItOC4zLjggMjIuOSAyOS4yIDIyLjggNC44LTMuMy02LjYtMzQuMXoiIGNsYXNzPSJzdDYiLz4KICA8cGF0aCBmaWxsPSIjYzBhZDllIiBzdHJva2U9IiNjMGFkOWUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0ibTE4MC4zIDI2Mi4zLjMtOS4zLTIuNS0yLjJoLTM3LjdsLTIuMyAyLjIuMiA5LjMtMzEuNS0xNC45IDExIDkgMjIuMyAxNS41aDM4LjNsMjIuNC0xNS41IDExLTl6Ii8+CiAgPHBhdGggZmlsbD0iIzE2MTYxNiIgc3Ryb2tlPSIjMTYxNjE2IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGQ9Im0xNzcuOSAyMzAuOS00LjgtMy4zaC0yNy43bC00LjggMy4zLTIuNSAyMi4xIDIuMy0yLjJoMzcuN2wyLjUgMi4yeiIvPgogIDxwYXRoIGZpbGw9IiM3NjNkMTYiIHN0cm9rZT0iIzc2M2QxNiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBkPSJtMjc4LjMgMTE0LjIgOC41LTQwLjgtMTIuNy0zNy45LTk2LjIgNzEuNCAzNyAzMS4zIDUyLjMgMTUuMyAxMS42LTEzLjUtNS0zLjYgOC03LjMtNi4yLTQuOCA4LTYuMXpNMzEuOCA3My40bDguNSA0MC44LTUuNCA0IDggNi4xLTYuMSA0LjggOCA3LjMtNSAzLjYgMTEuNSAxMy41IDUyLjMtMTUuMyAzNy0zMS4zLTk2LjItNzEuNHoiLz4KICA8cGF0aCBkPSJtMjY3LjIgMTUzLjUtNTIuMy0xNS4zIDE1LjkgMjMuOS0yMy43IDQ2IDMxLjItLjRoNDYuNXptLTE2My42LTE1LjMtNTIuMyAxNS4zLTE3LjQgNTQuMmg0Ni40bDMxLjEuNC0yMy42LTQ2em03MSAyNi40IDMuMy01Ny43IDE1LjItNDEuMWgtNjcuNWwxNSA0MS4xIDMuNSA1Ny43IDEuMiAxOC4yLjEgNDQuOGgyNy43bC4yLTQ0Ljh6IiBjbGFzcz0ic3Q2Ii8+Cjwvc3ZnPg==", xr = class Ne extends Error {
  constructor(t) {
    super(`${Ne.type}: ${t}}`), _(this, "type", Ne.type);
  }
  static asSimpleError(t) {
    return new Error(`${Ne.type}: ${t}`);
  }
  static isSimpleErrorMessage(t) {
    return t.startsWith(Ne.type + ": ");
  }
  static fromSimpleErrorMessage(t) {
    return new Ne(t.slice(Ne.type.length + 2));
  }
};
_(xr, "type", "INVALID_REQUEST_PARAMS");
var ar = xr, kr = class Qe extends Error {
  constructor() {
    super(Qe.type), _(this, "type", Qe.type);
  }
  static asSimpleError() {
    return new Error(Qe.type);
  }
  static isSimpleErrorMessage(t) {
    return t === Qe.type;
  }
};
_(kr, "type", "USER_REJECTION");
var ht = kr, zr = class Te extends Error {
  constructor(t) {
    super(`${Te.type}: ${t}`), _(this, "type", Te.type);
  }
  static asSimpleError(t) {
    return new Error(`${Te.type}: ${t}`);
  }
  static isSimpleErrorMessage(t) {
    return t.startsWith(Te.type + ": ");
  }
  static fromSimpleErrorMessage(t) {
    return new Te(t.slice(Te.type.length + 2));
  }
};
_(zr, "type", "INVALID_REQUEST_METHOD");
var or = zr, Or = class me extends Error {
  constructor(t) {
    let r = me.type;
    t && (r += ": " + t), super(r), _(this, "type", me.type);
  }
  static asSimpleError(t) {
    let r = me.type;
    return t && (r += ": " + t), new Error(r);
  }
  static isSimpleErrorMessage(t) {
    return t.startsWith(me.type);
  }
  static fromSimpleErrorMessage(t) {
    return new me(t.slice(me.type.length + 2));
  }
};
_(Or, "type", "DRY_RUN_FAILED");
var cr = Or, Br = class st extends Error {
  constructor() {
    super(st.type), _(this, "type", ht.type);
  }
  static asSimpleError() {
    return new Error(st.type);
  }
  static isSimpleErrorMessage(t) {
    return t === st.type;
  }
};
_(Br, "type", "NON_ADMIN_ORIGIN");
var ur = Br;
function hi(e) {
  return typeof e == "object" && e !== null && "message" in e;
}
function Bt(e) {
  return hi(e) ? ar.isSimpleErrorMessage(e.message) ? ar.fromSimpleErrorMessage(e.message) : ht.isSimpleErrorMessage(e.message) ? new ht() : or.isSimpleErrorMessage(e.message) ? or.fromSimpleErrorMessage(e.message) : cr.isSimpleErrorMessage(e.message) ? cr.fromSimpleErrorMessage(e.message) : ur.isSimpleErrorMessage(e.message) ? new ur() : e : e;
}
var qe = "npm:@kunalabs-io/sui-metamask-snap", Ii = "^1.0.0";
function fi() {
  const e = br();
  for (const r of e.get())
    if (r.name === lr.NAME)
      return console.warn("SuiSnapWallet already registered"), r;
  const t = new lr();
  return e.register(t), t;
}
async function yi(e) {
  return (await e.request({
    method: "wallet_invokeSnap",
    params: {
      snapId: qe,
      request: {
        method: "getAccounts"
      }
    }
  })).map((r) => new Bn(ii(r)));
}
async function Pr(e, t) {
  const r = si(t);
  try {
    return await e.request({
      method: "wallet_invokeSnap",
      params: {
        snapId: qe,
        request: {
          method: "signPersonalMessage",
          params: JSON.parse(JSON.stringify(r))
        }
      }
    });
  } catch (n) {
    throw Bt(n);
  }
}
async function pi(e, t) {
  const r = await Pr(e, t);
  return {
    messageBytes: r.bytes,
    signature: r.signature
  };
}
async function ji(e, t) {
  const r = ai(t);
  try {
    return await e.request({
      method: "wallet_invokeSnap",
      params: {
        snapId: qe,
        request: {
          method: "signTransactionBlock",
          params: JSON.parse(JSON.stringify(r))
        }
      }
    });
  } catch (n) {
    throw Bt(n);
  }
}
async function Ni(e, t) {
  const r = ci(t);
  try {
    return await e.request({
      method: "wallet_invokeSnap",
      params: {
        snapId: qe,
        request: {
          method: "signAndExecuteTransactionBlock",
          params: JSON.parse(JSON.stringify(r))
        }
      }
    });
  } catch (n) {
    throw Bt(n);
  }
}
async function Ti() {
  const e = window.ethereum;
  if (!e)
    return {
      available: !1,
      supportsSnaps: !1,
      suiSnapInstalled: !1
    };
  if (!e.isMetaMask)
    return {
      available: !1,
      suiSnapInstalled: !1,
      supportsSnaps: !1
    };
  try {
    const t = await e.request({ method: "web3_clientVersion" }), r = await e.request({ method: "wallet_getSnaps" }), n = !!r && "npm:@kunalabs-io/sui-metamask-snap" in r;
    return {
      available: !0,
      version: t,
      supportsSnaps: !0,
      suiSnapInstalled: n
    };
  } catch (t) {
    return console.warn(t), {
      available: !0,
      supportsSnaps: !1,
      suiSnapInstalled: !1
    };
  }
}
var ce, Ie, Oe, It, ft, yt, pt, jt, Nt, Rr = class Ur {
  constructor() {
    ae(this, ce, void 0), ae(this, Ie, void 0), ae(this, Oe, null), ae(this, It, async () => {
      if (q(this, ce))
        throw new Error("Already connecting");
      F(this, ce, !0), F(this, Ie, !1);
      try {
        const t = window.ethereum;
        if (!(await Ti()).available)
          throw new Error("MetaMask not detected!");
        return await t.request({
          method: "wallet_requestSnaps",
          params: {
            [qe]: {
              version: Ii
            }
          }
        }), F(this, Oe, await yi(t)), F(this, ce, !1), F(this, Ie, !0), {
          accounts: this.accounts
        };
      } catch (t) {
        throw F(this, ce, !1), F(this, Ie, !1), t;
      }
    }), ae(this, ft, async () => {
      F(this, ce, !1), F(this, Ie, !1), F(this, Oe, null);
    }), ae(this, yt, async (t) => Pr(window.ethereum, t)), ae(this, pt, async (t) => pi(window.ethereum, t)), ae(this, jt, async (t) => ji(window.ethereum, t)), ae(this, Nt, async (t) => Ni(window.ethereum, t)), F(this, ce, !1), F(this, Ie, !1);
  }
  get version() {
    return "1.0.0";
  }
  get name() {
    return Ur.NAME;
  }
  get icon() {
    return Ai;
  }
  get chains() {
    return Mi;
  }
  get connecting() {
    return q(this, ce);
  }
  get accounts() {
    return q(this, Ie) && q(this, Oe) ? q(this, Oe) : [];
  }
  get features() {
    return {
      "standard:connect": {
        version: "1.0.0",
        connect: q(this, It)
      },
      "standard:disconnect": {
        version: "1.0.0",
        disconnect: q(this, ft)
      },
      "sui:signPersonalMessage": {
        version: "1.0.0",
        signPersonalMessage: q(this, yt)
      },
      "sui:signMessage": {
        version: "1.0.0",
        signMessage: q(this, pt)
      },
      "sui:signTransactionBlock": {
        version: "1.0.0",
        signTransactionBlock: q(this, jt)
      },
      "sui:signAndExecuteTransactionBlock": {
        version: "1.0.0",
        signAndExecuteTransactionBlock: q(this, Nt)
      },
      "standard:events": {
        version: "1.0.0",
        on: () => () => {
        }
      }
    };
  }
};
ce = /* @__PURE__ */ new WeakMap();
Ie = /* @__PURE__ */ new WeakMap();
Oe = /* @__PURE__ */ new WeakMap();
It = /* @__PURE__ */ new WeakMap();
ft = /* @__PURE__ */ new WeakMap();
yt = /* @__PURE__ */ new WeakMap();
pt = /* @__PURE__ */ new WeakMap();
jt = /* @__PURE__ */ new WeakMap();
Nt = /* @__PURE__ */ new WeakMap();
_(Rr, "NAME", "Sui MetaMask Snap");
var lr = Rr;
function mi(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), r = 0; r < t.length; r++)
    t[r] = 255;
  for (var n = 0; n < e.length; n++) {
    var i = e.charAt(n), a = i.charCodeAt(0);
    if (t[a] !== 255)
      throw new TypeError(i + " is ambiguous");
    t[a] = n;
  }
  var o = e.length, l = e.charAt(0), c = Math.log(o) / Math.log(256), g = Math.log(256) / Math.log(o);
  function d(h) {
    if (h instanceof Uint8Array || (ArrayBuffer.isView(h) ? h = new Uint8Array(h.buffer, h.byteOffset, h.byteLength) : Array.isArray(h) && (h = Uint8Array.from(h))), !(h instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (h.length === 0)
      return "";
    for (var y = 0, T = 0, f = 0, S = h.length; f !== S && h[f] === 0; )
      f++, y++;
    for (var C = (S - f) * g + 1 >>> 0, w = new Uint8Array(C); f !== S; ) {
      for (var V = h[f], P = 0, X = C - 1; (V !== 0 || P < T) && X !== -1; X--, P++)
        V += 256 * w[X] >>> 0, w[X] = V % o >>> 0, V = V / o >>> 0;
      if (V !== 0)
        throw new Error("Non-zero carry");
      T = P, f++;
    }
    for (var se = C - T; se !== C && w[se] === 0; )
      se++;
    for (var Ke = l.repeat(y); se < C; ++se)
      Ke += e.charAt(w[se]);
    return Ke;
  }
  function A(h) {
    if (typeof h != "string")
      throw new TypeError("Expected String");
    if (h.length === 0)
      return new Uint8Array();
    for (var y = 0, T = 0, f = 0; h[y] === l; )
      T++, y++;
    for (var S = (h.length - y) * c + 1 >>> 0, C = new Uint8Array(S); h[y]; ) {
      var w = t[h.charCodeAt(y)];
      if (w === 255)
        return;
      for (var V = 0, P = S - 1; (w !== 0 || V < f) && P !== -1; P--, V++)
        w += o * C[P] >>> 0, C[P] = w % 256 >>> 0, w = w / 256 >>> 0;
      if (w !== 0)
        throw new Error("Non-zero carry");
      f = V, y++;
    }
    for (var X = S - f; X !== S && C[X] === 0; )
      X++;
    for (var se = new Uint8Array(T + (S - X)), Ke = T; X !== S; )
      se[Ke++] = C[X++];
    return se;
  }
  function j(h) {
    var y = A(h);
    if (y)
      return y;
    throw new Error("Non-base" + o + " character");
  }
  return {
    encode: d,
    decodeUnsafe: A,
    decode: j
  };
}
var wi = mi;
const Si = wi, Di = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Ei = Si(Di);
const Gr = /* @__PURE__ */ Pn(Ei);
function bi(e) {
  return e > 64 && e < 91 ? e - 65 : e > 96 && e < 123 ? e - 71 : e > 47 && e < 58 ? e + 4 : e === 43 ? 62 : e === 47 ? 63 : 0;
}
function Le(e, t) {
  for (var r = e.replace(/[^A-Za-z0-9+/]/g, ""), n = r.length, i = n * 3 + 1 >> 2, a = new Uint8Array(i), o, l, c = 0, g = 0, d = 0; d < n; d++)
    if (l = d & 3, c |= bi(r.charCodeAt(d)) << 6 * (3 - l), l === 3 || n - d === 1) {
      for (o = 0; o < 3 && g < i; o++, g++)
        a[g] = c >>> (16 >>> o & 24) & 255;
      c = 0;
    }
  return a;
}
function et(e) {
  return e < 26 ? e + 65 : e < 52 ? e + 71 : e < 62 ? e - 4 : e === 62 ? 43 : e === 63 ? 47 : 65;
}
function De(e) {
  for (var t = 2, r = "", n = e.length, i = 0, a = 0; a < n; a++)
    t = a % 3, a > 0 && a * 4 / 3 % 76 === 0 && (r += ""), i |= e[a] << (16 >>> t & 24), (t === 2 || e.length - a === 1) && (r += String.fromCodePoint(
      et(i >>> 18 & 63),
      et(i >>> 12 & 63),
      et(i >>> 6 & 63),
      et(i & 63)
    ), i = 0);
  return r.slice(0, r.length - 2 + t) + (t === 2 ? "" : t === 1 ? "=" : "==");
}
function Pt(e) {
  let t = e.replace("0x", "").match(/.{1,2}/g).map((r) => parseInt(r, 16));
  if (t === null)
    throw new Error(`Unable to parse HEX: ${e}`);
  return Uint8Array.from(t);
}
function Rt(e) {
  return e.reduce(
    (t, r) => t + r.toString(16).padStart(2, "0"),
    ""
  );
}
var Li = 32;
function Mt(e, t) {
  let r = new Uint8Array(t), n = 0;
  for (; e > 0; )
    r[n] = Number(e % BigInt(256)), e = e / BigInt(256), n += 1;
  return r;
}
var Ut = (e) => Gr.encode(e), Gt = (e) => Gr.decode(e), Ci = class {
  /**
   * @param {Uint8Array} data Data to use as a buffer.
   */
  constructor(e) {
    this.bytePosition = 0, this.dataView = new DataView(e.buffer);
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(e) {
    return this.bytePosition += e, this;
  }
  /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */
  read8() {
    let e = this.dataView.getUint8(this.bytePosition);
    return this.shift(1), e;
  }
  /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */
  read16() {
    let e = this.dataView.getUint16(this.bytePosition, !0);
    return this.shift(2), e;
  }
  /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */
  read32() {
    let e = this.dataView.getUint32(this.bytePosition, !0);
    return this.shift(4), e;
  }
  /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */
  read64() {
    let e = this.read32(), r = this.read32().toString(16) + e.toString(16).padStart(8, "0");
    return BigInt("0x" + r).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 16.
   */
  read128() {
    let e = BigInt(this.read64()), r = BigInt(this.read64()).toString(16) + e.toString(16).padStart(8, "0");
    return BigInt("0x" + r).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */
  read256() {
    let e = BigInt(this.read128()), r = BigInt(this.read128()).toString(16) + e.toString(16).padStart(16, "0");
    return BigInt("0x" + r).toString(10);
  }
  /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */
  readBytes(e) {
    let t = this.bytePosition + this.dataView.byteOffset, r = new Uint8Array(this.dataView.buffer, t, e);
    return this.shift(e), r;
  }
  /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */
  readULEB() {
    let e = this.bytePosition + this.dataView.byteOffset, t = new Uint8Array(this.dataView.buffer, e), { value: r, length: n } = ki(t);
    return this.shift(n), r;
  }
  /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */
  readVec(e) {
    let t = this.readULEB(), r = [];
    for (let n = 0; n < t; n++)
      r.push(e(this, n, t));
    return r;
  }
}, vi = class {
  constructor({
    size: e = 1024,
    maxSize: t,
    allocateSize: r = 1024
  } = {}) {
    this.bytePosition = 0, this.size = e, this.maxSize = t || e, this.allocateSize = r, this.dataView = new DataView(new ArrayBuffer(e));
  }
  ensureSizeOrGrow(e) {
    const t = this.bytePosition + e;
    if (t > this.size) {
      const r = Math.min(this.maxSize, this.size + this.allocateSize);
      if (t > r)
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`
        );
      this.size = r;
      const n = new ArrayBuffer(this.size);
      new Uint8Array(n).set(new Uint8Array(this.dataView.buffer)), this.dataView = new DataView(n);
    }
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(e) {
    return this.bytePosition += e, this;
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write8(e) {
    return this.ensureSizeOrGrow(1), this.dataView.setUint8(this.bytePosition, Number(e)), this.shift(1);
  }
  /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write16(e) {
    return this.ensureSizeOrGrow(2), this.dataView.setUint16(this.bytePosition, Number(e), !0), this.shift(2);
  }
  /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write32(e) {
    return this.ensureSizeOrGrow(4), this.dataView.setUint32(this.bytePosition, Number(e), !0), this.shift(4);
  }
  /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write64(e) {
    return Mt(BigInt(e), 8).forEach((t) => this.write8(t)), this;
  }
  /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write128(e) {
    return Mt(BigInt(e), 16).forEach((t) => this.write8(t)), this;
  }
  /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write256(e) {
    return Mt(BigInt(e), 32).forEach((t) => this.write8(t)), this;
  }
  /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeULEB(e) {
    return xi(e).forEach((t) => this.write8(t)), this;
  }
  /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */
  writeVec(e, t) {
    return this.writeULEB(e.length), Array.from(e).forEach((r, n) => t(this, r, n, e.length)), this;
  }
  /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */
  *[Symbol.iterator]() {
    for (let e = 0; e < this.bytePosition; e++)
      yield this.dataView.getUint8(e);
    return this.toBytes();
  }
  /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */
  toString(e) {
    return zi(this.toBytes(), e);
  }
};
function xi(e) {
  let t = [], r = 0;
  if (e === 0)
    return [0];
  for (; e > 0; )
    t[r] = e & 127, (e >>= 7) && (t[r] |= 128), r += 1;
  return t;
}
function ki(e) {
  let t = 0, r = 0, n = 0;
  for (; ; ) {
    let i = e[n];
    if (n += 1, t |= (i & 127) << r, !(i & 128))
      break;
    r += 7;
  }
  return {
    value: t,
    length: n
  };
}
var Ye = class {
  /**
   * Construct a BCS instance with a prepared schema.
   *
   * @param schema A prepared schema with type definitions
   * @param withPrimitives Whether to register primitive types by default
   */
  constructor(e) {
    if (this.types = /* @__PURE__ */ new Map(), this.counter = 0, e instanceof Ye) {
      this.schema = e.schema, this.types = new Map(e.types);
      return;
    }
    if (this.schema = e, this.registerAddressType(
      Ye.ADDRESS,
      e.addressLength,
      e.addressEncoding
    ), this.registerVectorType(e.vectorType), e.types && e.types.structs)
      for (let t of Object.keys(e.types.structs))
        this.registerStructType(t, e.types.structs[t]);
    if (e.types && e.types.enums)
      for (let t of Object.keys(e.types.enums))
        this.registerEnumType(t, e.types.enums[t]);
    if (e.types && e.types.aliases)
      for (let t of Object.keys(e.types.aliases))
        this.registerAlias(t, e.types.aliases[t]);
    e.withPrimitives !== !1 && Bi(this);
  }
  /**
   * Name of the key to use for temporary struct definitions.
   * Returns a temp key + index (for a case when multiple temp
   * structs are processed).
   */
  tempKey() {
    return `bcs-struct-${++this.counter}`;
  }
  /**
   * Serialize data into bcs.
   *
   * @example
   * bcs.registerVectorType('vector<u8>', 'u8');
   *
   * let serialized = BCS
   *   .set('vector<u8>', [1,2,3,4,5,6])
   *   .toBytes();
   *
   * console.assert(toHex(serialized) === '06010203040506');
   *
   * @param type Name of the type to serialize (must be registered) or a struct type.
   * @param data Data to serialize.
   * @param size Serialization buffer size. Default 1024 = 1KB.
   * @return A BCS reader instance. Usually you'd want to call `.toBytes()`
   */
  ser(e, t, r) {
    if (typeof e == "string" || Array.isArray(e)) {
      const { name: n, params: i } = this.parseTypeName(e);
      return this.getTypeInterface(n).encode(
        this,
        t,
        r,
        i
      );
    }
    if (typeof e == "object") {
      const n = this.tempKey();
      return new Ye(this).registerStructType(n, e).ser(n, t, r);
    }
    throw new Error(
      `Incorrect type passed into the '.ser()' function. 
${JSON.stringify(
        e
      )}`
    );
  }
  /**
   * Deserialize BCS into a JS type.
   *
   * @example
   * let num = bcs.ser('u64', '4294967295').toString('hex');
   * let deNum = bcs.de('u64', num, 'hex');
   * console.assert(deNum.toString(10) === '4294967295');
   *
   * @param type Name of the type to deserialize (must be registered) or a struct type definition.
   * @param data Data to deserialize.
   * @param encoding Optional - encoding to use if data is of type String
   * @return Deserialized data.
   */
  de(e, t, r) {
    if (typeof t == "string")
      if (r)
        t = Oi(t, r);
      else
        throw new Error("To pass a string to `bcs.de`, specify encoding");
    if (typeof e == "string" || Array.isArray(e)) {
      const { name: n, params: i } = this.parseTypeName(e);
      return this.getTypeInterface(n).decode(this, t, i);
    }
    if (typeof e == "object") {
      const n = new Ye(this), i = this.tempKey();
      return n.registerStructType(i, e).de(i, t, r);
    }
    throw new Error(
      `Incorrect type passed into the '.de()' function. 
${JSON.stringify(
        e
      )}`
    );
  }
  /**
   * Check whether a `TypeInterface` has been loaded for a `type`.
   * @param type Name of the type to check.
   * @returns
   */
  hasType(e) {
    return this.types.has(e);
  }
  /**
   * Create an alias for a type.
   * WARNING: this can potentially lead to recursion
   * @param name Alias to use
   * @param forType Type to reference
   * @returns
   *
   * @example
   * ```
   * let bcs = new BCS(getSuiMoveConfig());
   * bcs.registerAlias('ObjectDigest', BCS.BASE58);
   * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');
   * ```
   */
  registerAlias(e, t) {
    return this.types.set(e, t), this;
  }
  /**
   * Method to register new types for BCS internal representation.
   * For each registered type 2 callbacks must be specified and one is optional:
   *
   * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;
   * - decodeCb(reader) - write a way to deserialize data with BcsReader;
   * - validateCb(data) - validate data - either return bool or throw an error
   *
   * @example
   * // our type would be a string that consists only of numbers
   * bcs.registerType('number_string',
   *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),
   *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8
   *    (value) => /[0-9]+/.test(value) // test that it has at least one digit
   * );
   * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);
   *
   * @param name
   * @param encodeCb Callback to encode a value.
   * @param decodeCb Callback to decode a value.
   * @param validateCb Optional validator Callback to check type before serialization.
   */
  registerType(e, t, r, n = () => !0) {
    const { name: i, params: a } = this.parseTypeName(e);
    return this.types.set(i, {
      encode(o, l, c, g) {
        const d = a.reduce(
          (A, j, h) => Object.assign(A, { [j]: g[h] }),
          {}
        );
        return this._encodeRaw.call(
          o,
          new vi(c),
          l,
          g,
          d
        );
      },
      decode(o, l, c) {
        const g = a.reduce(
          (d, A, j) => Object.assign(d, { [A]: c[j] }),
          {}
        );
        return this._decodeRaw.call(
          o,
          new Ci(l),
          c,
          g
        );
      },
      // these methods should always be used with caution as they require pre-defined
      // reader and writer and mainly exist to allow multi-field (de)serialization;
      _encodeRaw(o, l, c, g) {
        if (n(l))
          return t.call(this, o, l, c, g);
        throw new Error(`Validation failed for type ${i}, data: ${l}`);
      },
      _decodeRaw(o, l, c) {
        return r.call(this, o, l, c);
      }
    }), this;
  }
  /**
   * Register an address type which is a sequence of U8s of specified length.
   * @example
   * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);
   * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');
   *
   * @param name Name of the address type.
   * @param length Byte length of the address.
   * @param encoding Encoding to use for the address type
   * @returns
   */
  registerAddressType(e, t, r = "hex") {
    switch (r) {
      case "base64":
        return this.registerType(
          e,
          function(i, a) {
            return Le(a).reduce(
              (o, l) => o.write8(l),
              i
            );
          },
          function(i) {
            return De(i.readBytes(t));
          }
        );
      case "hex":
        return this.registerType(
          e,
          function(i, a) {
            return Pt(a).reduce(
              (o, l) => o.write8(l),
              i
            );
          },
          function(i) {
            return Rt(i.readBytes(t));
          }
        );
      default:
        throw new Error("Unsupported encoding! Use either hex or base64");
    }
  }
  /**
   * Register custom vector type inside the bcs.
   *
   * @example
   * bcs.registerVectorType('vector<T>'); // generic registration
   * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];
   * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');
   *
   * @param name Name of the type to register
   * @param elementType Optional name of the inner type of the vector
   * @return Returns self for chaining.
   */
  registerVectorType(e) {
    let { name: t, params: r } = this.parseTypeName(e);
    if (r.length > 1)
      throw new Error("Vector can have only one type parameter; got " + t);
    return this.registerType(
      e,
      function(i, a, o, l) {
        return i.writeVec(a, (c, g) => {
          let d = o[0];
          if (!d)
            throw new Error(
              `Incorrect number of type parameters passed a to vector '${e}'`
            );
          let { name: A, params: j } = this.parseTypeName(d);
          if (this.hasType(A))
            return this.getTypeInterface(A)._encodeRaw.call(
              this,
              c,
              g,
              j,
              l
            );
          if (!(A in l))
            throw new Error(
              `Unable to find a matching type definition for ${A} in vector; make sure you passed a generic`
            );
          let { name: h, params: y } = this.parseTypeName(
            l[A]
          );
          return this.getTypeInterface(h)._encodeRaw.call(
            this,
            c,
            g,
            y,
            l
          );
        });
      },
      function(i, a, o) {
        return i.readVec((l) => {
          let c = a[0];
          if (!c)
            throw new Error(
              `Incorrect number of type parameters passed to a vector '${e}'`
            );
          let { name: g, params: d } = this.parseTypeName(c);
          if (this.hasType(g))
            return this.getTypeInterface(g)._decodeRaw.call(
              this,
              l,
              d,
              o
            );
          if (!(g in o))
            throw new Error(
              `Unable to find a matching type definition for ${g} in vector; make sure you passed a generic`
            );
          let { name: A, params: j } = this.parseTypeName(
            o[g]
          );
          this.getTypeInterface(A)._decodeRaw.call(
            this,
            l,
            j,
            o
          );
        });
      }
    );
  }
  /**
   * Safe method to register a custom Move struct. The first argument is a name of the
   * struct which is only used on the FrontEnd and has no affect on serialization results,
   * and the second is a struct description passed as an Object.
   *
   * The description object MUST have the same order on all of the platforms (ie in Move
   * or in Rust).
   *
   * @example
   * // Move / Rust struct
   * // struct Coin {
   * //   value: u64,
   * //   owner: vector<u8>, // name // Vec<u8> in Rust
   * //   is_locked: bool,
   * // }
   *
   * bcs.registerStructType('Coin', {
   *   value: bcs.U64,
   *   owner: bcs.STRING,
   *   is_locked: bcs.BOOL
   * });
   *
   * // Created in Rust with diem/bcs
   * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';
   * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array
   *  128, 209, 177,   5,  96,  0,  0,
   *    0,  14,  66, 105, 103, 32, 87,
   *   97, 108, 108, 101, 116, 32, 71,
   *  117, 121,   0
   * ];
   *
   * // Let's encode the value as well
   * let test_set = bcs.ser('Coin', {
   *   owner: 'Big Wallet Guy',
   *   value: '412412400000',
   *   is_locked: false,
   * });
   *
   * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');
   *
   * @param name Name of the type to register.
   * @param fields Fields of the struct. Must be in the correct order.
   * @return Returns BCS for chaining.
   */
  registerStructType(e, t) {
    for (let o in t) {
      let l = this.tempKey(), c = t[o];
      !Array.isArray(c) && typeof c != "string" && (t[o] = l, this.registerStructType(l, c));
    }
    let r = Object.freeze(t), n = Object.keys(r), { name: i, params: a } = this.parseTypeName(e);
    return this.registerType(
      e,
      function(l, c, g, d) {
        if (!c || c.constructor !== Object)
          throw new Error(
            `Expected ${i} to be an Object, got: ${c}`
          );
        if (g.length !== a.length)
          throw new Error(
            `Incorrect number of generic parameters passed; expected: ${a.length}, got: ${g.length}`
          );
        for (let A of n) {
          if (!(A in c))
            throw new Error(
              `Struct ${i} requires field ${A}:${r[A]}`
            );
          const { name: j, params: h } = this.parseTypeName(
            r[A]
          );
          if (!a.includes(j))
            this.getTypeInterface(j)._encodeRaw.call(
              this,
              l,
              c[A],
              h,
              d
            );
          else {
            const y = a.indexOf(j);
            let { name: T, params: f } = this.parseTypeName(g[y]);
            if (this.hasType(T)) {
              this.getTypeInterface(T)._encodeRaw.call(
                this,
                l,
                c[A],
                f,
                d
              );
              continue;
            }
            if (!(T in d))
              throw new Error(
                `Unable to find a matching type definition for ${T} in ${i}; make sure you passed a generic`
              );
            let { name: S, params: C } = this.parseTypeName(
              d[T]
            );
            this.getTypeInterface(S)._encodeRaw.call(
              this,
              l,
              c[A],
              C,
              d
            );
          }
        }
        return l;
      },
      function(l, c, g) {
        if (c.length !== a.length)
          throw new Error(
            `Incorrect number of generic parameters passed; expected: ${a.length}, got: ${c.length}`
          );
        let d = {};
        for (let A of n) {
          const { name: j, params: h } = this.parseTypeName(
            r[A]
          );
          if (!a.includes(j))
            d[A] = this.getTypeInterface(j)._decodeRaw.call(
              this,
              l,
              h,
              g
            );
          else {
            const y = a.indexOf(j);
            let { name: T, params: f } = this.parseTypeName(c[y]);
            if (this.hasType(T)) {
              d[A] = this.getTypeInterface(T)._decodeRaw.call(
                this,
                l,
                f,
                g
              );
              continue;
            }
            if (!(T in g))
              throw new Error(
                `Unable to find a matching type definition for ${T} in ${i}; make sure you passed a generic`
              );
            let { name: S, params: C } = this.parseTypeName(
              g[T]
            );
            d[A] = this.getTypeInterface(S)._decodeRaw.call(
              this,
              l,
              C,
              g
            );
          }
        }
        return d;
      }
    );
  }
  /**
   * Safe method to register custom enum type where each invariant holds the value of another type.
   * @example
   * bcs.registerStructType('Coin', { value: 'u64' });
   * bcs.registerEnumType('MyEnum', {
   *  single: 'Coin',
   *  multi: 'vector<Coin>',
   *  empty: null
   * });
   *
   * console.log(
   *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }
   *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }
   * )
   *
   * // and serialization
   * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();
   * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });
   *
   * @param name
   * @param variants
   */
  registerEnumType(e, t) {
    for (let o in t) {
      let l = this.tempKey(), c = t[o];
      c !== null && !Array.isArray(c) && typeof c != "string" && (t[o] = l, this.registerStructType(l, c));
    }
    let r = Object.freeze(t), n = Object.keys(r), { name: i, params: a } = this.parseTypeName(e);
    return this.registerType(
      e,
      function(l, c, g, d) {
        if (!c)
          throw new Error(
            `Unable to write enum "${i}", missing data.
Received: "${c}"`
          );
        if (typeof c != "object")
          throw new Error(
            `Incorrect data passed into enum "${i}", expected object with properties: "${n.join(
              " | "
            )}".
Received: "${JSON.stringify(c)}"`
          );
        let A = Object.keys(c)[0];
        if (A === void 0)
          throw new Error(
            `Empty object passed as invariant of the enum "${i}"`
          );
        let j = n.indexOf(A);
        if (j === -1)
          throw new Error(
            `Unknown invariant of the enum "${i}", allowed values: "${n.join(
              " | "
            )}"; received "${A}"`
          );
        let h = n[j], y = r[h];
        if (l.write8(j), y === null)
          return l;
        let T = a.indexOf(y), f = T === -1 ? y : g[T];
        {
          let { name: S, params: C } = this.parseTypeName(f);
          return this.getTypeInterface(S)._encodeRaw.call(
            this,
            l,
            c[A],
            C,
            d
          );
        }
      },
      function(l, c, g) {
        let d = l.readULEB(), A = n[d], j = r[A];
        if (d === -1)
          throw new Error(
            `Decoding type mismatch, expected enum "${i}" invariant index, received "${d}"`
          );
        if (j === null)
          return { [A]: !0 };
        let h = a.indexOf(j), y = h === -1 ? j : c[h];
        {
          let { name: T, params: f } = this.parseTypeName(y);
          return {
            [A]: this.getTypeInterface(T)._decodeRaw.call(
              this,
              l,
              f,
              g
            )
          };
        }
      }
    );
  }
  /**
   * Get a set of encoders/decoders for specific type.
   * Mainly used to define custom type de/serialization logic.
   *
   * @param type
   * @returns {TypeInterface}
   */
  getTypeInterface(e) {
    let t = this.types.get(e);
    if (typeof t == "string") {
      let r = [];
      for (; typeof t == "string"; ) {
        if (r.includes(t))
          throw new Error(
            `Recursive definition found: ${r.join(
              " -> "
            )} -> ${t}`
          );
        r.push(t), t = this.types.get(t);
      }
    }
    if (t === void 0)
      throw new Error(`Type ${e} is not registered`);
    return t;
  }
  /**
   * Parse a type name and get the type's generics.
   * @example
   * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');
   * // typeName: Option
   * // typeParams: [ 'Coin<SUI>' ]
   *
   * @param name Name of the type to process
   * @returns Object with typeName and typeParams listed as Array
   */
  parseTypeName(e) {
    if (Array.isArray(e)) {
      let [l, ...c] = e;
      return { name: l, params: c };
    }
    if (typeof e != "string")
      throw new Error(`Illegal type passed as a name of the type: ${e}`);
    let [t, r] = this.schema.genericSeparators || ["<", ">"], n = e.indexOf(t), i = Array.from(e).reverse().indexOf(r);
    if (n === -1 && i === -1)
      return { name: e, params: [] };
    if (n === -1 || i === -1)
      throw new Error(`Unclosed generic in name '${e}'`);
    let a = e.slice(0, n), o = e.slice(n + 1, e.length - i - 1).split(",").map((l) => l.trim());
    return { name: a, params: o };
  }
}, N = Ye;
N.U8 = "u8";
N.U16 = "u16";
N.U32 = "u32";
N.U64 = "u64";
N.U128 = "u128";
N.U256 = "u256";
N.BOOL = "bool";
N.VECTOR = "vector";
N.ADDRESS = "address";
N.STRING = "string";
N.HEX = "hex-string";
N.BASE58 = "base58-string";
N.BASE64 = "base64-string";
function zi(e, t) {
  switch (t) {
    case "base58":
      return Ut(e);
    case "base64":
      return De(e);
    case "hex":
      return Rt(e);
    default:
      throw new Error(
        "Unsupported encoding, supported values are: base64, hex"
      );
  }
}
function Oi(e, t) {
  switch (t) {
    case "base58":
      return Gt(e);
    case "base64":
      return Le(e);
    case "hex":
      return Pt(e);
    default:
      throw new Error(
        "Unsupported encoding, supported values are: base64, hex"
      );
  }
}
function Bi(e) {
  e.registerType(
    N.U8,
    function(t, r) {
      return t.write8(r);
    },
    function(t) {
      return t.read8();
    },
    (t) => t < 256
  ), e.registerType(
    N.U16,
    function(t, r) {
      return t.write16(r);
    },
    function(t) {
      return t.read16();
    },
    (t) => t < 65536
  ), e.registerType(
    N.U32,
    function(t, r) {
      return t.write32(r);
    },
    function(t) {
      return t.read32();
    },
    (t) => t <= 4294967296n
  ), e.registerType(
    N.U64,
    function(t, r) {
      return t.write64(r);
    },
    function(t) {
      return t.read64();
    }
  ), e.registerType(
    N.U128,
    function(t, r) {
      return t.write128(r);
    },
    function(t) {
      return t.read128();
    }
  ), e.registerType(
    N.U256,
    function(t, r) {
      return t.write256(r);
    },
    function(t) {
      return t.read256();
    }
  ), e.registerType(
    N.BOOL,
    function(t, r) {
      return t.write8(r);
    },
    function(t) {
      return t.read8().toString(10) === "1";
    }
  ), e.registerType(
    N.STRING,
    function(t, r) {
      return t.writeVec(
        Array.from(r),
        (n, i) => n.write8(i.charCodeAt(0))
      );
    },
    function(t) {
      return t.readVec((r) => r.read8()).map((r) => String.fromCharCode(Number(r))).join("");
    },
    (t) => !0
  ), e.registerType(
    N.HEX,
    function(t, r) {
      return t.writeVec(
        Array.from(Pt(r)),
        (n, i) => n.write8(i)
      );
    },
    function(t) {
      let r = t.readVec((n) => n.read8());
      return Rt(new Uint8Array(r));
    }
  ), e.registerType(
    N.BASE58,
    function(t, r) {
      return t.writeVec(
        Array.from(Gt(r)),
        (n, i) => n.write8(i)
      );
    },
    function(t) {
      let r = t.readVec((n) => n.read8());
      return Ut(new Uint8Array(r));
    }
  ), e.registerType(
    N.BASE64,
    function(t, r) {
      return t.writeVec(
        Array.from(Le(r)),
        (n, i) => n.write8(i)
      );
    },
    function(t) {
      let r = t.readVec((n) => n.read8());
      return De(new Uint8Array(r));
    }
  );
}
function Pi() {
  return {
    genericSeparators: ["<", ">"],
    vectorType: "vector",
    addressLength: Li,
    addressEncoding: "hex"
  };
}
class Ri extends TypeError {
  constructor(t, r) {
    let n;
    const { message: i, explanation: a, ...o } = t, { path: l } = t, c = l.length === 0 ? i : `At path: ${l.join(".")} -- ${i}`;
    super(a ?? c), a != null && (this.cause = c), Object.assign(this, o), this.name = this.constructor.name, this.failures = () => n ?? (n = [t, ...r()]);
  }
}
function Ui(e) {
  return J(e) && typeof e[Symbol.iterator] == "function";
}
function J(e) {
  return typeof e == "object" && e != null;
}
function H(e) {
  return typeof e == "symbol" ? e.toString() : typeof e == "string" ? JSON.stringify(e) : `${e}`;
}
function Gi(e) {
  const { done: t, value: r } = e.next();
  return t ? void 0 : r;
}
function Qi(e, t, r, n) {
  if (e === !0)
    return;
  e === !1 ? e = {} : typeof e == "string" && (e = { message: e });
  const { path: i, branch: a } = t, { type: o } = r, { refinement: l, message: c = `Expected a value of type \`${o}\`${l ? ` with refinement \`${l}\`` : ""}, but received: \`${H(n)}\`` } = e;
  return {
    value: n,
    type: o,
    refinement: l,
    key: i[i.length - 1],
    path: i,
    branch: a,
    ...e,
    message: c
  };
}
function* gr(e, t, r, n) {
  Ui(e) || (e = [e]);
  for (const i of e) {
    const a = Qi(i, t, r, n);
    a && (yield a);
  }
}
function* Qt(e, t, r = {}) {
  const { path: n = [], branch: i = [e], coerce: a = !1, mask: o = !1 } = r, l = { path: n, branch: i };
  if (a && (e = t.coercer(e, l), o && t.type !== "type" && J(t.schema) && J(e) && !Array.isArray(e)))
    for (const g in e)
      t.schema[g] === void 0 && delete e[g];
  let c = "valid";
  for (const g of t.validator(e, l))
    g.explanation = r.message, c = "not_valid", yield [g, void 0];
  for (let [g, d, A] of t.entries(e, l)) {
    const j = Qt(d, A, {
      path: g === void 0 ? n : [...n, g],
      branch: g === void 0 ? i : [...i, d],
      coerce: a,
      mask: o,
      message: r.message
    });
    for (const h of j)
      h[0] ? (c = h[0].refinement != null ? "not_refined" : "not_valid", yield [h[0], void 0]) : a && (d = h[1], g === void 0 ? e = d : e instanceof Map ? e.set(g, d) : e instanceof Set ? e.add(d) : J(e) && (d !== void 0 || g in e) && (e[g] = d));
  }
  if (c !== "not_valid")
    for (const g of t.refiner(e, l))
      g.explanation = r.message, c = "not_refined", yield [g, void 0];
  c === "valid" && (yield [void 0, e]);
}
class ie {
  constructor(t) {
    const { type: r, schema: n, validator: i, refiner: a, coercer: o = (c) => c, entries: l = function* () {
    } } = t;
    this.type = r, this.schema = n, this.entries = l, this.coercer = o, i ? this.validator = (c, g) => {
      const d = i(c, g);
      return gr(d, g, this, c);
    } : this.validator = () => [], a ? this.refiner = (c, g) => {
      const d = a(c, g);
      return gr(d, g, this, c);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(t, r) {
    return lt(t, this, r);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(t, r) {
    return Qr(t, this, r);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(t) {
    return O(t, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(t, r) {
    return Yr(t, this, r);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(t, r = {}) {
    return Ge(t, this, r);
  }
}
function lt(e, t, r) {
  const n = Ge(e, t, { message: r });
  if (n[0])
    throw n[0];
}
function Qr(e, t, r) {
  const n = Ge(e, t, { coerce: !0, message: r });
  if (n[0])
    throw n[0];
  return n[1];
}
function Yr(e, t, r) {
  const n = Ge(e, t, { coerce: !0, mask: !0, message: r });
  if (n[0])
    throw n[0];
  return n[1];
}
function O(e, t) {
  return !Ge(e, t)[0];
}
function Ge(e, t, r = {}) {
  const n = Qt(e, t, r), i = Gi(n);
  return i[0] ? [new Ri(i[0], function* () {
    for (const o of n)
      o[0] && (yield o[0]);
  }), void 0] : [void 0, i[1]];
}
function le(...e) {
  const t = e[0].type === "type", r = e.map((i) => i.schema), n = Object.assign({}, ...r);
  return t ? Yi(n) : u(n);
}
function $(e, t) {
  return new ie({ type: e, schema: null, validator: t });
}
function Me() {
  return $("any", () => !0);
}
function M(e) {
  return new ie({
    type: "array",
    schema: e,
    *entries(t) {
      if (e && Array.isArray(t))
        for (const [r, n] of t.entries())
          yield [r, n, e];
    },
    coercer(t) {
      return Array.isArray(t) ? t.slice() : t;
    },
    validator(t) {
      return Array.isArray(t) || `Expected an array value, but received: ${H(t)}`;
    }
  });
}
function x() {
  return $("boolean", (e) => typeof e == "boolean");
}
function de() {
  return $("integer", (e) => typeof e == "number" && !isNaN(e) && Number.isInteger(e) || `Expected an integer, but received: ${H(e)}`);
}
function p(e) {
  const t = H(e), r = typeof e;
  return new ie({
    type: "literal",
    schema: r === "string" || r === "number" || r === "boolean" ? e : null,
    validator(n) {
      return n === e || `Expected the literal \`${t}\`, but received: ${H(n)}`;
    }
  });
}
function Wr() {
  return $("never", () => !1);
}
function v(e) {
  return new ie({
    ...e,
    validator: (t, r) => t === null || e.validator(t, r),
    refiner: (t, r) => t === null || e.refiner(t, r)
  });
}
function m() {
  return $("number", (e) => typeof e == "number" && !isNaN(e) || `Expected a number, but received: ${H(e)}`);
}
function u(e) {
  const t = e ? Object.keys(e) : [], r = Wr();
  return new ie({
    type: "object",
    schema: e || null,
    *entries(n) {
      if (e && J(n)) {
        const i = new Set(Object.keys(n));
        for (const a of t)
          i.delete(a), yield [a, n[a], e[a]];
        for (const a of i)
          yield [a, n[a], r];
      }
    },
    validator(n) {
      return J(n) || `Expected an object, but received: ${H(n)}`;
    },
    coercer(n) {
      return J(n) ? { ...n } : n;
    }
  });
}
function I(e) {
  return new ie({
    ...e,
    validator: (t, r) => t === void 0 || e.validator(t, r),
    refiner: (t, r) => t === void 0 || e.refiner(t, r)
  });
}
function Ae(e, t) {
  return new ie({
    type: "record",
    schema: null,
    *entries(r) {
      if (J(r))
        for (const n in r) {
          const i = r[n];
          yield [n, n, e], yield [n, i, t];
        }
    },
    validator(r) {
      return J(r) || `Expected an object, but received: ${H(r)}`;
    }
  });
}
function s() {
  return $("string", (e) => typeof e == "string" || `Expected a string, but received: ${H(e)}`);
}
function W(e) {
  const t = Wr();
  return new ie({
    type: "tuple",
    schema: null,
    *entries(r) {
      if (Array.isArray(r)) {
        const n = Math.max(e.length, r.length);
        for (let i = 0; i < n; i++)
          yield [i, r[i], e[i] || t];
      }
    },
    validator(r) {
      return Array.isArray(r) || `Expected an array, but received: ${H(r)}`;
    }
  });
}
function Yi(e) {
  const t = Object.keys(e);
  return new ie({
    type: "type",
    schema: e,
    *entries(r) {
      if (J(r))
        for (const n of t)
          yield [n, r[n], e[n]];
    },
    validator(r) {
      return J(r) || `Expected an object, but received: ${H(r)}`;
    },
    coercer(r) {
      return J(r) ? { ...r } : r;
    }
  });
}
function b(e) {
  const t = e.map((r) => r.type).join(" | ");
  return new ie({
    type: "union",
    schema: null,
    coercer(r) {
      for (const n of e) {
        const [i, a] = n.validate(r, { coerce: !0 });
        if (!i)
          return a;
      }
      return r;
    },
    validator(r, n) {
      const i = [];
      for (const a of e) {
        const [...o] = Qt(r, a, n), [l] = o;
        if (l[0])
          for (const [c] of o)
            c && i.push(c);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${t}\`, but received: ${H(r)}`,
        ...i
      ];
    }
  });
}
var Yt = {}, Wt = {}, Zr = { exports: {} };
(function(e) {
  var t = Object.prototype.hasOwnProperty, r = "~";
  function n() {
  }
  Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = !1));
  function i(c, g, d) {
    this.fn = c, this.context = g, this.once = d || !1;
  }
  function a(c, g, d, A, j) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var h = new i(d, A || c, j), y = r ? r + g : g;
    return c._events[y] ? c._events[y].fn ? c._events[y] = [c._events[y], h] : c._events[y].push(h) : (c._events[y] = h, c._eventsCount++), c;
  }
  function o(c, g) {
    --c._eventsCount === 0 ? c._events = new n() : delete c._events[g];
  }
  function l() {
    this._events = new n(), this._eventsCount = 0;
  }
  l.prototype.eventNames = function() {
    var g = [], d, A;
    if (this._eventsCount === 0) return g;
    for (A in d = this._events)
      t.call(d, A) && g.push(r ? A.slice(1) : A);
    return Object.getOwnPropertySymbols ? g.concat(Object.getOwnPropertySymbols(d)) : g;
  }, l.prototype.listeners = function(g) {
    var d = r ? r + g : g, A = this._events[d];
    if (!A) return [];
    if (A.fn) return [A.fn];
    for (var j = 0, h = A.length, y = new Array(h); j < h; j++)
      y[j] = A[j].fn;
    return y;
  }, l.prototype.listenerCount = function(g) {
    var d = r ? r + g : g, A = this._events[d];
    return A ? A.fn ? 1 : A.length : 0;
  }, l.prototype.emit = function(g, d, A, j, h, y) {
    var T = r ? r + g : g;
    if (!this._events[T]) return !1;
    var f = this._events[T], S = arguments.length, C, w;
    if (f.fn) {
      switch (f.once && this.removeListener(g, f.fn, void 0, !0), S) {
        case 1:
          return f.fn.call(f.context), !0;
        case 2:
          return f.fn.call(f.context, d), !0;
        case 3:
          return f.fn.call(f.context, d, A), !0;
        case 4:
          return f.fn.call(f.context, d, A, j), !0;
        case 5:
          return f.fn.call(f.context, d, A, j, h), !0;
        case 6:
          return f.fn.call(f.context, d, A, j, h, y), !0;
      }
      for (w = 1, C = new Array(S - 1); w < S; w++)
        C[w - 1] = arguments[w];
      f.fn.apply(f.context, C);
    } else {
      var V = f.length, P;
      for (w = 0; w < V; w++)
        switch (f[w].once && this.removeListener(g, f[w].fn, void 0, !0), S) {
          case 1:
            f[w].fn.call(f[w].context);
            break;
          case 2:
            f[w].fn.call(f[w].context, d);
            break;
          case 3:
            f[w].fn.call(f[w].context, d, A);
            break;
          case 4:
            f[w].fn.call(f[w].context, d, A, j);
            break;
          default:
            if (!C) for (P = 1, C = new Array(S - 1); P < S; P++)
              C[P - 1] = arguments[P];
            f[w].fn.apply(f[w].context, C);
        }
    }
    return !0;
  }, l.prototype.on = function(g, d, A) {
    return a(this, g, d, A, !1);
  }, l.prototype.once = function(g, d, A) {
    return a(this, g, d, A, !0);
  }, l.prototype.removeListener = function(g, d, A, j) {
    var h = r ? r + g : g;
    if (!this._events[h]) return this;
    if (!d)
      return o(this, h), this;
    var y = this._events[h];
    if (y.fn)
      y.fn === d && (!j || y.once) && (!A || y.context === A) && o(this, h);
    else {
      for (var T = 0, f = [], S = y.length; T < S; T++)
        (y[T].fn !== d || j && !y[T].once || A && y[T].context !== A) && f.push(y[T]);
      f.length ? this._events[h] = f.length === 1 ? f[0] : f : o(this, h);
    }
    return this;
  }, l.prototype.removeAllListeners = function(g) {
    var d;
    return g ? (d = r ? r + g : g, this._events[d] && o(this, d)) : (this._events = new n(), this._eventsCount = 0), this;
  }, l.prototype.off = l.prototype.removeListener, l.prototype.addListener = l.prototype.on, l.prefixed = r, l.EventEmitter = l, e.exports = l;
})(Zr);
var Vr = Zr.exports;
Object.defineProperty(Wt, "__esModule", { value: !0 });
const Wi = Vr;
class Zi extends Wi.EventEmitter {
  /** Instantiate a WebSocket class
   * @constructor
   * @param {String} address - url to a websocket server
   * @param {(Object)} options - websocket options
   * @param {(String|Array)} protocols - a list of protocols
   * @return {WebSocketBrowserImpl} - returns a WebSocket instance
   */
  constructor(r, n, i) {
    super();
    k(this, "socket");
    this.socket = new window.WebSocket(r, i), this.socket.onopen = () => this.emit("open"), this.socket.onmessage = (a) => this.emit("message", a.data), this.socket.onerror = (a) => this.emit("error", a), this.socket.onclose = (a) => {
      this.emit("close", a.code, a.reason);
    };
  }
  /**
   * Sends data through a websocket connection
   * @method
   * @param {(String|Object)} data - data to be sent via websocket
   * @param {Object} optionsOrCallback - ws options
   * @param {Function} callback - a callback called once the data is sent
   * @return {Undefined}
   */
  send(r, n, i) {
    const a = i || n;
    try {
      this.socket.send(r), a();
    } catch (o) {
      a(o);
    }
  }
  /**
   * Closes an underlying socket
   * @method
   * @param {Number} code - status code explaining why the connection is being closed
   * @param {String} reason - a description why the connection is closing
   * @return {Undefined}
   * @throws {Error}
   */
  close(r, n) {
    this.socket.close(r, n);
  }
  addEventListener(r, n, i) {
    this.socket.addEventListener(r, n, i);
  }
}
function Vi(e, t) {
  return new Zi(e, t);
}
Wt.default = Vi;
var Zt = {}, Pe = {};
Object.defineProperty(Pe, "__esModule", { value: !0 });
Pe.createError = Pe.DefaultDataPack = void 0;
const Fi = /* @__PURE__ */ new Map([
  [-32e3, "Event not provided"],
  [-32600, "Invalid Request"],
  [-32601, "Method not found"],
  [-32602, "Invalid params"],
  [-32603, "Internal error"],
  [-32604, "Params not found"],
  [-32605, "Method forbidden"],
  [-32606, "Event forbidden"],
  [-32700, "Parse error"]
]);
class Ji {
  encode(t) {
    return JSON.stringify(t);
  }
  decode(t) {
    return JSON.parse(t);
  }
}
Pe.DefaultDataPack = Ji;
function Hi(e, t) {
  const r = {
    code: e,
    message: Fi.get(e) || "Internal Server Error"
  };
  return t && (r.data = t), r;
}
Pe.createError = Hi;
Object.defineProperty(Zt, "__esModule", { value: !0 });
const Xi = Vr, qi = Pe;
class Ki extends Xi.EventEmitter {
  /**
   * Instantiate a Client class.
   * @constructor
   * @param {webSocketFactory} webSocketFactory - factory method for WebSocket
   * @param {String} address - url to a websocket server
   * @param {Object} options - ws options object with reconnect parameters
   * @param {Function} generate_request_id - custom generation request Id
   * @param {DataPack} dataPack - data pack contains encoder and decoder
   * @return {CommonClient}
   */
  constructor(r, n = "ws://localhost:8080", { autoconnect: i = !0, reconnect: a = !0, reconnect_interval: o = 1e3, max_reconnects: l = 5, ...c } = {}, g, d) {
    super();
    k(this, "address");
    k(this, "rpc_id");
    k(this, "queue");
    k(this, "options");
    k(this, "autoconnect");
    k(this, "ready");
    k(this, "reconnect");
    k(this, "reconnect_timer_id");
    k(this, "reconnect_interval");
    k(this, "max_reconnects");
    k(this, "rest_options");
    k(this, "current_reconnects");
    k(this, "generate_request_id");
    k(this, "socket");
    k(this, "webSocketFactory");
    k(this, "dataPack");
    this.webSocketFactory = r, this.queue = {}, this.rpc_id = 0, this.address = n, this.autoconnect = i, this.ready = !1, this.reconnect = a, this.reconnect_timer_id = void 0, this.reconnect_interval = o, this.max_reconnects = l, this.rest_options = c, this.current_reconnects = 0, this.generate_request_id = g || (() => ++this.rpc_id), d ? this.dataPack = d : this.dataPack = new qi.DefaultDataPack(), this.autoconnect && this._connect(this.address, {
      autoconnect: this.autoconnect,
      reconnect: this.reconnect,
      reconnect_interval: this.reconnect_interval,
      max_reconnects: this.max_reconnects,
      ...this.rest_options
    });
  }
  /**
   * Connects to a defined server if not connected already.
   * @method
   * @return {Undefined}
   */
  connect() {
    this.socket || this._connect(this.address, {
      autoconnect: this.autoconnect,
      reconnect: this.reconnect,
      reconnect_interval: this.reconnect_interval,
      max_reconnects: this.max_reconnects,
      ...this.rest_options
    });
  }
  /**
   * Calls a registered RPC method on server.
   * @method
   * @param {String} method - RPC method name
   * @param {Object|Array} params - optional method parameters
   * @param {Number} timeout - RPC reply timeout value
   * @param {Object} ws_opts - options passed to ws
   * @return {Promise}
   */
  call(r, n, i, a) {
    return !a && typeof i == "object" && (a = i, i = null), new Promise((o, l) => {
      if (!this.ready)
        return l(new Error("socket not ready"));
      const c = this.generate_request_id(r, n), g = {
        jsonrpc: "2.0",
        method: r,
        params: n || void 0,
        id: c
      };
      this.socket.send(this.dataPack.encode(g), a, (d) => {
        if (d)
          return l(d);
        this.queue[c] = { promise: [o, l] }, i && (this.queue[c].timeout = setTimeout(() => {
          delete this.queue[c], l(new Error("reply timeout"));
        }, i));
      });
    });
  }
  /**
   * Logins with the other side of the connection.
   * @method
   * @param {Object} params - Login credentials object
   * @return {Promise}
   */
  async login(r) {
    const n = await this.call("rpc.login", r);
    if (!n)
      throw new Error("authentication failed");
    return n;
  }
  /**
   * Fetches a list of client's methods registered on server.
   * @method
   * @return {Array}
   */
  async listMethods() {
    return await this.call("__listMethods");
  }
  /**
   * Sends a JSON-RPC 2.0 notification to server.
   * @method
   * @param {String} method - RPC method name
   * @param {Object} params - optional method parameters
   * @return {Promise}
   */
  notify(r, n) {
    return new Promise((i, a) => {
      if (!this.ready)
        return a(new Error("socket not ready"));
      const o = {
        jsonrpc: "2.0",
        method: r,
        params: n
      };
      this.socket.send(this.dataPack.encode(o), (l) => {
        if (l)
          return a(l);
        i();
      });
    });
  }
  /**
   * Subscribes for a defined event.
   * @method
   * @param {String|Array} event - event name
   * @return {Undefined}
   * @throws {Error}
   */
  async subscribe(r) {
    typeof r == "string" && (r = [r]);
    const n = await this.call("rpc.on", r);
    if (typeof r == "string" && n[r] !== "ok")
      throw new Error("Failed subscribing to an event '" + r + "' with: " + n[r]);
    return n;
  }
  /**
   * Unsubscribes from a defined event.
   * @method
   * @param {String|Array} event - event name
   * @return {Undefined}
   * @throws {Error}
   */
  async unsubscribe(r) {
    typeof r == "string" && (r = [r]);
    const n = await this.call("rpc.off", r);
    if (typeof r == "string" && n[r] !== "ok")
      throw new Error("Failed unsubscribing from an event with: " + n);
    return n;
  }
  /**
   * Closes a WebSocket connection gracefully.
   * @method
   * @param {Number} code - socket close code
   * @param {String} data - optional data to be sent before closing
   * @return {Undefined}
   */
  close(r, n) {
    this.socket.close(r || 1e3, n);
  }
  /**
   * Enable / disable automatic reconnection.
   * @method
   * @param {Boolean} reconnect - enable / disable reconnection
   * @return {Undefined}
   */
  setAutoReconnect(r) {
    this.reconnect = r;
  }
  /**
   * Set the interval between reconnection attempts.
   * @method
   * @param {Number} interval - reconnection interval in milliseconds
   * @return {Undefined}
   */
  setReconnectInterval(r) {
    this.reconnect_interval = r;
  }
  /**
   * Set the maximum number of reconnection attempts.
   * @method
   * @param {Number} max_reconnects - maximum reconnection attempts
   * @return {Undefined}
   */
  setMaxReconnects(r) {
    this.max_reconnects = r;
  }
  /**
   * Connection/Message handler.
   * @method
   * @private
   * @param {String} address - WebSocket API address
   * @param {Object} options - ws options object
   * @return {Undefined}
   */
  _connect(r, n) {
    clearTimeout(this.reconnect_timer_id), this.socket = this.webSocketFactory(r, n), this.socket.addEventListener("open", () => {
      this.ready = !0, this.emit("open"), this.current_reconnects = 0;
    }), this.socket.addEventListener("message", ({ data: i }) => {
      i instanceof ArrayBuffer && (i = Rn.Buffer.from(i).toString());
      try {
        i = this.dataPack.decode(i);
      } catch {
        return;
      }
      if (i.notification && this.listeners(i.notification).length) {
        if (!Object.keys(i.params).length)
          return this.emit(i.notification);
        const a = [i.notification];
        if (i.params.constructor === Object)
          a.push(i.params);
        else
          for (let o = 0; o < i.params.length; o++)
            a.push(i.params[o]);
        return Promise.resolve().then(() => {
          this.emit.apply(this, a);
        });
      }
      if (!this.queue[i.id])
        return i.method ? Promise.resolve().then(() => {
          this.emit(i.method, i == null ? void 0 : i.params);
        }) : void 0;
      "error" in i == "result" in i && this.queue[i.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')), this.queue[i.id].timeout && clearTimeout(this.queue[i.id].timeout), i.error ? this.queue[i.id].promise[1](i.error) : this.queue[i.id].promise[0](i.result), delete this.queue[i.id];
    }), this.socket.addEventListener("error", (i) => this.emit("error", i)), this.socket.addEventListener("close", ({ code: i, reason: a }) => {
      this.ready && setTimeout(() => this.emit("close", i, a), 0), this.ready = !1, this.socket = void 0, i !== 1e3 && (this.current_reconnects++, this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0) && (this.reconnect_timer_id = setTimeout(() => this._connect(r, n), this.reconnect_interval)));
    });
  }
}
Zt.default = Ki;
var Fr = tr && tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Yt, "__esModule", { value: !0 });
var Jr = Yt.Client = void 0;
const _i = Fr(Wt), $i = Fr(Zt);
class es extends $i.default {
  constructor(t = "ws://localhost:8080", { autoconnect: r = !0, reconnect: n = !0, reconnect_interval: i = 1e3, max_reconnects: a = 5 } = {}, o) {
    super(_i.default, t, {
      autoconnect: r,
      reconnect: n,
      reconnect_interval: i,
      max_reconnects: a
    }, o);
  }
}
Jr = Yt.Client = es;
function Hr(e) {
  return /^\d+\.\d+\.\d+$/.test(e);
}
function K(e) {
  if (!Hr(e))
    throw new Error("Invalid semver version: " + e);
  const [t, r, n] = e.split(".").map((i) => parseInt(i, 10));
  return { major: t, minor: r, patch: n };
}
function ts(e, t) {
  const r = K(e), n = K(t);
  return r.major !== n.major ? r.major < n.major : r.minor !== n.minor ? r.minor < n.minor : r.patch !== n.patch ? r.patch < n.patch : !1;
}
function rs(e, t) {
  const r = K(e), n = K(t);
  return r.major !== n.major ? r.major <= n.major : r.minor !== n.minor ? r.minor <= n.minor : r.patch !== n.patch ? r.patch <= n.patch : !0;
}
function ns(e, t) {
  const r = K(e), n = K(t);
  return r.major !== n.major ? r.major > n.major : r.minor !== n.minor ? r.minor > n.minor : r.patch !== n.patch ? r.patch > n.patch : !1;
}
function is(e, t) {
  const r = K(e), n = K(t);
  return r.major !== n.major ? r.major >= n.major : r.minor !== n.minor ? r.minor >= n.minor : r.patch !== n.patch ? r.patch >= n.patch : !0;
}
function ss(e, t) {
  return K(e), K(t), e === t;
}
var dr = {
  isValid: Hr,
  parse: K,
  lt: ts,
  lte: rs,
  gt: ns,
  gte: is,
  eq: ss
}, Vt = (e, t, r) => {
  if (!t.has(e))
    throw TypeError("Cannot " + r);
}, L = (e, t, r) => (Vt(e, t, "read from private field"), r ? r.call(e) : t.get(e)), We = (e, t, r) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, r);
}, Ze = (e, t, r, n) => (Vt(e, t, "write to private field"), t.set(e, r), r), Ve = (e, t, r) => (Vt(e, t, "access private method"), r), Z = s(), as = s(), os = s(), E = s(), U = s(), G = s(), je = b([
  u({
    AddressOwner: U
  }),
  u({
    ObjectOwner: U
  }),
  u({
    Shared: u({
      initial_shared_version: m()
    })
  }),
  p("Immutable")
]), cs = $("SuiJsonValue", () => !0), us = 32;
function Mr(e) {
  try {
    return Gt(e).length === us;
  } catch {
    return !1;
  }
}
var Xr = 32;
function fe(e) {
  return ls(e) && gs(e) === Xr;
}
function tt(e) {
  return fe(e);
}
function B(e, t = !1) {
  let r = e.toLowerCase();
  return !t && r.startsWith("0x") && (r = r.slice(2)), `0x${r.padStart(Xr * 2, "0")}`;
}
function ge(e, t = !1) {
  return B(e, t);
}
function ls(e) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(e) && e.length % 2 === 0;
}
function gs(e) {
  return /^(0x|0X)/.test(e) ? (e.length - 2) / 2 : e.length / 2;
}
b([s(), p("package")]);
var ne = u({
  /** Base64 string representing the object digest */
  digest: Z,
  /** Hex code as string representing the object id */
  objectId: s(),
  /** Object version */
  version: b([m(), s()])
}), ds = u({
  payment: M(ne),
  /** Gas Object's owner */
  owner: s(),
  price: s(),
  budget: s()
}), Ms = le(
  ne,
  u({
    type: s(),
    owner: je,
    previousTransaction: Z
  })
), As = Ae(s(), Me()), hs = Ae(s(), s()), qr = u({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: s(),
  /** Fields and values stored inside the Move object */
  fields: As,
  hasPublicTransfer: x()
}), Tt = u({
  /** A mapping from module name to disassembled Move bytecode */
  disassembled: hs
}), Is = b([
  le(qr, u({ dataType: p("moveObject") })),
  le(Tt, u({ dataType: p("package") }))
]);
u({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: s(),
  hasPublicTransfer: x(),
  version: G,
  bcsBytes: M(m())
});
var fs = u({
  id: E,
  /** A mapping from module name to Move bytecode enocded in base64*/
  moduleMap: Ae(s(), s())
}), ys = b([
  le(qr, u({ dataType: p("moveObject") })),
  le(fs, u({ dataType: p("package") }))
]);
BigInt(1e9);
var xe = s(), Kr = u({
  code: s(),
  error: I(s()),
  object_id: I(E),
  version: I(G),
  digest: I(xe)
}), ps = u({
  data: v(Ae(s(), s())),
  error: v(Kr)
}), js = b([
  ps,
  I(Ae(s(), s()))
]), Ns = u({
  objectId: E,
  version: G,
  digest: xe,
  /**
   * Type of the object, default to be undefined unless SuiObjectDataOptions.showType is set to true
   */
  type: I(s()),
  /**
   * Move object content or package content, default to be undefined unless SuiObjectDataOptions.showContent is set to true
   */
  content: I(Is),
  /**
   * Move object content or package content in BCS bytes, default to be undefined unless SuiObjectDataOptions.showBcs is set to true
   */
  bcs: I(ys),
  /**
   * The owner of this object. Default to be undefined unless SuiObjectDataOptions.showOwner is set to true
   */
  owner: I(je),
  /**
   * The digest of the transaction that created or last mutated this object.
   * Default to be undefined unless SuiObjectDataOptions.showPreviousTransaction is set to true
   */
  previousTransaction: I(Z),
  /**
   * The amount of SUI we would rebate if this object gets deleted.
   * This number is re-calculated each time the object is mutated based on
   * the present storage gas price.
   * Default to be undefined unless SuiObjectDataOptions.showStorageRebate is set to true
   */
  storageRebate: I(s()),
  /**
   * Display metadata for this object, default to be undefined unless SuiObjectDataOptions.showDisplay is set to true
   * This can also be None if the struct type does not have Display defined
   * See more details in https://forums.sui.io/t/nft-object-display-proposal/4872
   */
  display: I(js)
});
u({
  /* Whether to fetch the object type, default to be true */
  showType: I(x()),
  /* Whether to fetch the object content, default to be false */
  showContent: I(x()),
  /* Whether to fetch the object content in BCS bytes, default to be false */
  showBcs: I(x()),
  /* Whether to fetch the object owner, default to be false */
  showOwner: I(x()),
  /* Whether to fetch the previous transaction digest, default to be false */
  showPreviousTransaction: I(x()),
  /* Whether to fetch the storage rebate, default to be false */
  showStorageRebate: I(x()),
  /* Whether to fetch the display metadata, default to be false */
  showDisplay: I(x())
});
b([
  p("Exists"),
  p("notExists"),
  p("Deleted")
]);
M(Ms);
var at = u({
  data: I(Ns),
  error: I(Kr)
});
function _r(e) {
  return e.data;
}
function Ts(e) {
  if (e.error && "object_id" in e.error && "version" in e.error && "digest" in e.error) {
    const t = e.error;
    return {
      objectId: t.object_id,
      version: t.version,
      digest: t.digest
    };
  }
}
function ms(e) {
  if ("reference" in e)
    return e.reference;
  const t = _r(e);
  return t ? {
    objectId: t.objectId,
    version: t.version,
    digest: t.digest
  } : Ts(e);
}
function ws(e) {
  var t;
  return O(e, je) ? e : (t = _r(e)) == null ? void 0 : t.owner;
}
function Ss(e) {
  const t = ws(e);
  if (typeof t == "object" && "Shared" in t)
    return t.Shared.initial_shared_version;
}
var Ds = u({
  objectId: E,
  atCheckpoint: I(m())
}), Es = u({
  data: M(at),
  // TODO: remove union after 0.30.0 is released
  nextCursor: b([v(E), v(Ds)]),
  hasNextPage: x()
}), $r = u({
  txDigest: Z,
  eventSeq: G
}), Ft = u({
  id: $r,
  // Move package where this event was emitted.
  packageId: E,
  // Move module where this event was emitted.
  transactionModule: s(),
  // Sender's Sui address.
  sender: U,
  // Move event type.
  type: s(),
  // Parsed json value of the event
  parsedJson: I(Ae(s(), Me())),
  // Base 58 encoded bcs bytes of the move event
  bcs: I(s()),
  timestampMs: I(s())
}), bs = u({
  data: M(Ft),
  nextCursor: v($r),
  hasNextPage: x()
}), Ls = m(), Cs = u({
  subscription: Ls,
  result: Ft
}), Ce = s(), vs = u({
  epoch: Ce,
  storage_charge: s(),
  computation_charge: s(),
  storage_rebate: s(),
  epoch_start_timestamp_ms: I(s())
}), xs = u({
  epoch: Ce,
  round: s(),
  commit_timestamp_ms: s()
}), ks = u({
  objects: M(E)
}), ee = b([
  p("GasCoin"),
  u({ Input: m() }),
  u({ Result: m() }),
  u({ NestedResult: W([m(), m()]) })
]), zs = u({
  arguments: I(M(ee)),
  type_arguments: I(M(s())),
  package: E,
  module: s(),
  function: s()
}), Os = b([
  u({ MoveCall: zs }),
  u({ TransferObjects: W([M(ee), ee]) }),
  u({ SplitCoins: W([ee, M(ee)]) }),
  u({ MergeCoins: W([ee, M(ee)]) }),
  u({ Publish: W([Tt, M(E)]) }),
  u({
    Upgrade: W([Tt, M(E), E, ee])
  }),
  u({ MakeMoveVec: W([v(s()), M(ee)]) })
]), Bs = b([
  u({
    type: p("pure"),
    valueType: I(s()),
    value: cs
  }),
  u({
    type: p("object"),
    objectType: p("immOrOwnedObject"),
    objectId: E,
    version: G,
    digest: xe
  }),
  u({
    type: p("object"),
    objectType: p("sharedObject"),
    objectId: E,
    initialSharedVersion: G,
    mutable: x()
  })
]), Ps = u({
  transactions: M(Os),
  inputs: M(Bs)
}), Rs = b([
  le(vs, u({ kind: p("ChangeEpoch") })),
  le(
    xs,
    u({
      kind: p("ConsensusCommitPrologue")
    })
  ),
  le(ks, u({ kind: p("Genesis") })),
  le(
    Ps,
    u({ kind: p("ProgrammableTransaction") })
  )
]), en = u({
  // Eventually this will become union(literal('v1'), literal('v2'), ...)
  messageVersion: p("v1"),
  transaction: Rs,
  sender: U,
  gasData: ds
  // this shit is diff bw wallet and explorer
}), Ar = s(), Us = b([
  Ar,
  M(Ar)
]);
u({
  epoch: Ce,
  signature: Us,
  signers_map: M(m())
});
var Gs = u({
  computationCost: s(),
  storageCost: s(),
  storageRebate: s(),
  nonRefundableStorageFee: s()
}), Qs = b([
  p("success"),
  p("failure")
]), Ys = u({
  status: Qs,
  error: I(s())
}), rt = u({
  owner: je,
  reference: ne
}), Ws = u({
  objectId: E,
  sequenceNumber: G
}), Jt = u({
  // Eventually this will become union(literal('v1'), literal('v2'), ...)
  messageVersion: p("v1"),
  /** The status of the execution */
  status: Ys,
  /** The epoch when this transaction was executed */
  executedEpoch: Ce,
  /** The version that every modified (mutated or deleted) object had before it was modified by this transaction. **/
  modifiedAtVersions: I(M(Ws)),
  gasUsed: Gs,
  /** The object references of the shared objects used in this transaction. Empty if no shared objects were used. */
  sharedObjects: I(M(ne)),
  /** The transaction digest */
  transactionDigest: Z,
  /** ObjectRef and owner of new objects created */
  created: I(M(rt)),
  /** ObjectRef and owner of mutated objects, including gas object */
  mutated: I(M(rt)),
  /**
   * ObjectRef and owner of objects that are unwrapped in this transaction.
   * Unwrapped objects are objects that were wrapped into other objects in the past,
   * and just got extracted out.
   */
  unwrapped: I(M(rt)),
  /** Object Refs of objects now deleted (the old refs) */
  deleted: I(M(ne)),
  /** Object Refs of objects now deleted (the old refs) */
  unwrapped_then_deleted: I(M(ne)),
  /** Object refs of objects now wrapped in other objects */
  wrapped: I(M(ne)),
  /**
   * The updated gas object reference. Have a dedicated field for convenient access.
   * It's also included in mutated.
   */
  gasObject: rt,
  /** The events emitted during execution. Note that only successful transactions emit events */
  eventsDigest: I(os),
  /** The set of transaction digests this transaction depends on */
  dependencies: I(M(Z))
}), Ht = M(Ft), Zs = W([M(m()), s()]), Vs = W([
  ee,
  M(m()),
  s()
]), Fs = u({
  mutableReferenceOutputs: I(M(Vs)),
  returnValues: I(M(Zs))
}), Js = u({
  effects: Jt,
  events: Ht,
  results: I(M(Fs)),
  error: I(s())
}), Hs = s(), Xs = u({
  data: en,
  txSignatures: M(s())
}), qs = u({
  type: p("published"),
  packageId: E,
  version: G,
  digest: xe,
  modules: M(s())
}), Ks = u({
  type: p("transferred"),
  sender: U,
  recipient: je,
  objectType: s(),
  objectId: E,
  version: G,
  digest: xe
}), _s = u({
  type: p("mutated"),
  sender: U,
  owner: je,
  objectType: s(),
  objectId: E,
  version: G,
  previousVersion: G,
  digest: xe
}), $s = u({
  type: p("deleted"),
  sender: U,
  objectType: s(),
  objectId: E,
  version: G
}), ea = u({
  type: p("wrapped"),
  sender: U,
  objectType: s(),
  objectId: E,
  version: G
}), ta = u({
  type: p("created"),
  sender: U,
  owner: je,
  objectType: s(),
  objectId: E,
  version: G,
  digest: xe
}), tn = b([
  qs,
  Ks,
  _s,
  $s,
  ea,
  ta
]), rn = u({
  owner: je,
  coinType: s(),
  /* Coin balance change(positive means receive, negative means send) */
  amount: s()
}), ot = u({
  digest: Z,
  transaction: I(Xs),
  effects: I(Jt),
  events: I(Ht),
  timestampMs: I(s()),
  checkpoint: I(s()),
  confirmedLocalExecution: I(x()),
  objectChanges: I(M(tn)),
  balanceChanges: I(M(rn)),
  /* Errors that occurred in fetching/serializing the transaction. */
  errors: I(M(s()))
});
u({
  /* Whether to show transaction input data. Default to be false. */
  showInput: I(x()),
  /* Whether to show transaction effects. Default to be false. */
  showEffects: I(x()),
  /* Whether to show transaction events. Default to be false. */
  showEvents: I(x()),
  /* Whether to show object changes. Default to be false. */
  showObjectChanges: I(x()),
  /* Whether to show coin balance changes. Default to be false. */
  showBalanceChanges: I(x())
});
var ra = u({
  data: M(ot),
  nextCursor: v(Z),
  hasNextPage: x()
}), na = u({
  effects: Jt,
  events: Ht,
  objectChanges: M(tn),
  balanceChanges: M(rn),
  // TODO: Remove optional when this is rolled out to all networks:
  input: I(en)
}), nn = "0x2", Xt = "0x1", ia = "object", sa = "ID", aa = `${nn}::sui::SUI`;
ge("0x6");
var oa = u({
  decimals: m(),
  name: s(),
  symbol: s(),
  description: s(),
  iconUrl: v(s()),
  id: v(E)
}), ze = "vector", ca = {
  kind: "TransactionKind",
  sender: N.ADDRESS,
  gasData: "GasData",
  expiration: "TransactionExpiration"
}, ua = {
  enums: {
    "Option<T>": {
      None: null,
      Some: "T"
    },
    ObjectArg: {
      ImmOrOwned: "SuiObjectRef",
      Shared: "SharedObjectRef"
    },
    CallArg: {
      Pure: [ze, N.U8],
      Object: "ObjectArg",
      ObjVec: [ze, "ObjectArg"]
    },
    TypeTag: {
      bool: null,
      u8: null,
      u64: null,
      u128: null,
      address: null,
      signer: null,
      vector: "TypeTag",
      struct: "StructTag",
      u16: null,
      u32: null,
      u256: null
    },
    TransactionKind: {
      // can not be called from sui.js; dummy placement
      // to set the enum counter right for ProgrammableTransact
      ProgrammableTransaction: "ProgrammableTransaction",
      ChangeEpoch: null,
      Genesis: null,
      ConsensusCommitPrologue: null
    },
    TransactionExpiration: {
      None: null,
      Epoch: N.U64
    },
    TransactionData: {
      V1: "TransactionDataV1"
    }
  },
  structs: {
    SuiObjectRef: {
      objectId: N.ADDRESS,
      version: N.U64,
      digest: "ObjectDigest"
    },
    SharedObjectRef: {
      objectId: N.ADDRESS,
      initialSharedVersion: N.U64,
      mutable: N.BOOL
    },
    StructTag: {
      address: N.ADDRESS,
      module: N.STRING,
      name: N.STRING,
      typeParams: [ze, "TypeTag"]
    },
    GasData: {
      payment: [ze, "SuiObjectRef"],
      owner: N.ADDRESS,
      price: N.U64,
      budget: N.U64
    },
    // Signed transaction data needed to generate transaction digest.
    SenderSignedData: {
      data: "TransactionData",
      txSignatures: [ze, [ze, N.U8]]
    },
    TransactionDataV1: ca
  },
  aliases: {
    ObjectDigest: N.BASE58
  }
}, sn = new N({ ...Pi(), types: ua });
sn.registerType(
  "utf8string",
  (e, t) => {
    const r = Array.from(new TextEncoder().encode(t));
    return e.writeVec(r, (n, i) => n.write8(i));
  },
  (e) => {
    let t = e.readVec((r) => r.read8());
    return new TextDecoder().decode(new Uint8Array(t));
  }
);
var la = u({
  amount: m(),
  id: E,
  transferTxDigest: Z
});
u({
  transferredGasObjects: M(la),
  error: v(s())
});
var ga = b([
  s(),
  u({ Object: s() })
]), da = M(ga), Ma = u({
  address: s(),
  name: s()
}), Aa = b([
  p("Private"),
  p("Public"),
  p("Friend")
]), qt = u({
  abilities: M(s())
}), ha = u({
  constraints: qt,
  isPhantom: x()
}), Ia = u({
  TypeParameter: m()
});
function an(e) {
  if (!e)
    return !1;
  if (typeof e == "string" || O(e, Ia) || on(e))
    return !0;
  if (typeof e != "object")
    return !1;
  const t = e;
  return !!(O(t.Reference, Be) || O(t.MutableReference, Be) || O(t.Vector, Be));
}
var Be = $(
  "SuiMoveNormalizedType",
  an
);
function on(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = e;
  if (!t.Struct || typeof t.Struct != "object")
    return !1;
  const r = t.Struct;
  return !(typeof r.address != "string" || typeof r.module != "string" || typeof r.name != "string" || !Array.isArray(r.typeArguments) || !r.typeArguments.every(
    (n) => an(n)
  ));
}
$(
  "SuiMoveNormalizedStructType",
  on
);
var cn = u({
  visibility: Aa,
  isEntry: x(),
  typeParameters: M(qt),
  parameters: M(Be),
  return: M(Be)
}), fa = u({
  name: s(),
  type: Be
}), un = u({
  abilities: qt,
  typeParameters: M(ha),
  fields: M(fa)
}), ln = u({
  fileFormatVersion: m(),
  address: s(),
  name: s(),
  friends: M(Ma),
  structs: Ae(s(), un),
  exposedFunctions: Ae(s(), cn)
}), ya = Ae(
  s(),
  ln
);
function gn(e) {
  return typeof e == "object" && "MutableReference" in e ? e.MutableReference : void 0;
}
function pa(e) {
  return typeof e == "object" && "Reference" in e ? e.Reference : void 0;
}
function dn(e) {
  if (typeof e == "object" && "Struct" in e)
    return e;
  const t = pa(e), r = gn(e);
  if (typeof t == "object" && "Struct" in t)
    return t;
  if (typeof r == "object" && "Struct" in r)
    return r;
}
u({
  value: m()
});
var ja = u({
  stakedSuiId: E,
  stakeRequestEpoch: Ce,
  stakeActiveEpoch: Ce,
  principal: s(),
  status: b([p("Active"), p("Pending"), p("Unstaked")]),
  estimatedReward: I(s())
}), hr = u({
  validatorAddress: U,
  stakingPool: E,
  stakes: M(ja)
}), Na = u({
  balance: u({ value: m() }),
  distribution_counter: m(),
  current_distribution_amount: m(),
  stake_subsidy_period_length: m(),
  stake_subsidy_decrease_rate: m()
});
u({
  type: s(),
  fields: Na
});
u({
  value: m()
});
var Ta = u({
  id: s(),
  size: m(),
  head: u({ vec: M() }),
  tail: u({ vec: M() })
});
u({
  id: s(),
  size: m()
});
u({
  type: s(),
  fields: Ta
});
var ma = u({
  exchangeRates: u({
    id: s(),
    size: m()
  }),
  id: s(),
  pendingStake: m(),
  pendingPoolTokenWithdraw: m(),
  pendingTotalSuiWithdraw: m(),
  poolTokenBalance: m(),
  rewardsPool: u({ value: m() }),
  activationEpoch: u({ vec: M() }),
  deactivationEpoch: u({ vec: M() }),
  suiBalance: m()
});
u({
  type: s(),
  fields: ma
});
var wa = M(W([Hs, s()])), Sa = u({
  epoch: Ce,
  /** Array of (validator public key, stake unit) tuple */
  validators: wa
}), Mn = u({
  suiAddress: U,
  protocolPubkeyBytes: s(),
  networkPubkeyBytes: s(),
  workerPubkeyBytes: s(),
  proofOfPossessionBytes: s(),
  operationCapId: s(),
  name: s(),
  description: s(),
  imageUrl: s(),
  projectUrl: s(),
  p2pAddress: s(),
  netAddress: s(),
  primaryAddress: s(),
  workerAddress: s(),
  nextEpochProtocolPubkeyBytes: v(s()),
  nextEpochProofOfPossession: v(s()),
  nextEpochNetworkPubkeyBytes: v(s()),
  nextEpochWorkerPubkeyBytes: v(s()),
  nextEpochNetAddress: v(s()),
  nextEpochP2pAddress: v(s()),
  nextEpochPrimaryAddress: v(s()),
  nextEpochWorkerAddress: v(s()),
  votingPower: s(),
  gasPrice: s(),
  commissionRate: s(),
  nextEpochStake: s(),
  nextEpochGasPrice: s(),
  nextEpochCommissionRate: s(),
  stakingPoolId: s(),
  stakingPoolActivationEpoch: v(s()),
  stakingPoolDeactivationEpoch: v(s()),
  stakingPoolSuiBalance: s(),
  rewardsPool: s(),
  poolTokenBalance: s(),
  pendingStake: s(),
  pendingPoolTokenWithdraw: s(),
  pendingTotalSuiWithdraw: s(),
  exchangeRatesId: s(),
  exchangeRatesSize: s()
}), Da = u({
  epoch: s(),
  protocolVersion: s(),
  systemStateVersion: s(),
  storageFundTotalObjectStorageRebates: s(),
  storageFundNonRefundableBalance: s(),
  referenceGasPrice: s(),
  safeMode: x(),
  safeModeStorageRewards: s(),
  safeModeComputationRewards: s(),
  safeModeStorageRebates: s(),
  safeModeNonRefundableStorageFee: s(),
  epochStartTimestampMs: s(),
  epochDurationMs: s(),
  stakeSubsidyStartEpoch: s(),
  maxValidatorCount: s(),
  minValidatorJoiningStake: s(),
  validatorLowStakeThreshold: s(),
  validatorVeryLowStakeThreshold: s(),
  validatorLowStakeGracePeriod: s(),
  stakeSubsidyBalance: s(),
  stakeSubsidyDistributionCounter: s(),
  stakeSubsidyCurrentDistributionAmount: s(),
  stakeSubsidyPeriodLength: s(),
  stakeSubsidyDecreaseRate: m(),
  totalStake: s(),
  activeValidators: M(Mn),
  pendingActiveValidatorsId: s(),
  pendingActiveValidatorsSize: s(),
  pendingRemovals: M(s()),
  stakingPoolMappingsId: s(),
  stakingPoolMappingsSize: s(),
  inactivePoolsId: s(),
  inactivePoolsSize: s(),
  validatorCandidatesId: s(),
  validatorCandidatesSize: s(),
  atRiskValidators: M(W([U, s()])),
  validatorReportRecords: M(W([U, M(U)]))
}), Ea = u({
  coinType: s(),
  // TODO(chris): rename this to objectId
  coinObjectId: E,
  version: s(),
  digest: Z,
  balance: s(),
  // TODO (jian): remove this when we move to 0.34
  lockedUntilEpoch: I(v(m())),
  previousTransaction: Z
}), Ir = u({
  data: M(Ea),
  nextCursor: v(E),
  hasNextPage: x()
}), fr = u({
  coinType: s(),
  coinObjectCount: m(),
  totalBalance: s(),
  lockedBalance: u({
    epochId: I(m()),
    number: I(m())
  })
}), ba = u({
  value: s()
}), La = u({
  lastCheckpointId: s(),
  epochEndTimestamp: s(),
  protocolVersion: s(),
  referenceGasPrice: s(),
  totalStake: s(),
  storageFundReinvestment: s(),
  storageCharge: s(),
  storageRebate: s(),
  storageFundBalance: s(),
  stakeSubsidyAmount: s(),
  totalGasFees: s(),
  totalStakeRewardsDistributed: s(),
  leftoverStorageFundInflow: s()
}), An = u({
  epoch: s(),
  validators: M(Mn),
  epochTotalTransactions: s(),
  firstCheckpointId: s(),
  epochStartTimestamp: s(),
  endOfEpochInfo: v(La)
}), Ca = u({
  data: M(An),
  nextCursor: v(s()),
  hasNextPage: x()
}), va = u({
  computationCost: s(),
  storageCost: s(),
  storageRebate: s(),
  nonRefundableStorageFee: s()
});
s();
var yr = s();
u({
  digest: M(m())
});
var hn = Me(), xa = s(), ka = u({
  nextEpochCommittee: M(W([s(), s()])),
  nextEpochProtocolVersion: s(),
  epochCommitments: M(hn)
});
u({
  transaction: Z,
  effects: as
});
var In = u({
  epoch: s(),
  sequenceNumber: s(),
  digest: yr,
  networkTotalTransactions: s(),
  previousDigest: I(yr),
  epochRollingGasCostSummary: va,
  timestampMs: s(),
  endOfEpochData: I(ka),
  // TODO(jian): remove optional after 0.30.0 is released
  validatorSignature: I(xa),
  transactions: M(Z),
  checkpointCommitments: M(hn)
}), za = u({
  data: M(In),
  nextCursor: v(s()),
  hasNextPage: x()
}), Oa = "0.32.2", Ba = "0.34.0", mt = class extends Error {
  constructor(e) {
    super(
      e.cause ? `RPC Error: ${e.cause.message}` : "Unknown RPC Error",
      { cause: e.cause }
    ), this.req = e.req, this.code = e.code, this.data = e.data;
  }
}, Pa = class extends Error {
  constructor(e) {
    super(
      "RPC Validation Error: The response returned from RPC server does not match the TypeScript definition. This is likely because the SDK version is not compatible with the RPC server.",
      { cause: e.cause }
    ), this.req = e.req, this.result = e.result, this.message = this.toString();
  }
  toString() {
    let e = super.toString();
    return this.cause && (e += `
Cause: ${this.cause}`), this.result && (e += `
Reponse Received: ${JSON.stringify(this.result, null, 2)}`), e;
  }
}, Ra = class extends Error {
}, Ua = u({
  jsonrpc: p("2.0"),
  id: s(),
  result: Me()
}), fn = u({
  jsonrpc: p("2.0"),
  id: s(),
  error: u({
    code: Me(),
    message: s(),
    data: I(Me())
  })
}), Ga = class {
  constructor(e, t) {
    this.rpcClient = new Un(
      async (r, n) => {
        const i = {
          method: "POST",
          body: r,
          headers: {
            "Content-Type": "application/json",
            "Client-Sdk-Type": "typescript",
            "Client-Sdk-Version": Oa,
            "Client-Target-Api-Version": Ba,
            ...t
          }
        };
        try {
          let a = await fetch(e, i);
          const o = await a.text();
          if (a.ok)
            n(null, o);
          else {
            const l = a.headers.get("content-type") === "text/html";
            n(
              new Error(
                `${a.status} ${a.statusText}${l ? "" : `: ${o}`}`
              )
            );
          }
        } catch (a) {
          n(a);
        }
      },
      {}
    );
  }
  async requestWithType(e, t, r) {
    const n = { method: e, args: t }, i = await this.request(e, t);
    if (O(i, fn))
      throw new mt({
        req: n,
        code: i.error.code,
        data: i.error.data,
        cause: new Error(i.error.message)
      });
    if (O(i, Ua)) {
      const [a] = Ge(i.result, r);
      return a && console.warn(
        new Pa({
          req: n,
          result: i.result,
          cause: a
        })
      ), i.result;
    }
    throw new mt({ req: n, data: i });
  }
  async request(e, t) {
    return new Promise((r, n) => {
      this.rpcClient.request(e, t, (i, a) => {
        if (i) {
          n(i);
          return;
        }
        r(a);
      });
    });
  }
}, Qa = b([
  p("DynamicField"),
  p("DynamicObject")
]), Ya = u({
  type: s(),
  value: Me()
}), Wa = u({
  name: Ya,
  bcsName: s(),
  type: Qa,
  objectType: s(),
  objectId: E,
  version: m(),
  digest: s()
}), Za = u({
  data: M(Wa),
  nextCursor: v(E),
  hasNextPage: x()
}), Va = (e, t) => {
  const r = new URL(e);
  return r.protocol = r.protocol.replace("http", "ws"), r.toString();
}, Fa = (e) => e && "subscription" in e && typeof e.subscription == "number" && "result" in e && typeof e.result == "object", yn = {
  connectTimeout: 15e3,
  callTimeout: 3e4,
  reconnectInterval: 3e3,
  maxReconnects: 5
}, pr = "suix_subscribeEvent", Ja = "suix_unsubscribeEvent", Ha = class {
  /**
   * @param endpoint Sui node endpoint to connect to (accepts websocket & http)
   * @param options Configuration options, such as timeouts & connection behavior
   */
  constructor(e, t = yn) {
    this.endpoint = e, this.options = t, this.connectionState = 0, this.connectionTimeout = null, this.isSetup = !1, this.connectionPromise = null, this.eventSubscriptions = /* @__PURE__ */ new Map(), this.endpoint.startsWith("http") && (this.endpoint = Va(this.endpoint)), this.rpcClient = new Jr(this.endpoint, {
      reconnect_interval: this.options.reconnectInterval,
      max_reconnects: this.options.maxReconnects,
      autoconnect: !1
    });
  }
  setupSocket() {
    this.isSetup || (this.rpcClient.on("open", () => {
      this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = null), this.connectionState = 2, this.rpcClient.socket.on(
        "message",
        this.onSocketMessage.bind(this)
      );
    }), this.rpcClient.on("close", () => {
      this.connectionState = 0;
    }), this.rpcClient.on("error", console.error), this.isSetup = !0);
  }
  // called for every message received from the node over websocket
  onSocketMessage(e) {
    const t = JSON.parse(e), r = t.params;
    if (t.method === pr) {
      if (Fa(r)) {
        const n = this.eventSubscriptions.get(r.subscription);
        n && n.onMessage(r.result);
      } else if (O(r, Cs)) {
        const n = this.eventSubscriptions.get(r.subscription);
        n && n.onMessage(r.result);
      }
    }
  }
  async connect() {
    return this.connectionPromise ? this.connectionPromise : this.connectionState === 2 ? Promise.resolve() : (this.setupSocket(), this.rpcClient.connect(), this.connectionState = 1, this.connectionPromise = new Promise((e, t) => {
      this.connectionTimeout = setTimeout(
        () => t(new Error("timeout")),
        this.options.connectTimeout
      ), this.rpcClient.once("open", () => {
        this.refreshSubscriptions(), this.connectionPromise = null, e();
      }), this.rpcClient.once("error", (r) => {
        this.connectionPromise = null, t(r);
      });
    }), this.connectionPromise);
  }
  /**
    call only upon reconnecting to a node over websocket.
    calling multiple times on the same connection will result
    in multiple message handlers firing each time
  */
  async refreshSubscriptions() {
    if (this.eventSubscriptions.size !== 0)
      try {
        let e = /* @__PURE__ */ new Map();
        (await Promise.all(
          Array.from(this.eventSubscriptions.values()).map(async (r) => {
            const n = r.onMessage, i = r.filter;
            return !i || !n ? Promise.resolve(null) : { id: await this.subscribeEvent(i, n), onMessage: n, filter: i };
          })
        )).forEach((r) => {
          if (r === null)
            return;
          const n = r.filter, i = r.onMessage;
          e.set(r.id, { filter: n, onMessage: i });
        }), this.eventSubscriptions = e;
      } catch (e) {
        throw new Error(`error refreshing event subscriptions: ${e}`);
      }
  }
  async subscribeEvent(e, t) {
    try {
      this.connectionState !== 2 && await this.connect();
      let r = await this.rpcClient.call(
        pr,
        [e],
        this.options.callTimeout
      );
      return this.eventSubscriptions.set(r, { filter: e, onMessage: t }), r;
    } catch (r) {
      throw new Error(
        `Error subscribing to event: ${JSON.stringify(
          r,
          null,
          2
        )}, filter: ${JSON.stringify(e)}`
      );
    }
  }
  async unsubscribeEvent(e) {
    try {
      this.connectionState !== 2 && await this.connect();
      let t = await this.rpcClient.call(
        Ja,
        [e],
        this.options.callTimeout
      );
      return this.eventSubscriptions.delete(e) || t;
    } catch (t) {
      throw new Error(
        `Error unsubscribing from event: ${t}, subscription: ${e}`
      );
    }
  }
};
async function Xa(e, t, r) {
  const n = await fetch(e, {
    method: "POST",
    body: JSON.stringify({
      FixedAmountRequest: {
        recipient: t
      }
    }),
    headers: {
      "Content-Type": "application/json",
      ...r || {}
    }
  });
  if (n.status === 429)
    throw new Ra(
      "Too many requests from this client have been sent to the faucet. Please retry later"
    );
  let i;
  try {
    i = await n.json();
  } catch (a) {
    throw new Error(
      `Encountered error when parsing response from faucet, error: ${a}, status ${n.status}, response ${n}`
    );
  }
  if (i.error)
    throw new Error(`Faucet returns error: ${i.error}`);
  return i;
}
var we, Kt = class {
  constructor(e) {
    We(this, we, void 0), Ze(this, we, e);
  }
  get fullnode() {
    return L(this, we).fullnode;
  }
  // TODO: Decide if we should default the websocket URL like this:
  get websocket() {
    return L(this, we).websocket || L(this, we).fullnode;
  }
  get faucet() {
    return L(this, we).faucet;
  }
};
we = /* @__PURE__ */ new WeakMap();
new Kt({
  fullnode: "http://127.0.0.1:9000",
  faucet: "http://127.0.0.1:9123/gas"
});
var qa = new Kt({
  fullnode: "https://fullnode.devnet.sui.io:443/",
  faucet: "https://faucet.devnet.sui.io/gas"
});
new Kt({
  fullnode: "https://fullnode.testnet.sui.io:443/",
  faucet: "https://faucet.testnet.sui.io/gas"
});
function Q(e, t) {
  return Qr(e, t);
}
var gt = Symbol("transaction-argument-type"), Ka = (e) => b([u({ None: p(null) }), u({ Some: e })]), He = u({
  kind: p("Input"),
  index: de(),
  value: I(Me()),
  type: I(b([p("pure"), p("object")]))
}), _t = [
  He,
  u({ kind: p("GasCoin") }),
  u({ kind: p("Result"), index: de() }),
  u({
    kind: p("NestedResult"),
    index: de(),
    resultIndex: de()
  })
], _a = b([..._t]), ve = b([..._t]);
ve[gt] = {
  kind: "object"
};
var pn = (e) => {
  const t = b([..._t]);
  return t[gt] = {
    kind: "pure",
    type: e
  }, t;
}, jn = u({
  kind: p("MoveCall"),
  target: $(
    "target",
    s().validator
  ),
  typeArguments: M(s()),
  arguments: M(_a)
}), Nn = u({
  kind: p("TransferObjects"),
  objects: M(ve),
  address: pn(N.ADDRESS)
}), Tn = u({
  kind: p("SplitCoins"),
  coin: ve,
  amounts: M(pn("u64"))
}), mn = u({
  kind: p("MergeCoins"),
  destination: ve,
  sources: M(ve)
}), wn = u({
  kind: p("MakeMoveVec"),
  type: I(Ka(s())),
  objects: M(ve)
}), Sn = u({
  kind: p("Publish"),
  modules: M(M(de())),
  dependencies: M(E)
}), Dn = u({
  kind: p("Upgrade"),
  modules: M(M(de())),
  dependencies: M(E),
  packageId: E,
  ticket: ve
}), En = [
  jn,
  Nn,
  Tn,
  mn,
  Sn,
  Dn,
  wn
], bn = b([...En]);
function $a(e) {
  return lt(e, bn), En.find((t) => O(e, t));
}
var he = {
  MoveCall(e) {
    return Q(
      {
        kind: "MoveCall",
        target: e.target,
        arguments: e.arguments ?? [],
        typeArguments: e.typeArguments ?? []
      },
      jn
    );
  },
  TransferObjects(e, t) {
    return Q(
      { kind: "TransferObjects", objects: e, address: t },
      Nn
    );
  },
  SplitCoins(e, t) {
    return Q({ kind: "SplitCoins", coin: e, amounts: t }, Tn);
  },
  MergeCoins(e, t) {
    return Q(
      { kind: "MergeCoins", destination: e, sources: t },
      mn
    );
  },
  Publish({
    modules: e,
    dependencies: t
  }) {
    return Q(
      {
        kind: "Publish",
        modules: e.map(
          (r) => typeof r == "string" ? Array.from(Le(r)) : r
        ),
        dependencies: t.map((r) => ge(r))
      },
      Sn
    );
  },
  Upgrade({
    modules: e,
    dependencies: t,
    packageId: r,
    ticket: n
  }) {
    return Q(
      {
        kind: "Upgrade",
        modules: e.map(
          (i) => typeof i == "string" ? Array.from(Le(i)) : i
        ),
        dependencies: t.map((i) => ge(i)),
        packageId: r,
        ticket: n
      },
      Dn
    );
  },
  MakeMoveVec({
    type: e,
    objects: t
  }) {
    return Q(
      {
        kind: "MakeMoveVec",
        type: e ? { Some: e } : { None: null },
        objects: t
      },
      wn
    );
  }
}, eo = /^vector<(.+)>$/, to = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/, Se = class {
  static parseFromStr(e, t = !1) {
    if (e === "address")
      return { address: null };
    if (e === "bool")
      return { bool: null };
    if (e === "u8")
      return { u8: null };
    if (e === "u16")
      return { u16: null };
    if (e === "u32")
      return { u32: null };
    if (e === "u64")
      return { u64: null };
    if (e === "u128")
      return { u128: null };
    if (e === "u256")
      return { u256: null };
    if (e === "signer")
      return { signer: null };
    const r = e.match(eo);
    if (r)
      return {
        vector: Se.parseFromStr(
          r[1],
          t
        )
      };
    const n = e.match(to);
    if (n)
      return {
        struct: {
          address: t ? B(n[1]) : n[1],
          module: n[2],
          name: n[3],
          typeParams: n[5] === void 0 ? [] : Se.parseStructTypeArgs(
            n[5],
            t
          )
        }
      };
    throw new Error(
      `Encountered unexpected token when parsing type args for ${e}`
    );
  }
  static parseStructTypeArgs(e, t = !1) {
    const r = [];
    let n = "", i = 0;
    for (let a = 0; a < e.length; a++) {
      const o = e[a];
      if (o === "<" && i++, o === ">" && i--, i === 0 && o === ",") {
        r.push(n.trim()), n = "";
        continue;
      }
      n += o;
    }
    return r.push(n.trim()), r.map(
      (a) => Se.parseFromStr(a, t)
    );
  }
  static tagToString(e) {
    if ("bool" in e)
      return "bool";
    if ("u8" in e)
      return "u8";
    if ("u16" in e)
      return "u16";
    if ("u32" in e)
      return "u32";
    if ("u64" in e)
      return "u64";
    if ("u128" in e)
      return "u128";
    if ("u256" in e)
      return "u256";
    if ("address" in e)
      return "address";
    if ("signer" in e)
      return "signer";
    if ("vector" in e)
      return `vector<${Se.tagToString(e.vector)}>`;
    if ("struct" in e) {
      const t = e.struct, r = t.typeParams.map(Se.tagToString).join(", ");
      return `${t.address}::${t.module}::${t.name}${r ? `<${r}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
}, Ln = "Argument", R = "vector", ro = "Option", no = "CallArg", jr = "TypeTag", io = "ProgrammableTransaction", wt = "ProgrammableMoveCall", Cn = "Transaction", $t = "EnumKind", so = [$t, Cn], oe = [$t, Ln], vn = "SimpleProgrammableMoveCall", ye = new N(sn).registerStructType(io, {
  inputs: [R, no],
  transactions: [R, so]
}).registerEnumType(Ln, {
  GasCoin: null,
  Input: { index: N.U16 },
  Result: { index: N.U16 },
  NestedResult: { index: N.U16, resultIndex: N.U16 }
}).registerStructType(wt, {
  package: N.ADDRESS,
  module: N.STRING,
  function: N.STRING,
  type_arguments: [R, jr],
  arguments: [R, oe]
}).registerEnumType(Cn, {
  /**
   * A Move Call - any public Move function can be called via
   * this transaction. The results can be used that instant to pass
   * into the next transaction.
   */
  MoveCall: vn,
  /**
   * Transfer vector of objects to a receiver.
   */
  TransferObjects: {
    objects: [R, oe],
    address: oe
  },
  /**
   * Split `amount` from a `coin`.
   */
  SplitCoins: { coin: oe, amounts: [R, oe] },
  /**
   * Merge Vector of Coins (`sources`) into a `destination`.
   */
  MergeCoins: { destination: oe, sources: [R, oe] },
  /**
   * Publish a Move module.
   */
  Publish: {
    modules: [R, [R, N.U8]],
    dependencies: [R, N.ADDRESS]
  },
  /**
   * Build a vector of objects using the input arguments.
   * It is impossible to construct a `vector<T: key>` otherwise,
   * so this call serves a utility function.
   */
  MakeMoveVec: {
    type: [ro, jr],
    objects: [R, oe]
  },
  /**  */
  Upgrade: {
    modules: [R, [R, N.U8]],
    dependencies: [R, N.ADDRESS],
    packageId: N.ADDRESS,
    ticket: oe
  }
});
ye.registerType(
  [$t, "T"],
  function(t, r, n, i) {
    const o = { [r.kind]: r }, [l] = n;
    return this.getTypeInterface(l)._encodeRaw.call(
      this,
      t,
      o,
      n,
      i
    );
  },
  function(t, r, n) {
    const [i] = r, a = this.getTypeInterface(i)._decodeRaw.call(
      this,
      t,
      r,
      n
    ), o = Object.keys(a)[0];
    return { kind: o, ...a[o] };
  },
  (e) => {
    if (typeof e != "object" && !("kind" in e))
      throw new Error(
        `EnumKind: Missing property "kind" in the input ${JSON.stringify(
          e
        )}`
      );
    return !0;
  }
);
ye.registerType(
  vn,
  function(t, r, n, i) {
    const [a, o, l] = r.target.split("::"), c = r.typeArguments.map(
      (g) => Se.parseFromStr(g, !0)
    );
    return this.getTypeInterface(wt)._encodeRaw.call(
      this,
      t,
      {
        package: B(a),
        module: o,
        function: l,
        type_arguments: c,
        arguments: r.arguments
      },
      n,
      i
    );
  },
  function(t, r, n) {
    let i = ye.getTypeInterface(wt)._decodeRaw.call(this, t, r, n);
    return {
      target: [i.package, i.module, i.function].join("::"),
      arguments: i.arguments,
      typeArguments: i.type_arguments.map(Se.tagToString)
    };
  },
  // Validation callback to error out if the data format is invalid.
  // TODO: make sure TypeTag can be parsed.
  (e) => e.target.split("::").length === 3
);
var ao = b([
  u({ ImmOrOwned: ne }),
  u({
    Shared: u({
      objectId: s(),
      initialSharedVersion: b([de(), s()]),
      mutable: x()
    })
  })
]), St = u({ Pure: M(de()) }), oo = u({ Object: ao }), Je = b([St, oo]), ue = {
  Pure(e, t) {
    return {
      Pure: Array.from(
        e instanceof Uint8Array ? e : ye.ser(t, e).toBytes()
      )
    };
  },
  ObjectRef({ objectId: e, digest: t, version: r }) {
    return {
      Object: {
        ImmOrOwned: {
          digest: t,
          version: r,
          objectId: B(e)
        }
      }
    };
  },
  SharedObjectRef({
    objectId: e,
    mutable: t,
    initialSharedVersion: r
  }) {
    return {
      Object: {
        Shared: {
          mutable: t,
          initialSharedVersion: r,
          objectId: B(e)
        }
      }
    };
  }
};
function Nr(e) {
  return typeof e == "string" ? B(e) : "ImmOrOwned" in e.Object ? B(e.Object.ImmOrOwned.objectId) : B(e.Object.Shared.objectId);
}
function co(e) {
  return typeof e == "object" && "Object" in e && "Shared" in e.Object ? e.Object.Shared : void 0;
}
function uo(e) {
  var t;
  return ((t = co(e)) == null ? void 0 : t.mutable) ?? !1;
}
var lo = "ascii", go = "String", Mo = "string", Ao = "String", ho = "option", Io = "Option", fo = {
  address: nn,
  module: ia,
  name: sa
}, yo = {
  address: Xt,
  module: lo,
  name: go
}, po = {
  address: Xt,
  module: Mo,
  name: Ao
}, jo = {
  address: Xt,
  module: ho,
  name: Io
}, nt = (e, t) => e.address === t.address && e.module === t.module && e.name === t.name;
function No(e) {
  var r;
  const t = (r = dn(e)) == null ? void 0 : r.Struct;
  return (t == null ? void 0 : t.address) === "0x2" && (t == null ? void 0 : t.module) === "tx_context" && (t == null ? void 0 : t.name) === "TxContext";
}
function At(e, t) {
  if (!(typeof t > "u") && typeof t !== e)
    throw new Error(
      `Expect ${t} to be ${e}, received ${typeof t}`
    );
}
var To = [
  "Address",
  "Bool",
  "U8",
  "U16",
  "U32",
  "U64",
  "U128",
  "U256"
];
function Dt(e, t) {
  if (typeof e == "string" && To.includes(e)) {
    if (e in ["U8", "U16", "U32", "U64", "U128", "U256"])
      At("number", t);
    else if (e === "Bool")
      At("boolean", t);
    else if (e === "Address" && (At("string", t), t && !fe(t)))
      throw new Error("Invalid Sui Address");
    return e.toLowerCase();
  } else if (typeof e == "string")
    throw new Error(
      `Unknown pure normalized type ${JSON.stringify(e, null, 2)}`
    );
  if ("Vector" in e) {
    if ((t === void 0 || typeof t == "string") && e.Vector === "U8")
      return "string";
    if (t !== void 0 && !Array.isArray(t))
      throw new Error(
        `Expect ${t} to be a array, received ${typeof t}`
      );
    const r = Dt(
      e.Vector,
      // undefined when argVal is empty
      t ? t[0] : void 0
    );
    return r === void 0 ? void 0 : `vector<${r}>`;
  }
  if ("Struct" in e) {
    if (nt(e.Struct, yo))
      return "string";
    if (nt(e.Struct, po))
      return "utf8string";
    if (nt(e.Struct, fo))
      return "address";
    if (nt(e.Struct, jo)) {
      const r = {
        Vector: e.Struct.typeArguments[0]
      };
      return Dt(r, t);
    }
  }
}
function mo(e, t) {
  const r = Array.from(`${e}::`).map((i) => i.charCodeAt(0)), n = new Uint8Array(r.length + t.length);
  return n.set(r), n.set(t, r.length), Gn(n, { dkLen: 32 });
}
var wo = I(
  v(
    b([
      u({ Epoch: de() }),
      u({ None: b([p(!0), p(null)]) })
    ])
  )
), xn = s(), Tr = $("StringEncodedBigint", (e) => {
  if (!["string", "number", "bigint"].includes(typeof e))
    return !1;
  try {
    return BigInt(e), !0;
  } catch {
    return !1;
  }
}), So = u({
  budget: I(Tr),
  price: I(Tr),
  payment: I(M(ne)),
  owner: I(xn)
}), it = u({
  version: p(1),
  sender: I(xn),
  expiration: wo,
  gasConfig: So,
  inputs: M(He),
  transactions: M(bn)
});
function mr(e) {
  return B(e).replace("0x", "");
}
var wr = 128 * 1024, pe = class {
  constructor(e) {
    this.version = 1, this.sender = e == null ? void 0 : e.sender, this.expiration = e == null ? void 0 : e.expiration, this.gasConfig = (e == null ? void 0 : e.gasConfig) ?? {}, this.inputs = (e == null ? void 0 : e.inputs) ?? [], this.transactions = (e == null ? void 0 : e.transactions) ?? [];
  }
  static fromKindBytes(e) {
    const t = ye.de("TransactionKind", e), r = t == null ? void 0 : t.ProgrammableTransaction;
    if (!r)
      throw new Error("Unable to deserialize from bytes.");
    const n = Q(
      {
        version: 1,
        gasConfig: {},
        inputs: r.inputs.map(
          (i, a) => Q(
            {
              kind: "Input",
              value: i,
              index: a,
              type: O(i, St) ? "pure" : "object"
            },
            He
          )
        ),
        transactions: r.transactions
      },
      it
    );
    return pe.restore(n);
  }
  static fromBytes(e) {
    var a;
    const t = ye.de("TransactionData", e), r = t == null ? void 0 : t.V1, n = (a = r == null ? void 0 : r.kind) == null ? void 0 : a.ProgrammableTransaction;
    if (!r || !n)
      throw new Error("Unable to deserialize from bytes.");
    const i = Q(
      {
        version: 1,
        sender: r.sender,
        expiration: r.expiration,
        gasConfig: r.gasData,
        inputs: n.inputs.map(
          (o, l) => Q(
            {
              kind: "Input",
              value: o,
              index: l,
              type: O(o, St) ? "pure" : "object"
            },
            He
          )
        ),
        transactions: n.transactions
      },
      it
    );
    return pe.restore(i);
  }
  static restore(e) {
    lt(e, it);
    const t = new pe();
    return Object.assign(t, e), t;
  }
  /**
   * Generate transaction digest.
   *
   * @param bytes BCS serialized transaction data
   * @returns transaction digest.
   */
  static getDigestFromBytes(e) {
    const t = mo("TransactionData", e);
    return Ut(t);
  }
  build({
    overrides: e,
    onlyTransactionKind: t
  } = {}) {
    const r = this.inputs.map((c) => (lt(c.value, Je), c.value)), n = {
      ProgrammableTransaction: {
        inputs: r,
        transactions: this.transactions
      }
    };
    if (t)
      return ye.ser("TransactionKind", n, { maxSize: wr }).toBytes();
    const i = (e == null ? void 0 : e.expiration) ?? this.expiration, a = (e == null ? void 0 : e.sender) ?? this.sender, o = { ...this.gasConfig, ...e == null ? void 0 : e.gasConfig };
    if (!a)
      throw new Error("Missing transaction sender");
    if (!o.budget)
      throw new Error("Missing gas budget");
    if (!o.payment)
      throw new Error("Missing gas payment");
    if (!o.price)
      throw new Error("Missing gas price");
    const l = {
      sender: mr(a),
      expiration: i || { None: !0 },
      gasData: {
        payment: o.payment,
        owner: mr(this.gasConfig.owner ?? a),
        price: BigInt(o.price),
        budget: BigInt(o.budget)
      },
      kind: {
        ProgrammableTransaction: {
          inputs: r,
          transactions: this.transactions
        }
      }
    };
    return ye.ser(
      "TransactionData",
      { V1: l },
      { maxSize: wr }
    ).toBytes();
  }
  getDigest() {
    const e = this.build({ onlyTransactionKind: !1 });
    return pe.getDigestFromBytes(e);
  }
  snapshot() {
    return Q(this, it);
  }
};
function Do(e) {
  const t = { kind: "Result", index: e }, r = [], n = (i) => r[i] ?? (r[i] = {
    kind: "NestedResult",
    index: e,
    resultIndex: i
  });
  return new Proxy(t, {
    set() {
      throw new Error(
        "The transaction result is a proxy, and does not support setting properties directly"
      );
    },
    // TODO: Instead of making this return a concrete argument, we should ideally
    // make it reference-based (so that this gets resolved at build-time), which
    // allows re-ordering transactions.
    get(i, a) {
      if (a in i)
        return Reflect.get(i, a);
      if (a === Symbol.iterator)
        return function* () {
          let l = 0;
          for (; ; )
            yield n(l), l++;
        };
      if (typeof a == "symbol")
        return;
      const o = parseInt(a, 10);
      if (!(Number.isNaN(o) || o < 0))
        return n(o);
    }
  });
}
function Fe(e) {
  if (!e)
    throw new Error(
      "No provider passed to Transaction#build, but transaction data was not sufficient to build offline."
    );
  return e;
}
var Sr = Symbol.for("@mysten/transaction"), Et = 256, Eo = 5e10, bo = 1000n, D, ct, bt, er, kn, ut, Lt, Ct = class {
  constructor(e) {
    We(this, ct), We(this, er), We(this, ut), We(this, D, void 0), Ze(this, D, new pe(
      e ? e.blockData : void 0
    ));
  }
  /** Returns `true` if the object is an instance of the Transaction builder class. */
  static is(e) {
    return !!e && typeof e == "object" && e[Sr] === !0;
  }
  /**
   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
   * Supports either a byte array, or base64-encoded bytes.
   */
  static fromKind(e) {
    const t = new Ct();
    return Ze(t, D, pe.fromKindBytes(
      typeof e == "string" ? Le(e) : e
    )), t;
  }
  /**
   * Converts from a serialized transaction format to a `Transaction` class.
   * There are two supported serialized formats:
   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
   * - A byte array (or base64-encoded bytes) containing BCS transaction data.
   */
  static from(e) {
    const t = new Ct();
    return typeof e != "string" || !e.startsWith("{") ? Ze(t, D, pe.fromBytes(
      typeof e == "string" ? Le(e) : e
    )) : Ze(t, D, pe.restore(
      JSON.parse(e)
    )), t;
  }
  /** A helper to retrieve the Transaction builder `Transactions` */
  static get Transactions() {
    return he;
  }
  /** A helper to retrieve the Transaction builder `Inputs` */
  static get Inputs() {
    return ue;
  }
  setSender(e) {
    L(this, D).sender = e;
  }
  /**
   * Sets the sender only if it has not already been set.
   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
   */
  setSenderIfNotSet(e) {
    L(this, D).sender || (L(this, D).sender = e);
  }
  setExpiration(e) {
    L(this, D).expiration = e;
  }
  setGasPrice(e) {
    L(this, D).gasConfig.price = String(e);
  }
  setGasBudget(e) {
    L(this, D).gasConfig.budget = String(e);
  }
  setGasOwner(e) {
    L(this, D).gasConfig.owner = e;
  }
  setGasPayment(e) {
    if (e.length >= Et)
      throw new Error(
        `Payment objects exceed maximum amount ${Et}`
      );
    L(this, D).gasConfig.payment = e.map(
      (t) => Yr(t, ne)
    );
  }
  /** Get a snapshot of the transaction data, in JSON form: */
  get blockData() {
    return L(this, D).snapshot();
  }
  // Used to brand transaction classes so that they can be identified, even between multiple copies
  // of the builder.
  get [Sr]() {
    return !0;
  }
  /** Returns an argument for the gas coin, to be used in a transaction. */
  get gas() {
    return { kind: "GasCoin" };
  }
  /**
   * Add a new object input to the transaction.
   */
  object(e) {
    const t = Nr(e);
    return L(this, D).inputs.find(
      (n) => n.type === "object" && t === Nr(n.value)
    ) ?? Ve(this, ct, bt).call(this, "object", e);
  }
  /**
   * Add a new object input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  objectRef(...e) {
    return this.object(ue.ObjectRef(...e));
  }
  /**
   * Add a new shared object input to the transaction using the fully-resolved shared object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  sharedObjectRef(...e) {
    return this.object(ue.SharedObjectRef(...e));
  }
  /**
   * Add a new non-object input to the transaction.
   */
  pure(e, t) {
    return Ve(this, ct, bt).call(this, "pure", e instanceof Uint8Array ? ue.Pure(e) : t ? ue.Pure(e, t) : e);
  }
  /** Add a transaction to the transaction block. */
  add(e) {
    const t = L(this, D).transactions.push(e);
    return Do(t - 1);
  }
  // Method shorthands:
  splitCoins(...e) {
    return this.add(he.SplitCoins(...e));
  }
  mergeCoins(...e) {
    return this.add(he.MergeCoins(...e));
  }
  publish(...e) {
    return this.add(he.Publish(...e));
  }
  upgrade(...e) {
    return this.add(he.Upgrade(...e));
  }
  moveCall(...e) {
    return this.add(he.MoveCall(...e));
  }
  transferObjects(...e) {
    return this.add(he.TransferObjects(...e));
  }
  makeMoveVec(...e) {
    return this.add(he.MakeMoveVec(...e));
  }
  /**
   * Serialize the transaction to a string so that it can be sent to a separate context.
   * This is different from `build` in that it does not serialize to BCS bytes, and instead
   * uses a separate format that is unique to the transaction builder. This allows
   * us to serialize partially-complete transactions, that can then be completed and
   * built in a separate context.
   *
   * For example, a dapp can construct a transaction, but not provide gas objects
   * or a gas budget. The transaction then can be sent to the wallet, where this
   * information is automatically filled in (e.g. by querying for coin objects
   * and performing a dry run).
   */
  serialize() {
    return JSON.stringify(L(this, D).snapshot());
  }
  /** Build the transaction to BCS bytes. */
  async build({
    provider: e,
    onlyTransactionKind: t
  } = {}) {
    return await Ve(this, ut, Lt).call(this, { provider: e, onlyTransactionKind: t }), L(this, D).build({ onlyTransactionKind: t });
  }
  /** Derive transaction digest */
  async getDigest({
    provider: e
  } = {}) {
    return await Ve(this, ut, Lt).call(this, { provider: e }), L(this, D).getDigest();
  }
}, Lo = Ct;
D = /* @__PURE__ */ new WeakMap();
ct = /* @__PURE__ */ new WeakSet();
bt = function(e, t) {
  const r = L(this, D).inputs.length, n = Q(
    {
      kind: "Input",
      // bigints can't be serialized to JSON, so just string-convert them here:
      value: typeof t == "bigint" ? String(t) : t,
      index: r,
      type: e
    },
    He
  );
  return L(this, D).inputs.push(n), n;
};
er = /* @__PURE__ */ new WeakSet();
kn = async function(e) {
  const t = L(this, D).gasConfig.owner ?? L(this, D).sender, n = (await Fe(e).getCoins({
    owner: t,
    coinType: aa
  })).data.filter((i) => !L(this, D).inputs.find((o) => O(o.value, Je) && "Object" in o.value && "ImmOrOwned" in o.value.Object ? i.coinObjectId === o.value.Object.ImmOrOwned.objectId : !1)).slice(0, Et - 1).map((i) => ({
    objectId: i.coinObjectId,
    digest: i.digest,
    version: i.version
  }));
  if (!n.length)
    throw new Error("No valid gas coins found for the transaction.");
  return n;
};
ut = /* @__PURE__ */ new WeakSet();
Lt = async function({ provider: e, onlyTransactionKind: t }) {
  if (!t && !L(this, D).sender)
    throw new Error("Missing transaction sender");
  const { inputs: r, transactions: n } = L(this, D), i = [], a = [];
  if (n.forEach((o) => {
    if (o.kind === "MoveCall") {
      o.arguments.some(
        (g) => g.kind === "Input" && !O(r[g.index].value, Je)
      ) && i.push(o);
      return;
    }
    const l = $a(o);
    l.schema && Object.entries(o).forEach(([c, g]) => {
      if (c === "kind")
        return;
      const d = l.schema[c], A = d.type === "array", j = A ? d.schema[gt] : d[gt];
      if (!j)
        return;
      const h = (y) => {
        const T = r[y];
        if (!T)
          throw new Error(`Missing input ${g.index}`);
        if (!O(T.value, Je))
          if (j.kind === "object" && typeof T.value == "string")
            a.push({ id: T.value, input: T });
          else if (j.kind === "pure")
            T.value = ue.Pure(T.value, j.type);
          else
            throw new Error("Unexpected input format.");
      };
      if (A)
        g.forEach((y) => {
          y.kind === "Input" && h(y.index);
        });
      else {
        if (g.kind !== "Input")
          return;
        h(g.index);
      }
    });
  }), i.length && await Promise.all(
    i.map(async (o) => {
      const [l, c, g] = o.target.split("::"), d = await Fe(
        e
      ).getNormalizedMoveFunction({
        package: ge(l),
        module: c,
        function: g
      }), j = d.parameters.length > 0 && No(d.parameters.at(-1)) ? d.parameters.slice(0, d.parameters.length - 1) : d.parameters;
      if (j.length !== o.arguments.length)
        throw new Error("Incorrect number of arguments.");
      j.forEach((h, y) => {
        const T = o.arguments[y];
        if (T.kind !== "Input")
          return;
        const f = r[T.index];
        if (O(f.value, Je))
          return;
        const S = f.value, C = Dt(h, S);
        if (C) {
          f.value = ue.Pure(S, C);
          return;
        }
        if (dn(h) != null || typeof h == "object" && "TypeParameter" in h) {
          if (typeof S != "string")
            throw new Error(
              `Expect the argument to be an object id string, got ${JSON.stringify(
                S,
                null,
                2
              )}`
            );
          a.push({
            id: S,
            input: f,
            normalizedType: h
          });
          return;
        }
        throw new Error(
          `Unknown call arg type ${JSON.stringify(
            h,
            null,
            2
          )} for value ${JSON.stringify(S, null, 2)}`
        );
      });
    })
  ), a.length) {
    const o = [...new Set(a.map(({ id: d }) => d))], l = await Fe(e).multiGetObjects({
      ids: o,
      options: { showOwner: !0 }
    });
    let c = new Map(
      o.map((d, A) => [d, l[A]])
    );
    const g = Array.from(c).filter(([d, A]) => A.error).map(([d, A]) => d);
    if (g.length)
      throw new Error(
        `The following input objects are not invalid: ${g.join(
          ", "
        )}`
      );
    a.forEach(({ id: d, input: A, normalizedType: j }) => {
      const h = c.get(d), y = Ss(h);
      if (y) {
        const T = uo(A.value) || j != null && gn(j) != null;
        A.value = ue.SharedObjectRef({
          objectId: d,
          initialSharedVersion: y,
          mutable: T
        });
      } else
        A.value = ue.ObjectRef(ms(h));
    });
  }
  if (!t && (L(this, D).gasConfig.price || this.setGasPrice(await Fe(e).getReferenceGasPrice()), L(this, D).gasConfig.payment || (L(this, D).gasConfig.payment = await Ve(this, er, kn).call(this, e)), !this.blockData.gasConfig.budget)) {
    const o = await Fe(
      e
    ).dryRunTransactionBlock({
      transactionBlock: L(this, D).build({
        overrides: {
          gasConfig: {
            budget: String(Eo),
            payment: []
          }
        }
      })
    });
    if (o.effects.status.status !== "success")
      throw new Error(
        `Dry run failed, could not automatically determine a budget: ${o.effects.status.error}`,
        { cause: o }
      );
    const l = bo * BigInt(this.blockData.gasConfig.price || 1n), c = BigInt(o.effects.gasUsed.computationCost) + l, g = c + BigInt(o.effects.gasUsed.storageCost) - BigInt(o.effects.gasUsed.storageRebate);
    this.setGasBudget(
      g > c ? g : c
    );
  }
};
var Co = u({
  currentTps: m(),
  tps30Days: m(),
  currentCheckpoint: s(),
  currentEpoch: s(),
  totalAddresses: s(),
  totalObjects: s(),
  totalPackages: s()
}), Dr = {
  socketOptions: yn,
  versionCacheTimeoutInSeconds: 600
}, vo = class {
  /**
   * Establish a connection to a Sui RPC endpoint
   *
   * @param connection The `Connection` object containing configuration for the network.
   * @param options configuration options for the provider
   */
  constructor(e = qa, t = Dr) {
    this.options = t, this.connection = e;
    const r = { ...Dr, ...t };
    this.options = r, this.client = r.rpcClient ?? new Ga(this.connection.fullnode), this.wsClient = r.websocketClient ?? new Ha(this.connection.websocket, r.socketOptions);
  }
  async getRpcApiVersion() {
    if (this.rpcApiVersion && this.cacheExpiry && this.cacheExpiry <= Date.now())
      return this.rpcApiVersion;
    try {
      const e = await this.client.requestWithType("rpc.discover", [], Me());
      return this.rpcApiVersion = e.info.version, this.cacheExpiry = // Date.now() is in milliseconds, but the timeout is in seconds
      Date.now() + (this.options.versionCacheTimeoutInSeconds ?? 0) * 1e3, this.rpcApiVersion;
    } catch (e) {
      console.warn("Error fetching version number of the RPC API", e);
    }
  }
  async requestSuiFromFaucet(e, t) {
    if (!this.connection.faucet)
      throw new Error("Faucet URL is not specified");
    return Xa(this.connection.faucet, e, t);
  }
  /**
   * Get all Coin<`coin_type`> objects owned by an address.
   */
  async getCoins(e) {
    if (!e.owner || !fe(B(e.owner)))
      throw new Error("Invalid Sui address");
    return await this.client.requestWithType(
      "suix_getCoins",
      [e.owner, e.coinType, e.cursor, e.limit],
      Ir
    );
  }
  /**
   * Get all Coin objects owned by an address.
   */
  async getAllCoins(e) {
    if (!e.owner || !fe(B(e.owner)))
      throw new Error("Invalid Sui address");
    return await this.client.requestWithType(
      "suix_getAllCoins",
      [e.owner, e.cursor, e.limit],
      Ir
    );
  }
  /**
   * Get the total coin balance for one coin type, owned by the address owner.
   */
  async getBalance(e) {
    if (!e.owner || !fe(B(e.owner)))
      throw new Error("Invalid Sui address");
    return await this.client.requestWithType(
      "suix_getBalance",
      [e.owner, e.coinType],
      fr
    );
  }
  /**
   * Get the total coin balance for all coin types, owned by the address owner.
   */
  async getAllBalances(e) {
    if (!e.owner || !fe(B(e.owner)))
      throw new Error("Invalid Sui address");
    return await this.client.requestWithType(
      "suix_getAllBalances",
      [e.owner],
      M(fr)
    );
  }
  /**
   * Fetch CoinMetadata for a given coin type
   */
  async getCoinMetadata(e) {
    return await this.client.requestWithType(
      "suix_getCoinMetadata",
      [e.coinType],
      oa
    );
  }
  /**
   *  Fetch total supply for a coin
   */
  async getTotalSupply(e) {
    return await this.client.requestWithType(
      "suix_getTotalSupply",
      [e.coinType],
      ba
    );
  }
  /**
   * Invoke any RPC method
   * @param method the method to be invoked
   * @param args the arguments to be passed to the RPC request
   */
  async call(e, t) {
    const r = await this.client.request(e, t);
    if (O(r, fn))
      throw new mt({
        req: { method: e, args: t },
        code: r.error.code,
        data: r.error.data,
        cause: new Error(r.error.message)
      });
    return r.result;
  }
  /**
   * Get Move function argument types like read, write and full access
   */
  async getMoveFunctionArgTypes(e) {
    return await this.client.requestWithType(
      "sui_getMoveFunctionArgTypes",
      [e.package, e.module, e.function],
      da
    );
  }
  /**
   * Get a map from module name to
   * structured representations of Move modules
   */
  async getNormalizedMoveModulesByPackage(e) {
    return await this.client.requestWithType(
      "sui_getNormalizedMoveModulesByPackage",
      [e.package],
      ya
    );
  }
  /**
   * Get a structured representation of Move module
   */
  async getNormalizedMoveModule(e) {
    return await this.client.requestWithType(
      "sui_getNormalizedMoveModule",
      [e.package, e.module],
      ln
    );
  }
  /**
   * Get a structured representation of Move function
   */
  async getNormalizedMoveFunction(e) {
    return await this.client.requestWithType(
      "sui_getNormalizedMoveFunction",
      [e.package, e.module, e.function],
      cn
    );
  }
  /**
   * Get a structured representation of Move struct
   */
  async getNormalizedMoveStruct(e) {
    return await this.client.requestWithType(
      "sui_getNormalizedMoveStruct",
      [e.package, e.module, e.struct],
      un
    );
  }
  /**
   * Get all objects owned by an address
   */
  async getOwnedObjects(e) {
    if (!e.owner || !fe(B(e.owner)))
      throw new Error("Invalid Sui address");
    return await this.client.requestWithType(
      "suix_getOwnedObjects",
      [
        e.owner,
        {
          filter: e.filter,
          options: e.options
        },
        e.cursor,
        e.limit
      ],
      Es
    );
  }
  /**
   * Get details about an object
   */
  async getObject(e) {
    if (!e.id || !tt(ge(e.id)))
      throw new Error("Invalid Sui Object id");
    return await this.client.requestWithType(
      "sui_getObject",
      [e.id, e.options],
      at
    );
  }
  /**
   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail
   */
  async multiGetObjects(e) {
    if (e.ids.forEach((r) => {
      if (!r || !tt(ge(r)))
        throw new Error(`Invalid Sui Object id ${r}`);
    }), e.ids.length !== new Set(e.ids).size)
      throw new Error(`Duplicate object ids in batch call ${e.ids}`);
    return await this.client.requestWithType(
      "sui_multiGetObjects",
      [e.ids, e.options],
      M(at)
    );
  }
  /**
   * Get transaction blocks for a given query criteria
   */
  async queryTransactionBlocks(e) {
    return await this.client.requestWithType(
      "suix_queryTransactionBlocks",
      [
        {
          filter: e.filter,
          options: e.options
        },
        e.cursor,
        e.limit,
        (e.order || "descending") === "descending"
      ],
      ra
    );
  }
  async getTransactionBlock(e) {
    if (!Mr(e.digest))
      throw new Error("Invalid Transaction digest");
    return await this.client.requestWithType(
      "sui_getTransactionBlock",
      [e.digest, e.options],
      ot
    );
  }
  async multiGetTransactionBlocks(e) {
    if (e.digests.forEach((r) => {
      if (!Mr(r))
        throw new Error(`Invalid Transaction digest ${r}`);
    }), e.digests.length !== new Set(e.digests).size)
      throw new Error(`Duplicate digests in batch call ${e.digests}`);
    return await this.client.requestWithType(
      "sui_multiGetTransactionBlocks",
      [e.digests, e.options],
      M(ot)
    );
  }
  async executeTransactionBlock(e) {
    return await this.client.requestWithType(
      "sui_executeTransactionBlock",
      [
        typeof e.transactionBlock == "string" ? e.transactionBlock : De(e.transactionBlock),
        Array.isArray(e.signature) ? e.signature : [e.signature],
        e.options,
        e.requestType
      ],
      ot
    );
  }
  /**
   * Get total number of transactions
   */
  async getTotalTransactionBlocks() {
    const e = await this.client.requestWithType(
      "sui_getTotalTransactionBlocks",
      [],
      s()
    );
    return BigInt(e);
  }
  /**
   * Getting the reference gas price for the network
   */
  async getReferenceGasPrice() {
    const e = await this.client.requestWithType(
      "suix_getReferenceGasPrice",
      [],
      s()
    );
    return BigInt(e);
  }
  /**
   * Return the delegated stakes for an address
   */
  async getStakes(e) {
    if (!e.owner || !fe(B(e.owner)))
      throw new Error("Invalid Sui address");
    return await this.client.requestWithType(
      "suix_getStakes",
      [e.owner],
      M(hr)
    );
  }
  /**
   * Return the delegated stakes queried by id.
   */
  async getStakesByIds(e) {
    return e.stakedSuiIds.forEach((t) => {
      if (!t || !tt(ge(t)))
        throw new Error(`Invalid Sui Stake id ${t}`);
    }), await this.client.requestWithType(
      "suix_getStakesByIds",
      [e.stakedSuiIds],
      M(hr)
    );
  }
  /**
   * Return the latest system state content.
   */
  async getLatestSuiSystemState() {
    return await this.client.requestWithType(
      "suix_getLatestSuiSystemState",
      [],
      Da
    );
  }
  /**
   * Get events for a given query criteria
   */
  async queryEvents(e) {
    return await this.client.requestWithType(
      "suix_queryEvents",
      [
        e.query,
        e.cursor,
        e.limit,
        (e.order || "descending") === "descending"
      ],
      bs
    );
  }
  /**
   * Subscribe to get notifications whenever an event matching the filter occurs
   */
  async subscribeEvent(e) {
    return this.wsClient.subscribeEvent(e.filter, e.onMessage);
  }
  /**
   * Unsubscribe from an event subscription
   */
  async unsubscribeEvent(e) {
    return this.wsClient.unsubscribeEvent(e.id);
  }
  /**
   * Runs the transaction block in dev-inspect mode. Which allows for nearly any
   * transaction (or Move call) with any arguments. Detailed results are
   * provided, including both the transaction effects and any return values.
   */
  async devInspectTransactionBlock(e) {
    let t;
    if (Lo.is(e.transactionBlock))
      e.transactionBlock.setSenderIfNotSet(e.sender), t = De(
        await e.transactionBlock.build({
          provider: this,
          onlyTransactionKind: !0
        })
      );
    else if (typeof e.transactionBlock == "string")
      t = e.transactionBlock;
    else if (e.transactionBlock instanceof Uint8Array)
      t = De(e.transactionBlock);
    else
      throw new Error("Unknown transaction block format.");
    return await this.client.requestWithType(
      "sui_devInspectTransactionBlock",
      [e.sender, t, e.gasPrice, e.epoch],
      Js
    );
  }
  /**
   * Dry run a transaction block and return the result.
   */
  async dryRunTransactionBlock(e) {
    return await this.client.requestWithType(
      "sui_dryRunTransactionBlock",
      [
        typeof e.transactionBlock == "string" ? e.transactionBlock : De(e.transactionBlock)
      ],
      na
    );
  }
  /**
   * Return the list of dynamic field objects owned by an object
   */
  async getDynamicFields(e) {
    if (!e.parentId || !tt(ge(e.parentId)))
      throw new Error("Invalid Sui Object id");
    return await this.client.requestWithType(
      "suix_getDynamicFields",
      [e.parentId, e.cursor, e.limit],
      Za
    );
  }
  /**
   * Return the dynamic field object information for a specified object
   */
  async getDynamicFieldObject(e) {
    return await this.client.requestWithType(
      "suix_getDynamicFieldObject",
      [e.parentId, e.name],
      at
    );
  }
  /**
   * Get the sequence number of the latest checkpoint that has been executed
   */
  async getLatestCheckpointSequenceNumber() {
    const e = await this.client.requestWithType(
      "sui_getLatestCheckpointSequenceNumber",
      [],
      s()
    );
    return String(e);
  }
  /**
   * Returns information about a given checkpoint
   */
  async getCheckpoint(e) {
    return await this.client.requestWithType(
      "sui_getCheckpoint",
      [e.id],
      In
    );
  }
  /**
   * Returns historical checkpoints paginated
   */
  async getCheckpoints(e) {
    const t = await this.getRpcApiVersion();
    return await this.client.requestWithType(
      "sui_getCheckpoints",
      [
        e.cursor,
        t && dr.lt(t, "0.32.0") ? String(e == null ? void 0 : e.limit) : e == null ? void 0 : e.limit,
        e.descendingOrder
      ],
      za
    );
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCommitteeInfo(e) {
    return await this.client.requestWithType(
      "suix_getCommitteeInfo",
      [e == null ? void 0 : e.epoch],
      Sa
    );
  }
  async getNetworkMetrics() {
    return await this.client.requestWithType(
      "suix_getNetworkMetrics",
      [],
      Co
    );
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getEpochs(e) {
    const t = await this.getRpcApiVersion();
    return await this.client.requestWithType(
      "suix_getEpochs",
      [
        e == null ? void 0 : e.cursor,
        t && dr.lt(t, "0.32.0") ? String(e == null ? void 0 : e.limit) : e == null ? void 0 : e.limit,
        e == null ? void 0 : e.descendingOrder
      ],
      Ca
    );
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCurrentEpoch() {
    return await this.client.requestWithType(
      "suix_getCurrentEpoch",
      [],
      An
    );
  }
  /**
   * Wait for a transaction block result to be available over the API.
   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to
   * be available via the API.
   * This currently polls the `getTransactionBlock` API to check for the transaction.
   */
  async waitForTransactionBlock({
    signal: e,
    timeout: t = 60 * 1e3,
    pollInterval: r = 2 * 1e3,
    ...n
  }) {
    const i = AbortSignal.timeout(t), a = new Promise((o, l) => {
      i.addEventListener(
        "abort",
        () => l(i.reason)
      );
    });
    for (; !i.aborted; ) {
      e == null || e.throwIfAborted();
      try {
        return await this.getTransactionBlock(n);
      } catch {
        await Promise.race([
          new Promise((l) => setTimeout(l, r)),
          a
        ]);
      }
    }
    throw i.throwIfAborted(), new Error("Unexpected error while waiting for transaction block.");
  }
};
ge("0x5");
var z;
(function(e) {
  e.SUI_WALLET = "Sui Wallet", e.SUIET_WALLET = "Suiet", e.ETHOS_WALLET = "Ethos Wallet", e.SURF_WALLET = "Surf Wallet", e.GLASS_WALLET = "GlassWallet", e.MORPHIS_WALLET = "Morphis Wallet", e.MARTIAN_WALLET = "Martian Sui Wallet", e.ONEKEY_WALLET = "OneKey Wallet", e.SPACECY_WALLET = "Spacecy Sui Wallet", e.NIGHTLY_WALLET = "Nightly Wallet", e.BITGET_WALLET = "Bitget Wallet", e.OKX_WALLET = "OKX Wallet", e.SUI_SNAP_WALLET = "Sui MetaMask Snap", e.PHANTOM_WALLET = "Phantom";
})(z || (z = {}));
const vt = {
  [z.BITGET_WALLET]: {
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgdmlld0JveD0iMCAwIDI1NiAyNTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8yMDM1XzExMDYpIj4KPHJlY3Qgd2lkdGg9IjI1NiIgaGVpZ2h0PSIyNTYiIGZpbGw9IiM1NEZGRjUiLz4KPGcgZmlsdGVyPSJ1cmwoI2ZpbHRlcjBfZl8yMDM1XzExMDYpIj4KPHBhdGggZD0iTTEzLjQ4MDYgMTk4LjYwNUMtMjkuMzI3NiAzMTkuMDQzIDE5OS42NjEgMjg1LjAyNyAzMTkuNTA3IDI1Mi45NjRDNDQyLjE2NSAyMTIuMjU5IDM1Ny4zODYgMzIuODI2OSAyNjkuNDE1IDI4Ljg1NThDMTgxLjQ0MyAyNC44ODQ3IDI4MC4zMjIgMTExLjgyNCAyMDUuNTk1IDEzNi42NTZDMTMwLjg2OCAxNjEuNDg3IDY2Ljk5MDcgNDguMDU4MyAxMy40ODA2IDE5OC42MDVaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIxX2ZfMjAzNV8xMTA2KSI+CjxwYXRoIGQ9Ik04NS41MTE4IC00NS44MjI1QzYzLjA1NjIgLTEwNy4xNzYgLTE2LjkxODkgLTIzLjk5NTMgLTU0LjA5OTUgMjUuMjY0M0MtODkuNTY1MiA3OC44NDc5IDMuMDA5MzcgMTI1LjE1MiAzOS4zMjA4IDEwMC4wMzdDNzUuNjMyMyA3NC45MjI3IDcuNzc0NDggNzAuMDM2MyAyOS4zNzA4IDM3LjM3ODVDNTAuOTY3MSA0LjcyMDc2IDExMy41ODEgMzAuODY5NSA4NS41MTE4IC00NS44MjI1WiIgZmlsbD0iIzAwRkZGMCIgZmlsbC1vcGFjaXR5PSIwLjY3Ii8+CjwvZz4KPGcgZmlsdGVyPSJ1cmwoI2ZpbHRlcjJfZl8yMDM1XzExMDYpIj4KPHBhdGggZD0iTTk2LjQ3OTYgMjI1LjQyNEM2NS44NTAyIDEyMi4zNjMgLTY2LjA4MTggMTc2LjYzNyAtMTI4LjIxOSAyMTYuNjU3Qy0xODcuOTkgMjY0LjA0MiAtNDYuMDcxMSA0MDAuMzQ4IDEyLjg3MjUgMzkzLjM3NkM3MS44MTYxIDM4Ni40MDMgLTM0LjQxMTggMzI3LjA2NSAxLjk4NzAyIDI5OC4xN0MzOC4zODU4IDI2OS4yNzYgMTM0Ljc2NiAzNTQuMjQ5IDk2LjQ3OTYgMjI1LjQyNFoiIGZpbGw9IiM5RDgxRkYiLz4KPC9nPgo8ZyBmaWx0ZXI9InVybCgjZmlsdGVyM19mXzIwMzVfMTEwNikiPgo8cGF0aCBkPSJNMjgyLjEyIC0xMDcuMzUzQzIxNi4wNDcgLTE4Ni4wMzEgMTIxLjQ2MyAtMTIwLjk3IDgyLjQyOTYgLTc4LjYwNDdDNDguMjczOSAtMzAuNjQ0NiAyMjQuMjc1IDU3LjIzMTIgMjczLjEyMSA0Mi4xNzE0QzMyMS45NjggMjcuMTExNSAyMDYuNTEyIC00LjA1MDM4IDIyNy4yOTcgLTMzLjI4NzlDMjQ4LjA4MiAtNjIuNTI1NSAzNjQuNzEyIC05LjAwNTY2IDI4Mi4xMiAtMTA3LjM1M1oiIGZpbGw9IiM0RDk0RkYiLz4KPC9nPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTkzLjE4OSAxNTIuODM2SDEzNi42NzRMODcuMjA4NiAxMDMuMDUxTDEzNy4zMSA1My4yNjYzTDE1MC45NTUgNDBIMTA1LjgxOUw0OC4zMzU5IDk3Ljc3NzNDNDUuNDM0OSAxMDAuNjg5IDQ1LjQ0OTggMTA1LjQwMiA0OC4zNjU2IDEwOC4yOTlMOTMuMTg5IDE1Mi44MzZaTTExOS4zMyAxMDMuMTY4SDExOC45OTVMMTE5LjMyNiAxMDMuMTY0TDExOS4zMyAxMDMuMTY4Wk0xMTkuMzMgMTAzLjE2OEwxNjguNzkxIDE1Mi45NDlMMTE4LjY5IDIwMi43MzRMMTA1LjA0NSAyMTZIMTUwLjE4TDIwNy42NjQgMTU4LjIyNkMyMTAuNTY1IDE1NS4zMTQgMjEwLjU1IDE1MC42MDIgMjA3LjYzNCAxNDcuNzA1TDE2Mi44MTEgMTAzLjE2OEgxMTkuMzNaIiBmaWxsPSJibGFjayIvPgo8L2c+CjxkZWZzPgo8ZmlsdGVyIGlkPSJmaWx0ZXIwX2ZfMjAzNV8xMTA2IiB4PSItOTAuMjQxMSIgeT0iLTY5LjczNjkiIHdpZHRoPSI1NjkuNTU4IiBoZWlnaHQ9IjQ1MS40MzEiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KPGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz4KPGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0ic2hhcGUiLz4KPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iNDkuMjMwOCIgcmVzdWx0PSJlZmZlY3QxX2ZvcmVncm91bmRCbHVyXzIwMzVfMTEwNiIvPgo8L2ZpbHRlcj4KPGZpbHRlciBpZD0iZmlsdGVyMV9mXzIwMzVfMTEwNiIgeD0iLTE2MC41MTEiIHk9Ii0xNjUuOTg3IiB3aWR0aD0iMzUxLjU5NiIgaGVpZ2h0PSIzNzEuNTA3IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBoaWMiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9InNoYXBlIi8+CjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjQ5LjIzMDgiIHJlc3VsdD0iZWZmZWN0MV9mb3JlZ3JvdW5kQmx1cl8yMDM1XzExMDYiLz4KPC9maWx0ZXI+CjxmaWx0ZXIgaWQ9ImZpbHRlcjJfZl8yMDM1XzExMDYiIHg9Ii0yNDEuMDc4IiB5PSI2Ny42NDIiIHdpZHRoPSI0NDQuODUxIiBoZWlnaHQ9IjQyNC40NTIiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KPGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz4KPGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0ic2hhcGUiLz4KPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iNDkuMjMwOCIgcmVzdWx0PSJlZmZlY3QxX2ZvcmVncm91bmRCbHVyXzIwMzVfMTEwNiIvPgo8L2ZpbHRlcj4KPGZpbHRlciBpZD0iZmlsdGVyM19mXzIwMzVfMTEwNiIgeD0iLTIwLjM5NjgiIHk9Ii0yNDIuNzU4IiB3aWR0aD0iNDMwLjE5MSIgaGVpZ2h0PSIzODUuMTA1IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBoaWMiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9InNoYXBlIi8+CjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjQ5LjIzMDgiIHJlc3VsdD0iZWZmZWN0MV9mb3JlZ3JvdW5kQmx1cl8yMDM1XzExMDYiLz4KPC9maWx0ZXI+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMjAzNV8xMTA2Ij4KPHJlY3Qgd2lkdGg9IjI1NiIgaGVpZ2h0PSIyNTYiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==",
    url: "https://chrome.google.com/webstore/detail/bitkeep-crypto-nft-wallet/jiidiaalihmmhddjgbnbgdfflelocpak"
  },
  [z.SUIET_WALLET]: {
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iMTYiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xNzA4XzI4Mjk3KSIvPjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfMTcwOF8yODI5NykiIGZpbGw9IiNmZmYiPjxwYXRoIGQ9Ik0yMi44IDIwYy0xLjQgMC0yLjctMS40LTMuMy0yLjMtLjcuOS0yIDIuMy0zLjQgMi4zcy0yLjctMS40LTMuNC0yLjNjLS42LjktMS45IDIuMy0zLjMgMi4zLS4zIDAtLjUtLjItLjUtLjVzLjItLjUuNS0uNWMxLjEgMCAyLjYtMS45IDIuOS0yLjVsLjUtLjJjLjIgMCAuMyAwIC40LjIuNC42IDEuOCAyLjUgMi45IDIuNSAxLjEgMCAyLjUtMS45IDIuOS0yLjVsLjQtLjJjLjIgMCAuNCAwIC41LjIuNC42IDEuOCAyLjUgMi45IDIuNS4yIDAgLjUuMi41LjVzLS4yLjUtLjUuNXoiLz48cGF0aCBkPSJNMjIuOCAyMy4zYy0xLjQgMC0yLjctMS4zLTMuMy0yLjMtLjcgMS0yIDIuMy0zLjQgMi4zUzEzLjQgMjIgMTIuNyAyMWMtLjYgMS0xLjkgMi4zLTMuMyAyLjMtLjMgMC0uNS0uMy0uNS0uNSAwLS4zLjItLjYuNS0uNiAxLjEgMCAyLjYtMS44IDIuOS0yLjRsLjUtLjIuNC4yYy40LjYgMS44IDIuNCAyLjkgMi40IDEuMSAwIDIuNS0xLjggMi45LTIuNGwuNC0uMi41LjJjLjQuNiAxLjggMi40IDIuOSAyLjQuMiAwIC41LjMuNS42IDAgLjItLjIuNS0uNS41ek05LjggMTYuN2MtLjMgMC0uNS0uMi0uNS0uNEw5LjEgMTVjMC0zLjkgMy4yLTcgNy03IDMuOSAwIDcgMy4xIDcgN2wtLjEgMS4yYzAgLjMtLjMuNS0uNi41LS40LS4xLS41LS4zLS40LS43di0xYzAtMy4zLTIuNi02LTUuOS02LTMuMiAwLTUuOSAyLjctNS45IDZsLjEgMWMuMS40LS4xLjctLjQuN2gtLjF6Ii8+PC9nPjxkZWZzPjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZF8xNzA4XzI4Mjk3IiB4PSI0LjkiIHk9IjYiIHdpZHRoPSIyMi40MzciIGhlaWdodD0iMjMuMzE5IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+PGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz48ZmVDb2xvck1hdHJpeCBpbj0iU291cmNlQWxwaGEiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAiIHJlc3VsdD0iaGFyZEFscGhhIi8+PGZlT2Zmc2V0IGR5PSIyIi8+PGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIvPjxmZUNvbXBvc2l0ZSBpbjI9ImhhcmRBbHBoYSIgb3BlcmF0b3I9Im91dCIvPjxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwLjE3NTY5NCAwIDAgMCAwIDAuNTc0MTQyIDAgMCAwIDAgMC45MTY2NjcgMCAwIDAgMSAwIi8+PGZlQmxlbmQgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0iZWZmZWN0MV9kcm9wU2hhZG93XzE3MDhfMjgyOTciLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJlZmZlY3QxX2Ryb3BTaGFkb3dfMTcwOF8yODI5NyIgcmVzdWx0PSJzaGFwZSIvPjwvZmlsdGVyPjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xNzA4XzI4Mjk3IiB5MT0iNCIgeDI9IjI4Ljg4OSIgeTI9IjMyIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iIzNFQTJGOCIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzY3QzhGRiIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjwvc3ZnPg==",
    url: "https://chrome.google.com/webstore/detail/suiet/khpkpbbcccdmmclmpigdgddabeilkdpd"
  },
  [z.SUI_WALLET]: {
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAIVBMVEUAAAD////////9/f39/f3+/v7x+Pz///95wfGj1PXI5fgEMJeQAAAAB3RSTlMAECNgmNr40ET05wAAAOBJREFUeNplUksOgjAQbYw38LdloQdw5VZJDGuNiWtXdGvUFjlAtT2AVC4AekrLvKKYvoTMm5fpfGGswWCdit2cfTFNZYO49YfSYwW/t2+FS0TCTH6x/Q/wISPZwcYJSVc4uxdg1wI2Yn0QbmCXbAKin7AHtiCbq6wicvI5syK/+azowlZSoxNGc4l7IWswhqKlagtD4Kl9CAWBAmspbGHwhJK+HDMlkiaIcJ9BWWqMu64yhcbGVMU5nKoc/XC2fGs/HMbPra78+MGCwhUGSw7OEB4qOKU7Nrki/p2/8zt8ABpiv63tyiOHAAAAAElFTkSuQmCC",
    url: "https://chrome.google.com/webstore/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil"
  },
  [z.ETHOS_WALLET]: {
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2aWV3Qm94PSIwIDAgMTIwMCAxMjAwIiB3aWR0aD0iMTIwMCIgaGVpZ2h0PSIxMjAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxyZWN0IGZpbGw9IiMxQTFDMjYiIHg9IjAiIHk9IjAiIHdpZHRoPSIxMjAwIiBoZWlnaHQ9IjEyMDAiIHJ4PSIyMDAiIHJ5PSIyMDAiLz4KICA8cGF0aCBkPSJNMzcwLjI1NyAzNDMuMjIxSDcyNS4xOUM3NTQuMDE5IDM0My4yMjEgNzc3LjM4OCAzNjYuOTM4IDc3Ny4zODggMzk2LjE5NFY4MDcuNzJDNzc3LjM4OCA4MzYuOTc4IDc1NC4wMTggODYwLjY5NCA3MjUuMTkgODYwLjY5NEgzNzAuMjU2QzM0MS40MjggODYwLjY5NCAzMTguMDU4IDgzNi45NzggMzE4LjA1OCA4MDcuNzJWMzk2LjE5NEMzMTguMDU4IDM2Ni45MzggMzQxLjQyOCAzNDMuMjIxIDM3MC4yNTcgMzQzLjIyMVoiIGZpbGw9IiNEN0I4RkYiLz4KICA8cGF0aCBkPSJNMzc3LjM3NiAzNDcuMjI3TDYyNy42NzQgNDY1LjQyM0M2NDIuNCA0NzIuMzc3IDY1MS44MTYgNDg3LjM2NCA2NTEuODE2IDUwMy44NDZWOTMwLjI5MkM2NTEuODE2IDk2MC45NTcgNjIwLjcxNiA5ODEuNDcxIDU5My4xMDIgOTY5LjAyTDM0Mi44MDQgODU2LjE2MUMzMjcuNzIxIDg0OS4zNjEgMzE4IDgzNC4xODMgMzE4IDgxNy40MzNWMzg1LjY1QzMxOCAzNTQuNjY1IDM0OS42OTUgMzM0LjE1NSAzNzcuMzc2IDM0Ny4yMjdaIiBmaWxsPSIjOUE0MkZGIi8+CiAgPHBhdGggZD0iTTg1NC45MTYgMTk2TDg2MC4xNDMgMjEwLjEyNUM4NzIuNDU1IDI0My40IDg5OC42OTEgMjY5LjYzNSA5MzEuOTY2IDI4MS45NDhMOTQ2LjA5MSAyODcuMTc1TDkzMS45NjYgMjkyLjQwMUM4OTguNjkxIDMwNC43MTQgODcyLjQ1NSAzMzAuOTUgODYwLjE0MyAzNjQuMjI1TDg1NC45MTYgMzc4LjM0OUw4NDkuNjg5IDM2NC4yMjVDODM3LjM3NiAzMzAuOTUgODExLjE0MSAzMDQuNzE0IDc3Ny44NjYgMjkyLjQwMUw3NjMuNzQxIDI4Ny4xNzVMNzc3Ljg2NiAyODEuOTQ4QzgxMS4xNDEgMjY5LjYzNSA4MzcuMzc2IDI0My40IDg0OS42ODkgMjEwLjEyNUw4NTQuOTE2IDE5NloiIGZpbGw9IiM5QTQyRkYiLz4KPC9zdmc+",
    url: "https://chrome.google.com/webstore/detail/ethos-sui-wallet/mcbigmjiafegjnnogedioegffbooigli"
  },
  [z.MARTIAN_WALLET]: {
    icon: "https://cdn.martianwallet.xyz/assets/icon.png",
    url: "https://chrome.google.com/webstore/detail/martian-wallet-aptos-sui/efbglgofoippbgcjepnhiblaibcnclgk"
  },
  [z.SURF_WALLET]: {
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNNDcwIDQwMGMtMTEgOC0yMyAxNC0zNSAxNS00NyA0LTEwNi00Mi0xNDQtNDdzLTYwIDIxLTY5IDM2Yy01IDktNiAyMi02IDMzIDAgNCAwIDkgMiAxNSAyIDExIDMwIDU1IDk0IDQ5IDY5LTYgMTA5LTQzIDE1MC05Mmw2LTYgMi0zeiIgZmlsbD0iIzU4QzVGMyIvPjxwYXRoIGQ9Ik0yNTQgMzI3YzExLTYgMjItMTEgMzMtMTEgNDIgMCA5MiA0NiAxMjUgNTMgMzQgNyA1Ni0xNSA2NC0yNyA3LTEyIDgtMjMgOC0zMWwtMS0xMmMtMi03LTIyLTUwLTc5LTUwLTYzIDAtMTAyIDMwLTE0MiA3MGwtNSA1LTMgM3oiIGZpbGw9IiM5REUyRkYiLz48cGF0aCBkPSJNMzMgMjk2djJjMCA1OCA0NyAxMDMgMTA0IDEwMyAyNCAwIDQ1LTcgNjMtMjFsMS0xIDEtMSAxLTF2LTFsMTEtMTAgNDAtMzkgMy0yIDUtNmM0MC00MCA3OS03MCAxNDEtNzAgNTggMCA3NyA0MyA4MCA1MS01LTk5LTc1LTE4MS0xNjgtMjA2bC0zLTFjLTEwLTItMzYtMTItMzYtMjdWMThzMi0xMy0xMi00Yy0zNiAyNC02NyA3Ni05NSA5MS02OSAzMC0xMjAgOTAtMTM0IDE2NmwtMiAxOXY2eiIgZmlsbD0iIzU4QzVGMyIvPjxwYXRoIGQ9Ik0yNTUgMjcxbC00MyAzNi00NCAzOGMtNiA2LTE1IDQtMTgtN3MzLTUyIDM0LTcyIDYyLTIwIDc0LTEzYzkgNyA2IDExIDQgMTNsLTcgNXoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=",
    url: "https://chrome.google.com/webstore/detail/surf-sui-wallet/emeeapjkbcbpbpgaagfchmcgglmebnen"
  },
  [z.GLASS_WALLET]: {
    icon: "data:image/png;base64,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",
    url: "https://chrome.google.com/webstore/detail/glass-wallet-sui-wallet/loinekcabhlmhjjbocijdoimmejangoa"
  },
  [z.MORPHIS_WALLET]: {
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiByeD0iNSIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xOS45NCA3LjRsLS4wMS0uMDhWNy4zYy0uMDEtLjAyLS4wMS0uMDQtLjAzLS4wNSAwLS4wMy0uMDItLjA1LS4wMy0uMDdsLS4wMS0uMDEtLjA2LS4wNS0uMDQtLjAyLTUuMDUtMy4wNWgtLjAxbC0uMDMtLjAxLS4wNC0uMDEtLjAzLS4wMi0uMDQtLjAxaC0uMDdsLS4wNC4wMS0uMDQuMDItLjAzLjAxLS4wNC4wMWgtLjAxTDkuMjkgNy4xIDQuMiAxMC4xM2wtLjA2LjAzLS4wMS4wMi0uMDUuMDUtLjAzLjA1LS4wMS4wMS0uMDMuMDYtLjAxLjA3djYuMTJjMCAuMTYuMDcuMjkuMi4zNmw1LjA1IDMuMDVjLjA1LjA0LjEzLjA1LjIuMDUuMDggMCAuMTQtLjAxLjIxLS4wNS4xMi0uMDguMi0uMjEuMi0uMzd2LTUuMzdsNC40NiAyLjY5Yy4wNi4wMy4xMy4wNC4yLjA0LjA4IDAgLjEzLS4wMS4yMS0uMDQuMTItLjA4LjItLjIyLjItLjM3di01LjM3bDQuNDYgMi42OGMuMDYuMDMuMTMuMDUuMjEuMDUuMDYgMCAuMTItLjAyLjItLjA1LjEyLS4wOC4yLS4yMi4yLS4zN1Y3LjM4Yy0uMDYuMDUtLjA2LjAyLS4wNi4wMnptLTEwLjUgNS42NEw1LjIgMTAuNDhsNC4yNC0yLjU3IDQuMjYgMi41Ny00LjI2IDIuNTZ6TTE0LjUgMTBsLTQuMjUtMi41NyA0LjI1LTIuNTYgNC4yNSAyLjU2TDE0LjUgMTB6bS01LjQ2IDguOUw0LjggMTYuMzNWMTEuMmw0LjI0IDIuNTZ2NS4xNHptMS4yMS01LjM3bDMuODUtMi4zM3Y0LjY1bC0zLjg1LTIuMzJ6bTUuMDUtMy4wM2wzLjg1LTIuMzR2NC42NGwtMy44NS0yLjN6IiBmaWxsPSIjMDAwIi8+PC9zdmc+",
    url: "https://chrome.google.com/webstore/detail/morphis-wallet/heefohaffomkkkphnlpohglngmbcclhi"
  },
  [z.ONEKEY_WALLET]: {
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF80NTkyMl84OCkiPgo8cGF0aCBkPSJNMTI3LjYxIDYzLjgwNDlDMTI3LjYxIDEwNy44NTMgMTA3Ljg1MyAxMjcuNjEgNjMuODA0OSAxMjcuNjFDMTkuNzU2OCAxMjcuNjEgMCAxMDcuODUzIDAgNjMuODA0OUMwIDE5Ljc1NjggMTkuNzU2OCAwIDYzLjgwNDkgMEMxMDcuODUzIDAgMTI3LjYxIDE5Ljc1NjggMTI3LjYxIDYzLjgwNDlaIiBmaWxsPSIjM0JEMjNEIi8+CjxwYXRoIGQ9Ik02OS41Njk5IDI3LjA1NTdMNTEuODE5NyAyNy4wNTU3TDQ4LjcwNTYgMzYuNDcxOUg1OC41NjQ1TDU4LjU2NDUgNTYuMzA2M0g2OS41Njk5VjI3LjA1NTdaIiBmaWxsPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTg0LjA0ODYgODAuMzExMUM4NC4wNDg2IDkxLjQ5MTIgNzQuOTg1NCAxMDAuNTU0IDYzLjgwNTMgMTAwLjU1NEM1Mi42MjUzIDEwMC41NTQgNDMuNTYyMSA5MS40OTEyIDQzLjU2MjEgODAuMzExMUM0My41NjIxIDY5LjEzMTEgNTIuNjI1MyA2MC4wNjc4IDYzLjgwNTMgNjAuMDY3OEM3NC45ODU0IDYwLjA2NzggODQuMDQ4NiA2OS4xMzExIDg0LjA0ODYgODAuMzExMVpNNzQuODU4NCA4MC4zMTExQzc0Ljg1ODQgODYuNDE1NSA2OS45MDk3IDkxLjM2NDEgNjMuODA1MyA5MS4zNjQxQzU3LjcwMDggOTEuMzY0MSA1Mi43NTIyIDg2LjQxNTUgNTIuNzUyMiA4MC4zMTExQzUyLjc1MjIgNzQuMjA2NiA1Ny43MDA4IDY5LjI1OCA2My44MDUzIDY5LjI1OEM2OS45MDk3IDY5LjI1OCA3NC44NTg0IDc0LjIwNjYgNzQuODU4NCA4MC4zMTExWiIgZmlsbD0iYmxhY2siLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF80NTkyMl84OCI+CjxyZWN0IHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
    url: "https://chrome.google.com/webstore/detail/onekey/jnmbobjmhlngoefaiojfljckilhhlhcj"
  },
  [z.SPACECY_WALLET]: {
    icon: "https://spacecywallet.com/favicon.ico",
    url: "https://chrome.google.com/webstore/detail/spacecy-wallet/mkchoaaiifodcflmbaphdgeidocajadp?hl=en-US"
  },
  [z.NIGHTLY_WALLET]: {
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAxIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDIwMSAyMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0wLjM5MDYyNSAxMDBDMC4zOTA2MjUgNDQuNzcxNSA0NS4xNjIyIDAgMTAwLjM5MSAwQzE1NS42MTkgMCAyMDAuMzkxIDQ0Ljc3MTUgMjAwLjM5MSAxMDBDMjAwLjM5MSAxNTUuMjI4IDE1NS42MTkgMjAwIDEwMC4zOTEgMjAwQzQ1LjE2MjIgMjAwIDAuMzkwNjI1IDE1NS4yMjggMC4zOTA2MjUgMTAwWiIgZmlsbD0iIzYwNjdGOSIvPgo8cGF0aCBkPSJNMTQ2LjgzOCA0MEMxMzguMDU0IDUyLjI2MDcgMTI3LjA2MSA2MC43NjM0IDExNC4wNzIgNjYuNDQ3NEMxMDkuNTYzIDY1LjIwMjYgMTA0LjkzNiA2NC41Njg0IDEwMC4zNzkgNjQuNjE1NEM5NS44MjIzIDY0LjU2ODQgOTEuMTk1MSA2NS4yMjYxIDg2LjY4NTUgNjYuNDQ3NEM3My42OTY2IDYwLjczOTkgNjIuNzA0MiA1Mi4yODQyIDUzLjkxOTggNDBDNTEuMjY1NiA0Ni42NzA2IDQxLjA0ODMgNjkuNjg4OCA1My4zMDkxIDEwMS44NjdDNTMuMzA5MSAxMDEuODY3IDQ5LjM4NjYgMTE4LjY2MSA1Ni41OTc0IDEzMy4wODNDNTYuNTk3NCAxMzMuMDgzIDY3LjAyNiAxMjguMzYyIDc1LjMxNzMgMTM1LjAwOUM4My45ODQzIDE0Mi4wMzIgODEuMjEyOCAxNDguNzk2IDg3LjMxOTYgMTU0LjYyMUM5Mi41ODA5IDE2MCAxMDAuNDAyIDE2MCAxMDAuNDAyIDE2MEMxMDAuNDAyIDE2MCAxMDguMjI0IDE2MCAxMTMuNDg1IDE1NC42NDVDMTE5LjU5MiAxNDguODQzIDExNi44NDQgMTQyLjA3OSAxMjUuNDg4IDEzNS4wMzJDMTMzLjc1NSAxMjguMzg1IDE0NC4yMDcgMTMzLjEwNiAxNDQuMjA3IDEzMy4xMDZDMTUxLjM5NSAxMTguNjg1IDE0Ny40OTYgMTAxLjg5MSAxNDcuNDk2IDEwMS44OTFDMTU5LjcxIDY5LjY4ODggMTQ5LjUxNiA0Ni42NzA2IDE0Ni44MzggNDBaTTU5LjgzODcgOTcuNDI4MUM1My4xNjgxIDgzLjczNDYgNTEuMzM2MSA2NC45NDQyIDU1LjU0MDQgNTAuMDk5OEM2MS4xMDcxIDY0LjE5MjYgNjguNjcwMiA3MC41MTA5IDc3LjY2NjEgNzcuMTgxNEM3My44NjEgODUuMDk2OSA2Ni42OTcyIDkyLjU2NjEgNTkuODM4NyA5Ny40MjgxWk03OS4wMjg0IDEyMS41NUM3My43NjcxIDExOS4yMjUgNzIuNjYzMSAxMTQuNjQ1IDcyLjY2MzEgMTE0LjY0NUM3OS44MjcgMTEwLjEzNSA5MC4zNzMxIDExMy41ODggOTAuNzAxOSAxMjQuMjUxQzg1LjE1ODcgMTIwLjg5MyA4My4zMDMyIDEyMy40MDYgNzkuMDI4NCAxMjEuNTVaTTEwMC4zNzkgMTU5LjQxM0M5Ni42MjA5IDE1OS40MTMgOTMuNTY3NCAxNTYuNzEyIDkzLjU2NzQgMTUzLjRDOTMuNTY3NCAxNTAuMDg4IDk2LjYyMDkgMTQ3LjM4NyAxMDAuMzc5IDE0Ny4zODdDMTA0LjEzNyAxNDcuMzg3IDEwNy4xOSAxNTAuMDg4IDEwNy4xOSAxNTMuNEMxMDcuMTkgMTU2LjczNSAxMDQuMTM3IDE1OS40MTMgMTAwLjM3OSAxNTkuNDEzWk0xMjEuNzUzIDEyMS41NUMxMTcuNDc4IDEyMy40MjkgMTE1LjY0NiAxMjAuODkzIDExMC4wNzkgMTI0LjI1MUMxMTAuNDMyIDExMy41ODggMTIwLjkzMSAxMTAuMTM1IDEyOC4xMTggMTE0LjY0NUMxMjguMTE4IDExNC42MjEgMTI2Ljk5MSAxMTkuMjI1IDEyMS43NTMgMTIxLjU1Wk0xNDAuOTE5IDk3LjQyODFDMTM0LjA4NCA5Mi41NjYxIDEyNi44OTcgODUuMTIwNCAxMjMuMDY4IDc3LjE4MTRDMTMyLjA2NCA3MC41MTA5IDEzOS42NTEgNjQuMTY5MSAxNDUuMTk0IDUwLjA5OThDMTQ5LjQ0NSA2NC45NDQyIDE0Ny42MTMgODMuNzU4MSAxNDAuOTE5IDk3LjQyODFaIiBmaWxsPSIjRjdGN0Y3Ii8+Cjwvc3ZnPgo=",
    url: "https://nightly.app"
  },
  [z.OKX_WALLET]: {
    icon: "data:image/png;base64,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",
    url: "https://okx.com/web3"
  },
  [z.SUI_SNAP_WALLET]: {
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbDpzcGFjZT0icHJlc2VydmUiIGlkPSJMYXllcl8xIiB4PSIwIiB5PSIwIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAzMTguNiAzMTguNiI+CiAgPHN0eWxlPgogICAgLnN0MSwuc3Q2e2ZpbGw6I2U0NzYxYjtzdHJva2U6I2U0NzYxYjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmR9LnN0NntmaWxsOiNmNjg1MWI7c3Ryb2tlOiNmNjg1MWJ9CiAgPC9zdHlsZT4KICA8cGF0aCBmaWxsPSIjZTI3NjFiIiBzdHJva2U9IiNlMjc2MWIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0ibTI3NC4xIDM1LjUtOTkuNSA3My45TDE5MyA2NS44eiIvPgogIDxwYXRoIGQ9Im00NC40IDM1LjUgOTguNyA3NC42LTE3LjUtNDQuM3ptMTkzLjkgMTcxLjMtMjYuNSA0MC42IDU2LjcgMTUuNiAxNi4zLTU1LjN6bS0yMDQuNC45TDUwLjEgMjYzbDU2LjctMTUuNi0yNi41LTQwLjZ6IiBjbGFzcz0ic3QxIi8+CiAgPHBhdGggZD0ibTEwMy42IDEzOC4yLTE1LjggMjMuOSA1Ni4zIDIuNS0yLTYwLjV6bTExMS4zIDAtMzktMzQuOC0xLjMgNjEuMiA1Ni4yLTIuNXpNMTA2LjggMjQ3LjRsMzMuOC0xNi41LTI5LjItMjIuOHptNzEuMS0xNi41IDMzLjkgMTYuNS00LjctMzkuM3oiIGNsYXNzPSJzdDEiLz4KICA8cGF0aCBmaWxsPSIjZDdjMWIzIiBzdHJva2U9IiNkN2MxYjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0ibTIxMS44IDI0Ny40LTMzLjktMTYuNSAyLjcgMjIuMS0uMyA5LjN6bS0xMDUgMCAzMS41IDE0LjktLjItOS4zIDIuNS0yMi4xeiIvPgogIDxwYXRoIGZpbGw9IiMyMzM0NDciIHN0cm9rZT0iIzIzMzQ0NyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBkPSJtMTM4LjggMTkzLjUtMjguMi04LjMgMTkuOS05LjF6bTQwLjkgMCA4LjMtMTcuNCAyMCA5LjF6Ii8+CiAgPHBhdGggZmlsbD0iI2NkNjExNiIgc3Ryb2tlPSIjY2Q2MTE2IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGQ9Im0xMDYuOCAyNDcuNCA0LjgtNDAuNi0zMS4zLjl6TTIwNyAyMDYuOGw0LjggNDAuNiAyNi41LTM5Ljd6bTIzLjgtNDQuNy01Ni4yIDIuNSA1LjIgMjguOSA4LjMtMTcuNCAyMCA5LjF6bS0xMjAuMiAyMy4xIDIwLTkuMSA4LjIgMTcuNCA1LjMtMjguOS01Ni4zLTIuNXoiLz4KICA8cGF0aCBmaWxsPSIjZTQ3NTFmIiBzdHJva2U9IiNlNDc1MWYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0ibTg3LjggMTYyLjEgMjMuNiA0Ni0uOC0yMi45em0xMjAuMyAyMy4xLTEgMjIuOSAyMy43LTQ2em0tNjQtMjAuNi01LjMgMjguOSA2LjYgMzQuMSAxLjUtNDQuOXptMzAuNSAwLTIuNyAxOCAxLjIgNDUgNi43LTM0LjF6Ii8+CiAgPHBhdGggZD0ibTE3OS44IDE5My41LTYuNyAzNC4xIDQuOCAzLjMgMjkuMi0yMi44IDEtMjIuOXptLTY5LjItOC4zLjggMjIuOSAyOS4yIDIyLjggNC44LTMuMy02LjYtMzQuMXoiIGNsYXNzPSJzdDYiLz4KICA8cGF0aCBmaWxsPSIjYzBhZDllIiBzdHJva2U9IiNjMGFkOWUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0ibTE4MC4zIDI2Mi4zLjMtOS4zLTIuNS0yLjJoLTM3LjdsLTIuMyAyLjIuMiA5LjMtMzEuNS0xNC45IDExIDkgMjIuMyAxNS41aDM4LjNsMjIuNC0xNS41IDExLTl6Ii8+CiAgPHBhdGggZmlsbD0iIzE2MTYxNiIgc3Ryb2tlPSIjMTYxNjE2IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGQ9Im0xNzcuOSAyMzAuOS00LjgtMy4zaC0yNy43bC00LjggMy4zLTIuNSAyMi4xIDIuMy0yLjJoMzcuN2wyLjUgMi4yeiIvPgogIDxwYXRoIGZpbGw9IiM3NjNkMTYiIHN0cm9rZT0iIzc2M2QxNiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBkPSJtMjc4LjMgMTE0LjIgOC41LTQwLjgtMTIuNy0zNy45LTk2LjIgNzEuNCAzNyAzMS4zIDUyLjMgMTUuMyAxMS42LTEzLjUtNS0zLjYgOC03LjMtNi4yLTQuOCA4LTYuMXpNMzEuOCA3My40bDguNSA0MC44LTUuNCA0IDggNi4xLTYuMSA0LjggOCA3LjMtNSAzLjYgMTEuNSAxMy41IDUyLjMtMTUuMyAzNy0zMS4zLTk2LjItNzEuNHoiLz4KICA8cGF0aCBkPSJtMjY3LjIgMTUzLjUtNTIuMy0xNS4zIDE1LjkgMjMuOS0yMy43IDQ2IDMxLjItLjRoNDYuNXptLTE2My42LTE1LjMtNTIuMyAxNS4zLTE3LjQgNTQuMmg0Ni40bDMxLjEuNC0yMy42LTQ2em03MSAyNi40IDMuMy01Ny43IDE1LjItNDEuMWgtNjcuNWwxNSA0MS4xIDMuNSA1Ny43IDEuMiAxOC4yLjEgNDQuOGgyNy43bC4yLTQ0Ljh6IiBjbGFzcz0ic3Q2Ii8+Cjwvc3ZnPg==",
    url: "https://suisnap.com"
  },
  [z.PHANTOM_WALLET]: {
    icon: "data:image/png;base64,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",
    url: "https://phantom.com/"
  }
}, Er = {
  icon: vt[z.SUI_WALLET].icon,
  url: "https://sui.io"
};
var te;
(function(e) {
  e.STANDARD__CONNECT = "standard:connect", e.STANDARD__DISCONNECT = "standard:disconnect", e.STANDARD__EVENTS = "standard:events", e.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK = "sui:signAndExecuteTransactionBlock", e.SUI__SIGN_TRANSACTION_BLOCK = "sui:signTransactionBlock", e.SUI__SIGN_MESSAGE = "sui:signMessage";
})(te || (te = {}));
const xo = ["OKX", "Bitget"];
class ko extends Qn {
  constructor(t, r) {
    super(), this.wallet = t, this.connection = r, this.accounts = [], xo.find((n) => t.name.includes(n)) ? this._name = t.name : this._name = t.name.replace("Wallet", "").trim();
  }
  async connect() {
    const { connect: t } = this.getFeature(te.STANDARD__CONNECT), { accounts: r } = await t();
    return this.accounts = [...r], this.activeAccount = r[0], this.emit("connect"), this.accounts.map((n) => n.address);
  }
  async disconnect() {
    const { disconnect: t } = this.getFeature(te.STANDARD__DISCONNECT, !1) || {};
    t && await t(), this.accounts = [], this.emit("disconnect");
  }
  signTransaction(t) {
    if (!this.activeAccount)
      throw new rr();
    const { signTransactionBlock: r } = this.getFeature(te.SUI__SIGN_TRANSACTION_BLOCK);
    return r({
      transactionBlock: t,
      account: this.activeAccount,
      chain: this.activeAccount.chains[0]
    });
  }
  async sendTransaction(t) {
    if (!this.connection)
      throw new Error("Connection not provided");
    const n = await new vo(this.connection).executeTransactionBlock({
      signature: t.signature,
      transactionBlock: t.transactionBlockBytes
    });
    return {
      id: n.digest,
      data: n
    };
  }
  async signAndSendTransaction(t) {
    if (!this.activeAccount)
      throw new rr();
    const { signAndExecuteTransactionBlock: r } = this.getFeature(te.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK), n = await r({
      ...t,
      account: this.activeAccount,
      chain: this.activeAccount.chains[0]
    });
    return {
      id: n.digest,
      data: n
    };
  }
  getName() {
    return this._name;
  }
  getUrl() {
    const t = vt[this.wallet.name];
    return (t == null ? void 0 : t.url) || Er.url;
  }
  getChainId() {
    return nr;
  }
  getAddress() {
    var t;
    return (t = this.activeAccount) == null ? void 0 : t.address;
  }
  getAddresses() {
    return this.accounts.map((t) => t.address);
  }
  setMainAddress(t) {
    const r = this.accounts.find((n) => n.address === t);
    if (!r)
      throw new Error("Account not found");
    this.activeAccount = r;
  }
  getBalance() {
    throw new Error("Method not implemented.");
  }
  signMessage(t) {
    const { signMessage: r } = this.getFeature(te.SUI__SIGN_MESSAGE);
    return r(t);
  }
  getIcon() {
    const t = vt[this.wallet.name];
    return (t == null ? void 0 : t.icon) || Er.icon;
  }
  isConnected() {
    return this.accounts.length > 0;
  }
  getNetworkInfo() {
    return this.activeAccount ? { chain: this.activeAccount.chains[0] } : void 0;
  }
  getFeature(t, r = !0) {
    const n = this.wallet.features[t];
    if (!n && r)
      throw new Yn();
    return n;
  }
  getFeatures() {
    const t = [_e.SendTransaction];
    return this.wallet.features[te.SUI__SIGN_TRANSACTION_BLOCK] && t.push(_e.SignTransaction), this.wallet.features[te.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK] && t.push(_e.SignAndSendTransaction), this.wallet.features[te.SUI__SIGN_MESSAGE] && t.push(_e.SignMessage), t;
  }
  supportsChain(t) {
    return t === nr;
  }
}
const zo = 250, Oo = (e) => {
  const { features: t } = e;
  return Object.entries(t).some(([r]) => r.startsWith("sui:"));
}, Bo = async (e = {}) => {
  const { timeout: t = zo, connection: r } = e, n = br(), i = [...n.get()];
  return new Promise((a) => {
    let o;
    const l = () => setTimeout(() => {
      o && o(), a(i.filter(Oo).map((g) => new ko(g, r)));
    }, t);
    let c = l();
    o = n.on("register", (g) => {
      i.push(g), clearTimeout(c), c = l();
    });
  });
};
fi();
async function Wo() {
  return (await Bo({ timeout: 0 })).reduce((t, r) => (t[r.getName()] = r, t), {});
}
const Zo = async (e, t) => {
  if (!t || !t.signAndSendTransaction)
    throw new Error("wallet.signAndSendTransaction is undefined");
  return await t.signAndSendTransaction({
    transactionBlock: e.transaction
  });
};
export {
  Wo as fetchOptions,
  Zo as signAndSendTransaction
};
