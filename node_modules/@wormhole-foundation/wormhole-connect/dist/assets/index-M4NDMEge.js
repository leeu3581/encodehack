var k=Object.defineProperty;var v=(u,s,t)=>s in u?k(u,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):u[s]=t;var i=(u,s,t)=>v(u,typeof s!="symbol"?s+"":s,t);import{T as f,S as w}from"./sui-DZhbOaP_.js";import{c$ as C,c5 as S,c3 as _,c4 as b,af as y,c6 as T,bV as M}from"../main.js";import{S as x}from"./unsignedTransaction-arVvzoJx.js";import"./blake2b-C_UGgjrB.js";import"./index-WlpSU6Q6.js";const j=[["Testnet",{tokenMessengerState:"0x5252abd1137094ed1db3e0d75bc36abcd287aee4bc310f8e047727ef5682e7c2",messageTransmitterState:"0x98234bd0fa9ac12cc0a20a144a22e36d6a32f7e0a97baaeaf9c76cdc6d122d2e",usdcTreasury:"0x7170137d4a6431bf83351ac025baf462909bffe2877d87716374fb42b9629ebe"}],["Mainnet",{tokenMessengerState:"0x45993eecc0382f37419864992c12faee2238f5cfe22b98ad3bf455baf65c8a2f",messageTransmitterState:"0xf68268c3d9b1df3215f2439400c1c4ea08ac4ef4bb7d6f3ca6a2a239e17510af",usdcTreasury:"0x57d6725e7a8b49a7b2a612f6bd66ab5f39fc95332ca48be421c3229d514a6de7"}]],$=C(j,[0,1]);class p{constructor(s,t,r,e){i(this,"network");i(this,"chain");i(this,"provider");i(this,"contracts");i(this,"usdcId");i(this,"usdcTreasuryId");i(this,"tokenMessengerId");i(this,"tokenMessengerStateId");i(this,"messageTransmitterId");i(this,"messageTransmitterStateId");var m,d,g,h;if(this.network=s,this.chain=t,this.provider=r,this.contracts=e,s==="Devnet")throw new Error("CircleBridge not supported on Devnet");const n=S.get(this.network,this.chain);if(!n)throw new Error(`No USDC contract configured for network=${this.network} chain=${this.chain}`);const{tokenMessengerState:o,messageTransmitterState:a,usdcTreasury:c}=$(s);if(!((m=e.cctp)!=null&&m.tokenMessenger))throw new Error(`Circle Token Messenger contract for domain ${t} not found`);if(!((d=e.cctp)!=null&&d.messageTransmitter))throw new Error(`Circle Message Transmitter contract for domain ${t} not found`);this.usdcId=n,this.usdcTreasuryId=c,this.tokenMessengerId=(g=e.cctp)==null?void 0:g.tokenMessenger,this.messageTransmitterId=(h=e.cctp)==null?void 0:h.messageTransmitter,this.tokenMessengerStateId=o,this.messageTransmitterStateId=a}async*transfer(s,t,r){const e=new f,n=_.get(this.network,t.chain),[o,...a]=await w.getCoins(this.provider,s,this.usdcId);if(o===void 0)throw new Error("No USDC in wallet");const c=e.object(o.coinObjectId);a.length>0&&e.mergeCoins(c,a.map(d=>e.object(d.coinObjectId)));const[m]=e.splitCoins(c,[r]);e.moveCall({target:`${this.tokenMessengerId}::deposit_for_burn::deposit_for_burn`,arguments:[m,e.pure.u32(n),e.pure.address(t.address.toUniversalAddress().toString()),e.object(this.tokenMessengerStateId),e.object(this.messageTransmitterStateId),e.object("0x403"),e.object(this.usdcTreasuryId)],typeArguments:[this.usdcId]}),yield this.createUnsignedTx(e,"Sui.CircleBridge.Transfer")}async isTransferCompleted(s){const t=new f;t.moveCall({target:`${this.messageTransmitterId}::state::is_nonce_used`,arguments:[t.object(this.messageTransmitterStateId),t.pure.u32(s.sourceDomain),t.pure.u64(s.nonce)]});const r=await this.provider.devInspectTransactionBlock({sender:"0x0000000000000000000000000000000000000000000000000000000000000000",transactionBlock:t});try{return!!r.results[0].returnValues[0][0][0]}catch(e){return console.error(`Error reading if nonce was used: ${e}`),!1}}async*redeem(s,t,r){const e=new f,[n]=e.moveCall({target:`${this.messageTransmitterId}::receive_message::receive_message`,arguments:[e.pure.vector("u8",b.serialize(t)),e.pure.vector("u8",y.decode(r)),e.object(this.messageTransmitterStateId)]});if(!n)throw new Error("Failed to produce receipt");const[o]=e.moveCall({target:`${this.tokenMessengerId}::handle_receive_message::handle_receive_message`,arguments:[n,e.object(this.tokenMessengerStateId),e.object("0x403"),e.object(this.usdcTreasuryId)],typeArguments:[this.usdcId]});if(!o)throw new Error("Failed to produce stamp receipt ticket with burn message");const[a]=e.moveCall({target:`${this.tokenMessengerId}::handle_receive_message::deconstruct_stamp_receipt_ticket_with_burn_message`,arguments:[o]});if(!a)throw new Error("Failed to produce stamp receipt ticket");const[c]=e.moveCall({target:`${this.messageTransmitterId}::receive_message::stamp_receipt`,arguments:[a,e.object(this.messageTransmitterStateId)],typeArguments:[`${this.tokenMessengerId}::message_transmitter_authenticator::MessageTransmitterAuthenticator`]});if(!c)throw new Error("Failed to produce stamped receipt");e.moveCall({target:`${this.messageTransmitterId}::receive_message::complete_receive_message`,arguments:[c,e.object(this.messageTransmitterStateId)]}),yield this.createUnsignedTx(e,"Sui.CircleBridge.Redeem")}async parseTransactionDetails(s){var l;const t=await this.provider.waitForTransaction({digest:s,options:{showEvents:!0,showEffects:!0,showInput:!0}});if(!t)throw new Error("Transaction not found");if(!t.events)throw new Error("Transaction events not found");const r=(l=t.events)==null?void 0:l.find(I=>I.type.includes("send_message::MessageSent"));if(!r)throw new Error("No MessageSent event found");const e=new Uint8Array((r==null?void 0:r.parsedJson).message),[n,o]=b.deserialize(e),{payload:a}=n,c=a.messageSender,m=a.mintRecipient,d=T(this.network,n.sourceDomain),g=T(this.network,n.destinationDomain),h={chain:d,address:a.burnToken};return{from:{chain:d,address:c},to:{chain:g,address:m},token:h,amount:a.amount,message:n,id:{hash:o}}}static async fromRpc(s,t){const[r,e]=await w.chainFromRpc(s),n=t[e];if(n.network!==r)throw new Error(`Network mismatch: ${n.network} != ${r}`);return new p(r,e,s,n.contracts)}createUnsignedTx(s,t,r=!1){return new x(s,this.network,this.chain,t,r)}}M("Sui","CircleBridge",p);export{p as SuiCircleBridge};
