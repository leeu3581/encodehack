var T=Object.defineProperty;var l=(i,t,e)=>t in i?T(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var r=(i,t,e)=>l(i,typeof t!="symbol"?t+"":t,e);import{cg as p,bK as g,bJ as b,p as y,bM as m,$ as d,a2 as h,bI as f,bO as o,bQ as u,bT as k,bU as v,bV as C,a4 as A}from"../main.js";class c{constructor(t,e,a,n){r(this,"network");r(this,"chain");r(this,"provider");r(this,"contracts");r(this,"chainId");r(this,"core");r(this,"gatewayAddress");r(this,"gateway");r(this,"tbtcTokenAddr");if(this.network=t,this.chain=e,this.provider=a,this.contracts=n,this.network!=="Mainnet")throw new Error("TBTC is only supported on Mainnet");if(!this.contracts.tbtc)throw new Error("TBTC contract address is required");const s=p.getNativeTbtcToken(this.chain);if(!s)throw new Error("Native tbtc token not found");this.chainId=g.get(t,e),this.core=new b(t,e,a,n),this.gatewayAddress=this.contracts.tbtc,this.gateway=new y(this.gatewayAddress,["function sendTbtc(uint256 amount, uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) payable returns (uint64)","function receiveTbtc(bytes calldata encodedVm)"],a),this.tbtcTokenAddr=m(s)}static async fromRpc(t,e){const[a,n]=await d.chainFromRpc(t),s=e[n];if(s.network!==a)throw new Error(`Network mismatch: ${s.network} != ${a}`);return new c(a,n,t,s.contracts)}async*transfer(t,e,a){const n=new h(t).toString(),s=await this.gateway.sendTbtc.populateTransaction(a,f(e.chain),e.address.toUniversalAddress().toUint8Array(),0n,0n);s.value=await this.core.getMessageFee(),yield*this.approve(n,a,this.gatewayAddress),yield this.createUnsignedTransaction(o(s,n),"TBTCBridge.Send")}async*redeem(t,e){if(e.payloadName!=="GatewayTransfer")throw new Error("Invalid VAA payload");const a=new h(t).toString(),n=await this.gateway.receiveTbtc.populateTransaction(u(e));yield this.createUnsignedTransaction(o(n,a),"TBTCBridge.Redeem")}async*approve(t,e,a){const n=d.getTokenImplementation(this.provider,this.tbtcTokenAddr);if(await n.allowance(t,a)<e){const w=await n.approve.populateTransaction(a,e);yield this.createUnsignedTransaction(o(w,t),"TBTC.Approve")}}createUnsignedTransaction(t,e){return new k(v(t,this.chainId),this.network,this.chain,e,!1)}}C(A,"TBTCBridge",c);export{c as EvmTBTCBridge};
