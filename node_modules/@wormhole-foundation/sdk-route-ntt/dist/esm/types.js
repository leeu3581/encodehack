import { Wormhole, amount, canonicalAddress, isNative, nativeTokenId, } from "@wormhole-foundation/sdk-connect";
export var NttRoute;
(function (NttRoute) {
    NttRoute.TRIMMED_DECIMALS = 8;
    NttRoute.ManualOptions = {
        automatic: false,
    };
    NttRoute.AutomaticOptions = {
        automatic: true,
        gasDropoff: "0.0",
    };
    function resolveSupportedNetworks(config) {
        return ["Mainnet", "Testnet"];
    }
    NttRoute.resolveSupportedNetworks = resolveSupportedNetworks;
    function resolveSupportedChains(config, network) {
        const configs = Object.values(config.tokens);
        return configs.flatMap((cfg) => cfg.map((chainCfg) => chainCfg.chain));
    }
    NttRoute.resolveSupportedChains = resolveSupportedChains;
    function resolveSourceTokens(config, fromChain) {
        const srcTokens = Object.entries(config.tokens).reduce((acc, [, configs]) => {
            const tokenConf = configs.find((config) => config.chain === fromChain.chain);
            if (tokenConf) {
                acc.push(Wormhole.tokenId(fromChain.chain, tokenConf.token));
                if (tokenConf.isWrappedGasToken) {
                    acc.push(nativeTokenId(fromChain.chain));
                }
            }
            return acc;
        }, []);
        // TODO: dedupe?  //return routes.uniqueTokens(srcTokens);
        return srcTokens;
    }
    NttRoute.resolveSourceTokens = resolveSourceTokens;
    function resolveDestinationTokens(config, sourceToken, fromChain, toChain) {
        return Object.entries(config.tokens)
            .map(([, configs]) => {
            const match = configs.find((config) => config.chain === fromChain.chain &&
                (config.token.toLowerCase() ===
                    canonicalAddress(sourceToken).toLowerCase() ||
                    (isNative(sourceToken.address) && config.isWrappedGasToken)));
            if (!match)
                return;
            const remote = configs.find((config) => config.chain === toChain.chain);
            if (!remote)
                return;
            return Wormhole.tokenId(toChain.chain, remote.token);
        })
            .filter((x) => !!x);
    }
    NttRoute.resolveDestinationTokens = resolveDestinationTokens;
    function resolveNttContracts(config, srcToken, dstToken) {
        const cfg = Object.values(config.tokens);
        const srcAddress = canonicalAddress(srcToken);
        const dstAddress = canonicalAddress(dstToken);
        for (const tokens of cfg) {
            const srcFound = tokens.find((tc) => tc.chain === srcToken.chain &&
                (tc.token.toLowerCase() === srcAddress.toLowerCase() ||
                    (isNative(srcToken.address) && tc.isWrappedGasToken)));
            if (srcFound) {
                const dstFound = tokens.find((tc) => tc.chain === dstToken.chain &&
                    (tc.token.toLowerCase() === dstAddress.toLowerCase() ||
                        (isNative(dstToken.address) && tc.isWrappedGasToken)));
                if (dstFound) {
                    return {
                        srcContracts: {
                            token: srcFound.token,
                            manager: srcFound.manager,
                            transceiver: {
                                wormhole: srcFound.transceiver.find((v) => v.type === "wormhole").address,
                            },
                            quoter: srcFound.quoter,
                        },
                        dstContracts: {
                            token: dstFound.token,
                            manager: dstFound.manager,
                            transceiver: {
                                wormhole: dstFound.transceiver.find((v) => v.type === "wormhole").address,
                            },
                        },
                    };
                }
            }
        }
        throw new Error("Cannot find Ntt contracts in config for: " + srcAddress);
    }
    NttRoute.resolveNttContracts = resolveNttContracts;
    function resolveDestinationNttContracts(config, srcManager, dstChain) {
        const cfg = Object.values(config.tokens);
        const address = canonicalAddress(srcManager);
        for (const tokens of cfg) {
            const found = tokens.find((tc) => tc.manager.toLowerCase() === address.toLowerCase() &&
                tc.chain === srcManager.chain);
            if (found) {
                const remote = tokens.find((tc) => tc.chain === dstChain);
                if (!remote) {
                    throw new Error(`Cannot find destination Ntt contracts in config for: ${address}`);
                }
                return {
                    token: remote.token,
                    manager: remote.manager,
                    transceiver: {
                        wormhole: remote.transceiver.find((v) => v.type === "wormhole")
                            .address,
                    },
                    quoter: remote.quoter,
                };
            }
        }
        throw new Error("Cannot find Ntt contracts in config for: " + address);
    }
    NttRoute.resolveDestinationNttContracts = resolveDestinationNttContracts;
    // returns true if the amount is greater than 95% of the capacity
    // useful for warning about the possibility of a transfer being queued
    function isCapacityThresholdExceeded(amount, capacity) {
        const threshold = (capacity * 95n) / 100n;
        return amount > threshold;
    }
    NttRoute.isCapacityThresholdExceeded = isCapacityThresholdExceeded;
    function trimAmount(amt, dstTokenDecimals) {
        // remove dust to avoid `TransferAmountHasDust` revert reason
        const truncatedAmount = amount.truncate(amt, Math.min(amt.decimals, dstTokenDecimals, NttRoute.TRIMMED_DECIMALS));
        return truncatedAmount;
    }
    NttRoute.trimAmount = trimAmount;
})(NttRoute || (NttRoute = {}));
//# sourceMappingURL=types.js.map