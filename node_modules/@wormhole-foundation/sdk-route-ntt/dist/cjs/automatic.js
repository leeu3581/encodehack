"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NttAutomaticRoute = exports.nttAutomaticRoute = void 0;
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
require("@wormhole-foundation/sdk-definitions-ntt");
const types_js_1 = require("./types.js");
function nttAutomaticRoute(config) {
    class NttRouteImpl extends NttAutomaticRoute {
        static config = config;
    }
    return NttRouteImpl;
}
exports.nttAutomaticRoute = nttAutomaticRoute;
class NttAutomaticRoute extends sdk_connect_1.routes.AutomaticRoute {
    // ntt does not support gas drop-off currently
    static NATIVE_GAS_DROPOFF_SUPPORTED = false;
    // @ts-ignore
    // Since we set the config on the static class, access it with this param
    // the NttManualRoute.config will always be empty
    staticConfig = this.constructor.config;
    static config = { tokens: {} };
    static meta = { name: "AutomaticNtt" };
    static supportedNetworks() {
        return types_js_1.NttRoute.resolveSupportedNetworks(this.config);
    }
    static supportedChains(network) {
        return types_js_1.NttRoute.resolveSupportedChains(this.config, network);
    }
    static async supportedSourceTokens(fromChain) {
        return types_js_1.NttRoute.resolveSourceTokens(this.config, fromChain);
    }
    static async supportedDestinationTokens(sourceToken, fromChain, toChain) {
        return types_js_1.NttRoute.resolveDestinationTokens(this.config, sourceToken, fromChain, toChain);
    }
    static isProtocolSupported(chain) {
        return chain.supportsProtocol("Ntt");
    }
    getDefaultOptions() {
        return types_js_1.NttRoute.AutomaticOptions;
    }
    async isAvailable(request) {
        const { srcContracts } = types_js_1.NttRoute.resolveNttContracts(this.staticConfig, request.source.id, request.destination.id);
        const ntt = await request.fromChain.getProtocol("Ntt", {
            ntt: srcContracts,
        });
        return ntt.isRelayingAvailable(request.toChain.chain);
    }
    async validate(request, params) {
        const options = params.options ?? this.getDefaultOptions();
        const gasDropoff = sdk_connect_1.amount.parse(options.gasDropoff ?? "0.0", request.toChain.config.nativeTokenDecimals);
        const wrapNative = (0, sdk_connect_1.isNative)(request.source.id.address);
        const parsedAmount = sdk_connect_1.amount.parse(params.amount, request.source.decimals);
        // The trimmedAmount may differ from the parsedAmount if the parsedAmount includes dust
        const trimmedAmount = types_js_1.NttRoute.trimAmount(parsedAmount, request.destination.decimals);
        const { srcContracts, dstContracts } = types_js_1.NttRoute.resolveNttContracts(this.staticConfig, request.source.id, request.destination.id);
        const validatedParams = {
            amount: params.amount,
            normalizedParams: {
                amount: trimmedAmount,
                sourceContracts: srcContracts,
                destinationContracts: dstContracts,
                options: {
                    queue: false,
                    automatic: true,
                    gasDropoff: sdk_connect_1.amount.units(gasDropoff),
                    wrapNative,
                },
            },
            options,
        };
        return { valid: true, params: validatedParams };
    }
    async quote(request, params) {
        const { fromChain, toChain } = request;
        const ntt = await fromChain.getProtocol("Ntt", {
            ntt: params.normalizedParams.sourceContracts,
        });
        if (!(await ntt.isRelayingAvailable(toChain.chain))) {
            return {
                success: false,
                error: new Error(`Relaying to chain ${toChain.chain} is not available`),
            };
        }
        const deliveryPrice = await ntt.quoteDeliveryPrice(toChain.chain, params.normalizedParams.options);
        const dstAmount = sdk_connect_1.amount.scale(params.normalizedParams.amount, request.destination.decimals);
        const result = {
            success: true,
            params,
            sourceToken: {
                token: request.source.id,
                amount: params.normalizedParams.amount,
            },
            destinationToken: {
                token: request.destination.id,
                amount: dstAmount,
            },
            relayFee: {
                token: sdk_connect_1.Wormhole.tokenId(fromChain.chain, "native"),
                amount: sdk_connect_1.amount.fromBaseUnits(deliveryPrice, fromChain.config.nativeTokenDecimals),
            },
            destinationNativeGas: sdk_connect_1.amount.fromBaseUnits(params.normalizedParams.options.gasDropoff ?? 0n, toChain.config.nativeTokenDecimals),
            eta: sdk_connect_1.finality.estimateFinalityTime(request.fromChain.chain),
        };
        const dstNtt = await toChain.getProtocol("Ntt", {
            ntt: params.normalizedParams.destinationContracts,
        });
        const duration = await dstNtt.getRateLimitDuration();
        if (duration > 0n) {
            const capacity = await dstNtt.getCurrentInboundCapacity(fromChain.chain);
            if (types_js_1.NttRoute.isCapacityThresholdExceeded(sdk_connect_1.amount.units(dstAmount), capacity)) {
                result.warnings = [
                    {
                        type: "DestinationCapacityWarning",
                        delayDurationSec: Number(duration),
                    },
                ];
            }
        }
        return result;
    }
    async initiate(request, signer, quote, to) {
        const { params } = quote;
        const { fromChain } = request;
        const sender = sdk_connect_1.Wormhole.parseAddress(signer.chain(), signer.address());
        const ntt = await fromChain.getProtocol("Ntt", {
            ntt: params.normalizedParams.sourceContracts,
        });
        const initXfer = ntt.transfer(sender, sdk_connect_1.amount.units(params.normalizedParams.amount), to, params.normalizedParams.options);
        const txids = await (0, sdk_connect_1.signSendWait)(fromChain, initXfer, signer);
        return {
            from: fromChain.chain,
            to: to.chain,
            state: sdk_connect_1.TransferState.SourceInitiated,
            originTxs: txids,
            params,
        };
    }
    async resume(tx) {
        const vaa = await this.wh.getVaa(tx.txid, "Ntt:WormholeTransferStandardRelayer");
        if (!vaa)
            throw new Error("No VAA found for transaction: " + tx.txid);
        const msgId = {
            chain: vaa.emitterChain,
            emitter: vaa.emitterAddress,
            sequence: vaa.sequence,
        };
        const { payload } = vaa.payload;
        const { recipientChain, trimmedAmount } = payload["nttManagerPayload"].payload;
        const token = (0, sdk_connect_1.canonicalAddress)({
            chain: vaa.emitterChain,
            address: payload["nttManagerPayload"].payload.sourceToken,
        });
        const manager = (0, sdk_connect_1.canonicalAddress)({
            chain: vaa.emitterChain,
            address: payload["sourceNttManager"],
        });
        const whTransceiver = vaa.emitterChain === "Solana"
            ? manager
            : (0, sdk_connect_1.canonicalAddress)({
                chain: vaa.emitterChain,
                address: vaa.emitterAddress,
            });
        const dstInfo = types_js_1.NttRoute.resolveDestinationNttContracts(this.staticConfig, {
            chain: vaa.emitterChain,
            address: payload["sourceNttManager"],
        }, recipientChain);
        const amt = sdk_connect_1.amount.fromBaseUnits(trimmedAmount.amount, trimmedAmount.decimals);
        return {
            from: vaa.emitterChain,
            to: recipientChain,
            state: sdk_connect_1.TransferState.Attested,
            originTxs: [tx],
            attestation: {
                id: msgId,
                attestation: vaa,
            },
            params: {
                amount: sdk_connect_1.amount.display(amt),
                options: { automatic: true },
                normalizedParams: {
                    amount: amt,
                    options: { queue: false, automatic: true },
                    sourceContracts: {
                        token,
                        manager,
                        transceiver: {
                            wormhole: whTransceiver,
                        },
                    },
                    destinationContracts: {
                        token: dstInfo.token,
                        manager: dstInfo.manager,
                        transceiver: {
                            wormhole: dstInfo.transceiver["wormhole"],
                        },
                    },
                },
            },
        };
    }
    // Even though this is an automatic route, the transfer may need to be
    // manually finalized if it was queued
    async finalize(signer, receipt) {
        if (!(0, sdk_connect_1.isDestinationQueued)(receipt)) {
            throw new Error("The transfer must be destination queued in order to finalize");
        }
        const { attestation: { attestation: vaa }, } = receipt;
        const toChain = this.wh.getChain(receipt.to);
        const ntt = await toChain.getProtocol("Ntt", {
            ntt: receipt.params.normalizedParams.destinationContracts,
        });
        const sender = sdk_connect_1.Wormhole.chainAddress(signer.chain(), signer.address());
        const payload = vaa.payloadName === "WormholeTransfer"
            ? vaa.payload
            : vaa.payload["payload"];
        const completeTransfer = ntt.completeInboundQueuedTransfer(receipt.from, payload["nttManagerPayload"], sender.address);
        const finalizeTxids = await (0, sdk_connect_1.signSendWait)(toChain, completeTransfer, signer);
        return {
            ...receipt,
            state: sdk_connect_1.TransferState.DestinationFinalized,
            destinationTxs: [...(receipt.destinationTxs ?? []), ...finalizeTxids],
        };
    }
    async *track(receipt, timeout) {
        if ((0, sdk_connect_1.isSourceInitiated)(receipt) || (0, sdk_connect_1.isSourceFinalized)(receipt)) {
            const { txid } = receipt.originTxs[receipt.originTxs.length - 1];
            const isEvmPlatform = (chain) => (0, sdk_connect_1.chainToPlatform)(chain) === "Evm";
            const vaaType = isEvmPlatform(receipt.from) && isEvmPlatform(receipt.to)
                ? // Automatic NTT transfers between EVM chains use standard relayers
                    "Ntt:WormholeTransferStandardRelayer"
                : "Ntt:WormholeTransfer";
            const vaa = await this.wh.getVaa(txid, vaaType, timeout);
            if (!vaa) {
                throw new Error(`No VAA found for transaction: ${txid}`);
            }
            const msgId = {
                chain: vaa.emitterChain,
                emitter: vaa.emitterAddress,
                sequence: vaa.sequence,
            };
            receipt = {
                ...receipt,
                state: sdk_connect_1.TransferState.Attested,
                attestation: {
                    id: msgId,
                    attestation: vaa,
                },
            };
            yield receipt;
        }
        const toChain = this.wh.getChain(receipt.to);
        const ntt = await toChain.getProtocol("Ntt", {
            ntt: receipt.params.normalizedParams.destinationContracts,
        });
        if ((0, sdk_connect_1.isAttested)(receipt)) {
            const { attestation: { attestation: vaa }, } = receipt;
            if (await ntt.getIsApproved(vaa)) {
                receipt = {
                    ...receipt,
                    state: sdk_connect_1.TransferState.DestinationInitiated,
                    // TODO: check for destination event transactions to get dest Txids
                };
                yield receipt;
            }
        }
        if ((0, sdk_connect_1.isRedeemed)(receipt) || (0, sdk_connect_1.isDestinationQueued)(receipt)) {
            const { attestation: { attestation: vaa }, } = receipt;
            const payload = vaa.payloadName === "WormholeTransfer"
                ? vaa.payload
                : vaa.payload["payload"];
            const queuedTransfer = await ntt.getInboundQueuedTransfer(vaa.emitterChain, payload["nttManagerPayload"]);
            if (queuedTransfer !== null) {
                receipt = {
                    ...receipt,
                    state: sdk_connect_1.TransferState.DestinationQueued,
                    queueReleaseTime: new Date(queuedTransfer.rateLimitExpiryTimestamp * 1000),
                };
                yield receipt;
            }
            else if (await ntt.getIsExecuted(vaa)) {
                receipt = {
                    ...receipt,
                    state: sdk_connect_1.TransferState.DestinationFinalized,
                };
                yield receipt;
            }
        }
        yield receipt;
    }
}
exports.NttAutomaticRoute = NttAutomaticRoute;
//# sourceMappingURL=automatic.js.map