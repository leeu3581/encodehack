import { Chain, Network } from "@wormhole-foundation/sdk-base";
import { AccountAddress, ChainAddress, ChainsConfig, Contracts } from "@wormhole-foundation/sdk-definitions";
import type { AnyEvmAddress, EvmChains, EvmPlatformType } from "@wormhole-foundation/sdk-evm";
import { EvmUnsignedTransaction } from "@wormhole-foundation/sdk-evm";
import "@wormhole-foundation/sdk-evm-core";
import { EvmNttTransceiver, Ntt, NttTransceiver, WormholeNttTransceiver } from "@wormhole-foundation/sdk-definitions-ntt";
import { type Provider, type TransactionRequest } from "ethers";
import { NttBindings, NttManagerBindings, NttTransceiverBindings } from "./bindings.js";
export declare class EvmNttWormholeTranceiver<N extends Network, C extends EvmChains> implements WormholeNttTransceiver<N, C>, EvmNttTransceiver<N, C, WormholeNttTransceiver.VAA> {
    readonly manager: EvmNtt<N, C>;
    readonly address: string;
    transceiver: NttTransceiverBindings.NttTransceiver;
    constructor(manager: EvmNtt<N, C>, address: string, abiBindings: NttBindings);
    getTransceiverType(): Promise<string>;
    getAddress(): ChainAddress<C>;
    encodeFlags(flags: {
        skipRelay: boolean;
    }): Uint8Array;
    setPeer<P extends Chain>(peer: ChainAddress<P>): AsyncGenerator<EvmUnsignedTransaction<N, C>>;
    getPauser(): Promise<AccountAddress<C> | null>;
    setPauser(pauser: AccountAddress<C>): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
    getPeer<C extends Chain>(chain: C): Promise<ChainAddress<C> | null>;
    isEvmChain(chain: Chain): Promise<boolean>;
    setIsEvmChain(chain: Chain, isEvm: boolean): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
    receive(attestation: WormholeNttTransceiver.VAA): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
    isWormholeRelayingEnabled(destChain: Chain): Promise<boolean>;
    setIsWormholeRelayingEnabled(destChain: Chain, enabled: boolean): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
    isSpecialRelayingEnabled(destChain: Chain): Promise<boolean>;
    setIsSpecialRelayingEnabled(destChain: Chain, enabled: boolean): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
}
export declare class EvmNtt<N extends Network, C extends EvmChains> implements Ntt<N, C> {
    readonly network: N;
    readonly chain: C;
    readonly provider: Provider;
    readonly contracts: Contracts & {
        ntt?: Ntt.Contracts;
    };
    readonly version: string;
    tokenAddress: string;
    readonly chainId: bigint;
    manager: NttManagerBindings.NttManager;
    xcvrs: EvmNttWormholeTranceiver<N, C>[];
    managerAddress: string;
    constructor(network: N, chain: C, provider: Provider, contracts: Contracts & {
        ntt?: Ntt.Contracts;
    }, version?: string);
    getTransceiver(ix: number): Promise<NttTransceiver<N, C, any> | null>;
    getMode(): Promise<Ntt.Mode>;
    isPaused(): Promise<boolean>;
    pause(): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
    unpause(): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
    getOwner(): Promise<AccountAddress<C>>;
    getPauser(): Promise<AccountAddress<C> | null>;
    setOwner(owner: AnyEvmAddress): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
    setPauser(pauser: AnyEvmAddress): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
    getThreshold(): Promise<number>;
    isRelayingAvailable(destination: Chain): Promise<boolean>;
    getIsExecuted(attestation: Ntt.Attestation): Promise<boolean>;
    getIsTransferInboundQueued(attestation: Ntt.Attestation): Promise<boolean>;
    getIsApproved(attestation: Ntt.Attestation): Promise<boolean>;
    getTokenDecimals(): Promise<number>;
    getPeer<C extends Chain>(chain: C): Promise<Ntt.Peer<C> | null>;
    static fromRpc<N extends Network>(provider: Provider, config: ChainsConfig<N, EvmPlatformType>): Promise<EvmNtt<N, EvmChains>>;
    encodeOptions(options: Ntt.TransferOptions): Ntt.TransceiverInstruction[];
    static getVersion(provider: Provider, contracts: Contracts & {
        ntt?: Ntt.Contracts;
    }): Promise<any>;
    getCustodyAddress(): Promise<string>;
    quoteDeliveryPrice(dstChain: Chain, options: Ntt.TransferOptions): Promise<bigint>;
    setPeer(peer: ChainAddress<C>, tokenDecimals: number, inboundLimit: bigint): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
    setWormholeTransceiverPeer(peer: ChainAddress<C>): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
    setTransceiverPeer(ix: number, peer: ChainAddress<C>): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
    transfer(sender: AccountAddress<C>, amount: bigint, destination: ChainAddress, options: Ntt.TransferOptions): AsyncGenerator<EvmUnsignedTransaction<N, C>>;
    redeem(attestations: Ntt.Attestation[]): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
    getCurrentOutboundCapacity(): Promise<bigint>;
    getOutboundLimit(): Promise<bigint>;
    setOutboundLimit(limit: bigint): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
    getCurrentInboundCapacity(fromChain: Chain): Promise<bigint>;
    getInboundLimit(fromChain: Chain): Promise<bigint>;
    setInboundLimit(fromChain: Chain, limit: bigint): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
    getRateLimitDuration(): Promise<bigint>;
    getInboundQueuedTransfer(fromChain: Chain, transceiverMessage: Ntt.Message): Promise<Ntt.InboundQueuedTransfer<C> | null>;
    completeInboundQueuedTransfer(fromChain: Chain, transceiverMessage: Ntt.Message, payer?: AccountAddress<C>): AsyncGenerator<EvmUnsignedTransaction<N, C>, void, unknown>;
    verifyAddresses(): Promise<Partial<Ntt.Contracts> | null>;
    createUnsignedTx(txReq: TransactionRequest, description: string, parallelizable?: boolean): EvmUnsignedTransaction<N, C>;
}
//# sourceMappingURL=ntt.d.ts.map