"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmNtt = exports.EvmNttWormholeTranceiver = void 0;
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const sdk_definitions_1 = require("@wormhole-foundation/sdk-definitions");
const sdk_evm_1 = require("@wormhole-foundation/sdk-evm");
require("@wormhole-foundation/sdk-evm-core");
const sdk_definitions_ntt_1 = require("@wormhole-foundation/sdk-definitions-ntt");
const ethers_1 = require("ethers");
const bindings_js_1 = require("./bindings.js");
class EvmNttWormholeTranceiver {
    manager;
    address;
    transceiver;
    constructor(manager, address, abiBindings) {
        this.manager = manager;
        this.address = address;
        this.transceiver = abiBindings.NttTransceiver.connect(address, manager.provider);
    }
    async getTransceiverType() {
        // NOTE: We hardcode the type here as transceiver type is only available for versions >1.1.0
        // For those versions, we can return `this.transceiver.getTransceiverType()` directly
        return "wormhole";
    }
    getAddress() {
        return {
            chain: this.manager.chain,
            address: (0, sdk_definitions_1.toUniversal)(this.manager.chain, this.address),
        };
    }
    encodeFlags(flags) {
        return new Uint8Array([flags.skipRelay ? 1 : 0]);
    }
    async *setPeer(peer) {
        const tx = await this.transceiver.setWormholePeer.populateTransaction((0, sdk_base_1.toChainId)(peer.chain), (0, sdk_definitions_1.universalAddress)(peer));
        yield this.manager.createUnsignedTx(tx, "WormholeTransceiver.registerPeer");
    }
    async getPauser() {
        const pauser = await this.transceiver.pauser();
        return new sdk_evm_1.EvmAddress(pauser);
    }
    async *setPauser(pauser) {
        const canonicalPauser = (0, sdk_definitions_1.canonicalAddress)({
            chain: this.manager.chain,
            address: pauser,
        });
        const tx = await this.transceiver.transferPauserCapability.populateTransaction(canonicalPauser);
        yield this.manager.createUnsignedTx(tx, "WormholeTransceiver.setPauser");
    }
    async getPeer(chain) {
        const peer = await this.transceiver.getWormholePeer((0, sdk_base_1.toChainId)(chain));
        const peerAddress = sdk_base_1.encoding.hex.decode(peer);
        const zeroAddress = new Uint8Array(32);
        if (sdk_base_1.encoding.bytes.equals(zeroAddress, peerAddress)) {
            return null;
        }
        return {
            chain: chain,
            address: (0, sdk_definitions_1.toUniversal)(chain, peerAddress),
        };
    }
    async isEvmChain(chain) {
        return await this.transceiver.isWormholeEvmChain((0, sdk_base_1.toChainId)(chain));
    }
    async *setIsEvmChain(chain, isEvm) {
        const tx = await this.transceiver.setIsWormholeEvmChain.populateTransaction((0, sdk_base_1.toChainId)(chain), isEvm);
        yield this.manager.createUnsignedTx(tx, "WormholeTransceiver.setIsEvmChain");
    }
    async *receive(attestation) {
        const tx = await this.transceiver.receiveMessage.populateTransaction((0, sdk_definitions_1.serialize)(attestation));
        yield this.manager.createUnsignedTx(tx, "WormholeTransceiver.receiveMessage");
    }
    async isWormholeRelayingEnabled(destChain) {
        return await this.transceiver.isWormholeRelayingEnabled((0, sdk_base_1.toChainId)(destChain));
    }
    async *setIsWormholeRelayingEnabled(destChain, enabled) {
        const tx = await this.transceiver.setIsWormholeRelayingEnabled.populateTransaction((0, sdk_base_1.toChainId)(destChain), enabled);
        yield this.manager.createUnsignedTx(tx, "WormholeTransceiver.setWormholeRelayingEnabled");
    }
    async isSpecialRelayingEnabled(destChain) {
        return await this.transceiver.isSpecialRelayingEnabled((0, sdk_base_1.toChainId)(destChain));
    }
    async *setIsSpecialRelayingEnabled(destChain, enabled) {
        const tx = await this.transceiver.setIsSpecialRelayingEnabled.populateTransaction((0, sdk_base_1.toChainId)(destChain), enabled);
        yield this.manager.createUnsignedTx(tx, "WormholeTransceiver.setSpecialRelayingEnabled");
    }
}
exports.EvmNttWormholeTranceiver = EvmNttWormholeTranceiver;
class EvmNtt {
    network;
    chain;
    provider;
    contracts;
    version;
    tokenAddress;
    chainId;
    manager;
    xcvrs;
    managerAddress;
    constructor(network, chain, provider, contracts, version = "1.0.0") {
        this.network = network;
        this.chain = chain;
        this.provider = provider;
        this.contracts = contracts;
        this.version = version;
        if (!contracts.ntt)
            throw new Error("No Ntt Contracts provided");
        this.chainId = sdk_base_1.nativeChainIds.networkChainToNativeChainId.get(network, chain);
        this.tokenAddress = contracts.ntt.token;
        this.managerAddress = contracts.ntt.manager;
        const abiBindings = (0, bindings_js_1.loadAbiVersion)(this.version);
        this.manager = abiBindings.NttManager.connect(contracts.ntt.manager, this.provider);
        this.xcvrs = [];
        if ("wormhole" in contracts.ntt.transceiver &&
            contracts.ntt.transceiver["wormhole"]) {
            const transceiverTypes = [
                "wormhole", // wormhole xcvr should be ix 0
                ...Object.keys(contracts.ntt.transceiver).filter((transceiverType) => {
                    transceiverType !== "wormhole";
                }),
            ];
            transceiverTypes.map((transceiverType) => {
                // we currently only support wormhole transceivers
                if (transceiverType !== "wormhole") {
                    throw new Error(`Unsupported transceiver type: ${transceiverType}`);
                }
                // Enable more Transceivers here
                this.xcvrs.push(new EvmNttWormholeTranceiver(this, contracts.ntt.transceiver[transceiverType], abiBindings));
            });
        }
    }
    async getTransceiver(ix) {
        // TODO: should we make an RPC call here, or just trust that the xcvrs are set up correctly?
        return this.xcvrs[ix] || null;
    }
    async getMode() {
        const mode = await this.manager.getMode();
        return mode === 0n ? "locking" : "burning";
    }
    async isPaused() {
        return await this.manager.isPaused();
    }
    async *pause() {
        const tx = await this.manager.pause.populateTransaction();
        yield this.createUnsignedTx(tx, "Ntt.pause");
    }
    async *unpause() {
        const tx = await this.manager.unpause.populateTransaction();
        yield this.createUnsignedTx(tx, "Ntt.unpause");
    }
    async getOwner() {
        return new sdk_evm_1.EvmAddress(await this.manager.owner());
    }
    async getPauser() {
        return new sdk_evm_1.EvmAddress(await this.manager.pauser());
    }
    async *setOwner(owner) {
        const canonicalOwner = new sdk_evm_1.EvmAddress(owner).toString();
        const tx = await this.manager.transferOwnership.populateTransaction(canonicalOwner);
        yield this.createUnsignedTx(tx, "Ntt.setOwner");
    }
    async *setPauser(pauser) {
        const canonicalPauser = new sdk_evm_1.EvmAddress(pauser).toString();
        const tx = await this.manager.transferPauserCapability.populateTransaction(canonicalPauser);
        yield this.createUnsignedTx(tx, "Ntt.setPauser");
    }
    async getThreshold() {
        return Number(await this.manager.getThreshold());
    }
    async isRelayingAvailable(destination) {
        const enabled = await Promise.all(this.xcvrs.map(async (x) => {
            const [wh, special] = await Promise.all([
                x.isWormholeRelayingEnabled(destination),
                x.isSpecialRelayingEnabled(destination),
            ]);
            return wh || special;
        }));
        return enabled.filter((x) => x).length > 0;
    }
    async getIsExecuted(attestation) {
        const payload = attestation.payloadName === "WormholeTransfer"
            ? attestation.payload
            : attestation.payload["payload"];
        const isExecuted = await this.manager.isMessageExecuted(sdk_definitions_ntt_1.Ntt.messageDigest(attestation.emitterChain, payload["nttManagerPayload"]));
        if (!isExecuted)
            return false;
        // Also check that the transfer is not queued for it to be considered complete
        return !(await this.getIsTransferInboundQueued(attestation));
    }
    async getIsTransferInboundQueued(attestation) {
        const payload = attestation.payloadName === "WormholeTransfer"
            ? attestation.payload
            : attestation.payload["payload"];
        return ((await this.getInboundQueuedTransfer(attestation.emitterChain, payload["nttManagerPayload"])) !== null);
    }
    getIsApproved(attestation) {
        const payload = attestation.payloadName === "WormholeTransfer"
            ? attestation.payload
            : attestation.payload["payload"];
        return this.manager.isMessageApproved(sdk_definitions_ntt_1.Ntt.messageDigest(attestation.emitterChain, payload["nttManagerPayload"]));
    }
    async getTokenDecimals() {
        return await sdk_evm_1.EvmPlatform.getDecimals(this.chain, this.provider, this.tokenAddress);
    }
    async getPeer(chain) {
        const peer = await this.manager.getPeer((0, sdk_base_1.toChainId)(chain));
        const peerAddress = sdk_base_1.encoding.hex.decode(peer.peerAddress);
        const zeroAddress = new Uint8Array(32);
        if (sdk_base_1.encoding.bytes.equals(zeroAddress, peerAddress)) {
            return null;
        }
        return {
            address: { chain: chain, address: (0, sdk_definitions_1.toUniversal)(chain, peerAddress) },
            tokenDecimals: Number(peer.tokenDecimals),
            inboundLimit: await this.getInboundLimit(chain),
        };
    }
    static async fromRpc(provider, config) {
        const [network, chain] = await sdk_evm_1.EvmPlatform.chainFromRpc(provider);
        const conf = config[chain];
        if (conf.network !== network)
            throw new Error(`Network mismatch: ${conf.network} != ${network}`);
        const version = await EvmNtt.getVersion(provider, conf.contracts);
        return new EvmNtt(network, chain, provider, conf.contracts, version);
    }
    encodeOptions(options) {
        const ixs = [];
        ixs.push({
            index: 0,
            payload: this.xcvrs[0].encodeFlags({ skipRelay: !options.automatic }),
        });
        return ixs;
    }
    static async getVersion(provider, contracts) {
        const contract = new ethers_1.Contract(contracts.ntt.manager, ["function NTT_MANAGER_VERSION() public view returns (string)"], provider);
        try {
            const abiVersion = await contract
                .getFunction("NTT_MANAGER_VERSION")
                .staticCall();
            if (!abiVersion) {
                throw new Error("NTT_MANAGER_VERSION not found");
            }
            return abiVersion;
        }
        catch (e) {
            console.error(`Failed to get NTT_MANAGER_VERSION from contract ${contracts.ntt?.manager}`);
            throw e;
        }
    }
    async getCustodyAddress() {
        return this.managerAddress;
    }
    async quoteDeliveryPrice(dstChain, options) {
        const [, totalPrice] = await this.manager.quoteDeliveryPrice((0, sdk_base_1.toChainId)(dstChain), sdk_definitions_ntt_1.Ntt.encodeTransceiverInstructions(this.encodeOptions(options)));
        return totalPrice;
    }
    async *setPeer(peer, tokenDecimals, inboundLimit) {
        const tx = await this.manager.setPeer.populateTransaction((0, sdk_base_1.toChainId)(peer.chain), (0, sdk_definitions_1.universalAddress)(peer), tokenDecimals, inboundLimit);
        yield this.createUnsignedTx(tx, "Ntt.setPeer");
    }
    async *setWormholeTransceiverPeer(peer) {
        yield* this.setTransceiverPeer(0, peer);
    }
    async *setTransceiverPeer(ix, peer) {
        if (ix >= this.xcvrs.length) {
            throw new Error("Transceiver not found");
        }
        yield* this.xcvrs[ix].setPeer(peer);
    }
    async *transfer(sender, amount, destination, options) {
        const senderAddress = new sdk_evm_1.EvmAddress(sender).toString();
        // Note: these flags are indexed by transceiver index
        const totalPrice = await this.quoteDeliveryPrice(destination.chain, options);
        if (options.wrapNative) {
            // TODO: the contract should handle this for us
            const wrappedNative = new ethers_1.Contract(this.tokenAddress, [
                "function deposit() public payable",
            ]);
            const txReq = await wrappedNative
                .getFunction("deposit")
                .populateTransaction({ value: amount });
            yield this.createUnsignedTx((0, sdk_evm_1.addFrom)(txReq, senderAddress), "Ntt.Deposit");
        }
        //TODO check for ERC-2612 (permit) support on token?
        const tokenContract = sdk_evm_1.EvmPlatform.getTokenImplementation(this.provider, this.tokenAddress);
        const allowance = await tokenContract.allowance(senderAddress, this.managerAddress);
        if (allowance < amount) {
            const txReq = await tokenContract.approve.populateTransaction(this.managerAddress, amount);
            yield this.createUnsignedTx((0, sdk_evm_1.addFrom)(txReq, senderAddress), "Ntt.Approve");
        }
        const receiver = (0, sdk_definitions_1.universalAddress)(destination);
        const txReq = await this.manager
            .getFunction("transfer(uint256,uint16,bytes32,bytes32,bool,bytes)")
            .populateTransaction(amount, (0, sdk_base_1.toChainId)(destination.chain), receiver, receiver, options.queue, sdk_definitions_ntt_1.Ntt.encodeTransceiverInstructions(this.encodeOptions(options)), { value: totalPrice });
        yield this.createUnsignedTx((0, sdk_evm_1.addFrom)(txReq, senderAddress), "Ntt.transfer");
    }
    // TODO: should this be some map of idx to transceiver?
    async *redeem(attestations) {
        if (attestations.length !== this.xcvrs.length)
            throw new Error("Not enough attestations for the registered Transceivers");
        for (const idx in this.xcvrs) {
            const xcvr = this.xcvrs[idx];
            const attestation = attestations[idx];
            if (attestation?.payloadName !== "WormholeTransfer") {
                // TODO: support standard relayer attestations
                // which must be submitted to the delivery provider
                throw new Error("Invalid attestation type for redeem");
            }
            yield* xcvr.receive(attestation);
        }
    }
    async getCurrentOutboundCapacity() {
        return await this.manager.getCurrentOutboundCapacity();
    }
    async getOutboundLimit() {
        const encoded = (await this.manager.getOutboundLimitParams()).limit;
        const trimmedAmount = decodeTrimmedAmount(encoded);
        const tokenDecimals = await this.getTokenDecimals();
        return untrim(trimmedAmount, tokenDecimals);
    }
    async *setOutboundLimit(limit) {
        const tx = await this.manager.setOutboundLimit.populateTransaction(limit);
        yield this.createUnsignedTx(tx, "Ntt.setOutboundLimit");
    }
    async getCurrentInboundCapacity(fromChain) {
        return await this.manager.getCurrentInboundCapacity((0, sdk_base_1.toChainId)(fromChain));
    }
    async getInboundLimit(fromChain) {
        const encoded = (await this.manager.getInboundLimitParams((0, sdk_base_1.toChainId)(fromChain))).limit;
        const trimmedAmount = decodeTrimmedAmount(encoded);
        const tokenDecimals = await this.getTokenDecimals();
        return untrim(trimmedAmount, tokenDecimals);
    }
    async *setInboundLimit(fromChain, limit) {
        const tx = await this.manager.setInboundLimit.populateTransaction(limit, (0, sdk_base_1.toChainId)(fromChain));
        yield this.createUnsignedTx(tx, "Ntt.setInboundLimit");
    }
    async getRateLimitDuration() {
        return await this.manager.rateLimitDuration();
    }
    async getInboundQueuedTransfer(fromChain, transceiverMessage) {
        const queuedTransfer = await this.manager.getInboundQueuedTransfer(sdk_definitions_ntt_1.Ntt.messageDigest(fromChain, transceiverMessage));
        if (queuedTransfer.txTimestamp > 0n) {
            const { recipient, amount, txTimestamp } = queuedTransfer;
            const duration = await this.getRateLimitDuration();
            return {
                recipient: new sdk_evm_1.EvmAddress(recipient),
                amount: amount,
                rateLimitExpiryTimestamp: Number(txTimestamp + duration),
            };
        }
        return null;
    }
    async *completeInboundQueuedTransfer(fromChain, transceiverMessage, payer) {
        const tx = await this.manager.completeInboundQueuedTransfer.populateTransaction(sdk_definitions_ntt_1.Ntt.messageDigest(fromChain, transceiverMessage));
        yield this.createUnsignedTx(tx, "Ntt.completeInboundQueuedTransfer");
    }
    async verifyAddresses() {
        const local = {
            manager: this.managerAddress,
            token: this.tokenAddress,
            transceiver: {
                ...(this.xcvrs.length > 0 && { wormhole: this.xcvrs[0].address }),
            },
            // TODO: what about the quoter?
        };
        const remote = {
            manager: this.managerAddress,
            token: await this.manager.token(),
            transceiver: {
                wormhole: (await this.manager.getTransceivers())[0], // TODO: make this more generic
            },
        };
        const deleteMatching = (a, b) => {
            for (const k in a) {
                if (typeof a[k] === "object") {
                    deleteMatching(a[k], b[k]);
                    if (Object.keys(a[k]).length === 0)
                        delete a[k];
                }
                else if (a[k] === b[k]) {
                    delete a[k];
                }
            }
        };
        deleteMatching(remote, local);
        return Object.keys(remote).length > 0 ? remote : null;
    }
    createUnsignedTx(txReq, description, parallelizable = false) {
        return new sdk_evm_1.EvmUnsignedTransaction((0, sdk_evm_1.addChainId)(txReq, this.chainId), this.network, this.chain, description, parallelizable);
    }
}
exports.EvmNtt = EvmNtt;
function decodeTrimmedAmount(encoded) {
    const decimals = Number(encoded & 0xffn);
    const amount = encoded >> 8n;
    return {
        amount,
        decimals,
    };
}
function untrim(trimmed, toDecimals) {
    const { amount, decimals: fromDecimals } = trimmed;
    return scale(amount, fromDecimals, toDecimals);
}
function scale(amount, fromDecimals, toDecimals) {
    if (fromDecimals == toDecimals) {
        return amount;
    }
    if (fromDecimals > toDecimals) {
        return amount / 10n ** BigInt(fromDecimals - toDecimals);
    }
    else {
        return amount * 10n ** BigInt(toDecimals - fromDecimals);
    }
}
//# sourceMappingURL=ntt.js.map