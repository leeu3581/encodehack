import { encoding, serializeLayout, toChainId, } from "@wormhole-foundation/sdk-base";
import { keccak256, } from "@wormhole-foundation/sdk-definitions";
import { nativeTokenTransferLayout, nttManagerMessageLayout, transceiverInstructionLayout, } from "./layouts/index.js";
/**
 * @namespace Ntt
 */
export var Ntt;
(function (Ntt) {
    const _protocol = "Ntt";
    // TODO: should layoutify this but couldnt immediately figure out how to
    // specify the length of the array as an encoded value
    function encodeTransceiverInstructions(ixs) {
        if (ixs.length > 255)
            throw new Error(`Too many instructions (${ixs.length})`);
        return encoding.bytes.concat(new Uint8Array([ixs.length]), ...ixs.map((ix) => serializeLayout(transceiverInstructionLayout(), ix)));
    }
    Ntt.encodeTransceiverInstructions = encodeTransceiverInstructions;
    /**
     * messageDigest hashes a message for the Ntt manager, the digest is used
     * to uniquely identify the message
     * @param chain The chain that sent the message
     * @param message The ntt message to hash
     * @returns a 32 byte digest of the message
     */
    function messageDigest(chain, message) {
        return keccak256(encoding.bytes.concat(encoding.bignum.toBytes(toChainId(chain), 2), serializeLayout(nttManagerMessageLayout(nativeTokenTransferLayout), message)));
    }
    Ntt.messageDigest = messageDigest;
    // Checks for compatibility between the Contract version in use on chain,
    // and the ABI version the SDK has. Major version must match, minor version on chain
    // should be gte SDK's ABI version.
    //
    // For example, if the contract is using 1.1.0, we would use 1.0.0 but not 1.2.0.
    function abiVersionMatches(targetVersion, abiVersion) {
        const parseVersion = (version) => {
            // allow optional tag on patch version
            const versionRegex = /^(\d+)\.(\d+)\.(.*)$/;
            const match = version.match(versionRegex);
            if (!match) {
                throw new Error(`Invalid version format: ${version}`);
            }
            const [, major, minor, patchAndTag] = match;
            return { major: Number(major), minor: Number(minor), patchAndTag };
        };
        const { major: majorTarget, minor: minorTarget } = parseVersion(targetVersion);
        const { major: majorAbi, minor: minorAbi } = parseVersion(abiVersion);
        return majorTarget === majorAbi && minorTarget >= minorAbi;
    }
    Ntt.abiVersionMatches = abiVersionMatches;
})(Ntt || (Ntt = {}));
export var WormholeNttTransceiver;
(function (WormholeNttTransceiver) {
    const _payloads = [
        "WormholeTransfer",
        "WormholeTransferStandardRelayer",
    ];
})(WormholeNttTransceiver || (WormholeNttTransceiver = {}));
//# sourceMappingURL=ntt.js.map