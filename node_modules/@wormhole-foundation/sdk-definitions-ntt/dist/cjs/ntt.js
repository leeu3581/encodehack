"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WormholeNttTransceiver = exports.Ntt = void 0;
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const sdk_definitions_1 = require("@wormhole-foundation/sdk-definitions");
const index_js_1 = require("./layouts/index.js");
/**
 * @namespace Ntt
 */
var Ntt;
(function (Ntt) {
    const _protocol = "Ntt";
    // TODO: should layoutify this but couldnt immediately figure out how to
    // specify the length of the array as an encoded value
    function encodeTransceiverInstructions(ixs) {
        if (ixs.length > 255)
            throw new Error(`Too many instructions (${ixs.length})`);
        return sdk_base_1.encoding.bytes.concat(new Uint8Array([ixs.length]), ...ixs.map((ix) => (0, sdk_base_1.serializeLayout)((0, index_js_1.transceiverInstructionLayout)(), ix)));
    }
    Ntt.encodeTransceiverInstructions = encodeTransceiverInstructions;
    /**
     * messageDigest hashes a message for the Ntt manager, the digest is used
     * to uniquely identify the message
     * @param chain The chain that sent the message
     * @param message The ntt message to hash
     * @returns a 32 byte digest of the message
     */
    function messageDigest(chain, message) {
        return (0, sdk_definitions_1.keccak256)(sdk_base_1.encoding.bytes.concat(sdk_base_1.encoding.bignum.toBytes((0, sdk_base_1.toChainId)(chain), 2), (0, sdk_base_1.serializeLayout)((0, index_js_1.nttManagerMessageLayout)(index_js_1.nativeTokenTransferLayout), message)));
    }
    Ntt.messageDigest = messageDigest;
    // Checks for compatibility between the Contract version in use on chain,
    // and the ABI version the SDK has. Major version must match, minor version on chain
    // should be gte SDK's ABI version.
    //
    // For example, if the contract is using 1.1.0, we would use 1.0.0 but not 1.2.0.
    function abiVersionMatches(targetVersion, abiVersion) {
        const parseVersion = (version) => {
            // allow optional tag on patch version
            const versionRegex = /^(\d+)\.(\d+)\.(.*)$/;
            const match = version.match(versionRegex);
            if (!match) {
                throw new Error(`Invalid version format: ${version}`);
            }
            const [, major, minor, patchAndTag] = match;
            return { major: Number(major), minor: Number(minor), patchAndTag };
        };
        const { major: majorTarget, minor: minorTarget } = parseVersion(targetVersion);
        const { major: majorAbi, minor: minorAbi } = parseVersion(abiVersion);
        return majorTarget === majorAbi && minorTarget >= minorAbi;
    }
    Ntt.abiVersionMatches = abiVersionMatches;
})(Ntt || (exports.Ntt = Ntt = {}));
var WormholeNttTransceiver;
(function (WormholeNttTransceiver) {
    const _payloads = [
        "WormholeTransfer",
        "WormholeTransferStandardRelayer",
    ];
})(WormholeNttTransceiver || (exports.WormholeNttTransceiver = WormholeNttTransceiver = {}));
//# sourceMappingURL=ntt.js.map