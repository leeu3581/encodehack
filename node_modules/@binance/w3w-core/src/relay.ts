import { detectWebSocket } from '@binance/w3w-socket-transport'
import {
  isNode,
  setStorage,
  getStorage,
  removeStorage,
} from '@binance/w3w-utils'
import { Interface } from '@ethersproject/abi'
import axios from 'axios'
import { decode } from 'js-base64'

import {
  BSC_RPCS,
  DOMAINS_KEY,
  DOMAINS_CONFIGS_KEY,
  DEFAULT_RELAY,
} from './constants'

type RpcResponse = {
  id: string
  jsonrpc: '2.0'
  result: string
}

// get domains configs immediately when the app code initializes
let initDomainsConfigsPromise = null

async function getDomains() {
  const res = await Promise.any(
    BSC_RPCS.map((url) =>
      axios.request<any, { data: RpcResponse }>({
        url: url,
        method: 'POST',
        data: {
          jsonrpc: '2.0',
          id: Date.now(),
          method: 'eth_call',
          params: [
            {
              to: '0x76054B318785b588A3164B2A6eA5476F7cBA51e0',
              data: '0x97b5f450',
            },
            'latest',
          ],
        },
      })
    )
  )
  const itf = new Interface(['function apiDomains() view returns (string)'])
  const domains = decode(
    itf.decodeFunctionResult('apiDomains', res.data.result)[0]
  )

  const domainStrList = domains.split(',')
  setStorage(DOMAINS_CONFIGS_KEY, domainStrList)
  console.log('ðŸš€ ~ file: relay.ts ~ .then ~ domains configs:', domainStrList)
  return domainStrList
}

function sortWebSocketByTtl(domains: { url: string; ttl: number }[]) {
  return domains
    .filter((item) => item.ttl > 0)
    .sort((a, b) => a.ttl - b.ttl)
    .map((item) => item.url)
}

/**
 * Retrieves all the domains of the connections.
 *
 * @return {Array} sortedDomains
 */
async function retrieveConnectionDomains(): Promise<string[]> {
  const domainsConfigsFromStorage = getStorage<string[]>(DOMAINS_CONFIGS_KEY)
  const domains =
    domainsConfigsFromStorage?.length > 0
      ? domainsConfigsFromStorage
      : ((await initDomainsConfigsPromise) as string[])
  const domainsWithTtl = await Promise.all(
    domains.map((domain) => {
      const subDomain = domain.split('.').slice(1).join('.')
      return detectWebSocket(`wss://nbstream.${subDomain}/wallet-connector`)
    })
  )
  const sortedDomains = sortWebSocketByTtl(domainsWithTtl)

  return sortedDomains
}

/**
 * detective centain domains of the ws.
 *
 * @return {Array} sortedDomains
 */
async function detectiveWSConnections(wsUrls?: string[]): Promise<string[]> {
  const domainsWithTtl = await Promise.all(
    wsUrls?.map((wsUrl) => detectWebSocket(wsUrl))
  )
  const sortedDomains = sortWebSocketByTtl(domainsWithTtl || [])
  return sortedDomains
}

// retrieves eligible connection urls immediately when the app code initializes
let initRetrivePromise = null

/**
 * Retrieves all the domains of the connections relays.
 * @return {Array} sorted domains relays
 */
async function retrieveEligibleConnectionRelays(): Promise<string[]> {
  const relaysFromStorage = getStorage<string[]>(DOMAINS_KEY)
  try {
    let relays = []
    if (!relaysFromStorage || relaysFromStorage.length === 0) {
      relays = await retrieveConnectionDomains()
    } else {
      const firstRelay = relaysFromStorage[0]
      // if one domain is not available, we will be concerned that network had changed, need to update the eligible ws domains.
      const isNetworkStatusChange =
        (await detectiveWSConnections([firstRelay])).length === 0
      if (isNetworkStatusChange) {
        relays = await retrieveConnectionDomains()
      } else {
        relays = relaysFromStorage
      }
    }
    console.log('ðŸš€ ~ file: relay.ts ~ .then ~ domains:', relays)
    setStorage(DOMAINS_KEY, relays)
    return relays
  } catch (error) {
    return [] as string[]
  }
}

if (!isNode()) {
  initDomainsConfigsPromise = getDomains()
  initRetrivePromise = retrieveEligibleConnectionRelays()
}

export async function getEligibleConnectionRelays(): Promise<string[]> {
  const relays = await (initRetrivePromise ||
    retrieveEligibleConnectionRelays())

  initRetrivePromise = null

  if (relays.length === 0) {
    // pod default relay
    relays.push(DEFAULT_RELAY)
  }

  return relays
}

export function removeRelayFromStorage(relay: string) {
  const relays = getStorage<string[]>(DOMAINS_KEY)
  if (!relays) return

  const newRelays = relays.filter((item) => item !== relay)
  setStorage(DOMAINS_KEY, newRelays)
}

export function clearRelaysFromStorage() {
  removeStorage(DOMAINS_KEY)
}
