import QrcodeModal from '@binance/w3w-qrcode-modal'
import { SocketTransport } from '@binance/w3w-socket-transport'
import {
  ITransportLib,
  SessionParams,
  DisconnectType,
  SocketMessage,
  JsonRpcRequest,
  EncryptionPayload,
  PrivateEthJsonRpc,
  PrivateEthJsonRpcValue,
} from '@binance/w3w-types'
import {
  log,
  uuid,
  encrypt,
  decrypt,
  MISC_ERR,
  RPC_ERROR,
  payloadId,
  generateKey,
  signingMethods,
  CONNECTION_ERR,
  ProviderRpcError,
  getClientMetadata,
  convertNumberToHex,
  openBinanceDeepLink,
  formatJsonRpcRequest,
} from '@binance/w3w-utils'

import { SessionManage } from './base'
import {
  getEligibleConnectionRelays,
  removeRelayFromStorage,
  clearRelaysFromStorage,
} from './relay'
import { populateError, removeQueryParams } from './utils'

export class Core extends SessionManage {
  private transport: ITransportLib
  private lng?: string
  constructor() {
    super()

    this.clientMeta = getClientMetadata()
    // recovery from storage
    const session = this.getStorageSession()
    if (session) {
      this.session = session
    }
    if (this.handshakeId) {
      this.subscribeToSessionResponse(this.handshakeId)
    }

    this.initTransport()
    this.subscribeInternalEvent()
  }

  public async request<T extends keyof PrivateEthJsonRpc>(
    payload: Partial<PrivateEthJsonRpc[T]['request']>
  ): Promise<PrivateEthJsonRpc[T]['response']['result']> {
    if (!this.connected) {
      throw new ProviderRpcError(
        CONNECTION_ERR.PROVIDER_NOT_READY.code,
        CONNECTION_ERR.PROVIDER_NOT_READY.message
      )
    }

    if (signingMethods.indexOf(payload.method) < 0) {
      throw new ProviderRpcError(
        RPC_ERROR.METHOD_NOT_SUPPORT.code,
        RPC_ERROR.METHOD_NOT_SUPPORT.message
      )
    }

    switch (payload.method) {
      case 'eth_requestAccounts':
        return this.accounts
      case 'eth_accounts':
        return this.accounts
      case 'eth_chainId':
        return convertNumberToHex(this.chainId)
      case 'eth_signTransaction':
      case 'eth_sendTransaction':
      case 'eth_sign':
      case 'personal_sign':
      case 'eth_signTypedData':
      case 'eth_signTypedData_v1':
      case 'eth_signTypedData_v2':
      case 'eth_signTypedData_v3':
      case 'eth_signTypedData_v4':
      case 'wallet_switchEthereumChain':
      case 'wallet_watchAsset':
        return new Promise<PrivateEthJsonRpcValue['response']['result']>(
          (resolve, reject) => {
            if (!payload.id) {
              payload.id = payloadId()
            }
            this.callbacks.set(`response-${payload.id}`, (error, data) => {
              if (error) {
                reject(populateError(error))
              } else if (!data) {
                reject(
                  new ProviderRpcError(
                    RPC_ERROR.MISSING_RESPONSE.code,
                    RPC_ERROR.MISSING_RESPONSE.message
                  )
                )
              } else {
                resolve(data.result)
              }
            })
            this.sendRequest(payload)
            this.events.emit('call_request_sent')
          }
        )
      default:
        break
    }
  }

  public killSession() {
    if (!this.connected) {
      return
    }
    const sessionParams = {
      approved: false,
      chainId: null,
      networkId: null,
      accounts: null,
    }
    const payload = {
      id: payloadId(),
      method: 'wc_sessionUpdate',
      params: [sessionParams],
    }
    // send kill session request
    this.sendRequest(payload)

    this.handleSessionDisconnect(DisconnectType.DisconnectAtClient)
  }

  public async connect({
    chainId,
    lng,
    showQrCodeModal,
  }: {
    chainId?: string
    lng?: string
    showQrCodeModal?: boolean
  } = {}): Promise<{ chainId: string; accounts: string[] }> {
    this.lng = lng
    if (this.connected) {
      return {
        chainId: this.chainId,
        accounts: this.accounts,
      }
    }

    return new Promise((resolve, reject) => {
      this.on('modal_closed', (err) => {
        reject(err)
      })

      this.on('session_error', (err) => {
        reject(err)
      })

      this.on('connect', (payload) => {
        resolve(payload)
      })

      this.createSession({ chainId, showQrCodeModal })
    })
  }

  public createSession({
    chainId,
    showQrCodeModal,
  }: {
    chainId?: string
    showQrCodeModal?: boolean
  }) {
    try {
      if (this.connected) {
        throw new ProviderRpcError(
          CONNECTION_ERR.CONNECTED.code,
          CONNECTION_ERR.CONNECTED.message
        )
      }
      if (this.pending || this._handshakeTopic) {
        throw new ProviderRpcError(
          CONNECTION_ERR.CONNECTING.code,
          CONNECTION_ERR.CONNECTING.message
        )
      }

      this.pending = true

      this._key = generateKey()
      this.handshakeId = payloadId()
      this.handshakeTopic = uuid()

      const payload = {
        id: this.handshakeId,
        method: 'wc_sessionRequest',
        params: [
          {
            peerId: this.clientId,
            peerMeta: this.clientMeta,
            chainId: chainId ? Number(chainId) : null,
          },
        ],
      }
      // send request
      this.sendRequest(payload, this.handshakeTopic)
      // subscribe session response
      this.subscribeToSessionResponse(this.handshakeId)
      // display wallet modal
      this.events.emit('display_uri', {
        showQrCodeModal,
      })
    } catch (error) {
      this.pending = false
      const topicId = `response-${this.handshakeId}`
      if (this.callbacks.get(topicId)) {
        this.callbacks.delete(topicId)
      }
      const errorMsg: string = error.message
      const internalError =
        error instanceof ProviderRpcError
          ? error
          : new ProviderRpcError(
              MISC_ERR.INTERNAL_ERR.code,
              `${MISC_ERR.INTERNAL_ERR.message}: ${errorMsg}`
            )
      this.handleRejectSessionConnection(internalError)
      log.error(`[binance-w3w] create connection failed: ${errorMsg}`)
      throw internalError
    }
  }

  private async initTransport() {
    this.transport = new SocketTransport({
      version: 1,
      subscriptions: [this.clientId],
    })

    this.transport.on('message', (socketMessage: SocketMessage) =>
      this.setIncomingMessages(socketMessage)
    )

    this.transport.on('open', (relay: string) => {
      this.events.emit('transport_open', relay)
    })

    this.transport.on('close', () => {
      this.events.emit('transport_close')
    })

    this.transport.on('error', (error: Error, relay: string) => {
      this.events.emit('transport_error', error, relay)
    })

    try {
      // recovery session
      if (this.session.relay) {
        this.transport.open([this.session.relay])
      } else {
        // new session
        const relays = await getEligibleConnectionRelays()
        this.transport.open(relays)
      }
    } catch (error) {
      // connection failed after retry
      clearRelaysFromStorage()
      const errorMsg: string = error.message
      const internalError = new ProviderRpcError(
        MISC_ERR.INTERNAL_ERR.code,
        `${MISC_ERR.INTERNAL_ERR.message}: ${errorMsg}`
      )
      this.handleRejectSessionConnection(internalError)
      throw internalError
    }
  }

  /**
   * @dev Set incoming socket message to js
   */
  private setIncomingMessages(socketMessage: SocketMessage) {
    const activeTopics = [this.clientId, this.handshakeTopic]

    if (!activeTopics.includes(socketMessage.topic)) {
      return
    }
    let encryptionPayload
    try {
      encryptionPayload = JSON.parse(socketMessage.payload)
    } catch (error) {
      return
    }
    /**
     *  1. session response
     *   { id, jsonrpc, result }
     *   { id, jsonrpc, error: { code, message }}
     *
     *  2. disconnect wc_sessionUpdate
     *   { id, jsonrpc, method, params }
     */
    const payload = this.decrypt(encryptionPayload)
    if (!payload) {
      return
    }

    // session updte, invoked by wallet side
    if ('method' in payload && payload.method) {
      this.events.emit(payload.method, null, payload)
      return
    }

    const id = payload.id
    const callbackId = `response-${id}`
    const callback = this.callbacks.get(callbackId)
    if (callback) {
      if ('error' in payload && payload.error) {
        const error = new ProviderRpcError(
          payload.error.code,
          payload.error.message
        )
        callback(error, null)
      } else if ('result' in payload && payload.result) {
        callback(null, payload)
      }
      this.callbacks.delete(callbackId)
    } else {
      log.error(`[binance-w3w] callback id: ${id} not found`)
    }
  }

  private encrypt(data: JsonRpcRequest): EncryptionPayload | null {
    const key: ArrayBuffer | null = this._key
    if (key) {
      const result = encrypt(data, key)
      return result
    }
    return null
  }

  private decrypt(payload: EncryptionPayload) {
    const key: ArrayBuffer | null = this._key
    if (key) {
      const result = decrypt(payload, key)
      return result
    }
    return null
  }

  private sendRequest(request: Partial<JsonRpcRequest>, topic?: string) {
    const callRequest = formatJsonRpcRequest(
      request.method,
      request.params,
      request.id
    )
    const encryptionPayload = this.encrypt(callRequest)

    const nextTopic = topic || this.peerId
    const payload: string = JSON.stringify(encryptionPayload)

    this.transport.send(payload, nextTopic, true)
  }

  private subscribeInternalEvent() {
    this.on('display_uri', ({ showQrCodeModal }) => {
      // If showQrModal is false, then the user is responsible for displaying the QR code
      if (showQrCodeModal === false) {
        return
      }
      QrcodeModal.open({
        cb: () => {
          // closed by user
          this.events.emit(
            'modal_closed',
            new ProviderRpcError(
              CONNECTION_ERR.CLOSE_MODAL.code,
              CONNECTION_ERR.CLOSE_MODAL.message
            )
          )
        },
        lng: this.lng,
      })
      // check connection status immediately
      if (this.transport.connected) {
        this.events.emit('uri_ready', this.uri)
        // In some cases the uri doesn't have key
        if (this.key) {
          QrcodeModal.ready(this.uri)
        }
      } else if (this.transport.retryFailed) {
        QrcodeModal.fail()
      }
    })

    this.on('transport_open', (relay: string) => {
      this.relay = relay
      this.events.emit('uri_ready', this.uri)

      // In some cases the uri doesn't have key
      if (this.key) {
        QrcodeModal.ready(this.uri)
      }
    })

    this.on('transport_error', (error: Error, relay: string) => {
      if (relay) {
        // remove the failed relay from storage
        removeRelayFromStorage(removeQueryParams(relay))
      } else {
        // remove all relays from storage
        clearRelaysFromStorage()
        QrcodeModal.fail()
      }
    })

    // user close the modal
    this.on('modal_closed', () => {
      // close connection proactively
      const topic = `response-${this.handshakeId}`
      if (this.callbacks.get(topic)) {
        this.callbacks.delete(topic)
      }
      this.clearConnectionStatus()
    })

    this.on('connect', () => {
      this.pending = false
      QrcodeModal.close()
    })

    // open wallet when send signer transaction
    this.on('call_request_sent', () => {
      // open binance app via deeplink
      openBinanceDeepLink()
    })

    //  dispatched by the Wallet when updating the session
    this.on('wc_sessionUpdate', (error, payload) => {
      if (error) {
        this.handleSessionResponse()
        return
      }
      if (payload.params && Array.isArray(payload.params)) {
        this.handleSessionResponse(payload.params[0])
      } else if (payload.error) {
        this.handleSessionResponse()
      }
    })
  }

  private subscribeToSessionResponse(id: number) {
    this.callbacks.set(`response-${id}`, (error, payload) => {
      if (error) {
        this.handleSessionResponse()
        return
      }
      if (!payload) {
        return
      }
      if (payload.result) {
        this.handleSessionResponse(payload.result as SessionParams)
      } else if (payload.error && payload.error.message) {
        this.handleSessionResponse()
      } else {
        this.handleSessionResponse()
      }
    })
  }

  private handleSessionResponse(sessionParams?: SessionParams) {
    if (sessionParams) {
      if (sessionParams.approved) {
        if (!this._connected) {
          this._connected = true
          if (sessionParams.chainId) {
            this.setChainId(sessionParams.chainId)
          }
          if (sessionParams.accounts) {
            this.setAddress(sessionParams.accounts)
          }
          if (sessionParams.peerId && !this.peerId) {
            this.peerId = sessionParams.peerId
          }
          if (sessionParams.peerMeta && !this.peerMeta) {
            this.peerMeta = sessionParams.peerMeta
          }

          this.events.emit('connect', {
            chainId: this.chainId,
            accounts: this.accounts,
          })
        } else {
          if (sessionParams.chainId) {
            this.setChainId(sessionParams.chainId)
          }
          if (sessionParams.accounts) {
            this.setAddress(sessionParams.accounts)
          }
        }

        this.manageStorageSession()
      } else {
        // disconnect connection at wallet side
        if (this.connected) {
          this.handleSessionDisconnect(DisconnectType.DisconnectAtWallet)
        } else {
          // user reject session creation
          this.handleRejectSessionConnection(
            new ProviderRpcError(
              CONNECTION_ERR.REJECT_SESSION.code,
              CONNECTION_ERR.REJECT_SESSION.message
            )
          )
        }
      }
    } else {
      // user reject session creation
      this.handleRejectSessionConnection(
        new ProviderRpcError(
          CONNECTION_ERR.REJECT_SESSION.code,
          CONNECTION_ERR.REJECT_SESSION.message
        )
      )
    }
  }

  private handleRejectSessionConnection(error: Error) {
    // close qrcode modal
    QrcodeModal.close()
    this.clearConnectionStatus()
    this.events.emit('session_error', error)
  }

  private handleSessionDisconnect(type: DisconnectType) {
    if (!this._connected) {
      // close qrcode modal
      QrcodeModal.close()
    }

    this.events.emit('disconnect', type)

    this.clearConnectionStatus()
  }

  private clearConnectionStatus() {
    if (this._connected) {
      this._connected = false
    }
    if (this._handshakeId) {
      this._handshakeId = 0
    }
    if (this._handshakeTopic) {
      this._handshakeTopic = ''
    }
    if (this._peerId) {
      this._peerId = ''
    }
    if (this._clientId) {
      this._clientId = ''
    }
    if (this.pending) {
      this.pending = false
    }
    this.callbacks.clear()
    this._peerMeta = null
    this._accounts = []
    this._chainId = '0x0'

    this.offConnectEvents()
    this.removeStorageSession()
    this.transport.close()
  }

  private offConnectEvents() {
    this.removeListener('connect')
  }

  private setChainId(value?: number | string) {
    const nextChainId = convertNumberToHex(value)
    if (nextChainId === '0x0') {
      this.chainId = nextChainId
      return
    }

    if (typeof this.chainId !== 'undefined' && this.chainId !== nextChainId) {
      this.events.emit('chainChanged', nextChainId)
    }

    this.chainId = nextChainId
  }

  private setAddress(value: string[] = []) {
    const nextAddress = value
      .filter((e) => typeof e === 'string')
      .map((e) => e.toLowerCase())
      .filter(Boolean)

    // Note: deep compare to previous
    if (JSON.stringify(this.accounts) !== JSON.stringify(nextAddress)) {
      this.events.emit('accountsChanged', nextAddress)
    }

    this.accounts = nextAddress
  }
}
