{"version":3,"sources":["../src/index.ts","../src/base.ts","../src/constants.ts","../src/relay.ts","../src/utils.ts"],"names":["QrcodeModal","SocketTransport","DisconnectType","log","uuid","encrypt","decrypt","MISC_ERR","RPC_ERROR","payloadId","generateKey","signingMethods","CONNECTION_ERR","ProviderRpcError","getClientMetadata","convertNumberToHex","openBinanceDeepLink","formatJsonRpcRequest","Events","convertHexToArrayBuffer","convertArrayBufferToHex","getStorage","removeStorage","setStorage","SESSION_KEY","DOMAINS_KEY","DOMAINS_CONFIGS_KEY","DEFAULT_RELAY","BSC_RPCS","BaseCore","__publicField","value","key","clientId","_","SessionManage","detectWebSocket","isNode","Interface","axios","decode","initDomainsConfigsPromise","getDomains","res","url","itf","domainStrList","sortWebSocketByTtl","domains","item","a","b","retrieveConnectionDomains","domainsConfigsFromStorage","domainsWithTtl","domain","subDomain","detectiveWSConnections","wsUrls","wsUrl","initRetrivePromise","retrieveEligibleConnectionRelays","relaysFromStorage","relays","firstRelay","getEligibleConnectionRelays","removeRelayFromStorage","relay","newRelays","clearRelaysFromStorage","populateError","error","removeQueryParams","index","Core","session","payload","resolve","reject","data","sessionParams","chainId","lng","showQrCodeModal","err","topicId","errorMsg","internalError","socketMessage","encryptionPayload","id","callbackId","callback","request","topic","callRequest","nextTopic","type","nextChainId","nextAddress","e"],"mappings":"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","sourcesContent":["import QrcodeModal from '@binance/w3w-qrcode-modal'\nimport { SocketTransport } from '@binance/w3w-socket-transport'\nimport {\n  ITransportLib,\n  SessionParams,\n  DisconnectType,\n  SocketMessage,\n  JsonRpcRequest,\n  EncryptionPayload,\n  PrivateEthJsonRpc,\n  PrivateEthJsonRpcValue,\n} from '@binance/w3w-types'\nimport {\n  log,\n  uuid,\n  encrypt,\n  decrypt,\n  MISC_ERR,\n  RPC_ERROR,\n  payloadId,\n  generateKey,\n  signingMethods,\n  CONNECTION_ERR,\n  ProviderRpcError,\n  getClientMetadata,\n  convertNumberToHex,\n  openBinanceDeepLink,\n  formatJsonRpcRequest,\n} from '@binance/w3w-utils'\n\nimport { SessionManage } from './base'\nimport {\n  getEligibleConnectionRelays,\n  removeRelayFromStorage,\n  clearRelaysFromStorage,\n} from './relay'\nimport { populateError, removeQueryParams } from './utils'\n\nexport class Core extends SessionManage {\n  private transport: ITransportLib\n  private lng?: string\n  constructor() {\n    super()\n\n    this.clientMeta = getClientMetadata()\n    // recovery from storage\n    const session = this.getStorageSession()\n    if (session) {\n      this.session = session\n    }\n    if (this.handshakeId) {\n      this.subscribeToSessionResponse(this.handshakeId)\n    }\n\n    this.initTransport()\n    this.subscribeInternalEvent()\n  }\n\n  public async request<T extends keyof PrivateEthJsonRpc>(\n    payload: Partial<PrivateEthJsonRpc[T]['request']>\n  ): Promise<PrivateEthJsonRpc[T]['response']['result']> {\n    if (!this.connected) {\n      throw new ProviderRpcError(\n        CONNECTION_ERR.PROVIDER_NOT_READY.code,\n        CONNECTION_ERR.PROVIDER_NOT_READY.message\n      )\n    }\n\n    if (signingMethods.indexOf(payload.method) < 0) {\n      throw new ProviderRpcError(\n        RPC_ERROR.METHOD_NOT_SUPPORT.code,\n        RPC_ERROR.METHOD_NOT_SUPPORT.message\n      )\n    }\n\n    switch (payload.method) {\n      case 'eth_requestAccounts':\n        return this.accounts\n      case 'eth_accounts':\n        return this.accounts\n      case 'eth_chainId':\n        return convertNumberToHex(this.chainId)\n      case 'eth_signTransaction':\n      case 'eth_sendTransaction':\n      case 'eth_sign':\n      case 'personal_sign':\n      case 'eth_signTypedData':\n      case 'eth_signTypedData_v1':\n      case 'eth_signTypedData_v2':\n      case 'eth_signTypedData_v3':\n      case 'eth_signTypedData_v4':\n      case 'wallet_switchEthereumChain':\n      case 'wallet_watchAsset':\n        return new Promise<PrivateEthJsonRpcValue['response']['result']>(\n          (resolve, reject) => {\n            if (!payload.id) {\n              payload.id = payloadId()\n            }\n            this.callbacks.set(`response-${payload.id}`, (error, data) => {\n              if (error) {\n                reject(populateError(error))\n              } else if (!data) {\n                reject(\n                  new ProviderRpcError(\n                    RPC_ERROR.MISSING_RESPONSE.code,\n                    RPC_ERROR.MISSING_RESPONSE.message\n                  )\n                )\n              } else {\n                resolve(data.result)\n              }\n            })\n            this.sendRequest(payload)\n            this.events.emit('call_request_sent')\n          }\n        )\n      default:\n        break\n    }\n  }\n\n  public killSession() {\n    if (!this.connected) {\n      return\n    }\n    const sessionParams = {\n      approved: false,\n      chainId: null,\n      networkId: null,\n      accounts: null,\n    }\n    const payload = {\n      id: payloadId(),\n      method: 'wc_sessionUpdate',\n      params: [sessionParams],\n    }\n    // send kill session request\n    this.sendRequest(payload)\n\n    this.handleSessionDisconnect(DisconnectType.DisconnectAtClient)\n  }\n\n  public async connect({\n    chainId,\n    lng,\n    showQrCodeModal,\n  }: {\n    chainId?: string\n    lng?: string\n    showQrCodeModal?: boolean\n  } = {}): Promise<{ chainId: string; accounts: string[] }> {\n    this.lng = lng\n    if (this.connected) {\n      return {\n        chainId: this.chainId,\n        accounts: this.accounts,\n      }\n    }\n\n    return new Promise((resolve, reject) => {\n      this.on('modal_closed', (err) => {\n        reject(err)\n      })\n\n      this.on('session_error', (err) => {\n        reject(err)\n      })\n\n      this.on('connect', (payload) => {\n        resolve(payload)\n      })\n\n      this.createSession({ chainId, showQrCodeModal })\n    })\n  }\n\n  public createSession({\n    chainId,\n    showQrCodeModal,\n  }: {\n    chainId?: string\n    showQrCodeModal?: boolean\n  }) {\n    try {\n      if (this.connected) {\n        throw new ProviderRpcError(\n          CONNECTION_ERR.CONNECTED.code,\n          CONNECTION_ERR.CONNECTED.message\n        )\n      }\n      if (this.pending || this._handshakeTopic) {\n        throw new ProviderRpcError(\n          CONNECTION_ERR.CONNECTING.code,\n          CONNECTION_ERR.CONNECTING.message\n        )\n      }\n\n      this.pending = true\n\n      this._key = generateKey()\n      this.handshakeId = payloadId()\n      this.handshakeTopic = uuid()\n\n      const payload = {\n        id: this.handshakeId,\n        method: 'wc_sessionRequest',\n        params: [\n          {\n            peerId: this.clientId,\n            peerMeta: this.clientMeta,\n            chainId: chainId ? Number(chainId) : null,\n          },\n        ],\n      }\n      // send request\n      this.sendRequest(payload, this.handshakeTopic)\n      // subscribe session response\n      this.subscribeToSessionResponse(this.handshakeId)\n      // display wallet modal\n      this.events.emit('display_uri', {\n        showQrCodeModal,\n      })\n    } catch (error) {\n      this.pending = false\n      const topicId = `response-${this.handshakeId}`\n      if (this.callbacks.get(topicId)) {\n        this.callbacks.delete(topicId)\n      }\n      const errorMsg: string = error.message\n      const internalError =\n        error instanceof ProviderRpcError\n          ? error\n          : new ProviderRpcError(\n              MISC_ERR.INTERNAL_ERR.code,\n              `${MISC_ERR.INTERNAL_ERR.message}: ${errorMsg}`\n            )\n      this.handleRejectSessionConnection(internalError)\n      log.error(`[binance-w3w] create connection failed: ${errorMsg}`)\n      throw internalError\n    }\n  }\n\n  private async initTransport() {\n    this.transport = new SocketTransport({\n      version: 1,\n      subscriptions: [this.clientId],\n    })\n\n    this.transport.on('message', (socketMessage: SocketMessage) =>\n      this.setIncomingMessages(socketMessage)\n    )\n\n    this.transport.on('open', (relay: string) => {\n      this.events.emit('transport_open', relay)\n    })\n\n    this.transport.on('close', () => {\n      this.events.emit('transport_close')\n    })\n\n    this.transport.on('error', (error: Error, relay: string) => {\n      this.events.emit('transport_error', error, relay)\n    })\n\n    try {\n      // recovery session\n      if (this.session.relay) {\n        this.transport.open([this.session.relay])\n      } else {\n        // new session\n        const relays = await getEligibleConnectionRelays()\n        this.transport.open(relays)\n      }\n    } catch (error) {\n      // connection failed after retry\n      clearRelaysFromStorage()\n      const errorMsg: string = error.message\n      const internalError = new ProviderRpcError(\n        MISC_ERR.INTERNAL_ERR.code,\n        `${MISC_ERR.INTERNAL_ERR.message}: ${errorMsg}`\n      )\n      this.handleRejectSessionConnection(internalError)\n      throw internalError\n    }\n  }\n\n  /**\n   * @dev Set incoming socket message to js\n   */\n  private setIncomingMessages(socketMessage: SocketMessage) {\n    const activeTopics = [this.clientId, this.handshakeTopic]\n\n    if (!activeTopics.includes(socketMessage.topic)) {\n      return\n    }\n    let encryptionPayload\n    try {\n      encryptionPayload = JSON.parse(socketMessage.payload)\n    } catch (error) {\n      return\n    }\n    /**\n     *  1. session response\n     *   { id, jsonrpc, result }\n     *   { id, jsonrpc, error: { code, message }}\n     *\n     *  2. disconnect wc_sessionUpdate\n     *   { id, jsonrpc, method, params }\n     */\n    const payload = this.decrypt(encryptionPayload)\n    if (!payload) {\n      return\n    }\n\n    // session updte, invoked by wallet side\n    if ('method' in payload && payload.method) {\n      this.events.emit(payload.method, null, payload)\n      return\n    }\n\n    const id = payload.id\n    const callbackId = `response-${id}`\n    const callback = this.callbacks.get(callbackId)\n    if (callback) {\n      if ('error' in payload && payload.error) {\n        const error = new ProviderRpcError(\n          payload.error.code,\n          payload.error.message\n        )\n        callback(error, null)\n      } else if ('result' in payload && payload.result) {\n        callback(null, payload)\n      }\n      this.callbacks.delete(callbackId)\n    } else {\n      log.error(`[binance-w3w] callback id: ${id} not found`)\n    }\n  }\n\n  private encrypt(data: JsonRpcRequest): EncryptionPayload | null {\n    const key: ArrayBuffer | null = this._key\n    if (key) {\n      const result = encrypt(data, key)\n      return result\n    }\n    return null\n  }\n\n  private decrypt(payload: EncryptionPayload) {\n    const key: ArrayBuffer | null = this._key\n    if (key) {\n      const result = decrypt(payload, key)\n      return result\n    }\n    return null\n  }\n\n  private sendRequest(request: Partial<JsonRpcRequest>, topic?: string) {\n    const callRequest = formatJsonRpcRequest(\n      request.method,\n      request.params,\n      request.id\n    )\n    const encryptionPayload = this.encrypt(callRequest)\n\n    const nextTopic = topic || this.peerId\n    const payload: string = JSON.stringify(encryptionPayload)\n\n    this.transport.send(payload, nextTopic, true)\n  }\n\n  private subscribeInternalEvent() {\n    this.on('display_uri', ({ showQrCodeModal }) => {\n      // If showQrModal is false, then the user is responsible for displaying the QR code\n      if (showQrCodeModal === false) {\n        return\n      }\n      QrcodeModal.open({\n        cb: () => {\n          // closed by user\n          this.events.emit(\n            'modal_closed',\n            new ProviderRpcError(\n              CONNECTION_ERR.CLOSE_MODAL.code,\n              CONNECTION_ERR.CLOSE_MODAL.message\n            )\n          )\n        },\n        lng: this.lng,\n      })\n      // check connection status immediately\n      if (this.transport.connected) {\n        this.events.emit('uri_ready', this.uri)\n        // In some cases the uri doesn't have key\n        if (this.key) {\n          QrcodeModal.ready(this.uri)\n        }\n      } else if (this.transport.retryFailed) {\n        QrcodeModal.fail()\n      }\n    })\n\n    this.on('transport_open', (relay: string) => {\n      this.relay = relay\n      this.events.emit('uri_ready', this.uri)\n\n      // In some cases the uri doesn't have key\n      if (this.key) {\n        QrcodeModal.ready(this.uri)\n      }\n    })\n\n    this.on('transport_error', (error: Error, relay: string) => {\n      if (relay) {\n        // remove the failed relay from storage\n        removeRelayFromStorage(removeQueryParams(relay))\n      } else {\n        // remove all relays from storage\n        clearRelaysFromStorage()\n        QrcodeModal.fail()\n      }\n    })\n\n    // user close the modal\n    this.on('modal_closed', () => {\n      // close connection proactively\n      const topic = `response-${this.handshakeId}`\n      if (this.callbacks.get(topic)) {\n        this.callbacks.delete(topic)\n      }\n      this.clearConnectionStatus()\n    })\n\n    this.on('connect', () => {\n      this.pending = false\n      QrcodeModal.close()\n    })\n\n    // open wallet when send signer transaction\n    this.on('call_request_sent', () => {\n      // open binance app via deeplink\n      openBinanceDeepLink()\n    })\n\n    //  dispatched by the Wallet when updating the session\n    this.on('wc_sessionUpdate', (error, payload) => {\n      if (error) {\n        this.handleSessionResponse()\n        return\n      }\n      if (payload.params && Array.isArray(payload.params)) {\n        this.handleSessionResponse(payload.params[0])\n      } else if (payload.error) {\n        this.handleSessionResponse()\n      }\n    })\n  }\n\n  private subscribeToSessionResponse(id: number) {\n    this.callbacks.set(`response-${id}`, (error, payload) => {\n      if (error) {\n        this.handleSessionResponse()\n        return\n      }\n      if (!payload) {\n        return\n      }\n      if (payload.result) {\n        this.handleSessionResponse(payload.result as SessionParams)\n      } else if (payload.error && payload.error.message) {\n        this.handleSessionResponse()\n      } else {\n        this.handleSessionResponse()\n      }\n    })\n  }\n\n  private handleSessionResponse(sessionParams?: SessionParams) {\n    if (sessionParams) {\n      if (sessionParams.approved) {\n        if (!this._connected) {\n          this._connected = true\n          if (sessionParams.chainId) {\n            this.setChainId(sessionParams.chainId)\n          }\n          if (sessionParams.accounts) {\n            this.setAddress(sessionParams.accounts)\n          }\n          if (sessionParams.peerId && !this.peerId) {\n            this.peerId = sessionParams.peerId\n          }\n          if (sessionParams.peerMeta && !this.peerMeta) {\n            this.peerMeta = sessionParams.peerMeta\n          }\n\n          this.events.emit('connect', {\n            chainId: this.chainId,\n            accounts: this.accounts,\n          })\n        } else {\n          if (sessionParams.chainId) {\n            this.setChainId(sessionParams.chainId)\n          }\n          if (sessionParams.accounts) {\n            this.setAddress(sessionParams.accounts)\n          }\n        }\n\n        this.manageStorageSession()\n      } else {\n        // disconnect connection at wallet side\n        if (this.connected) {\n          this.handleSessionDisconnect(DisconnectType.DisconnectAtWallet)\n        } else {\n          // user reject session creation\n          this.handleRejectSessionConnection(\n            new ProviderRpcError(\n              CONNECTION_ERR.REJECT_SESSION.code,\n              CONNECTION_ERR.REJECT_SESSION.message\n            )\n          )\n        }\n      }\n    } else {\n      // user reject session creation\n      this.handleRejectSessionConnection(\n        new ProviderRpcError(\n          CONNECTION_ERR.REJECT_SESSION.code,\n          CONNECTION_ERR.REJECT_SESSION.message\n        )\n      )\n    }\n  }\n\n  private handleRejectSessionConnection(error: Error) {\n    // close qrcode modal\n    QrcodeModal.close()\n    this.clearConnectionStatus()\n    this.events.emit('session_error', error)\n  }\n\n  private handleSessionDisconnect(type: DisconnectType) {\n    if (!this._connected) {\n      // close qrcode modal\n      QrcodeModal.close()\n    }\n\n    this.events.emit('disconnect', type)\n\n    this.clearConnectionStatus()\n  }\n\n  private clearConnectionStatus() {\n    if (this._connected) {\n      this._connected = false\n    }\n    if (this._handshakeId) {\n      this._handshakeId = 0\n    }\n    if (this._handshakeTopic) {\n      this._handshakeTopic = ''\n    }\n    if (this._peerId) {\n      this._peerId = ''\n    }\n    if (this._clientId) {\n      this._clientId = ''\n    }\n    if (this.pending) {\n      this.pending = false\n    }\n    this.callbacks.clear()\n    this._peerMeta = null\n    this._accounts = []\n    this._chainId = '0x0'\n\n    this.offConnectEvents()\n    this.removeStorageSession()\n    this.transport.close()\n  }\n\n  private offConnectEvents() {\n    this.removeListener('connect')\n  }\n\n  private setChainId(value?: number | string) {\n    const nextChainId = convertNumberToHex(value)\n    if (nextChainId === '0x0') {\n      this.chainId = nextChainId\n      return\n    }\n\n    if (typeof this.chainId !== 'undefined' && this.chainId !== nextChainId) {\n      this.events.emit('chainChanged', nextChainId)\n    }\n\n    this.chainId = nextChainId\n  }\n\n  private setAddress(value: string[] = []) {\n    const nextAddress = value\n      .filter((e) => typeof e === 'string')\n      .map((e) => e.toLowerCase())\n      .filter(Boolean)\n\n    // Note: deep compare to previous\n    if (JSON.stringify(this.accounts) !== JSON.stringify(nextAddress)) {\n      this.events.emit('accountsChanged', nextAddress)\n    }\n\n    this.accounts = nextAddress\n  }\n}\n","import { ClientMetadata, Session, Any } from '@binance/w3w-types'\nimport {\n  Events,\n  convertHexToArrayBuffer,\n  convertArrayBufferToHex,\n  getStorage,\n  removeStorage,\n  setStorage,\n  uuid,\n} from '@binance/w3w-utils'\n\nimport { SESSION_KEY } from './constants'\n\ntype JsonRpcCallback = (error: Error | null, response: Any) => void\n\nexport class BaseCore extends Events {\n  public pending = false\n\n  protected callbacks = new Map<string, JsonRpcCallback>()\n  protected clientMeta: ClientMetadata\n  protected relay: string\n\n  // -- connection ----------------------------------------------------- //\n\n  protected _key: ArrayBuffer | null = null\n\n  // -- client ----------------------------------------------------- //\n\n  protected _clientId = ''\n\n  // -- peer ----------------------------------------------------- //\n\n  protected _peerId = ''\n  protected _peerMeta: ClientMetadata | null = null\n\n  // -- handshake ----------------------------------------------------- //\n\n  protected _handshakeId = 0\n  protected _handshakeTopic = ''\n\n  // -- session ----------------------------------------------------- //\n\n  protected _connected = false\n  protected _accounts: string[] = []\n  protected _chainId = '0x0'\n\n  // -- setters / getters ----------------------------------------------- //\n\n  set key(value: string) {\n    if (!value) {\n      return\n    }\n    const key: ArrayBuffer = convertHexToArrayBuffer(value)\n    this._key = key\n  }\n\n  get key(): string {\n    if (this._key) {\n      const key: string = convertArrayBufferToHex(this._key, true)\n      return key\n    }\n    return ''\n  }\n\n  set clientId(value: string) {\n    if (!value) {\n      return\n    }\n    this._clientId = value\n  }\n\n  get clientId() {\n    let clientId: string | null = this._clientId\n    if (!clientId) {\n      clientId = this._clientId = uuid()\n    }\n\n    return this._clientId\n  }\n\n  set peerId(value) {\n    if (!value) {\n      return\n    }\n    this._peerId = value\n  }\n\n  get peerId() {\n    return this._peerId\n  }\n\n  set peerMeta(value) {\n    this._peerMeta = value\n  }\n\n  get peerMeta() {\n    return this._peerMeta\n  }\n\n  set handshakeTopic(value) {\n    if (!value) {\n      return\n    }\n    this._handshakeTopic = value\n  }\n\n  get handshakeTopic() {\n    return this._handshakeTopic\n  }\n\n  set handshakeId(value) {\n    if (!value) {\n      return\n    }\n    this._handshakeId = value\n  }\n\n  get handshakeId() {\n    return this._handshakeId\n  }\n\n  get uri() {\n    return `wc:${this.handshakeTopic}@1?bridge=${this.relay}&key=${this.key}&scene=bid`\n  }\n\n  set chainId(value) {\n    this._chainId = value\n  }\n\n  get chainId() {\n    const chainId: string | undefined = this._chainId\n    return chainId\n  }\n\n  set accounts(value) {\n    this._accounts = value\n  }\n\n  get accounts() {\n    const accounts: string[] | null = this._accounts\n    return accounts\n  }\n\n  set connected(_) {\n    // empty\n  }\n\n  get connected() {\n    return this._connected\n  }\n\n  get session() {\n    return {\n      connected: this.connected,\n      accounts: this.accounts,\n      chainId: this.chainId,\n      relay: this.relay,\n      key: this.key,\n      clientId: this.clientId,\n      clientMeta: this.clientMeta,\n      peerId: this.peerId,\n      peerMeta: this.peerMeta,\n      handshakeId: this.handshakeId,\n      handshakeTopic: this.handshakeTopic,\n    }\n  }\n\n  set session(value) {\n    if (!value) {\n      return\n    }\n    this._connected = value.connected\n    this.accounts = value.accounts\n    this.chainId = value.chainId\n    this.relay = value.relay\n    this.key = value.key\n    this.clientId = value.clientId\n    this.clientMeta = value.clientMeta\n    this.peerId = value.peerId\n    this.peerMeta = value.peerMeta\n    this.handshakeId = value.handshakeId\n    this.handshakeTopic = value.handshakeTopic\n  }\n}\n\nexport class SessionManage extends BaseCore {\n  protected getStorageSession() {\n    try {\n      return getStorage<Session>(SESSION_KEY)\n    } catch (error) {\n      // ignore error\n    }\n    return null\n  }\n\n  protected setStorageSession() {\n    setStorage<Session>(SESSION_KEY, this.session)\n  }\n\n  protected removeStorageSession() {\n    removeStorage(SESSION_KEY)\n  }\n\n  protected manageStorageSession() {\n    if (this._connected) {\n      this.setStorageSession()\n    } else {\n      this.removeStorageSession()\n    }\n  }\n}\n","export const SESSION_KEY = 'connect-session'\n\nexport const DOMAINS_KEY = 'connect-domains'\n\nexport const DOMAINS_CONFIGS_KEY = 'connect-domains-configs'\n\nexport const DEFAULT_RELAY = 'wss://nbstream.binance.com/wallet-connector'\n\nexport const BSC_RPCS = [\n  'https://rpc.ankr.com/bsc',\n  'https://binance.nodereal.io',\n  'https://bscrpc.com',\n  'https://bsc-dataseed2.ninicoin.io',\n]\n","import { detectWebSocket } from '@binance/w3w-socket-transport'\nimport {\n  isNode,\n  setStorage,\n  getStorage,\n  removeStorage,\n} from '@binance/w3w-utils'\nimport { Interface } from '@ethersproject/abi'\nimport axios from 'axios'\nimport { decode } from 'js-base64'\n\nimport {\n  BSC_RPCS,\n  DOMAINS_KEY,\n  DOMAINS_CONFIGS_KEY,\n  DEFAULT_RELAY,\n} from './constants'\n\ntype RpcResponse = {\n  id: string\n  jsonrpc: '2.0'\n  result: string\n}\n\n// get domains configs immediately when the app code initializes\nlet initDomainsConfigsPromise = null\n\nasync function getDomains() {\n  const res = await Promise.any(\n    BSC_RPCS.map((url) =>\n      axios.request<any, { data: RpcResponse }>({\n        url: url,\n        method: 'POST',\n        data: {\n          jsonrpc: '2.0',\n          id: Date.now(),\n          method: 'eth_call',\n          params: [\n            {\n              to: '0x76054B318785b588A3164B2A6eA5476F7cBA51e0',\n              data: '0x97b5f450',\n            },\n            'latest',\n          ],\n        },\n      })\n    )\n  )\n  const itf = new Interface(['function apiDomains() view returns (string)'])\n  const domains = decode(\n    itf.decodeFunctionResult('apiDomains', res.data.result)[0]\n  )\n\n  const domainStrList = domains.split(',')\n  setStorage(DOMAINS_CONFIGS_KEY, domainStrList)\n  console.log('🚀 ~ file: relay.ts ~ .then ~ domains configs:', domainStrList)\n  return domainStrList\n}\n\nfunction sortWebSocketByTtl(domains: { url: string; ttl: number }[]) {\n  return domains\n    .filter((item) => item.ttl > 0)\n    .sort((a, b) => a.ttl - b.ttl)\n    .map((item) => item.url)\n}\n\n/**\n * Retrieves all the domains of the connections.\n *\n * @return {Array} sortedDomains\n */\nasync function retrieveConnectionDomains(): Promise<string[]> {\n  const domainsConfigsFromStorage = getStorage<string[]>(DOMAINS_CONFIGS_KEY)\n  const domains =\n    domainsConfigsFromStorage?.length > 0\n      ? domainsConfigsFromStorage\n      : ((await initDomainsConfigsPromise) as string[])\n  const domainsWithTtl = await Promise.all(\n    domains.map((domain) => {\n      const subDomain = domain.split('.').slice(1).join('.')\n      return detectWebSocket(`wss://nbstream.${subDomain}/wallet-connector`)\n    })\n  )\n  const sortedDomains = sortWebSocketByTtl(domainsWithTtl)\n\n  return sortedDomains\n}\n\n/**\n * detective centain domains of the ws.\n *\n * @return {Array} sortedDomains\n */\nasync function detectiveWSConnections(wsUrls?: string[]): Promise<string[]> {\n  const domainsWithTtl = await Promise.all(\n    wsUrls?.map((wsUrl) => detectWebSocket(wsUrl))\n  )\n  const sortedDomains = sortWebSocketByTtl(domainsWithTtl || [])\n  return sortedDomains\n}\n\n// retrieves eligible connection urls immediately when the app code initializes\nlet initRetrivePromise = null\n\n/**\n * Retrieves all the domains of the connections relays.\n * @return {Array} sorted domains relays\n */\nasync function retrieveEligibleConnectionRelays(): Promise<string[]> {\n  const relaysFromStorage = getStorage<string[]>(DOMAINS_KEY)\n  try {\n    let relays = []\n    if (!relaysFromStorage || relaysFromStorage.length === 0) {\n      relays = await retrieveConnectionDomains()\n    } else {\n      const firstRelay = relaysFromStorage[0]\n      // if one domain is not available, we will be concerned that network had changed, need to update the eligible ws domains.\n      const isNetworkStatusChange =\n        (await detectiveWSConnections([firstRelay])).length === 0\n      if (isNetworkStatusChange) {\n        relays = await retrieveConnectionDomains()\n      } else {\n        relays = relaysFromStorage\n      }\n    }\n    console.log('🚀 ~ file: relay.ts ~ .then ~ domains:', relays)\n    setStorage(DOMAINS_KEY, relays)\n    return relays\n  } catch (error) {\n    return [] as string[]\n  }\n}\n\nif (!isNode()) {\n  initDomainsConfigsPromise = getDomains()\n  initRetrivePromise = retrieveEligibleConnectionRelays()\n}\n\nexport async function getEligibleConnectionRelays(): Promise<string[]> {\n  const relays = await (initRetrivePromise ||\n    retrieveEligibleConnectionRelays())\n\n  initRetrivePromise = null\n\n  if (relays.length === 0) {\n    // pod default relay\n    relays.push(DEFAULT_RELAY)\n  }\n\n  return relays\n}\n\nexport function removeRelayFromStorage(relay: string) {\n  const relays = getStorage<string[]>(DOMAINS_KEY)\n  if (!relays) return\n\n  const newRelays = relays.filter((item) => item !== relay)\n  setStorage(DOMAINS_KEY, newRelays)\n}\n\nexport function clearRelaysFromStorage() {\n  removeStorage(DOMAINS_KEY)\n}\n","import { ProviderRpcError, RPC_ERROR, MISC_ERR } from '@binance/w3w-utils'\n\nexport function populateError(error: Error) {\n  // user reject transaction\n  if (error.code === -32050 || error.code === -32000 || error.code === 1000) {\n    return new ProviderRpcError(\n      RPC_ERROR.REJECT_ERR.code,\n      RPC_ERROR.REJECT_ERR.message\n    )\n  }\n\n  // internal error\n  if (error.code === -32603) {\n    return new ProviderRpcError(\n      MISC_ERR.INTERNAL_ERR.code,\n      MISC_ERR.INTERNAL_ERR.message\n    )\n  }\n\n  // invalid params\n  if (error.code === -32600 || error.code === -32602) {\n    return new ProviderRpcError(\n      RPC_ERROR.INVALID_PARAM.code,\n      RPC_ERROR.INVALID_PARAM.message\n    )\n  }\n\n  return error\n}\n\nexport function removeQueryParams(url: string) {\n  const index = url.indexOf('?')\n  return index > -1 ? url.slice(0, index) : url\n}\n"]}