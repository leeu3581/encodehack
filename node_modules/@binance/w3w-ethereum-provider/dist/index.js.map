{"version":3,"sources":["../src/index.ts"],"names":["HttpClient","SignClient","log","signingMethods","utf8ToHex","getRpcUrl","formatJsonRpcRequest","isJsonRpcSuccess","isInBinance","normalizeChainId","EventEmitter","BinanceW3WProvider","opts","__publicField","args","requestArgs","res","message","callback","response","error","lng","chainId","nextChainId","event","listener","accounts","uri","rpcUrl","getProvider","provider","src_default"],"mappings":"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","sourcesContent":["import { HttpClient } from '@binance/w3w-http-client'\nimport { SignClient } from '@binance/w3w-sign-client'\nimport { IRpcConfig, IWCEthRpcConnectionOptions } from '@binance/w3w-types'\nimport {\n  log,\n  signingMethods,\n  utf8ToHex,\n  getRpcUrl,\n  formatJsonRpcRequest,\n  isJsonRpcSuccess,\n  isInBinance,\n  normalizeChainId,\n} from '@binance/w3w-utils'\nimport {\n  IEthereumProvider,\n  ProviderAccounts,\n  RequestArguments,\n} from 'eip1193-provider'\nimport EventEmitter from 'eventemitter3'\n\nclass BinanceW3WProvider implements IEthereumProvider {\n  public events: any = new EventEmitter()\n\n  private signClient: SignClient\n  private rpc: IRpcConfig\n  private httpClient: HttpClient\n  private optsChainId: number\n  private lng: string\n  private showQrCodeModal?: boolean\n\n  constructor(opts?: IWCEthRpcConnectionOptions) {\n    this.rpc = { infuraId: opts?.infuraId, custom: opts?.rpc }\n    this.lng = opts?.lng || 'en'\n    this.showQrCodeModal = opts?.showQrCodeModal\n\n    this.signClient = new SignClient()\n    this.optsChainId =\n      Number(this.signClient.coreConnection.chainId) || opts?.chainId || 56\n    this.registerEventListeners()\n    this.httpClient = this.setHttpProvider(this.optsChainId)\n  }\n\n  get connected(): boolean {\n    return this.signClient.connected\n  }\n\n  get connector(): SignClient {\n    return this.signClient\n  }\n\n  get accounts(): string[] {\n    return this.signClient.accounts\n  }\n\n  get chainId(): string {\n    log.debug('provider get chainId', this.signClient.chainId)\n    return this.signClient.chainId\n  }\n  get rpcUrl(): string {\n    return this.httpClient.url || ''\n  }\n\n  public async request(args: RequestArguments) {\n    log.debug('ethereum-provider request', args)\n    switch (args.method) {\n      case 'eth_requestAccounts':\n        await this.connect()\n        return this.accounts\n      case 'eth_chainId':\n        return this.chainId\n      case 'eth_accounts':\n        return this.accounts\n      case 'wallet_switchEthereumChain':\n        return this.switchChain(args)\n      default:\n        break\n    }\n    const requestArgs = formatJsonRpcRequest(args.method, args.params || [])\n    if (signingMethods.includes(args.method)) {\n      // Remove any\n      return this.signClient.request<any>(requestArgs)\n    }\n    if (typeof this.httpClient === 'undefined') {\n      throw new Error(\n        `Cannot request JSON-RPC method (${args.method}) without provided rpc url`\n      )\n    }\n    const res = await this.httpClient.request(requestArgs)\n    if (isJsonRpcSuccess(res)) {\n      return res.result\n    } else {\n      throw new Error(res.error.message)\n    }\n  }\n\n  public async signMessage(message: string): Promise<string> {\n    log.debug('signMessage', message)\n    if (!this.accounts.length) {\n      await this.enable()\n    }\n    return await this.request({\n      method: 'personal_sign',\n      params: [utf8ToHex(message), this.accounts[0]],\n    })\n  }\n\n  public sendAsync(\n    args: RequestArguments,\n    callback: (error: Error | null, response: any) => void\n  ): void {\n    this.request(args)\n      .then((response) => callback(null, response))\n      .catch((error) => callback(error, undefined))\n  }\n  public setLng(lng: string): void {\n    this.lng = lng\n  }\n\n  public async enable(chainId?: number): Promise<ProviderAccounts> {\n    await this.connect(chainId)\n    return this.accounts\n  }\n\n  private async switchChain(args: RequestArguments): Promise<void> {\n    const requestArgs = formatJsonRpcRequest(args.method, args.params || [])\n    const res = await Promise.race([\n      this.signClient.request<any>(requestArgs),\n      new Promise((res) =>\n        this.on('chainChanged', (nextChainId) => {\n          if (nextChainId === args.params[0].chainId) res(nextChainId)\n        })\n      ),\n    ])\n    return res\n  }\n\n  private async connect(chainId?: number): Promise<void> {\n    if (!this.connected) {\n      await this.signClient.open({\n        requestChainId: chainId?.toString() ?? this.optsChainId.toString(),\n        lng: this.lng,\n        showQrCodeModal: this.showQrCodeModal,\n      })\n    } else {\n      log.info('already connected')\n    }\n  }\n\n  public disconnect() {\n    if (this.connected) {\n      this.signClient.disconnect()\n    }\n  }\n\n  public on(event: any, listener: any): void {\n    this.events.on(event, listener)\n  }\n  public once(event: string, listener: any): void {\n    this.events.once(event, listener)\n  }\n  public removeListener(event: string, listener: any): void {\n    this.events.removeListener(event, listener)\n  }\n  public off(event: string, listener: any): void {\n    this.events.off(event, listener)\n  }\n\n  get isWalletConnect() {\n    return true\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private registerEventListeners() {\n    this.signClient.on('accountsChanged', (accounts) => {\n      this.events.emit('accountsChanged', accounts)\n    })\n    this.signClient.on('chainChanged', (chainId) => {\n      this.httpClient = this.setHttpProvider(normalizeChainId(chainId))\n      this.events.emit('chainChanged', chainId)\n    })\n    this.signClient.on('disconnect', () => {\n      this.events.emit('disconnect')\n    })\n    this.signClient.on('uri_ready', (uri: string) => {\n      this.events.emit('uri_ready', uri)\n    })\n  }\n  private setHttpProvider(chainId: number): HttpClient | undefined {\n    const rpcUrl = getRpcUrl(chainId, this.rpc)\n    if (typeof rpcUrl === 'undefined') return undefined\n    return new HttpClient(rpcUrl)\n  }\n}\n\nexport const getProvider = (\n  opts?: IWCEthRpcConnectionOptions\n): BinanceW3WProvider => {\n  const isBinance = isInBinance()\n  if (isBinance) {\n    const provider =\n      typeof window !== 'undefined' ? (window as any).ethereum : undefined\n    if (provider) {\n      provider.setLng = () => {}\n      provider.disconnect = () => {}\n      return provider as BinanceW3WProvider\n    }\n  }\n  return new BinanceW3WProvider(opts)\n}\nexport default BinanceW3WProvider\n"]}