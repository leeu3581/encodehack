{"version":3,"sources":["../src/index.ts"],"names":["Events","NodeWS","WS","SocketTransport","opts","__publicField","value","urls","message","topic","silent","url","event","e","socketMessage","detectWebSocket","start","resolve","ws"],"mappings":"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","sourcesContent":["import {\n  ITransportLib,\n  SocketMessage,\n  SocketTransportOptions,\n} from '@binance/w3w-types'\nimport { Events } from '@binance/w3w-utils'\nimport NodeWS from 'ws'\n\nconst WS = typeof window !== 'undefined' ? window.WebSocket : NodeWS\n\n// -- SocketTransport ------------------------------------------------------ //\n\nexport class SocketTransport extends Events implements ITransportLib {\n  private qs: string\n  private urls: string[] = []\n  private url: string\n  private socket: WebSocket | null\n  private nextSocket: WebSocket | null\n  private queue: SocketMessage[] = []\n  private subscriptions: string[] = []\n  private retryIndex = 0\n\n  // -- constructor ----------------------------------------------------- //\n\n  constructor(private opts: SocketTransportOptions) {\n    super()\n\n    this.socket = null\n    this.nextSocket = null\n    this.subscriptions = opts.subscriptions || []\n    this.qs = `env=browser&protocol=wc&version=${opts.version}`\n  }\n\n  set readyState(value) {\n    // empty\n  }\n\n  get readyState(): number {\n    return this.socket ? this.socket.readyState : -1\n  }\n\n  set connecting(value) {\n    // empty\n  }\n\n  get connecting(): boolean {\n    return this.readyState === 0\n  }\n\n  set connected(value) {\n    // empty\n  }\n\n  get connected(): boolean {\n    return this.readyState === 1\n  }\n\n  set retryFailed(value) {\n    // empty\n  }\n\n  get retryFailed(): boolean {\n    return this.retryIndex > 0 && this.retryIndex > this.urls.length\n  }\n\n  // -- public ---------------------------------------------------------- //\n\n  public open(urls: string[]) {\n    if (!Array.isArray(urls) || urls.length === 0) {\n      throw new Error('Missing or invalid WebSocket url')\n    }\n\n    this.urls = urls\n    this.retryIndex = 0\n    this.socketCreate()\n  }\n\n  public close() {\n    this._socketClose()\n  }\n\n  public send(message: string, topic?: string, silent?: boolean): void {\n    if (!topic || typeof topic !== 'string') {\n      throw new Error('Missing or invalid topic field')\n    }\n\n    this.socketSend({\n      topic: topic,\n      type: 'pub',\n      payload: message,\n      silent: !!silent,\n    })\n  }\n\n  public subscribe(topic: string) {\n    this.socketSend({\n      topic: topic,\n      type: 'sub',\n      payload: '',\n      silent: true,\n    })\n  }\n\n  // -- private ---------------------------------------------------------- //\n\n  private socketCreate() {\n    if (this.nextSocket) {\n      return\n    }\n\n    const url = this.url || this.getWsUrl()\n    if (!url) {\n      return this.events.emit(\n        'error',\n        new Error(\"Retry limit reached. Can't connect to any url.\"),\n        url\n      )\n    }\n    this.url = url\n    this.nextSocket = new WS(url)\n\n    if (!this.nextSocket) {\n      throw new Error('Failed to create socket')\n    }\n\n    this.nextSocket.onmessage = (event: MessageEvent) =>\n      this.socketReceive(event)\n\n    this.nextSocket.onopen = () => this.socketOpen()\n\n    this.nextSocket.onerror = (event: Event) => this.socketError(event, url)\n\n    this.nextSocket.onclose = (e) => {\n      this.nextSocket = null\n      this.socketCreate()\n    }\n  }\n\n  private getWsUrl() {\n    if (this.retryIndex >= this.urls.length) {\n      return ''\n    }\n\n    return `${this.urls[this.retryIndex++]}?${this.qs}`\n  }\n\n  private socketOpen() {\n    this._socketClose()\n    this.socket = this.nextSocket\n    this.nextSocket = null\n    this.queueSubscriptions()\n    this.pushQueue()\n\n    this.events.emit('open', this.urls[this.retryIndex - 1])\n  }\n\n  private _socketClose() {\n    if (this.socket) {\n      this.socket.onclose = () => {\n        // empty\n      }\n      this.socket.close()\n      this.events.emit('close')\n    }\n  }\n\n  private socketSend(socketMessage: SocketMessage) {\n    const message: string = JSON.stringify(socketMessage)\n\n    if (this.socket && this.socket.readyState === 1) {\n      this.socket.send(message)\n    } else {\n      this.setToQueue(socketMessage)\n    }\n  }\n\n  private socketReceive(event: MessageEvent) {\n    let socketMessage: SocketMessage\n\n    try {\n      socketMessage = JSON.parse(event.data)\n    } catch (error) {\n      return\n    }\n\n    this.socketSend({\n      topic: socketMessage.topic,\n      type: 'ack',\n      payload: '',\n      silent: true,\n    })\n\n    if (this.socket && this.socket.readyState === 1) {\n      this.events.emit('message', socketMessage)\n    }\n  }\n\n  private socketError(e: Event, url: string) {\n    this.events.emit('error', e, url)\n  }\n\n  private queueSubscriptions() {\n    const subscriptions = this.subscriptions\n\n    subscriptions.forEach((topic: string) =>\n      this.queue.push({\n        topic: topic,\n        type: 'sub',\n        payload: '',\n        silent: true,\n      })\n    )\n\n    this.subscriptions = this.opts.subscriptions || []\n  }\n\n  private setToQueue(socketMessage: SocketMessage) {\n    this.queue.push(socketMessage)\n  }\n\n  private pushQueue() {\n    const queue = this.queue\n\n    queue.forEach((socketMessage: SocketMessage) =>\n      this.socketSend(socketMessage)\n    )\n\n    this.queue = []\n  }\n}\n\nexport type DetectWebsocketResult = {\n  ttl: number\n  url: string\n}\n\nexport function detectWebSocket(url: string): Promise<DetectWebsocketResult> {\n  const start = Date.now()\n  return new Promise((resolve) => {\n    try {\n      setTimeout(() => {\n        resolve({ ttl: 0, url })\n      }, 5000)\n      const ws = new WS(url)\n      ws.onopen = () => {\n        ws.close()\n        resolve({ ttl: Date.now() - start, url })\n      }\n      ws.onerror = () => {\n        resolve({ ttl: 0, url })\n      }\n    } catch (error) {\n      resolve({ ttl: 0, url })\n    }\n  })\n}\n"]}