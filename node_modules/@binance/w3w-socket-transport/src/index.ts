import {
  ITransportLib,
  SocketMessage,
  SocketTransportOptions,
} from '@binance/w3w-types'
import { Events } from '@binance/w3w-utils'
import NodeWS from 'ws'

const WS = typeof window !== 'undefined' ? window.WebSocket : NodeWS

// -- SocketTransport ------------------------------------------------------ //

export class SocketTransport extends Events implements ITransportLib {
  private qs: string
  private urls: string[] = []
  private url: string
  private socket: WebSocket | null
  private nextSocket: WebSocket | null
  private queue: SocketMessage[] = []
  private subscriptions: string[] = []
  private retryIndex = 0

  // -- constructor ----------------------------------------------------- //

  constructor(private opts: SocketTransportOptions) {
    super()

    this.socket = null
    this.nextSocket = null
    this.subscriptions = opts.subscriptions || []
    this.qs = `env=browser&protocol=wc&version=${opts.version}`
  }

  set readyState(value) {
    // empty
  }

  get readyState(): number {
    return this.socket ? this.socket.readyState : -1
  }

  set connecting(value) {
    // empty
  }

  get connecting(): boolean {
    return this.readyState === 0
  }

  set connected(value) {
    // empty
  }

  get connected(): boolean {
    return this.readyState === 1
  }

  set retryFailed(value) {
    // empty
  }

  get retryFailed(): boolean {
    return this.retryIndex > 0 && this.retryIndex > this.urls.length
  }

  // -- public ---------------------------------------------------------- //

  public open(urls: string[]) {
    if (!Array.isArray(urls) || urls.length === 0) {
      throw new Error('Missing or invalid WebSocket url')
    }

    this.urls = urls
    this.retryIndex = 0
    this.socketCreate()
  }

  public close() {
    this._socketClose()
  }

  public send(message: string, topic?: string, silent?: boolean): void {
    if (!topic || typeof topic !== 'string') {
      throw new Error('Missing or invalid topic field')
    }

    this.socketSend({
      topic: topic,
      type: 'pub',
      payload: message,
      silent: !!silent,
    })
  }

  public subscribe(topic: string) {
    this.socketSend({
      topic: topic,
      type: 'sub',
      payload: '',
      silent: true,
    })
  }

  // -- private ---------------------------------------------------------- //

  private socketCreate() {
    if (this.nextSocket) {
      return
    }

    const url = this.url || this.getWsUrl()
    if (!url) {
      return this.events.emit(
        'error',
        new Error("Retry limit reached. Can't connect to any url."),
        url
      )
    }
    this.url = url
    this.nextSocket = new WS(url)

    if (!this.nextSocket) {
      throw new Error('Failed to create socket')
    }

    this.nextSocket.onmessage = (event: MessageEvent) =>
      this.socketReceive(event)

    this.nextSocket.onopen = () => this.socketOpen()

    this.nextSocket.onerror = (event: Event) => this.socketError(event, url)

    this.nextSocket.onclose = (e) => {
      this.nextSocket = null
      this.socketCreate()
    }
  }

  private getWsUrl() {
    if (this.retryIndex >= this.urls.length) {
      return ''
    }

    return `${this.urls[this.retryIndex++]}?${this.qs}`
  }

  private socketOpen() {
    this._socketClose()
    this.socket = this.nextSocket
    this.nextSocket = null
    this.queueSubscriptions()
    this.pushQueue()

    this.events.emit('open', this.urls[this.retryIndex - 1])
  }

  private _socketClose() {
    if (this.socket) {
      this.socket.onclose = () => {
        // empty
      }
      this.socket.close()
      this.events.emit('close')
    }
  }

  private socketSend(socketMessage: SocketMessage) {
    const message: string = JSON.stringify(socketMessage)

    if (this.socket && this.socket.readyState === 1) {
      this.socket.send(message)
    } else {
      this.setToQueue(socketMessage)
    }
  }

  private socketReceive(event: MessageEvent) {
    let socketMessage: SocketMessage

    try {
      socketMessage = JSON.parse(event.data)
    } catch (error) {
      return
    }

    this.socketSend({
      topic: socketMessage.topic,
      type: 'ack',
      payload: '',
      silent: true,
    })

    if (this.socket && this.socket.readyState === 1) {
      this.events.emit('message', socketMessage)
    }
  }

  private socketError(e: Event, url: string) {
    this.events.emit('error', e, url)
  }

  private queueSubscriptions() {
    const subscriptions = this.subscriptions

    subscriptions.forEach((topic: string) =>
      this.queue.push({
        topic: topic,
        type: 'sub',
        payload: '',
        silent: true,
      })
    )

    this.subscriptions = this.opts.subscriptions || []
  }

  private setToQueue(socketMessage: SocketMessage) {
    this.queue.push(socketMessage)
  }

  private pushQueue() {
    const queue = this.queue

    queue.forEach((socketMessage: SocketMessage) =>
      this.socketSend(socketMessage)
    )

    this.queue = []
  }
}

export type DetectWebsocketResult = {
  ttl: number
  url: string
}

export function detectWebSocket(url: string): Promise<DetectWebsocketResult> {
  const start = Date.now()
  return new Promise((resolve) => {
    try {
      setTimeout(() => {
        resolve({ ttl: 0, url })
      }, 5000)
      const ws = new WS(url)
      ws.onopen = () => {
        ws.close()
        resolve({ ttl: Date.now() - start, url })
      }
      ws.onerror = () => {
        resolve({ ttl: 0, url })
      }
    } catch (error) {
      resolve({ ttl: 0, url })
    }
  })
}
