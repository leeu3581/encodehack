{"version":3,"sources":["../src/index.ts"],"names":["formatJsonRpcError","isHttpUrl","log","parseConnectionError","safeJsonParse","safeJsonStringify","fetch","EventEmitter","DEFAULT_HTTP_HEADERS","DEFAULT_HTTP_METHOD","DEFAULT_FETCH_OPTS","HttpClient","url","__publicField","payload","body","data","result","e","id","error","message","resolve","reject"],"mappings":"wKACA,OACE,sBAAAA,EACA,aAAAC,EACA,OAAAC,EACA,wBAAAC,EACA,iBAAAC,EACA,qBAAAC,MACK,qBACP,OAAOC,MAAW,cAClB,OAAS,gBAAAC,MAAoB,gBAE7B,IAAMC,EAAuB,CAC3B,OAAQ,mBACR,eAAgB,kBAClB,EAEMC,EAAsB,OAEtBC,EAAqB,CACzB,QAASF,EACT,OAAQC,CACV,EAEaE,EAAN,KAAiB,CAOtB,YAAmBC,EAAa,CAAb,SAAAA,EANnBC,EAAA,KAAO,SAAS,IAAIN,GAEpBM,EAAA,KAAQ,cAAc,IAEtBA,EAAA,KAAQ,cAAc,IAGpB,GAAI,CAACZ,EAAUW,CAAG,EAChB,MAAM,IAAI,MACR,wDAAwDA,GAC1D,EAEF,KAAK,IAAMA,CACb,CAEA,IAAI,WAAqB,CACvB,OAAO,KAAK,WACd,CAEA,IAAI,YAAsB,CACxB,OAAO,KAAK,WACd,CAEA,MAAa,KAAKA,EAAc,KAAK,IAAoB,CACvD,MAAM,KAAK,SAASA,CAAG,CACzB,CAGA,MAAa,OAAQ,CACnB,GAAI,CAAC,KAAK,YACR,MAAM,IAAI,MAAM,2BAA2B,EAE7C,KAAK,QAAQ,CACf,CAEA,MAAa,QAAQE,EAAmD,CACtEZ,EAAI,MAAM,kCAAmCY,CAAO,EAC/C,KAAK,aACR,MAAM,KAAK,SAAS,EAEtB,GAAI,CACF,IAAMC,EAAOV,EAAkBS,CAAO,EAEhCE,EAAO,MADD,MAAMV,EAAM,KAAK,IAAK,CAAE,GAAGI,EAAoB,KAAAK,CAAK,CAAC,GAC1C,KAAK,EACtBE,EAAS,OAAOD,GAAS,SAAWZ,EAAcY,CAAI,EAAIA,EAChE,OAAAd,EAAI,MAAM,iCAAkCe,CAAM,EAC3CA,CACT,OAASC,EAAP,CACA,OAAO,KAAK,YAAYJ,EAAQ,GAAII,CAAC,CACvC,CACF,CAIQ,YAAYC,EAAYD,EAAU,CACxC,IAAME,EAAQ,KAAK,WAAWF,CAAC,EACzBG,EAAUD,EAAM,SAAWA,EAAM,SAAS,EAEhD,OADgBpB,EAAmBmB,EAAIE,CAAO,CAEhD,CAEA,MAAc,SAAST,EAAM,KAAK,IAAoB,CACpD,GAAI,CAACX,EAAUW,CAAG,EAChB,MAAM,IAAI,MACR,wDAAwDA,GAC1D,EAEF,GAAI,KAAK,YACP,OAAO,IAAI,QAAQ,CAACU,EAASC,IAAW,CACtC,KAAK,OAAO,KAAK,iBAAmBH,GAAU,CAC5CG,EAAOH,CAAK,CACd,CAAC,EACD,KAAK,OAAO,KAAK,OAAQ,IAAM,CAC7B,GAAI,OAAO,KAAK,YAAgB,IAC9B,OAAOG,EAAO,IAAI,MAAM,uCAAuC,CAAC,EAElED,EAAQ,CACV,CAAC,CACH,CAAC,EAEH,KAAK,IAAMV,EACX,KAAK,YAAc,GACnB,GAAI,CACF,IAAMG,EAAOV,EAAkB,CAC7B,GAAI,EACJ,QAAS,MACT,OAAQ,OACR,OAAQ,CAAC,CACX,CAAC,EACD,MAAMC,EAAMM,EAAK,CAAE,GAAGF,EAAoB,KAAAK,CAAK,CAAC,EAChD,KAAK,OAAO,CACd,OAASG,EAAP,CACA,IAAME,EAAQ,KAAK,WAAWF,CAAC,EAC/B,WAAK,OAAO,KAAK,iBAAkBE,CAAK,EACxC,KAAK,QAAQ,EACPA,CACR,CACF,CAEQ,QAAS,CACf,KAAK,YAAc,GACnB,KAAK,YAAc,GACnB,KAAK,OAAO,KAAK,MAAM,CACzB,CAEQ,SAAU,CAChB,KAAK,YAAc,GACnB,KAAK,YAAc,GACnB,KAAK,OAAO,KAAK,MAAM,CACzB,CAEQ,WAAW,EAAUR,EAAM,KAAK,IAAK,CAC3C,OAAOT,EAAqB,EAAGS,EAAK,MAAM,CAC5C,CACF","sourcesContent":["import { JsonRpcPayload, JsonRpcResponse } from '@binance/w3w-types'\nimport {\n  formatJsonRpcError,\n  isHttpUrl,\n  log,\n  parseConnectionError,\n  safeJsonParse,\n  safeJsonStringify,\n} from '@binance/w3w-utils'\nimport fetch from 'cross-fetch'\nimport { EventEmitter } from 'eventemitter3'\n\nconst DEFAULT_HTTP_HEADERS = {\n  Accept: 'application/json',\n  'Content-Type': 'application/json',\n}\n\nconst DEFAULT_HTTP_METHOD = 'POST'\n\nconst DEFAULT_FETCH_OPTS = {\n  headers: DEFAULT_HTTP_HEADERS,\n  method: DEFAULT_HTTP_METHOD,\n}\n\nexport class HttpClient {\n  public events = new EventEmitter()\n\n  private isAvailable = false\n\n  private registering = false\n\n  constructor(public url: string) {\n    if (!isHttpUrl(url)) {\n      throw new Error(\n        `Provided URL is not compatible with HTTP connection: ${url}`\n      )\n    }\n    this.url = url\n  }\n\n  get connected(): boolean {\n    return this.isAvailable\n  }\n\n  get connecting(): boolean {\n    return this.registering\n  }\n\n  public async open(url: string = this.url): Promise<void> {\n    await this.register(url)\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  public async close() {\n    if (!this.isAvailable) {\n      throw new Error('Connection already closed')\n    }\n    this.onClose()\n  }\n\n  public async request(payload: JsonRpcPayload): Promise<JsonRpcResponse> {\n    log.debug('HttpClient ~ request ~ payload:', payload)\n    if (!this.isAvailable) {\n      await this.register()\n    }\n    try {\n      const body = safeJsonStringify(payload)\n      const res = await fetch(this.url, { ...DEFAULT_FETCH_OPTS, body })\n      const data = await res.json()\n      const result = typeof data === 'string' ? safeJsonParse(data) : data\n      log.debug('HttpClient ~ request ~ result:', result)\n      return result\n    } catch (e) {\n      return this.formatError(payload.id, e)\n    }\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private formatError(id: number, e: Error) {\n    const error = this.parseError(e)\n    const message = error.message || error.toString()\n    const payload = formatJsonRpcError(id, message)\n    return payload\n  }\n\n  private async register(url = this.url): Promise<void> {\n    if (!isHttpUrl(url)) {\n      throw new Error(\n        `Provided URL is not compatible with HTTP connection: ${url}`\n      )\n    }\n    if (this.registering) {\n      return new Promise((resolve, reject) => {\n        this.events.once('register_error', (error) => {\n          reject(error)\n        })\n        this.events.once('open', () => {\n          if (typeof this.isAvailable === 'undefined') {\n            return reject(new Error('HTTP connection is missing or invalid'))\n          }\n          resolve()\n        })\n      })\n    }\n    this.url = url\n    this.registering = true\n    try {\n      const body = safeJsonStringify({\n        id: 1,\n        jsonrpc: '2.0',\n        method: 'test',\n        params: [],\n      })\n      await fetch(url, { ...DEFAULT_FETCH_OPTS, body })\n      this.onOpen()\n    } catch (e) {\n      const error = this.parseError(e)\n      this.events.emit('register_error', error)\n      this.onClose()\n      throw error\n    }\n  }\n\n  private onOpen() {\n    this.isAvailable = true\n    this.registering = false\n    this.events.emit('open')\n  }\n\n  private onClose() {\n    this.isAvailable = false\n    this.registering = false\n    this.events.emit('open')\n  }\n\n  private parseError(e: Error, url = this.url) {\n    return parseConnectionError(e, url, 'HTTP')\n  }\n}\n"]}