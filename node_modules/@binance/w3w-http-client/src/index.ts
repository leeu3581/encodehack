import { JsonRpcPayload, JsonRpcResponse } from '@binance/w3w-types'
import {
  formatJsonRpcError,
  isHttpUrl,
  log,
  parseConnectionError,
  safeJsonParse,
  safeJsonStringify,
} from '@binance/w3w-utils'
import fetch from 'cross-fetch'
import { EventEmitter } from 'eventemitter3'

const DEFAULT_HTTP_HEADERS = {
  Accept: 'application/json',
  'Content-Type': 'application/json',
}

const DEFAULT_HTTP_METHOD = 'POST'

const DEFAULT_FETCH_OPTS = {
  headers: DEFAULT_HTTP_HEADERS,
  method: DEFAULT_HTTP_METHOD,
}

export class HttpClient {
  public events = new EventEmitter()

  private isAvailable = false

  private registering = false

  constructor(public url: string) {
    if (!isHttpUrl(url)) {
      throw new Error(
        `Provided URL is not compatible with HTTP connection: ${url}`
      )
    }
    this.url = url
  }

  get connected(): boolean {
    return this.isAvailable
  }

  get connecting(): boolean {
    return this.registering
  }

  public async open(url: string = this.url): Promise<void> {
    await this.register(url)
  }

  // eslint-disable-next-line @typescript-eslint/require-await
  public async close() {
    if (!this.isAvailable) {
      throw new Error('Connection already closed')
    }
    this.onClose()
  }

  public async request(payload: JsonRpcPayload): Promise<JsonRpcResponse> {
    log.debug('HttpClient ~ request ~ payload:', payload)
    if (!this.isAvailable) {
      await this.register()
    }
    try {
      const body = safeJsonStringify(payload)
      const res = await fetch(this.url, { ...DEFAULT_FETCH_OPTS, body })
      const data = await res.json()
      const result = typeof data === 'string' ? safeJsonParse(data) : data
      log.debug('HttpClient ~ request ~ result:', result)
      return result
    } catch (e) {
      return this.formatError(payload.id, e)
    }
  }

  // ---------- Private ----------------------------------------------- //

  private formatError(id: number, e: Error) {
    const error = this.parseError(e)
    const message = error.message || error.toString()
    const payload = formatJsonRpcError(id, message)
    return payload
  }

  private async register(url = this.url): Promise<void> {
    if (!isHttpUrl(url)) {
      throw new Error(
        `Provided URL is not compatible with HTTP connection: ${url}`
      )
    }
    if (this.registering) {
      return new Promise((resolve, reject) => {
        this.events.once('register_error', (error) => {
          reject(error)
        })
        this.events.once('open', () => {
          if (typeof this.isAvailable === 'undefined') {
            return reject(new Error('HTTP connection is missing or invalid'))
          }
          resolve()
        })
      })
    }
    this.url = url
    this.registering = true
    try {
      const body = safeJsonStringify({
        id: 1,
        jsonrpc: '2.0',
        method: 'test',
        params: [],
      })
      await fetch(url, { ...DEFAULT_FETCH_OPTS, body })
      this.onOpen()
    } catch (e) {
      const error = this.parseError(e)
      this.events.emit('register_error', error)
      this.onClose()
      throw error
    }
  }

  private onOpen() {
    this.isAvailable = true
    this.registering = false
    this.events.emit('open')
  }

  private onClose() {
    this.isAvailable = false
    this.registering = false
    this.events.emit('open')
  }

  private parseError(e: Error, url = this.url) {
    return parseConnectionError(e, url, 'HTTP')
  }
}
