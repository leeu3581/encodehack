import { addresses, createSwapFromSolanaInstructions, createSwapFromSuiMoveCalls, generateFetchQuoteUrl, getSwapFromEvmTxPayload, } from "@mayanfinance/swap-sdk";
import { MessageV0, PublicKey, VersionedTransaction } from "@solana/web3.js";
import { TransferState, Wormhole, amount, canonicalAddress, isAttested, isCompleted, isNative, isRedeemed, isRefunded, isSameToken, isSignAndSendSigner, isSignOnlySigner, isSourceFinalized, isSourceInitiated, nativeChainIds, routes, } from "@wormhole-foundation/sdk-connect";
import { circle, } from "@wormhole-foundation/sdk-base";
import { EvmPlatform, EvmUnsignedTransaction, } from "@wormhole-foundation/sdk-evm";
import { SolanaPlatform, SolanaUnsignedTransaction, } from "@wormhole-foundation/sdk-solana";
import { SuiPlatform, SuiUnsignedTransaction, } from "@wormhole-foundation/sdk-sui";
import axios from "axios";
import { fetchTokensForChain, getNativeContractAddress, getTransactionStatus, getUSDCTokenId, supportedChains, toMayanChainName, txStatusToReceipt, } from "./utils";
class MayanRouteBase extends routes.AutomaticRoute {
    MAX_SLIPPAGE = 1;
    static NATIVE_GAS_DROPOFF_SUPPORTED = false;
    static IS_AUTOMATIC = true;
    protocols = ['WH', 'MCTP', 'SWIFT', 'SHUTTLE'];
    getDefaultOptions() {
        return {
            gasDrop: 0,
            slippageBps: 'auto',
            optimizeFor: 'speed'
        };
    }
    static supportedNetworks() {
        return ["Mainnet"];
    }
    static supportedChains(_) {
        return supportedChains();
    }
    static async supportedSourceTokens(fromChain) {
        return fetchTokensForChain(fromChain.chain);
    }
    static isProtocolSupported(chain) {
        return supportedChains().includes(chain.chain);
    }
    static async supportedDestinationTokens(_token, fromChain, toChain) {
        if (!supportedChains().includes(fromChain.chain) || !supportedChains().includes(toChain.chain)) {
            return [];
        }
        return fetchTokensForChain(toChain.chain);
    }
    async isAvailable() {
        // No way to check relayer availability so assume true
        return true;
    }
    async validate(request, params) {
        try {
            params.options = params.options ?? this.getDefaultOptions();
            return {
                valid: true,
                params: {
                    ...params,
                    normalizedParams: {
                        slippageBps: params.options.slippageBps,
                    },
                },
            };
        }
        catch (e) {
            return { valid: false, params, error: e };
        }
    }
    toMayanAddress(tokenId) {
        return !isNative(tokenId.address)
            ? canonicalAddress(tokenId)
            : getNativeContractAddress(tokenId.chain);
    }
    async fetchQuote(request, params) {
        const { fromChain, toChain } = request;
        const quoteParams = {
            amount: Number(params.amount),
            fromToken: this.toMayanAddress(request.source.id),
            toToken: this.toMayanAddress(request.destination.id),
            fromChain: toMayanChainName(fromChain.chain),
            toChain: toMayanChainName(toChain.chain),
            ...this.getDefaultOptions(),
            ...params.options,
            slippageBps: 'auto',
        };
        const quoteOpts = {
            swift: this.protocols.includes('SWIFT'),
            mctp: this.protocols.includes('MCTP'),
            shuttle: this.protocols.includes('SHUTTLE'),
        };
        const fetchQuoteUrl = new URL(generateFetchQuoteUrl(quoteParams, quoteOpts));
        if (!fetchQuoteUrl) {
            throw new Error("Unable to generate fetch quote URL");
        }
        if (!fetchQuoteUrl.searchParams.has('fullList')) {
            // Attach the fullList param to fetch all quotes
            fetchQuoteUrl.searchParams.append('fullList', 'true');
        }
        const res = await axios.get(fetchQuoteUrl.toString());
        if (res.status !== 200) {
            throw new Error("Unable to fetch quote", { cause: res });
        }
        const quotes = res.data?.quotes?.filter((quote) => this.protocols.includes(quote.type));
        if (!quotes || quotes.length === 0)
            return undefined;
        if (quotes.length === 1)
            return quotes[0];
        // Wormhole SDK routes return only a single quote, but Mayan offers multiple quotes (because 
        // Mayan comprises multiple competing protocols). We sort the quotes Mayan gives us and choose
        // the best one here.
        //
        // User can provide optimizeFor option to indicate what they care about. It defaults to "cost"
        // which just optimizes for highest amount out, but it can also be set to "speed" which will
        // choose the fastest route instead.
        quotes.sort((a, b) => {
            if (params.options.optimizeFor === 'cost') {
                if (b.expectedAmountOut === a.expectedAmountOut) {
                    // If expected amounts out are identical, fall back to speed
                    /* @ts-ignore */
                    return a.etaSeconds - b.etaSeconds;
                }
                else {
                    // Otherwise sort by amount out, descending
                    return b.expectedAmountOut - a.expectedAmountOut;
                }
            }
            else if (params.options.optimizeFor === 'speed') {
                /* @ts-ignore */
                if (a.etaSeconds === b.etaSeconds) {
                    // If ETAs are identical, fall back to cost
                    return b.expectedAmountOut - a.expectedAmountOut;
                }
                else {
                    // Otherwise sort by ETA, ascending
                    /* @ts-ignore */
                    return a.etaSeconds - b.etaSeconds;
                }
            }
            else {
                // Should be unreachable
                return 0;
            }
        });
        return quotes[0];
    }
    async quote(request, params) {
        try {
            const quote = await this.fetchQuote(request, params);
            if (!quote) {
                return {
                    success: false,
                    error: new routes.UnavailableError(new Error(`Couldn't fetch a quote`)),
                };
            }
            // Mayan fees are complicated and they normalize them for us in USD as clientRelayerFeeSuccess
            // We return this value as-is and express it as a USDC value for the sake of formatting
            const relayFee = {
                token: {
                    chain: 'Solana',
                    address: Wormhole.parseAddress('Solana', circle.usdcContract.get(request.fromChain.network, 'Solana')),
                },
                amount: amount.parse(amount.denoise(quote.clientRelayerFeeSuccess || '0', 6), 6),
            };
            const fullQuote = {
                success: true,
                params,
                sourceToken: {
                    token: request.source.id,
                    amount: amount.parse(amount.denoise(quote.effectiveAmountIn, quote.fromToken.decimals), quote.fromToken.decimals),
                },
                destinationToken: {
                    token: request.destination.id,
                    amount: amount.parse(amount.denoise(quote.expectedAmountOut, quote.toToken.decimals), quote.toToken.decimals),
                },
                relayFee,
                destinationNativeGas: amount.parse(amount.denoise(quote.gasDrop, quote.toToken.decimals), quote.toToken.decimals),
                /* @ts-ignore TODO: https://github.com/mayan-finance/swap-sdk/pull/11 */
                eta: quote.etaSeconds * 1000,
                details: quote,
            };
            return fullQuote;
        }
        catch (e) {
            if (e.code && e.code === 'AMOUNT_TOO_SMALL') {
                // When amount is too small, Mayan SDK returns errors in this format:
                //
                // {
                //   code: "AMOUNT_TOO_SMALL"
                //   message: "Amount too small (min ~0.00055 ETH)"
                // }
                //
                // We parse this and return a standardized Wormhole SDK MinAmountError
                const amountMatch = e.message.match(/([\d\.]+)/);
                if (amountMatch[1] !== undefined && !e.message.includes('$')) {
                    const minAmountFloat = parseFloat(amountMatch[1]);
                    const minAmount = amount.parse(minAmountFloat, request.source.decimals);
                    return {
                        success: false,
                        error: new routes.MinAmountError(minAmount),
                    };
                }
                else {
                    // Failed to find a floating point number in the error message
                    return {
                        success: false,
                        error: e,
                    };
                }
            }
            return {
                success: false,
                error: e,
            };
        }
    }
    async initiate(request, signer, quote, to) {
        const originAddress = signer.address();
        const destinationAddress = canonicalAddress(to);
        try {
            const rpc = await request.fromChain.getRpc();
            const txs = [];
            if (request.fromChain.chain === "Solana") {
                const { instructions, signers, lookupTables } = await createSwapFromSolanaInstructions(quote.details, originAddress, destinationAddress, this.referrerAddress(), rpc);
                const message = MessageV0.compile({
                    instructions,
                    payerKey: new PublicKey(originAddress),
                    recentBlockhash: "",
                    addressLookupTableAccounts: lookupTables,
                });
                const txReqs = [
                    new SolanaUnsignedTransaction({
                        transaction: new VersionedTransaction(message),
                        signers: signers,
                    }, request.fromChain.network, request.fromChain.chain, "Execute Swap"),
                ];
                if (isSignAndSendSigner(signer)) {
                    const txids = await signer.signAndSend(txReqs);
                    txs.push(...txids.map((txid) => ({
                        chain: request.fromChain.chain,
                        txid,
                    })));
                }
                else if (isSignOnlySigner(signer)) {
                    const signed = await signer.sign(txReqs);
                    const txids = await SolanaPlatform.sendWait(request.fromChain.chain, rpc, signed);
                    txs.push(...txids.map((txid) => ({
                        chain: request.fromChain.chain,
                        txid,
                    })));
                }
            }
            else if (request.fromChain.chain === "Sui") {
                const tx = await createSwapFromSuiMoveCalls(quote.details, originAddress, destinationAddress, this.referrerAddress(), undefined, rpc);
                const txReqs = [
                    new SuiUnsignedTransaction(tx, request.fromChain.network, request.fromChain.chain, "Execute Swap"),
                ];
                if (isSignAndSendSigner(signer)) {
                    const txids = await signer.signAndSend(txReqs);
                    txs.push(...txids.map((txid) => ({
                        chain: request.fromChain.chain,
                        txid,
                    })));
                }
                else if (isSignOnlySigner(signer)) {
                    const signed = await signer.sign(txReqs);
                    const txids = await SuiPlatform.sendWait(request.fromChain.chain, rpc, signed);
                    txs.push(...txids.map((txid) => ({
                        chain: request.fromChain.chain,
                        txid,
                    })));
                }
            }
            else {
                const txReqs = [];
                const nativeChainId = nativeChainIds.networkChainToNativeChainId.get(request.fromChain.network, request.fromChain.chain);
                if (!isNative(request.source.id.address)) {
                    const tokenContract = EvmPlatform.getTokenImplementation(await request.fromChain.getRpc(), this.toMayanAddress(request.source.id));
                    const contractAddress = addresses.MAYAN_FORWARDER_CONTRACT;
                    const allowance = await tokenContract.allowance(originAddress, contractAddress);
                    const amt = amount.units(quote.sourceToken.amount);
                    if (allowance < amt) {
                        const txReq = await tokenContract.approve.populateTransaction(
                        // mayan contract address,
                        contractAddress, amt);
                        txReqs.push(new EvmUnsignedTransaction({
                            from: signer.address(),
                            chainId: nativeChainId,
                            ...txReq,
                        }, request.fromChain.network, request.fromChain.chain, "Approve Allowance"));
                    }
                }
                const txReq = getSwapFromEvmTxPayload(quote.details, originAddress, destinationAddress, this.referrerAddress(), originAddress, Number(nativeChainId), undefined, undefined // permit?
                );
                txReqs.push(new EvmUnsignedTransaction({
                    from: signer.address(),
                    chainId: nativeChainId,
                    ...txReq,
                }, request.fromChain.network, request.fromChain.chain, "Execute Swap"));
                if (isSignAndSendSigner(signer)) {
                    const txids = await signer.signAndSend(txReqs);
                    txs.push(...txids.map((txid) => ({
                        chain: request.fromChain.chain,
                        txid,
                    })));
                }
                else if (isSignOnlySigner(signer)) {
                    const signed = await signer.sign(txReqs);
                    const txids = await EvmPlatform.sendWait(request.fromChain.chain, rpc, signed);
                    txs.push(...txids.map((txid) => ({
                        chain: request.fromChain.chain,
                        txid,
                    })));
                }
            }
            return {
                from: request.fromChain.chain,
                to: request.toChain.chain,
                state: TransferState.SourceInitiated,
                originTxs: txs,
            };
        }
        catch (e) {
            console.error(e);
            throw e;
        }
    }
    async *track(receipt, timeout) {
        if (isCompleted(receipt) || isRedeemed(receipt) || isRefunded(receipt))
            return receipt;
        // What should be the default if no timeout is provided?
        let leftover = timeout ? timeout : 60 * 60 * 1000;
        while (leftover > 0) {
            const start = Date.now();
            if (
            // this is awkward but there is not hasSourceInitiated like fn in sdk (todo)
            isSourceInitiated(receipt) ||
                isSourceFinalized(receipt) ||
                isAttested(receipt)) {
                const txstatus = await getTransactionStatus(receipt.originTxs[receipt.originTxs.length - 1]);
                if (txstatus) {
                    receipt = txStatusToReceipt(txstatus);
                    yield { ...receipt, txstatus };
                    if (isCompleted(receipt) || isRedeemed(receipt) || isRefunded(receipt))
                        return receipt;
                }
            }
            else {
                throw new Error("Transfer must have been initiated");
            }
            // sleep for 1 second so we dont spam the endpoint
            await new Promise((resolve) => setTimeout(resolve, 1000));
            leftover -= Date.now() - start;
        }
        return receipt;
    }
    transferUrl(txid) {
        return `https://explorer.mayan.finance/swap/${txid}`;
    }
    referrerAddress() {
        return undefined;
    }
}
export class MayanRoute extends MayanRouteBase {
    static meta = {
        name: "MayanSwap",
        provider: "Mayan",
    };
    protocols = ['WH', 'MCTP', 'SWIFT', 'SHUTTLE'];
}
export class MayanRouteSWIFT extends MayanRouteBase {
    static meta = {
        name: "MayanSwapSWIFT",
        provider: "Mayan Swift",
    };
    protocols = ['SWIFT'];
}
export class MayanRouteMCTP extends MayanRouteBase {
    static meta = {
        name: "MayanSwapMCTP",
        provider: "Mayan MCTP",
    };
    protocols = ['MCTP'];
}
export class MayanRouteWH extends MayanRouteBase {
    static meta = {
        name: "MayanSwapWH",
        provider: "Mayan",
    };
    protocols = ['WH'];
}
export class MayanRouteSHUTTLE extends MayanRouteBase {
    static meta = {
        name: "MayanSwapSHUTTLE",
        provider: "Mayan Shuttle Beta",
    };
    protocols = ['SHUTTLE'];
    static async supportedSourceTokens(fromChain) {
        if (!supportedChains().includes(fromChain.chain)) {
            return [];
        }
        const usdcTokenId = getUSDCTokenId(fromChain.chain, fromChain.network);
        return usdcTokenId ? [usdcTokenId] : [];
    }
    static async supportedDestinationTokens(_token, fromChain, toChain) {
        if (!supportedChains().includes(toChain.chain)) {
            return [];
        }
        const supportedSourceTokens = await this.supportedSourceTokens(fromChain);
        if (!supportedSourceTokens.some((t) => isSameToken(t, _token))) {
            return [];
        }
        const usdcTokenId = getUSDCTokenId(toChain.chain, toChain.network);
        return usdcTokenId ? [usdcTokenId] : [];
    }
}
//# sourceMappingURL=index.js.map