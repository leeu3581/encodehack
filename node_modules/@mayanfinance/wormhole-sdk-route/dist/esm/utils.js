import { fetchTokenList, } from "@mayanfinance/swap-sdk";
import { Transaction, VersionedTransaction } from "@solana/web3.js";
import { TransferState, deserialize, encoding, isSignOnlySigner, nativeTokenId, toChain, toNative, circle, Wormhole, } from "@wormhole-foundation/sdk-connect";
import { isEvmNativeSigner } from "@wormhole-foundation/sdk-evm";
import axios from "axios";
import tokenCache from "./tokens.json";
export function getNativeContractAddress(chain) {
    if (chain === "Sui")
        return "0x2::sui::SUI";
    return "0x0000000000000000000000000000000000000000";
}
// Deadline in minutes recommended by api
// hardcoded for now, but can be fetched from
// https://sia.mayan.finance/v3/init
const defaultDeadlines = {
    Bsc: 16,
    Avalanche: 16,
    Polygon: 18,
    Ethereum: 76,
    Solana: 10,
    Arbitrum: 96,
    Aptos: 50,
    Unichain: 96,
    Sui: 40,
};
// return the default deadline for a given chain in seconds
// or return 1 hour if not found
export function getDefaultDeadline(chain) {
    if (chain in defaultDeadlines)
        return defaultDeadlines[chain] * 60;
    return 60 * 60;
}
const chainNameMap = {
    Solana: "solana",
    Ethereum: "ethereum",
    Bsc: "bsc",
    Polygon: "polygon",
    Avalanche: "avalanche",
    Arbitrum: "arbitrum",
    Aptos: "aptos",
    Base: "base",
    Optimism: "optimism",
    Unichain: "unichain",
    Sui: "sui",
};
export function toMayanChainName(chain) {
    if (!chainNameMap[chain])
        throw new Error(`Chain ${chain} not supported`);
    return chainNameMap[chain];
}
export function fromMayanChainName(mayanChain) {
    for (const [wormholeChain, mayanName] of Object.entries(chainNameMap)) {
        if (mayanName === mayanChain) {
            return wormholeChain;
        }
    }
    throw new Error(`Unknown Mayan chain ${mayanChain}`);
}
export function toWormholeChainName(chainIdStr) {
    return toChain(Number(chainIdStr));
}
export function supportedChains() {
    return Object.keys(chainNameMap);
}
let tokenListCache = {};
export async function fetchTokensForChain(chain) {
    if (chain in tokenListCache) {
        return tokenListCache[chain];
    }
    let mayanTokens;
    let chainName = toMayanChainName(chain);
    try {
        mayanTokens = await fetchTokenList(chainName);
    }
    catch (e) {
        mayanTokens = tokenCache[chainName];
    }
    const whTokens = mayanTokens.map((mt) => {
        if (mt.contract === getNativeContractAddress(chain)) {
            return nativeTokenId(chain);
        }
        else {
            return {
                chain,
                address: toNative(chain, mt.contract),
            };
        }
    });
    tokenListCache[chain] = whTokens;
    return whTokens;
}
// https://solana-labs.github.io/solana-web3.js/classes/Transaction.html
function isTransaction(tx) {
    return typeof tx.verifySignatures === "function";
}
export function mayanSolanaSigner(signer) {
    if (!isSignOnlySigner(signer))
        throw new Error("Signer must be a SignOnlySigner");
    return async (tx) => {
        const ust = {
            transaction: { transaction: tx },
            description: "Mayan.InitiateSwap",
            network: "Mainnet",
            chain: "Solana",
            parallelizable: false,
        };
        const signed = (await signer.sign([ust]));
        if (isTransaction(tx))
            return Transaction.from(signed[0]);
        else
            return VersionedTransaction.deserialize(signed[0]);
    };
}
export function mayanEvmSigner(signer) {
    if (isEvmNativeSigner(signer))
        return signer.unwrap();
    throw new Error("Signer must be an EvmNativeSigner");
}
export function mayanEvmProvider(signer) {
    return {
        getBlock: async function () {
            let block = await signer.provider.getBlock("latest");
            if (block === null)
                throw new Error("Failed to get latest Ethereum block");
            return block;
        },
    };
}
export var MayanClientStatus;
(function (MayanClientStatus) {
    MayanClientStatus["INPROGRESS"] = "INPROGRESS";
    MayanClientStatus["COMPLETED"] = "COMPLETED";
    MayanClientStatus["REFUNDED"] = "REFUNDED";
    MayanClientStatus["CANCELED"] = "CANCELED";
})(MayanClientStatus || (MayanClientStatus = {}));
const possibleVaaTypes = [
    // Bridge to swap chain (solana)
    "transfer",
    // Info about the swap
    "swap",
    // Successful, bridge to destination chain
    "redeem",
    // Unsuccessful auction, refund back to source chain (evm)
    "refund",
];
export var MayanTransactionGoal;
(function (MayanTransactionGoal) {
    // send from evm to solana
    MayanTransactionGoal["Send"] = "SEND";
    // bridge to destination chain
    MayanTransactionGoal["Bridge"] = "BRIDGE";
    // perform the swap
    MayanTransactionGoal["Swap"] = "SWAP";
    // register for auction
    MayanTransactionGoal["Register"] = "REGISTER";
    // settle on destination
    MayanTransactionGoal["Settle"] = "SETTLE";
})(MayanTransactionGoal || (MayanTransactionGoal = {}));
export function txStatusToReceipt(txStatus) {
    const srcChain = toWormholeChainName(txStatus.sourceChain);
    const dstChain = toWormholeChainName(txStatus.destChain);
    const originTxs = txStatus.txs
        .filter((tx) => {
        return (
        // Send from Evm to Solana
        tx.goals.includes(MayanTransactionGoal.Send) ||
            // Register for auction on Solana
            tx.goals.includes(MayanTransactionGoal.Register));
    })
        .map((tx) => {
        return {
            chain: srcChain,
            txid: tx.txHash,
        };
    });
    const destinationTxs = txStatus.txs
        .filter((tx) => {
        return tx.goals.includes(MayanTransactionGoal.Settle);
    })
        .map((tx) => {
        return {
            chain: dstChain,
            txid: tx.txHash,
        };
    });
    let refundTxs = [];
    if (txStatus.refundTxHash) {
        refundTxs.push({
            chain: toWormholeChainName(txStatus.refundChain),
            txid: txStatus.refundTxHash
        });
    }
    const attestations = {};
    for (const vaaType of possibleVaaTypes) {
        const key = `${vaaType}SignedVaa`;
        if (key in txStatus && txStatus[key] !== null) {
            const vaa = deserialize("Uint8Array", encoding.hex.decode(txStatus[key]));
            attestations[vaaType] = {
                id: {
                    emitter: vaa.emitterAddress,
                    sequence: vaa.sequence,
                    chain: vaa.emitterChain,
                },
                attestation: vaa,
            };
        }
    }
    // TODO this is a hack. The Receipt type should ideally not require an Attestation.
    let attestation = {};
    let isAttested = false;
    if ("redeem" in attestations) {
        attestation = attestations["redeem"];
        isAttested = true;
    }
    else if ("transfer" in attestations) {
        attestation = attestations["transfer"];
        isAttested = true;
    }
    if (txStatus.clientStatus === MayanClientStatus.COMPLETED) {
        return {
            from: srcChain,
            to: dstChain,
            originTxs,
            destinationTxs,
            state: TransferState.DestinationFinalized,
            attestation,
        };
    }
    else if (txStatus.clientStatus === MayanClientStatus.REFUNDED || txStatus.clientStatus === MayanClientStatus.CANCELED) {
        return {
            from: srcChain,
            to: dstChain,
            originTxs,
            refundTxs,
            state: TransferState.Refunded,
            attestation: attestations["refund"],
        };
    }
    else if (txStatus.clientStatus === MayanClientStatus.INPROGRESS) {
        if (isAttested && destinationTxs.length > 0) {
            return {
                from: srcChain,
                to: dstChain,
                originTxs,
                destinationTxs,
                state: TransferState.DestinationInitiated,
                attestation: attestation,
            };
        }
        else {
            return {
                from: srcChain,
                to: dstChain,
                originTxs,
                state: TransferState.SourceInitiated,
            };
        }
    }
    else {
        throw new Error(`Unknown Mayan clientStatus ${txStatus.clientStatus}`);
    }
}
export async function getTransactionStatus(tx) {
    const url = `https://explorer-api.mayan.finance/v3/swap/trx/${tx.txid}`;
    try {
        const response = await axios.get(url);
        if (response.data.id)
            return response.data;
    }
    catch (error) {
        if (!error)
            return null;
        if (typeof error === "object") {
            // A 404 error means the VAA is not yet available
            // since its not available yet, we return null signaling it can be tried again
            if (axios.isAxiosError(error) && error.response?.status === 404)
                return null;
            if ("status" in error && error.status === 404)
                return null;
        }
        throw error;
    }
    return null;
}
export function getUSDCTokenId(chain, network) {
    const usdcContract = circle.usdcContract.get(network, chain);
    if (!usdcContract) {
        return undefined;
    }
    return Wormhole.tokenId(chain, usdcContract);
}
//# sourceMappingURL=utils.js.map