"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MayanRouteSHUTTLE = exports.MayanRouteWH = exports.MayanRouteMCTP = exports.MayanRouteSWIFT = exports.MayanRoute = void 0;
const swap_sdk_1 = require("@mayanfinance/swap-sdk");
const web3_js_1 = require("@solana/web3.js");
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const sdk_evm_1 = require("@wormhole-foundation/sdk-evm");
const sdk_solana_1 = require("@wormhole-foundation/sdk-solana");
const sdk_sui_1 = require("@wormhole-foundation/sdk-sui");
const axios_1 = __importDefault(require("axios"));
const utils_1 = require("./utils");
class MayanRouteBase extends sdk_connect_1.routes.AutomaticRoute {
    MAX_SLIPPAGE = 1;
    static NATIVE_GAS_DROPOFF_SUPPORTED = false;
    static IS_AUTOMATIC = true;
    protocols = ['WH', 'MCTP', 'SWIFT', 'SHUTTLE'];
    getDefaultOptions() {
        return {
            gasDrop: 0,
            slippageBps: 'auto',
            optimizeFor: 'speed'
        };
    }
    static supportedNetworks() {
        return ["Mainnet"];
    }
    static supportedChains(_) {
        return (0, utils_1.supportedChains)();
    }
    static async supportedSourceTokens(fromChain) {
        return (0, utils_1.fetchTokensForChain)(fromChain.chain);
    }
    static isProtocolSupported(chain) {
        return (0, utils_1.supportedChains)().includes(chain.chain);
    }
    static async supportedDestinationTokens(_token, fromChain, toChain) {
        if (!(0, utils_1.supportedChains)().includes(fromChain.chain) || !(0, utils_1.supportedChains)().includes(toChain.chain)) {
            return [];
        }
        return (0, utils_1.fetchTokensForChain)(toChain.chain);
    }
    async isAvailable() {
        // No way to check relayer availability so assume true
        return true;
    }
    async validate(request, params) {
        try {
            params.options = params.options ?? this.getDefaultOptions();
            return {
                valid: true,
                params: {
                    ...params,
                    normalizedParams: {
                        slippageBps: params.options.slippageBps,
                    },
                },
            };
        }
        catch (e) {
            return { valid: false, params, error: e };
        }
    }
    toMayanAddress(tokenId) {
        return !(0, sdk_connect_1.isNative)(tokenId.address)
            ? (0, sdk_connect_1.canonicalAddress)(tokenId)
            : (0, utils_1.getNativeContractAddress)(tokenId.chain);
    }
    async fetchQuote(request, params) {
        const { fromChain, toChain } = request;
        const quoteParams = {
            amount: Number(params.amount),
            fromToken: this.toMayanAddress(request.source.id),
            toToken: this.toMayanAddress(request.destination.id),
            fromChain: (0, utils_1.toMayanChainName)(fromChain.chain),
            toChain: (0, utils_1.toMayanChainName)(toChain.chain),
            ...this.getDefaultOptions(),
            ...params.options,
            slippageBps: 'auto',
        };
        const quoteOpts = {
            swift: this.protocols.includes('SWIFT'),
            mctp: this.protocols.includes('MCTP'),
            shuttle: this.protocols.includes('SHUTTLE'),
        };
        const fetchQuoteUrl = new URL((0, swap_sdk_1.generateFetchQuoteUrl)(quoteParams, quoteOpts));
        if (!fetchQuoteUrl) {
            throw new Error("Unable to generate fetch quote URL");
        }
        if (!fetchQuoteUrl.searchParams.has('fullList')) {
            // Attach the fullList param to fetch all quotes
            fetchQuoteUrl.searchParams.append('fullList', 'true');
        }
        const res = await axios_1.default.get(fetchQuoteUrl.toString());
        if (res.status !== 200) {
            throw new Error("Unable to fetch quote", { cause: res });
        }
        const quotes = res.data?.quotes?.filter((quote) => this.protocols.includes(quote.type));
        if (!quotes || quotes.length === 0)
            return undefined;
        if (quotes.length === 1)
            return quotes[0];
        // Wormhole SDK routes return only a single quote, but Mayan offers multiple quotes (because 
        // Mayan comprises multiple competing protocols). We sort the quotes Mayan gives us and choose
        // the best one here.
        //
        // User can provide optimizeFor option to indicate what they care about. It defaults to "cost"
        // which just optimizes for highest amount out, but it can also be set to "speed" which will
        // choose the fastest route instead.
        quotes.sort((a, b) => {
            if (params.options.optimizeFor === 'cost') {
                if (b.expectedAmountOut === a.expectedAmountOut) {
                    // If expected amounts out are identical, fall back to speed
                    /* @ts-ignore */
                    return a.etaSeconds - b.etaSeconds;
                }
                else {
                    // Otherwise sort by amount out, descending
                    return b.expectedAmountOut - a.expectedAmountOut;
                }
            }
            else if (params.options.optimizeFor === 'speed') {
                /* @ts-ignore */
                if (a.etaSeconds === b.etaSeconds) {
                    // If ETAs are identical, fall back to cost
                    return b.expectedAmountOut - a.expectedAmountOut;
                }
                else {
                    // Otherwise sort by ETA, ascending
                    /* @ts-ignore */
                    return a.etaSeconds - b.etaSeconds;
                }
            }
            else {
                // Should be unreachable
                return 0;
            }
        });
        return quotes[0];
    }
    async quote(request, params) {
        try {
            const quote = await this.fetchQuote(request, params);
            if (!quote) {
                return {
                    success: false,
                    error: new sdk_connect_1.routes.UnavailableError(new Error(`Couldn't fetch a quote`)),
                };
            }
            // Mayan fees are complicated and they normalize them for us in USD as clientRelayerFeeSuccess
            // We return this value as-is and express it as a USDC value for the sake of formatting
            const relayFee = {
                token: {
                    chain: 'Solana',
                    address: sdk_connect_1.Wormhole.parseAddress('Solana', sdk_base_1.circle.usdcContract.get(request.fromChain.network, 'Solana')),
                },
                amount: sdk_connect_1.amount.parse(sdk_connect_1.amount.denoise(quote.clientRelayerFeeSuccess || '0', 6), 6),
            };
            const fullQuote = {
                success: true,
                params,
                sourceToken: {
                    token: request.source.id,
                    amount: sdk_connect_1.amount.parse(sdk_connect_1.amount.denoise(quote.effectiveAmountIn, quote.fromToken.decimals), quote.fromToken.decimals),
                },
                destinationToken: {
                    token: request.destination.id,
                    amount: sdk_connect_1.amount.parse(sdk_connect_1.amount.denoise(quote.expectedAmountOut, quote.toToken.decimals), quote.toToken.decimals),
                },
                relayFee,
                destinationNativeGas: sdk_connect_1.amount.parse(sdk_connect_1.amount.denoise(quote.gasDrop, quote.toToken.decimals), quote.toToken.decimals),
                /* @ts-ignore TODO: https://github.com/mayan-finance/swap-sdk/pull/11 */
                eta: quote.etaSeconds * 1000,
                details: quote,
            };
            return fullQuote;
        }
        catch (e) {
            if (e.code && e.code === 'AMOUNT_TOO_SMALL') {
                // When amount is too small, Mayan SDK returns errors in this format:
                //
                // {
                //   code: "AMOUNT_TOO_SMALL"
                //   message: "Amount too small (min ~0.00055 ETH)"
                // }
                //
                // We parse this and return a standardized Wormhole SDK MinAmountError
                const amountMatch = e.message.match(/([\d\.]+)/);
                if (amountMatch[1] !== undefined && !e.message.includes('$')) {
                    const minAmountFloat = parseFloat(amountMatch[1]);
                    const minAmount = sdk_connect_1.amount.parse(minAmountFloat, request.source.decimals);
                    return {
                        success: false,
                        error: new sdk_connect_1.routes.MinAmountError(minAmount),
                    };
                }
                else {
                    // Failed to find a floating point number in the error message
                    return {
                        success: false,
                        error: e,
                    };
                }
            }
            return {
                success: false,
                error: e,
            };
        }
    }
    async initiate(request, signer, quote, to) {
        const originAddress = signer.address();
        const destinationAddress = (0, sdk_connect_1.canonicalAddress)(to);
        try {
            const rpc = await request.fromChain.getRpc();
            const txs = [];
            if (request.fromChain.chain === "Solana") {
                const { instructions, signers, lookupTables } = await (0, swap_sdk_1.createSwapFromSolanaInstructions)(quote.details, originAddress, destinationAddress, this.referrerAddress(), rpc);
                const message = web3_js_1.MessageV0.compile({
                    instructions,
                    payerKey: new web3_js_1.PublicKey(originAddress),
                    recentBlockhash: "",
                    addressLookupTableAccounts: lookupTables,
                });
                const txReqs = [
                    new sdk_solana_1.SolanaUnsignedTransaction({
                        transaction: new web3_js_1.VersionedTransaction(message),
                        signers: signers,
                    }, request.fromChain.network, request.fromChain.chain, "Execute Swap"),
                ];
                if ((0, sdk_connect_1.isSignAndSendSigner)(signer)) {
                    const txids = await signer.signAndSend(txReqs);
                    txs.push(...txids.map((txid) => ({
                        chain: request.fromChain.chain,
                        txid,
                    })));
                }
                else if ((0, sdk_connect_1.isSignOnlySigner)(signer)) {
                    const signed = await signer.sign(txReqs);
                    const txids = await sdk_solana_1.SolanaPlatform.sendWait(request.fromChain.chain, rpc, signed);
                    txs.push(...txids.map((txid) => ({
                        chain: request.fromChain.chain,
                        txid,
                    })));
                }
            }
            else if (request.fromChain.chain === "Sui") {
                const tx = await (0, swap_sdk_1.createSwapFromSuiMoveCalls)(quote.details, originAddress, destinationAddress, this.referrerAddress(), undefined, rpc);
                const txReqs = [
                    new sdk_sui_1.SuiUnsignedTransaction(tx, request.fromChain.network, request.fromChain.chain, "Execute Swap"),
                ];
                if ((0, sdk_connect_1.isSignAndSendSigner)(signer)) {
                    const txids = await signer.signAndSend(txReqs);
                    txs.push(...txids.map((txid) => ({
                        chain: request.fromChain.chain,
                        txid,
                    })));
                }
                else if ((0, sdk_connect_1.isSignOnlySigner)(signer)) {
                    const signed = await signer.sign(txReqs);
                    const txids = await sdk_sui_1.SuiPlatform.sendWait(request.fromChain.chain, rpc, signed);
                    txs.push(...txids.map((txid) => ({
                        chain: request.fromChain.chain,
                        txid,
                    })));
                }
            }
            else {
                const txReqs = [];
                const nativeChainId = sdk_connect_1.nativeChainIds.networkChainToNativeChainId.get(request.fromChain.network, request.fromChain.chain);
                if (!(0, sdk_connect_1.isNative)(request.source.id.address)) {
                    const tokenContract = sdk_evm_1.EvmPlatform.getTokenImplementation(await request.fromChain.getRpc(), this.toMayanAddress(request.source.id));
                    const contractAddress = swap_sdk_1.addresses.MAYAN_FORWARDER_CONTRACT;
                    const allowance = await tokenContract.allowance(originAddress, contractAddress);
                    const amt = sdk_connect_1.amount.units(quote.sourceToken.amount);
                    if (allowance < amt) {
                        const txReq = await tokenContract.approve.populateTransaction(
                        // mayan contract address,
                        contractAddress, amt);
                        txReqs.push(new sdk_evm_1.EvmUnsignedTransaction({
                            from: signer.address(),
                            chainId: nativeChainId,
                            ...txReq,
                        }, request.fromChain.network, request.fromChain.chain, "Approve Allowance"));
                    }
                }
                const txReq = (0, swap_sdk_1.getSwapFromEvmTxPayload)(quote.details, originAddress, destinationAddress, this.referrerAddress(), originAddress, Number(nativeChainId), undefined, undefined // permit?
                );
                txReqs.push(new sdk_evm_1.EvmUnsignedTransaction({
                    from: signer.address(),
                    chainId: nativeChainId,
                    ...txReq,
                }, request.fromChain.network, request.fromChain.chain, "Execute Swap"));
                if ((0, sdk_connect_1.isSignAndSendSigner)(signer)) {
                    const txids = await signer.signAndSend(txReqs);
                    txs.push(...txids.map((txid) => ({
                        chain: request.fromChain.chain,
                        txid,
                    })));
                }
                else if ((0, sdk_connect_1.isSignOnlySigner)(signer)) {
                    const signed = await signer.sign(txReqs);
                    const txids = await sdk_evm_1.EvmPlatform.sendWait(request.fromChain.chain, rpc, signed);
                    txs.push(...txids.map((txid) => ({
                        chain: request.fromChain.chain,
                        txid,
                    })));
                }
            }
            return {
                from: request.fromChain.chain,
                to: request.toChain.chain,
                state: sdk_connect_1.TransferState.SourceInitiated,
                originTxs: txs,
            };
        }
        catch (e) {
            console.error(e);
            throw e;
        }
    }
    async *track(receipt, timeout) {
        if ((0, sdk_connect_1.isCompleted)(receipt) || (0, sdk_connect_1.isRedeemed)(receipt) || (0, sdk_connect_1.isRefunded)(receipt))
            return receipt;
        // What should be the default if no timeout is provided?
        let leftover = timeout ? timeout : 60 * 60 * 1000;
        while (leftover > 0) {
            const start = Date.now();
            if (
            // this is awkward but there is not hasSourceInitiated like fn in sdk (todo)
            (0, sdk_connect_1.isSourceInitiated)(receipt) ||
                (0, sdk_connect_1.isSourceFinalized)(receipt) ||
                (0, sdk_connect_1.isAttested)(receipt)) {
                const txstatus = await (0, utils_1.getTransactionStatus)(receipt.originTxs[receipt.originTxs.length - 1]);
                if (txstatus) {
                    receipt = (0, utils_1.txStatusToReceipt)(txstatus);
                    yield { ...receipt, txstatus };
                    if ((0, sdk_connect_1.isCompleted)(receipt) || (0, sdk_connect_1.isRedeemed)(receipt) || (0, sdk_connect_1.isRefunded)(receipt))
                        return receipt;
                }
            }
            else {
                throw new Error("Transfer must have been initiated");
            }
            // sleep for 1 second so we dont spam the endpoint
            await new Promise((resolve) => setTimeout(resolve, 1000));
            leftover -= Date.now() - start;
        }
        return receipt;
    }
    transferUrl(txid) {
        return `https://explorer.mayan.finance/swap/${txid}`;
    }
    referrerAddress() {
        return undefined;
    }
}
class MayanRoute extends MayanRouteBase {
    static meta = {
        name: "MayanSwap",
        provider: "Mayan",
    };
    protocols = ['WH', 'MCTP', 'SWIFT', 'SHUTTLE'];
}
exports.MayanRoute = MayanRoute;
class MayanRouteSWIFT extends MayanRouteBase {
    static meta = {
        name: "MayanSwapSWIFT",
        provider: "Mayan Swift",
    };
    protocols = ['SWIFT'];
}
exports.MayanRouteSWIFT = MayanRouteSWIFT;
class MayanRouteMCTP extends MayanRouteBase {
    static meta = {
        name: "MayanSwapMCTP",
        provider: "Mayan MCTP",
    };
    protocols = ['MCTP'];
}
exports.MayanRouteMCTP = MayanRouteMCTP;
class MayanRouteWH extends MayanRouteBase {
    static meta = {
        name: "MayanSwapWH",
        provider: "Mayan",
    };
    protocols = ['WH'];
}
exports.MayanRouteWH = MayanRouteWH;
class MayanRouteSHUTTLE extends MayanRouteBase {
    static meta = {
        name: "MayanSwapSHUTTLE",
        provider: "Mayan Shuttle Beta",
    };
    protocols = ['SHUTTLE'];
    static async supportedSourceTokens(fromChain) {
        if (!(0, utils_1.supportedChains)().includes(fromChain.chain)) {
            return [];
        }
        const usdcTokenId = (0, utils_1.getUSDCTokenId)(fromChain.chain, fromChain.network);
        return usdcTokenId ? [usdcTokenId] : [];
    }
    static async supportedDestinationTokens(_token, fromChain, toChain) {
        if (!(0, utils_1.supportedChains)().includes(toChain.chain)) {
            return [];
        }
        const supportedSourceTokens = await this.supportedSourceTokens(fromChain);
        if (!supportedSourceTokens.some((t) => (0, sdk_connect_1.isSameToken)(t, _token))) {
            return [];
        }
        const usdcTokenId = (0, utils_1.getUSDCTokenId)(toChain.chain, toChain.network);
        return usdcTokenId ? [usdcTokenId] : [];
    }
}
exports.MayanRouteSHUTTLE = MayanRouteSHUTTLE;
//# sourceMappingURL=index.js.map