"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MayanTransactionGoal = exports.MayanClientStatus = void 0;
exports.getNativeContractAddress = getNativeContractAddress;
exports.getDefaultDeadline = getDefaultDeadline;
exports.toMayanChainName = toMayanChainName;
exports.fromMayanChainName = fromMayanChainName;
exports.toWormholeChainName = toWormholeChainName;
exports.supportedChains = supportedChains;
exports.fetchTokensForChain = fetchTokensForChain;
exports.mayanSolanaSigner = mayanSolanaSigner;
exports.mayanEvmSigner = mayanEvmSigner;
exports.mayanEvmProvider = mayanEvmProvider;
exports.txStatusToReceipt = txStatusToReceipt;
exports.getTransactionStatus = getTransactionStatus;
exports.getUSDCTokenId = getUSDCTokenId;
const swap_sdk_1 = require("@mayanfinance/swap-sdk");
const web3_js_1 = require("@solana/web3.js");
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const sdk_evm_1 = require("@wormhole-foundation/sdk-evm");
const axios_1 = __importDefault(require("axios"));
const tokens_json_1 = __importDefault(require("./tokens.json"));
function getNativeContractAddress(chain) {
    if (chain === "Sui")
        return "0x2::sui::SUI";
    return "0x0000000000000000000000000000000000000000";
}
// Deadline in minutes recommended by api
// hardcoded for now, but can be fetched from
// https://sia.mayan.finance/v3/init
const defaultDeadlines = {
    Bsc: 16,
    Avalanche: 16,
    Polygon: 18,
    Ethereum: 76,
    Solana: 10,
    Arbitrum: 96,
    Aptos: 50,
    Unichain: 96,
    Sui: 40,
};
// return the default deadline for a given chain in seconds
// or return 1 hour if not found
function getDefaultDeadline(chain) {
    if (chain in defaultDeadlines)
        return defaultDeadlines[chain] * 60;
    return 60 * 60;
}
const chainNameMap = {
    Solana: "solana",
    Ethereum: "ethereum",
    Bsc: "bsc",
    Polygon: "polygon",
    Avalanche: "avalanche",
    Arbitrum: "arbitrum",
    Aptos: "aptos",
    Base: "base",
    Optimism: "optimism",
    Unichain: "unichain",
    Sui: "sui",
};
function toMayanChainName(chain) {
    if (!chainNameMap[chain])
        throw new Error(`Chain ${chain} not supported`);
    return chainNameMap[chain];
}
function fromMayanChainName(mayanChain) {
    for (const [wormholeChain, mayanName] of Object.entries(chainNameMap)) {
        if (mayanName === mayanChain) {
            return wormholeChain;
        }
    }
    throw new Error(`Unknown Mayan chain ${mayanChain}`);
}
function toWormholeChainName(chainIdStr) {
    return (0, sdk_connect_1.toChain)(Number(chainIdStr));
}
function supportedChains() {
    return Object.keys(chainNameMap);
}
let tokenListCache = {};
async function fetchTokensForChain(chain) {
    if (chain in tokenListCache) {
        return tokenListCache[chain];
    }
    let mayanTokens;
    let chainName = toMayanChainName(chain);
    try {
        mayanTokens = await (0, swap_sdk_1.fetchTokenList)(chainName);
    }
    catch (e) {
        mayanTokens = tokens_json_1.default[chainName];
    }
    const whTokens = mayanTokens.map((mt) => {
        if (mt.contract === getNativeContractAddress(chain)) {
            return (0, sdk_connect_1.nativeTokenId)(chain);
        }
        else {
            return {
                chain,
                address: (0, sdk_connect_1.toNative)(chain, mt.contract),
            };
        }
    });
    tokenListCache[chain] = whTokens;
    return whTokens;
}
// https://solana-labs.github.io/solana-web3.js/classes/Transaction.html
function isTransaction(tx) {
    return typeof tx.verifySignatures === "function";
}
function mayanSolanaSigner(signer) {
    if (!(0, sdk_connect_1.isSignOnlySigner)(signer))
        throw new Error("Signer must be a SignOnlySigner");
    return async (tx) => {
        const ust = {
            transaction: { transaction: tx },
            description: "Mayan.InitiateSwap",
            network: "Mainnet",
            chain: "Solana",
            parallelizable: false,
        };
        const signed = (await signer.sign([ust]));
        if (isTransaction(tx))
            return web3_js_1.Transaction.from(signed[0]);
        else
            return web3_js_1.VersionedTransaction.deserialize(signed[0]);
    };
}
function mayanEvmSigner(signer) {
    if ((0, sdk_evm_1.isEvmNativeSigner)(signer))
        return signer.unwrap();
    throw new Error("Signer must be an EvmNativeSigner");
}
function mayanEvmProvider(signer) {
    return {
        getBlock: async function () {
            let block = await signer.provider.getBlock("latest");
            if (block === null)
                throw new Error("Failed to get latest Ethereum block");
            return block;
        },
    };
}
var MayanClientStatus;
(function (MayanClientStatus) {
    MayanClientStatus["INPROGRESS"] = "INPROGRESS";
    MayanClientStatus["COMPLETED"] = "COMPLETED";
    MayanClientStatus["REFUNDED"] = "REFUNDED";
    MayanClientStatus["CANCELED"] = "CANCELED";
})(MayanClientStatus || (exports.MayanClientStatus = MayanClientStatus = {}));
const possibleVaaTypes = [
    // Bridge to swap chain (solana)
    "transfer",
    // Info about the swap
    "swap",
    // Successful, bridge to destination chain
    "redeem",
    // Unsuccessful auction, refund back to source chain (evm)
    "refund",
];
var MayanTransactionGoal;
(function (MayanTransactionGoal) {
    // send from evm to solana
    MayanTransactionGoal["Send"] = "SEND";
    // bridge to destination chain
    MayanTransactionGoal["Bridge"] = "BRIDGE";
    // perform the swap
    MayanTransactionGoal["Swap"] = "SWAP";
    // register for auction
    MayanTransactionGoal["Register"] = "REGISTER";
    // settle on destination
    MayanTransactionGoal["Settle"] = "SETTLE";
})(MayanTransactionGoal || (exports.MayanTransactionGoal = MayanTransactionGoal = {}));
function txStatusToReceipt(txStatus) {
    const srcChain = toWormholeChainName(txStatus.sourceChain);
    const dstChain = toWormholeChainName(txStatus.destChain);
    const originTxs = txStatus.txs
        .filter((tx) => {
        return (
        // Send from Evm to Solana
        tx.goals.includes(MayanTransactionGoal.Send) ||
            // Register for auction on Solana
            tx.goals.includes(MayanTransactionGoal.Register));
    })
        .map((tx) => {
        return {
            chain: srcChain,
            txid: tx.txHash,
        };
    });
    const destinationTxs = txStatus.txs
        .filter((tx) => {
        return tx.goals.includes(MayanTransactionGoal.Settle);
    })
        .map((tx) => {
        return {
            chain: dstChain,
            txid: tx.txHash,
        };
    });
    let refundTxs = [];
    if (txStatus.refundTxHash) {
        refundTxs.push({
            chain: toWormholeChainName(txStatus.refundChain),
            txid: txStatus.refundTxHash
        });
    }
    const attestations = {};
    for (const vaaType of possibleVaaTypes) {
        const key = `${vaaType}SignedVaa`;
        if (key in txStatus && txStatus[key] !== null) {
            const vaa = (0, sdk_connect_1.deserialize)("Uint8Array", sdk_connect_1.encoding.hex.decode(txStatus[key]));
            attestations[vaaType] = {
                id: {
                    emitter: vaa.emitterAddress,
                    sequence: vaa.sequence,
                    chain: vaa.emitterChain,
                },
                attestation: vaa,
            };
        }
    }
    // TODO this is a hack. The Receipt type should ideally not require an Attestation.
    let attestation = {};
    let isAttested = false;
    if ("redeem" in attestations) {
        attestation = attestations["redeem"];
        isAttested = true;
    }
    else if ("transfer" in attestations) {
        attestation = attestations["transfer"];
        isAttested = true;
    }
    if (txStatus.clientStatus === MayanClientStatus.COMPLETED) {
        return {
            from: srcChain,
            to: dstChain,
            originTxs,
            destinationTxs,
            state: sdk_connect_1.TransferState.DestinationFinalized,
            attestation,
        };
    }
    else if (txStatus.clientStatus === MayanClientStatus.REFUNDED || txStatus.clientStatus === MayanClientStatus.CANCELED) {
        return {
            from: srcChain,
            to: dstChain,
            originTxs,
            refundTxs,
            state: sdk_connect_1.TransferState.Refunded,
            attestation: attestations["refund"],
        };
    }
    else if (txStatus.clientStatus === MayanClientStatus.INPROGRESS) {
        if (isAttested && destinationTxs.length > 0) {
            return {
                from: srcChain,
                to: dstChain,
                originTxs,
                destinationTxs,
                state: sdk_connect_1.TransferState.DestinationInitiated,
                attestation: attestation,
            };
        }
        else {
            return {
                from: srcChain,
                to: dstChain,
                originTxs,
                state: sdk_connect_1.TransferState.SourceInitiated,
            };
        }
    }
    else {
        throw new Error(`Unknown Mayan clientStatus ${txStatus.clientStatus}`);
    }
}
async function getTransactionStatus(tx) {
    const url = `https://explorer-api.mayan.finance/v3/swap/trx/${tx.txid}`;
    try {
        const response = await axios_1.default.get(url);
        if (response.data.id)
            return response.data;
    }
    catch (error) {
        if (!error)
            return null;
        if (typeof error === "object") {
            // A 404 error means the VAA is not yet available
            // since its not available yet, we return null signaling it can be tried again
            if (axios_1.default.isAxiosError(error) && error.response?.status === 404)
                return null;
            if ("status" in error && error.status === 404)
                return null;
        }
        throw error;
    }
    return null;
}
function getUSDCTokenId(chain, network) {
    const usdcContract = sdk_connect_1.circle.usdcContract.get(network, chain);
    if (!usdcContract) {
        return undefined;
    }
    return sdk_connect_1.Wormhole.tokenId(chain, usdcContract);
}
//# sourceMappingURL=utils.js.map